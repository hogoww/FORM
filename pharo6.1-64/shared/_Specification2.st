Object subclass: #Clause	instanceVariableNames: 'atomes'	classVariableNames: ''	poolDictionaries: ''	category: '_Specification'!!Clause methodsFor: 'accessing' stamp: 'pm 10/2/2018 17:29'!add: var	(var isKindOf: Var)		ifTrue:[			atomes add.			^self."able chaining operation"			]		ifFalse:[				Transcript show: 'wrong type'.				"should add an error."			].! !!Clause methodsFor: 'accessing' stamp: 'pm 10/2/2018 17:33'!initialize: OrProp	atomes:=LinkedList new.	self addAll:OrProp.! !!Clause methodsFor: 'accessing' stamp: 'pm 10/1/2018 20:18'!atomes	^atomes.! !!Clause methodsFor: 'accessing' stamp: 'pm 10/2/2018 19:08'!addAll: OrProp	(OrProp isKindOf: Atome)	ifTrue:[self add:OrProp.]	ifFalse:[		((OrProp) isKindOf: Not)		ifTrue:[			(OrProp operand isKindOf:Atome)				ifTrue:[self add:(NotVar new:(OrProp operand))]				ifFalse:["switch to Error new:"					Transcript show: 'Error, shouldn''t be any more not ( binaryOp )'					].			]		ifFalse:[			((OrProp) isKindOf: Or)			ifTrue:[				self addAll: (OrProp left).				self addAll: (OrProp right).				]			ifFalse:["switch to Error new:"				Transcript show:'Error, shouldn''t be any other kind of prop here.'.				].			].		].! !!Clause methodsFor: 'accessing' stamp: 'pm 10/2/2018 17:03'!initialize	atomes:=LinkedList new.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Clause class	instanceVariableNames: ''!!Clause class methodsFor: 'instance creation' stamp: 'pm 10/2/2018 17:31'!new: OrProp	^self basicNew initialize:OrProp.! !!Clause class methodsFor: 'instance creation' stamp: 'pm 10/2/2018 17:06'!new	^self basicNew initialize.! !Object subclass: #FormeClausale	instanceVariableNames: 'clauses'	classVariableNames: ''	poolDictionaries: ''	category: '_Specification'!!FormeClausale methodsFor: 'accessing' stamp: 'pm 10/1/2018 20:17'!clauses	^clauses.! !!FormeClausale methodsFor: 'initialization' stamp: 'pm 10/2/2018 19:49'!initialize	clauses:=LinkedList new.	! !!FormeClausale methodsFor: 'initialization' stamp: 'pm 10/2/2018 21:34'!addAll: clausifiedProp		(clausifiedProp  isKindOf: Or) | (clausifiedProp isKindOf: Atome) "If i'm in a or, there's only or(s) under him."		ifTrue:[self clauses add: (Clause new:clausifiedProp)]		ifFalse:[			(clausifiedProp isKindOf: And)			ifTrue:[				self addAll: (clausifiedProp left).				self addAll: (clausifiedProp right).				]			ifFalse:[			Transcript show: 'Tried to add a non clause object to a clausaleForm'  ].		].! !!FormeClausale methodsFor: 'initialization' stamp: 'pm 10/2/2018 19:52'!initialize: ClausifiedFormula	clauses:=LinkedList new.	self addAll: ClausifiedFormula.! !!FormeClausale methodsFor: 'initialization' stamp: 'pm 10/2/2018 20:10'!add: clause	(clause isKindOf: Clause)	ifTrue: [ self clauses add: clause ]	ifFalse:[Transcript show: 'Tried to add a non clause object to a clausaleForm'  ].! !Object subclass: #Prop	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_Specification'!!Prop methodsFor: 'printing' stamp: 'pm 9/28/2018 22:41'!prettyPrint	^SubclassResponsibility ! !!Prop methodsFor: 'accessing' stamp: 'pm 9/28/2018 22:42'!getSymb	^SubclassResponsibility. ! !!Prop methodsFor: 'testing' stamp: 'pm 9/30/2018 19:07'!propUnitTest	Transcript show: self prettyPrint; show: '  ' ;show: self isClause; cr; cr.! !!Prop methodsFor: 'testing' stamp: 'pm 9/30/2018 12:34'!matchingUnitTest: prop	"self will be considered as a pattern"	Transcript cr;		show: 'prop : ' ; 		show: (prop prettyPrint);		cr;		show: 'pattern : ';		show: (self prettyPrint);		cr.		(self matchPatternWith: prop)			ifTrue:[ Transcript show: 'matched!!';cr.]			ifFalse:[ Transcript show: 'didn''t match!!';cr]	! !!Prop methodsFor: 'testing' stamp: 'pm 9/30/2018 20:12'!clausificationUnitTest	|t|	Transcript show: self prettyPrint; show: '  ' ;show: self isClause; cr.	t:=self fullClausification.	Transcript show: t prettyPrint; show: '  ' ;show: t isClause; cr;cr.! !!Prop methodsFor: 'clausification' stamp: 'pm 9/29/2018 08:21'!isClause	^SubclassResponsibility ! !!Prop methodsFor: 'clausification' stamp: 'pm 9/30/2018 20:06'!clausification	"Only one iteration over the full formula."	"Basic empty comportement for atomes mostly. (only?)"! !!Prop methodsFor: 'clausification' stamp: 'pm 10/1/2018 10:58'!fullClausification	| t |	t:=self clausification.	[t isClause] whileFalse:[			(Prop debug) ifTrue:[Transcript show: t prettyPrint; show: t isClause;cr.].		t:=t clausification.].	^t! !!Prop methodsFor: 'matching' stamp: 'pm 9/30/2018 09:09'!matchPatternWith: prop	"Match self and prop. to end a branch of the pattern	use a random variable	var == whatever	anythingElse == anythingElse only :  !!n => T == !!(A /\ B)=> T for example	"	^SubclassResponsibility.! !!Prop methodsFor: 'matching' stamp: 'pm 9/30/2018 10:16'!compareSymbol: otherProp	^(self getSymb = otherProp getSymb) ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Prop class	instanceVariableNames: 'debug'!!Prop class methodsFor: 'testing' stamp: 'pm 9/30/2018 18:48'!testingClausification 	"everything is tested in those few lines"	"Binary"	| p |		Transcript clear.	Transcript show: 'Testing clausification related stuff';cr.		p:=And new: (Var new: 'a') rightProp: (False_Const new).	p clausificationUnitTest.	p:=Or new: (Var new: 'a') rightProp: (False_Const new).	p clausificationUnitTest.	p:=Equal new: (Var new: 'a') rightProp: (True_Const new).	p clausificationUnitTest.		p:=Imply new: (Var new: 'a') rightProp: (True_Const new).	p clausificationUnitTest.	"unary"	p:=Not new: (Var new: 'a').	p clausificationUnitTest.		Transcript show: 'Bit more complicated stuff!!';cr.		p:=Imply new: (Equal new: (Not new: (Var new: 'a')) rightProp: (Var new: 'b')) rightProp: (False_Const new).	p clausificationUnitTest.			Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !!Prop class methodsFor: 'testing' stamp: 'pm 9/30/2018 12:34'!testingMatch	|pattern prop|	Transcript clear.	Transcript show: 'Testing matching related stuff'.		pattern:= Imply new: (True_Const new) rightProp: (Var new: 'a').	prop:= Imply new: (True_Const new) rightProp: (Not new:(Var new: 'a')).	pattern matchingUnitTest: prop.		pattern:= Imply new: (True_Const new) rightProp: (False_Const  new).	prop:= Imply new: (True_Const new) rightProp: (Not new:(Var new: 'a')).	pattern matchingUnitTest: prop.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/1/2018 10:58'!debug	^debug! !!Prop class methodsFor: 'testing' stamp: 'pm 9/30/2018 18:51'!initEverything	Prop initialize.	Atome initialize.	Constant initialize.	False_Const initialize.	True_Const initialize.	Var initialize.	Operator initialize.	Binary initialize.	And initialize.	Equal initialize.	Imply initialize.	Or initialize.	Unary initialize.	Not initialize.! !!Prop class methodsFor: 'testing' stamp: 'pm 9/30/2018 11:04'!testingProp 	"everything is tested in those few lines"	"Binary"	| p l r|		Transcript clear.	Transcript show: 'Testing prop related stuff';cr.		Transcript show: 'testing every constructor in a simple way, and if they are clauses:';cr.		p:=And new: (Var new: 'a') rightProp: (False_Const new).	p propUnitTest.	p:=Or new: (Var new: 'a') rightProp: (False_Const new).	p propUnitTest.	p:=Equal new: (Var new: 'a') rightProp: (True_Const new).	p propUnitTest.		p:=Imply new: (Var new: 'a') rightProp: (True_Const new).	p propUnitTest.	"unary"	p:=Not new: (Var new: 'a').	p propUnitTest.		Transcript show: 'Bit more complicated stuff!!';cr.		p:=Imply new: (Equal new: (Not new: (Var new: 'a')) rightProp: (Var new: 'b')) rightProp: (False_Const new).	p propUnitTest.		Transcript show: 'Testing Comparisons on Vars:'; cr.		l:=Var new: 'a'.	r:=Var new: 'b'.	Transcript show: 'is var a = b ? ';			show: (l isSameVar: r); cr.	r:=Var new: 'a'.	Transcript show: 'is var a = a ? ';		show: (l isSameVar: r); cr.		Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !!Prop class methodsFor: 'initialization' stamp: 'pm 10/1/2018 10:56'!initialize	debug:=false.! !Prop subclass: #Atome	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_Specification'!!Atome methodsFor: 'printing' stamp: 'pm 9/28/2018 20:26'!prettyPrint	^self getSymb! !!Atome methodsFor: 'clausification' stamp: 'pm 9/29/2018 08:25'!isClause	^true! !Atome subclass: #Constant	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_Specification'!!Constant methodsFor: 'printing' stamp: 'pm 9/28/2018 22:30'!getSymb	^(self class symb)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Constant class	instanceVariableNames: 'symb'!Constant subclass: #False_Const	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_Specification'!!False_Const methodsFor: 'matching' stamp: 'pm 9/30/2018 09:45'!matchPatternWith: prop	"see Prop comment for usage."	^prop isKindOf: False_Const! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!False_Const class	instanceVariableNames: ''!!False_Const class methodsFor: 'accessing' stamp: 'pm 9/28/2018 21:18'!symb	^symb! !!False_Const class methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!initialize	symb:='F'.! !Prop subclass: #Operator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_Specification'!!Operator methodsFor: 'print' stamp: 'pm 9/28/2018 20:26'!getSymb	^(self class symb)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Operator class	instanceVariableNames: 'symb'!Operator subclass: #Binary	instanceVariableNames: 'left right'	classVariableNames: ''	poolDictionaries: ''	category: '_Specification'!!Binary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:27'!right: replacement	right:=replacement.	^right! !!Binary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:27'!left: replacement	left:=replacement.	^left! !!Binary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:27'!right	^right! !!Binary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:26'!left	^left! !!Binary methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!initialize: leftProp rightProp: rp	left:=leftProp.	right:=rp.	! !!Binary methodsFor: 'clausification' stamp: 'pm 9/29/2018 08:39'!isClause	"false unless it's a or/and"	^false! !!Binary methodsFor: 'printing' stamp: 'pm 9/30/2018 12:15'!prettyPrint	^((left isKindOf: Atome) ifTrue:[' '] ifFalse:[' (']) ,		left prettyPrint,		((left isKindOf: Atome) ifTrue:[' '] ifFalse:[') ']) ,		self getSymb,		((right isKindOf: Atome) ifTrue:[' '] ifFalse:[' (']) ,		right prettyPrint,		((right isKindOf: Atome) ifTrue:[' '] ifFalse:[') ']).! !!Binary methodsFor: 'matching' stamp: 'pm 9/30/2018 12:00'!matchPatternWith: prop	(self compareSymbol: prop)		ifTrue:[			^(left matchPatternWith: (prop left))			& (right matchPatternWith: (prop right))			]		ifFalse:[^false].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Binary class	instanceVariableNames: ''!!Binary class methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!new: leftProp rightProp: rp	^self basicNew initialize: leftProp rightProp: rp.! !Binary subclass: #And	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_Specification'!!And methodsFor: 'clausification' stamp: 'pm 9/29/2018 08:40'!isClause	^(left isClause & right isClause)! !!And methodsFor: 'clausification' stamp: 'pm 10/1/2018 11:09'!clausification	| t |	t:=nil. 	((And patternFalse) matchPatternWith: self)	ifTrue:[t:=right]	ifFalse:[		((And patternFalseSym) matchPatternWith: self)		ifTrue:[t:=left]		ifFalse:[			((And patternTrue) matchPatternWith: self)			ifTrue:[t:=left]			ifFalse:[				((And patternTrueSym) matchPatternWith: self)				ifTrue:[t:=right]				ifFalse:["					((And patternOr) matchPatternWith: self)					ifTrue:[t:=Or new: (And new: ((self left) left) rightProp: (self right)) 								  rightProp: (And new:((self left) right) rightProp: (self right))]					ifFalse:[						((And patternOrSym) matchPatternWith: self)						ifTrue:[t:=Or new:(And new: (self left) rightProp: ((self right) left)) 									  rightProp: (And new: (self left) rightProp: ((self right) right))].						]					"]				]			]		].		(t isNil) ifTrue:[ (Prop debug) ifTrue:[Transcript show:'in And';show: self prettyPrint;cr.].			self left:(left clausification).								self right:(right clausification).								^self]					 ifFalse:[(Prop debug) ifTrue:[Transcript show:'in And2';show: t prettyPrint;cr.].						^t "clausification"]. ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!And class	instanceVariableNames: 'patternOr patternOrSym patternTrue patternTrueSym patternFalse patternFalseSym'!!And class methodsFor: 'initialize' stamp: 'pm 10/1/2018 07:46'!initialize	symb:='/\'.	patternOr:=And new: (Or new: (Var new: 'a') rightProp: (Var new:('a')))  rightProp: (Var new: 'a').	patternOrSym:=And new: (Var new: 'a') rightProp: (Or new: (Var new: 'a') rightProp: (Var new:('a'))).	patternTrue:=And new: (Var new: 'a') rightProp: (True_Const new).	patternTrueSym:=And new: (True_Const new) rightProp:(Var new:'a').	patternFalse:=And new: (Var new: 'a') rightProp: (False_Const new).	patternFalseSym:=And new: (False_Const new) rightProp:(Var new:'a').! !!And class methodsFor: 'initialize' stamp: 'pm 9/30/2018 15:51'!symb	^symb.! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternOr	^patternOr! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternOrSym	^patternOrSym! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternFalseSym	^patternFalseSym! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternFalse	^patternFalse! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternTrueSym	^patternTrueSym! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternTrue	^patternTrue! !Binary subclass: #Equal	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_Specification'!!Equal methodsFor: 'clausification' stamp: 'pm 10/1/2018 11:09'!clausification	| t |	t:=Or new: (And new: (self left) rightProp: (self right))		 rightProp: (And new:(Not new: (self left)) rightProp:(Not new: (self right))).	(Prop debug) ifTrue:[Transcript show:'in equal';show: t prettyPrint;cr.].	^t "clausification".! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Equal class	instanceVariableNames: ''!!Equal class methodsFor: 'accessing' stamp: 'pm 9/28/2018 22:16'!symb	^symb.! !!Equal class methodsFor: 'initialize' stamp: 'pm 9/30/2018 17:36'!initialize	symb:='<->'.! !Binary subclass: #Imply	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_Specification'!!Imply methodsFor: 'clausification' stamp: 'pm 10/1/2018 11:09'!clausification	|t|	t:=Or new: (Not new:left)  rightProp: right.	(Prop debug) ifTrue:[Transcript show:'in Imply';show: t prettyPrint;cr.].	^t "clausification".! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Imply class	instanceVariableNames: ''!!Imply class methodsFor: 'initialize' stamp: 'pm 9/30/2018 17:35'!initialize	symb:='->'.! !!Imply class methodsFor: 'accessing' stamp: 'pm 9/28/2018 22:16'!symb	^symb.! !Binary subclass: #Or	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_Specification'!!Or methodsFor: 'clausification' stamp: 'pm 9/29/2018 08:41'!isClause	^(left isClause & right isClause)! !!Or methodsFor: 'clausification' stamp: 'pm 10/1/2018 11:09'!clausification	| t |	t:=nil. 	((Or patternFalse) matchPatternWith: self)	ifTrue:[t:=left]	ifFalse:[		((Or patternFalseSym) matchPatternWith: self)		ifTrue:[t:=right]		ifFalse:[			((Or patternTrue) matchPatternWith: self)			ifTrue:[t:=right]			ifFalse:[				((Or patternTrueSym) matchPatternWith: self)				ifTrue:[t:=left]				ifFalse:[					((Or patternAnd) matchPatternWith: self)					ifTrue:[t:=And new: (Or new: ((self left) left) rightProp: (self right)) 								  rightProp: (Or new:((self left) right) rightProp: (self right))]					ifFalse:[						((Or patternAndSym) matchPatternWith: self)						ifTrue:[t:=And new:(Or new: (self left) rightProp: ((self right) left)) 									  rightProp: (Or new: (self left) rightProp: ((self right) right))].						]					]				]			]		].		(t isNil) ifTrue:[(Prop debug) ifTrue:[Transcript show:'in Or';show: self prettyPrint;cr.].								self left:(left clausification).								self right:(right clausification).								^self]					 ifFalse:[(Prop debug) ifTrue:[Transcript show:'in Or2';show: t prettyPrint;cr.].						^t "clausification" ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Or class	instanceVariableNames: 'patternAnd patternAndSym patternTrue patternTrueSym patternFalse patternFalseSym'!!Or class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:13'!patternFalseSym	^patternFalseSym! !!Or class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:11'!patternAnd	^patternAnd! !!Or class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:13'!patternFalse	^patternFalse! !!Or class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:12'!patternTrueSym	^patternTrueSym! !!Or class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:12'!patternAndSym	^patternAndSym! !!Or class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:12'!patternTrue	^patternTrue! !!Or class methodsFor: 'accessing' stamp: 'pm 9/28/2018 22:16'!symb	^symb.! !!Or class methodsFor: 'initialize' stamp: 'pm 10/1/2018 07:46'!initialize	symb:='\/'.	patternAnd:=Or new: (And new: (Var new: 'a') rightProp: (Var new:('a')))  rightProp: (Var new: 'a').	patternAndSym:=Or new: (Var new: 'a') rightProp: (And new: (Var new: 'a') rightProp: (Var new:('a'))).	patternTrue:=Or new: (Var new: 'a') rightProp: (True_Const new).	patternTrueSym:=Or new: (True_Const new) rightProp:(Var new:'a').	patternFalse:=Or new: (Var new: 'a') rightProp: (False_Const new).	patternFalseSym:=Or new: (False_Const new) rightProp:(Var new:'a').! !Constant subclass: #True_Const	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_Specification'!!True_Const methodsFor: 'matching' stamp: 'pm 9/30/2018 09:48'!matchPatternWith: prop	"see Prop comment for usage."	^prop isKindOf: True_Const! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!True_Const class	instanceVariableNames: ''!!True_Const class methodsFor: 'accessing' stamp: 'pm 9/28/2018 21:08'!symb	^symb! !!True_Const class methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!initialize	symb:='T'.! !Operator subclass: #Unary	instanceVariableNames: 'operand'	classVariableNames: ''	poolDictionaries: ''	category: '_Specification'!!Unary methodsFor: 'Initialize' stamp: 'pm 9/28/2018 22:38'!initialize: prop	operand:=prop.! !!Unary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:28'!operand: replacement	operand:=replacement.	^operand! !!Unary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:28'!operand	^operand! !!Unary methodsFor: 'Matching' stamp: 'pm 9/30/2018 10:39'!matchPatternWith: prop	(self compareSymbol: prop)		ifTrue:[^operand matchPatternWith: (prop operand)]		ifFalse:[^false].! !!Unary methodsFor: 'printing' stamp: 'pm 9/30/2018 19:21'!prettyPrint	^self getSymb,		((operand isKindOf: Atome) ifTrue:[' '] ifFalse:[' (']) ,		operand prettyPrint,		((operand isKindOf: Atome) ifTrue:[' '] ifFalse:[') ']).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Unary class	instanceVariableNames: ''!!Unary class methodsFor: 'Initialize' stamp: 'pm 9/28/2018 22:31'!new: prop	^self basicNew initialize: prop.! !Unary subclass: #Not	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_Specification'!!Not methodsFor: 'clausification' stamp: 'pm 9/30/2018 20:33'!isClause	" (!! a) is a clause, but !! (a \/ b) isn't"	^(operand isKindOf: Atome)! !!Not methodsFor: 'clausification' stamp: 'pm 10/1/2018 11:09'!clausification	"Only one clausification operation at time"	"/!!\ since we're in an unary operator, the pattern doesn't start at self, but at operand"	| t |	t:=nil.	((Not patternNot) matchPatternWith: operand)	ifTrue:[t:=operand operand.]	ifFalse:[			((Not patternTrue) matchPatternWith: operand)			ifTrue:[t:=False_Const new]			ifFalse:[				((Not patternFalse) matchPatternWith: operand)				ifTrue:[t:=True_Const new]				ifFalse:[					((Not patternOr) matchPatternWith: operand)					ifTrue:[t:=And new: (Not new:(operand left)) rightProp:(Not new:(operand right))]					ifFalse:[						((Not patternAnd) matchPatternWith: operand)						ifTrue:[t:=Or new: (Not new:(operand left)) rightProp:(Not new:(operand right))].						]					]				 ]			].		(t isNil) ifTrue:[(Prop debug) ifTrue:[Transcript show:'in Not';show: self prettyPrint;cr.].			 self operand:(operand clausification).								^self]					 ifFalse:[(Prop debug) ifTrue:[Transcript show:'in Not2';show: t prettyPrint;cr.].						^t "clausification" ].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Not class	instanceVariableNames: 'patternNot patternTrue patternFalse patternOr patternAnd'!!Not class methodsFor: 'Initialize' stamp: 'pm 9/30/2018 18:50'!initialize	symb:='!!'.	patternNot:=Not new:(Var new: 'a').	patternTrue:=True_Const new.	patternFalse:=False_Const new.	patternOr:=Or new:(Var new: 'a') rightProp: (Var new: 'a').	patternAnd:=And new:(Var new: 'a') rightProp: (Var new: 'a').! !!Not class methodsFor: 'accessing' stamp: 'pm 9/30/2018 14:14'!patternOr	^patternOr.! !!Not class methodsFor: 'accessing' stamp: 'pm 9/30/2018 14:15'!patternNot	^patternNot.! !!Not class methodsFor: 'accessing' stamp: 'pm 9/30/2018 14:15'!patternAnd	^patternAnd.! !!Not class methodsFor: 'accessing' stamp: 'pm 9/30/2018 14:14'!patternFalse	^patternFalse.! !!Not class methodsFor: 'accessing' stamp: 'pm 9/28/2018 22:16'!symb	^symb.! !!Not class methodsFor: 'accessing' stamp: 'pm 9/30/2018 14:15'!patternTrue	^patternTrue.! !Atome subclass: #Var	instanceVariableNames: 'symb'	classVariableNames: ''	poolDictionaries: ''	category: '_Specification'!!Var methodsFor: 'accessing' stamp: 'pm 9/28/2018 22:25'!getSymb	^symb! !!Var methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!initialize: varName	symb:=varName.! !!Var methodsFor: 'comparison' stamp: 'pm 9/29/2018 09:19'!isSameVar: other	^self getSymb = other getSymb.! !!Var methodsFor: 'matching' stamp: 'pm 9/30/2018 09:59'!matchPatternWith: prop	"see Prop comment for usage."	^true! !!Var methodsFor: 'printing' stamp: 'pm 9/28/2018 20:26'!prettyPrint	^symb! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Var class	instanceVariableNames: ''!!Var class methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!new: varName	^self basicNew initialize: varName.! !Var subclass: #NotVar	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_Specification'!Prop initialize!False_Const initialize!And initialize!Equal initialize!Imply initialize!Or initialize!True_Const initialize!Not initialize!