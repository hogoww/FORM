OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T16:38:08.522477+01:00' ],		#prior : OmReference [ 'Pharo.4zrmwqwp7wsqnwtnyhwmpc07n', '2' ],		#self : OmReference [ '1' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestUnification\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestUnification,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestUnification class\r\tinstanceVariableNames: \'\''				},				#name : #'TestUnification class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestUnification,					#isMetaSide : false				},				#parent : @7,				#content : 'Unification test. \rFor reference, the table of possible operations used is:\rVery unsure on some of those, but i\'m missing some examples.\rVERY unsure about  what to do on a const=Func or the other way around.\r\r             =         |     const      |   Linked    |     Func/Pred     \r        Const    |  Conflict     |  Swap       |    conflict\r                        |  Delete        |                    |\r                        |                       |                     | \r     Linked     | Eliminate  |  Delete     |    Check\r                        |                       |                     | \rFunc/Pred  | Conflict      |  Swap        |   Decompose\r                        |                       |                      |   Conflict\r                        |                       |                      | ',				#stamp : 'pm 12/19/2018 16:38'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'Unification test. \rFor reference, the table of possible operations used is:\rVery unsure on some of those, but i\'m missing some examples.\rVERY unsure about  what to do on a const=Func or the other way arround.\r\r             =         |     const      |   Linked    |     Func/Pred     \r        Const    |  Conflict     |  Swap       |    conflict\r                        |  Delete        |                    |\r                        |                       |                     | \r     Linked     | Eliminate  |  Delete     |    Check\r                        |                       |                     | \rFunc/Pred  | Conflict      |  Swap        |   Decompose\r                        |                       |                      |   Conflict\r                        |                       |                      | ',		#newComment : 'Unification test. \rFor reference, the table of possible operations used is:\rVery unsure on some of those, but i\'m missing some examples.\rVERY unsure about  what to do on a const=Func or the other way around.\r\r             =         |     const      |   Linked    |     Func/Pred     \r        Const    |  Conflict     |  Swap       |    conflict\r                        |  Delete        |                    |\r                        |                       |                     | \r     Linked     | Eliminate  |  Delete     |    Check\r                        |                       |                     | \rFunc/Pred  | Conflict      |  Swap        |   Decompose\r                        |                       |                      |   Conflict\r                        |                       |                      | ',		#oldStamp : 'pm 12/15/2018 19:56',		#newStamp : 'pm 12/19/2018 16:38'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T16:55:52.644423+01:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see a program trace"\r\r\t"Variable to activate traces or not."\r\tskolemnTrace:=false.\r\tclausificationTrace:=false.\r\tunificationTrace:=false.\r\tresolutionTrace:=false.\r\t\r\t"Used to provided context during the textual tests available in the Prop class "\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/18/2018 09:55',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see a program trace"\r\r\t"Variable to activate traces or not."\r\tskolemnTrace:=true.\r\tclausificationTrace:=false.\r\tunificationTrace:=false.\r\tresolutionTrace:=false.\r\t\r\t"Used to provided context during the textual tests available in the Prop class "\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/19/2018 16:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T16:56:01.591635+01:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see a program trace"\r\r\t"Variable to activate traces or not."\r\tskolemnTrace:=true.\r\tclausificationTrace:=false.\r\tunificationTrace:=false.\r\tresolutionTrace:=false.\r\t\r\t"Used to provided context during the textual tests available in the Prop class "\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/19/2018 16:55',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see a program trace"\r\r\t"Variable to activate traces or not."\r\tskolemnTrace:=false.\r\tclausificationTrace:=false.\r\tunificationTrace:=false.\r\tresolutionTrace:=false.\r\t\r\t"Used to provided context during the textual tests available in the Prop class "\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/19/2018 16:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T17:53:21.568709+01:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestUnification\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestUnification,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestUnification class\r\tinstanceVariableNames: \'\''				},				#name : #'TestUnification class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestUnification,					#isMetaSide : false				},				#parent : @7,				#content : 'Unification test. \rFor reference, the table of possible operations used is:\rVery unsure on some of those, but i\'m missing some examples.\rVERY unsure about  what to do on a const=Func or the other way around.\r\r             =         |     const      |   Linked    |     Func \r        Const    |  Conflict     |  Swap       |    conflict\r                        |  Delete        |                    |\r                        |                       |                     | \r     Linked     | Eliminate  |  Delete     |    Check\r                        |                       |                     | \rFunc              | Conflict      |  Swap        |   Decompose\r                        |                       |                      |   Conflict\r                        |                       |                      | ',				#stamp : 'pm 12/19/2018 17:53'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'Unification test. \rFor reference, the table of possible operations used is:\rVery unsure on some of those, but i\'m missing some examples.\rVERY unsure about  what to do on a const=Func or the other way around.\r\r             =         |     const      |   Linked    |     Func/Pred     \r        Const    |  Conflict     |  Swap       |    conflict\r                        |  Delete        |                    |\r                        |                       |                     | \r     Linked     | Eliminate  |  Delete     |    Check\r                        |                       |                     | \rFunc/Pred  | Conflict      |  Swap        |   Decompose\r                        |                       |                      |   Conflict\r                        |                       |                      | ',		#newComment : 'Unification test. \rFor reference, the table of possible operations used is:\rVery unsure on some of those, but i\'m missing some examples.\rVERY unsure about  what to do on a const=Func or the other way around.\r\r             =         |     const      |   Linked    |     Func \r        Const    |  Conflict     |  Swap       |    conflict\r                        |  Delete        |                    |\r                        |                       |                     | \r     Linked     | Eliminate  |  Delete     |    Check\r                        |                       |                     | \rFunc              | Conflict      |  Swap        |   Decompose\r                        |                       |                      |   Conflict\r                        |                       |                      | ',		#oldStamp : 'pm 12/19/2018 16:38',		#newStamp : 'pm 12/19/2018 17:53'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T17:53:41.831015+01:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Unifier\r\tinstanceVariableNames: \'setOfPairs hasFailed initialPair unifiedPair\'\r\tclassVariableNames: \'UnifiedTerm\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Clausal Form\''			},			#name : #Unifier,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #setOfPairs,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #hasFailed,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #initialPair,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #unifiedPair,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Unifier class\r\tinstanceVariableNames: \'\''				},				#name : #'Unifier class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Unifier,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent an Unifier object.\r\rMy purpose is to unify two predicate.\r\rPublic API and Key Messages\r\r-Unifier new: Predicate2:\r- UnifyThis\r\rp1:=Predicate new:(..)\rp2:=Predicate new:(...)\rUnifier new: p1 Predicate2:p2\r \rInstance Variables\r\thasFailed:\tBoolean to see if the unification failed.\r\rFor reference, the table of possible operations used is:\rVery unsure on some of those, but i\'m missing some examples.VERY unsure about  what to do on a const=Func or the other way arround.\r\r             =         |     const      |   Linked    |     Func\r        Const    |  Conflict     |  Swap       |    conflict\r                        |  Delete        |                    |\r                        |                       |                     | \r     Linked     | Eliminate  |  Delete     |    Check\r                        |                       |                     | \rFunc            | Conflict      |  Swap        |   Decompose\r                        |                       |                      |   Conflict\r                        |                       |                      | ',				#stamp : 'pm 12/19/2018 17:53'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #UnifiedTerm,					#parent : @7				}			],			#category : #'_resolution_1erOrdre-Clausal Form',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'I represent an Unifier object.\r\rMy purpose is to unify two predicate.\r\rPublic API and Key Messages\r\r-Unifier new: Predicate2:\r- UnifyThis\r\rp1:=Predicate new:(..)\rp2:=Predicate new:(...)\rUnifier new: p1 Predicate2:p2\r \rInstance Variables\r\thasFailed:\tBoolean to see if the unification failed.\r\rFor reference, the table of possible operations used is:\rVery unsure on some of those, but i\'m missing some examples.VERY unsure about  what to do on a const=Func or the other way arround.\r\r             =         |     const      |   Linked    |     Func/Pred     \r        Const    |  Conflict     |  Swap       |    conflict\r                        |  Delete        |                    |\r                        |                       |                     | \r     Linked     | Eliminate  |  Delete     |    Check\r                        |                       |                     | \rFunc/Pred  | Conflict      |  Swap        |   Decompose\r                        |                       |                      |   Conflict\r                        |                       |                      | ',		#newComment : 'I represent an Unifier object.\r\rMy purpose is to unify two predicate.\r\rPublic API and Key Messages\r\r-Unifier new: Predicate2:\r- UnifyThis\r\rp1:=Predicate new:(..)\rp2:=Predicate new:(...)\rUnifier new: p1 Predicate2:p2\r \rInstance Variables\r\thasFailed:\tBoolean to see if the unification failed.\r\rFor reference, the table of possible operations used is:\rVery unsure on some of those, but i\'m missing some examples.VERY unsure about  what to do on a const=Func or the other way arround.\r\r             =         |     const      |   Linked    |     Func\r        Const    |  Conflict     |  Swap       |    conflict\r                        |  Delete        |                    |\r                        |                       |                     | \r     Linked     | Eliminate  |  Delete     |    Check\r                        |                       |                     | \rFunc            | Conflict      |  Swap        |   Decompose\r                        |                       |                      |   Conflict\r                        |                       |                      | ',		#oldStamp : 'pm 12/15/2018 19:56',		#newStamp : 'pm 12/19/2018 17:53'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T17:53:43.239221+01:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Unifier\r\tinstanceVariableNames: \'setOfPairs hasFailed initialPair unifiedPair\'\r\tclassVariableNames: \'UnifiedTerm\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Clausal Form\''			},			#name : #Unifier,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #setOfPairs,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #hasFailed,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #initialPair,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #unifiedPair,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Unifier class\r\tinstanceVariableNames: \'\''				},				#name : #'Unifier class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Unifier,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent an Unifier object.\r\rMy purpose is to unify two predicate.\r\rPublic API and Key Messages\r\r-Unifier new: Predicate2:\r- UnifyThis\r\rp1:=Predicate new:(..)\rp2:=Predicate new:(...)\rUnifier new: p1 Predicate2:p2\r \rInstance Variables\r\thasFailed:\tBoolean to see if the unification failed.\r\rFor reference, the table of possible operations used is:\rVery unsure on some of those, but i\'m missing some examples.VERY unsure about  what to do on a const=Func or the other way arround.\r\r             =         |     const      |   Linked    |     Func\r        Const    |  Conflict     |  Swap       |    conflict\r                        |  Delete        |                    |\r                        |                       |                     | \r     Linked     | Eliminate  |  Delete     |    Check\r                        |                       |                     | \rFunc             | Conflict      |  Swap        |   Decompose\r                        |                       |                      |   Conflict\r                        |                       |                      | ',				#stamp : 'pm 12/19/2018 17:53'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #UnifiedTerm,					#parent : @7				}			],			#category : #'_resolution_1erOrdre-Clausal Form',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'I represent an Unifier object.\r\rMy purpose is to unify two predicate.\r\rPublic API and Key Messages\r\r-Unifier new: Predicate2:\r- UnifyThis\r\rp1:=Predicate new:(..)\rp2:=Predicate new:(...)\rUnifier new: p1 Predicate2:p2\r \rInstance Variables\r\thasFailed:\tBoolean to see if the unification failed.\r\rFor reference, the table of possible operations used is:\rVery unsure on some of those, but i\'m missing some examples.VERY unsure about  what to do on a const=Func or the other way arround.\r\r             =         |     const      |   Linked    |     Func\r        Const    |  Conflict     |  Swap       |    conflict\r                        |  Delete        |                    |\r                        |                       |                     | \r     Linked     | Eliminate  |  Delete     |    Check\r                        |                       |                     | \rFunc            | Conflict      |  Swap        |   Decompose\r                        |                       |                      |   Conflict\r                        |                       |                      | ',		#newComment : 'I represent an Unifier object.\r\rMy purpose is to unify two predicate.\r\rPublic API and Key Messages\r\r-Unifier new: Predicate2:\r- UnifyThis\r\rp1:=Predicate new:(..)\rp2:=Predicate new:(...)\rUnifier new: p1 Predicate2:p2\r \rInstance Variables\r\thasFailed:\tBoolean to see if the unification failed.\r\rFor reference, the table of possible operations used is:\rVery unsure on some of those, but i\'m missing some examples.VERY unsure about  what to do on a const=Func or the other way arround.\r\r             =         |     const      |   Linked    |     Func\r        Const    |  Conflict     |  Swap       |    conflict\r                        |  Delete        |                    |\r                        |                       |                     | \r     Linked     | Eliminate  |  Delete     |    Check\r                        |                       |                     | \rFunc             | Conflict      |  Swap        |   Decompose\r                        |                       |                      |   Conflict\r                        |                       |                      | ',		#oldStamp : 'pm 12/19/2018 17:53',		#newStamp : 'pm 12/19/2018 17:53'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:29:35.723591+01:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ],		#time : DateAndTime [ '2018-12-19T20:29:35.73288+01:00' ],		#trigger : @3	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'clausificationTrace resolutionTrace skolemnTrace testNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @7,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- fullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- prettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 12/15/2018 15:14'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'ClausificationTrace clausificationTrace resolutionTrace skolemnTrace testNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @31			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @31,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- fullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- prettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 12/15/2018 15:14'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #ClausificationTrace,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @31				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ],		#time : DateAndTime [ '2018-12-19T20:29:35.741588+01:00' ],		#trigger : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #fullClausification,			#protocol : #clausification,			#sourceCode : 'fullClausification\r\t| t |\r\tt:=self clausification.\r\t[t isClause] whileFalse:[\t\r\t\tclausificationTrace ifTrue:[Transcript show: t prettyPrint; show: t isClause;cr.].\r\t\tt:=t clausification.].\r\t^t',			#stamp : 'pm 12/15/2018 16:49',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #fullClausification,			#protocol : #clausification,			#sourceCode : 'fullClausification\r\t| t |\r\tt:=self clausification.\r\t[t isClause] whileFalse:[\t\r\t\tClausificationTrace ifTrue:[Transcript show: t prettyPrint; show: t isClause;cr.].\r\t\tt:=t clausification.].\r\t^t',			#stamp : 'pm 12/19/2018 20:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ],		#time : DateAndTime [ '2018-12-19T20:29:35.761856+01:00' ],		#trigger : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see a program trace"\r\r\t"Variable to activate traces or not."\r\tskolemnTrace:=false.\r\tclausificationTrace:=false.\r\tunificationTrace:=false.\r\tresolutionTrace:=false.\r\t\r\t"Used to provided context during the textual tests available in the Prop class "\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/19/2018 16:56',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see a program trace"\r\r\t"Variable to activate traces or not."\r\tskolemnTrace:=false.\r\tClausificationTrace:=false.\r\tunificationTrace:=false.\r\tresolutionTrace:=false.\r\t\r\t"Used to provided context during the textual tests available in the Prop class "\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/19/2018 20:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:31:07.464104+01:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpRedo {		#entryReferences : [			OmReference [ '7' ]		]	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:31:16.025209+01:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpUndo {		#entryReferences : OrderedCollection [			OmReference [ '2xtq8w00di0tewdbkyc0xu66c', '1' ],			OmReference [ '2xtq8w00di0tewdbkyc0xu66c', '2' ],			OmReference [ '2xtq8w00di0tewdbkyc0xu66c', '3' ]		]	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ],		#time : DateAndTime [ '2018-12-19T20:31:16.035495+01:00' ],		#trigger : @3	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see a program trace"\r\r\t"Variable to activate traces or not."\r\tskolemnTrace:=false.\r\tClausificationTrace:=false.\r\tunificationTrace:=false.\r\tresolutionTrace:=false.\r\t\r\t"Used to provided context during the textual tests available in the Prop class "\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/19/2018 20:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see a program trace"\r\r\t"Variable to activate traces or not."\r\tskolemnTrace:=false.\r\tclausificationTrace:=false.\r\tunificationTrace:=false.\r\tresolutionTrace:=false.\r\t\r\t"Used to provided context during the textual tests available in the Prop class "\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/19/2018 20:31',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ],		#time : DateAndTime [ '2018-12-19T20:31:16.0439+01:00' ],		#trigger : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #fullClausification,			#protocol : #clausification,			#sourceCode : 'fullClausification\r\t| t |\r\tt:=self clausification.\r\t[t isClause] whileFalse:[\t\r\t\tClausificationTrace ifTrue:[Transcript show: t prettyPrint; show: t isClause;cr.].\r\t\tt:=t clausification.].\r\t^t',			#stamp : 'pm 12/19/2018 20:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #fullClausification,			#protocol : #clausification,			#sourceCode : 'fullClausification\r\t| t |\r\tt:=self clausification.\r\t[t isClause] whileFalse:[\t\r\t\tclausificationTrace ifTrue:[Transcript show: t prettyPrint; show: t isClause;cr.].\r\t\tt:=t clausification.].\r\t^t',			#stamp : 'pm 12/19/2018 20:31',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ],		#time : DateAndTime [ '2018-12-19T20:31:16.095861+01:00' ],		#trigger : OmReference [ '12' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'ClausificationTrace resolutionTrace skolemnTrace testNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @8,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- fullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- prettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 12/15/2018 15:14'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #ClausificationTrace,					#parent : @8				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @8				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @8				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @8				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @8				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'ClausificationTrace resolutionTrace skolemnTrace testNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @32			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @32,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- fullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- prettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 12/15/2018 15:14'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #ClausificationTrace,					#parent : @32				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @32				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @32				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @32				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @32				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ],		#time : DateAndTime [ '2018-12-19T20:31:16.259991+01:00' ],		#trigger : OmReference [ '12' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'clausificationTrace resolutionTrace skolemnTrace testNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @8,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- fullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- prettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 12/15/2018 15:14'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @8				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @8				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @8				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @8				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @8				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'clausificationTrace resolutionTrace skolemnTrace testNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @32			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @32,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- fullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- prettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 12/15/2018 15:14'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @32				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @32				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @32				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @32				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @32				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:32:21.615991+01:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #'Skolemnise:CorrespondingValue:',		#newSelector : #'Skolemise:CorrespondingValue:',		#affectedClassName : #Prop	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ],		#time : DateAndTime [ '2018-12-19T20:32:21.637389+01:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars:  setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.\r\t\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ],		#time : DateAndTime [ '2018-12-19T20:32:21.640765+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ;space ; show:self ;cr].\r\t\r\t^self updateTerms: setOfLinkedVar CorrespondingValue: aMap.',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ],		#time : DateAndTime [ '2018-12-19T20:32:21.64334+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self operand Herbrandise: setOfLinkedVar CorrespondingValue: aMap).',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ],		#time : DateAndTime [ '2018-12-19T20:32:21.646037+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self class name ;space ; show:self ;cr].\r\t^self.',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ],		#time : DateAndTime [ '2018-12-19T20:32:21.652948+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t^SubclassResponsibility.',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ],		#time : DateAndTime [ '2018-12-19T20:32:21.65605+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Skolemnise: (setOfLinkedVar veryDeepCopy)  CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Skolemnise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t"Works for Or & And."\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ],		#time : DateAndTime [ '2018-12-19T20:32:21.658466+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) Skolemnise:setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ],		#time : DateAndTime [ '2018-12-19T20:32:21.661434+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Skolemnise: setOfLinkedVar CorrespondingValue: aMap).\r\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ],		#time : DateAndTime [ '2018-12-19T20:32:21.663655+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\r\t^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.\r\t \r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ],		#time : DateAndTime [ '2018-12-19T20:32:21.665716+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Skolemnise: setOfLinkedVar CorrespondingValue: aMap).\r\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Skolemise: setOfLinkedVar CorrespondingValue: aMap).\r\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ],		#time : DateAndTime [ '2018-12-19T20:32:21.673512+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Skolemnise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Herbrandise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/12/2018 16:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Skolemise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Herbrandise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ],		#time : DateAndTime [ '2018-12-19T20:32:21.679759+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Skolemnise: setOfLinkedVar CorrespondingValue: aMap).\r\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/12/2018 16:28',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Skolemise: setOfLinkedVar CorrespondingValue: aMap).\r\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ],		#time : DateAndTime [ '2018-12-19T20:32:21.684831+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars:  setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.\r\t\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars:  setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Skolemise: setOfLinkedVar CorrespondingValue: aMap.\r\t\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ],		#time : DateAndTime [ '2018-12-19T20:32:21.690492+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars:  setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.\r\t\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/12/2018 16:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars:  setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Skolemise: setOfLinkedVar CorrespondingValue: aMap.\r\t\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ],		#time : DateAndTime [ '2018-12-19T20:32:21.695387+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #StartSkolemnisation,			#protocol : #Skoleminsation,			#sourceCode : 'StartSkolemnisation\r\t| set aMap |\r\tset:=MinimalOrderedSet new.\r\taMap:=Dictionary new.\r\t^self Skolemnise: set CorrespondingValue: aMap',			#stamp : 'pm 10/7/2018 19:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #StartSkolemnisation,			#protocol : #Skoleminsation,			#sourceCode : 'StartSkolemnisation\r\t| set aMap |\r\tset:=MinimalOrderedSet new.\r\taMap:=Dictionary new.\r\t^self Skolemise: set CorrespondingValue: aMap',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ],		#time : DateAndTime [ '2018-12-19T20:32:21.701735+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self operand Skolemnise: setOfLinkedVar CorrespondingValue: aMap).',			#stamp : 'pm 12/12/2018 16:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self operand Skolemise: setOfLinkedVar CorrespondingValue: aMap).',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ],		#time : DateAndTime [ '2018-12-19T20:32:21.70728+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\r\t^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.\r\t \r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\r\t^(self operand) Skolemise: setOfLinkedVar CorrespondingValue: aMap.\r\t \r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ],		#time : DateAndTime [ '2018-12-19T20:32:21.712281+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\r\t^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.\r\t \r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/12/2018 16:27',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\r\t^(self operand) Skolemise: setOfLinkedVar CorrespondingValue: aMap.\r\t \r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ],		#time : DateAndTime [ '2018-12-19T20:32:21.71776+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) Skolemnise:setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) Skolemise:setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ],		#time : DateAndTime [ '2018-12-19T20:32:21.722544+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) Skolemnise:setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/12/2018 16:28',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) Skolemise:setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ],		#time : DateAndTime [ '2018-12-19T20:32:21.727971+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Skolemnise: (setOfLinkedVar veryDeepCopy)  CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Skolemnise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t"Works for Or & And."\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Skolemise: (setOfLinkedVar veryDeepCopy)  CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Skolemise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t"Works for Or & And."\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ],		#time : DateAndTime [ '2018-12-19T20:32:21.73376+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Skolemnise: (setOfLinkedVar veryDeepCopy)  CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Skolemnise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t"Works for Or & And."\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/12/2018 17:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Skolemise: (setOfLinkedVar veryDeepCopy)  CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Skolemise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t"Works for Or & And."\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ],		#time : DateAndTime [ '2018-12-19T20:32:21.737647+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars:  setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Skolemise: setOfLinkedVar CorrespondingValue: aMap.\r\t\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ],		#time : DateAndTime [ '2018-12-19T20:32:21.740258+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ;space ; show:self ;cr].\r\t\r\t^self updateTerms: setOfLinkedVar CorrespondingValue: aMap.',			#stamp : 'pm 12/12/2018 16:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ],		#time : DateAndTime [ '2018-12-19T20:32:21.742296+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self operand Herbrandise: setOfLinkedVar CorrespondingValue: aMap).',			#stamp : 'pm 12/12/2018 16:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ],		#time : DateAndTime [ '2018-12-19T20:32:21.743802+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self class name ;space ; show:self ;cr].\r\t^self.',			#stamp : 'pm 12/12/2018 16:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ],		#time : DateAndTime [ '2018-12-19T20:32:21.760959+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t^SubclassResponsibility.',			#stamp : 'pm 11/26/2018 20:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ],		#time : DateAndTime [ '2018-12-19T20:32:21.764854+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Skolemise: (setOfLinkedVar veryDeepCopy)  CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Skolemise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t"Works for Or & And."\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ],		#time : DateAndTime [ '2018-12-19T20:32:21.766486+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) Skolemise:setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ],		#time : DateAndTime [ '2018-12-19T20:32:21.767992+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Skolemise: setOfLinkedVar CorrespondingValue: aMap).\r\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ],		#time : DateAndTime [ '2018-12-19T20:32:21.769405+01:00' ],		#trigger : OmReference [ '17' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\r\t^(self operand) Skolemise: setOfLinkedVar CorrespondingValue: aMap.\r\t \r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:32:43.232688+01:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #'Skolemise:CorrespondingValue:',		#newSelector : #'skolemise:CorrespondingValue:',		#affectedClassName : #Prop	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ],		#time : DateAndTime [ '2018-12-19T20:32:43.256266+01:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars:  setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Skolemise: setOfLinkedVar CorrespondingValue: aMap.\r\t\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ],		#time : DateAndTime [ '2018-12-19T20:32:43.260047+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ;space ; show:self ;cr].\r\t\r\t^self updateTerms: setOfLinkedVar CorrespondingValue: aMap.',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ],		#time : DateAndTime [ '2018-12-19T20:32:43.262707+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self operand Herbrandise: setOfLinkedVar CorrespondingValue: aMap).',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ],		#time : DateAndTime [ '2018-12-19T20:32:43.264973+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self class name ;space ; show:self ;cr].\r\t^self.',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ],		#time : DateAndTime [ '2018-12-19T20:32:43.270996+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t^SubclassResponsibility.',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ],		#time : DateAndTime [ '2018-12-19T20:32:43.273795+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Skolemise: (setOfLinkedVar veryDeepCopy)  CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Skolemise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t"Works for Or & And."\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ],		#time : DateAndTime [ '2018-12-19T20:32:43.276598+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) Skolemise:setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ],		#time : DateAndTime [ '2018-12-19T20:32:43.279212+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Skolemise: setOfLinkedVar CorrespondingValue: aMap).\r\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ],		#time : DateAndTime [ '2018-12-19T20:32:43.282069+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\r\t^(self operand) Skolemise: setOfLinkedVar CorrespondingValue: aMap.\r\t \r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ],		#time : DateAndTime [ '2018-12-19T20:32:43.284465+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Skolemise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Herbrandise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left skolemise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Herbrandise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ],		#time : DateAndTime [ '2018-12-19T20:32:43.293255+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Skolemise: setOfLinkedVar CorrespondingValue: aMap).\r\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right skolemise: setOfLinkedVar CorrespondingValue: aMap).\r\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ],		#time : DateAndTime [ '2018-12-19T20:32:43.299481+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Skolemise: setOfLinkedVar CorrespondingValue: aMap).\r\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right skolemise: setOfLinkedVar CorrespondingValue: aMap).\r\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ],		#time : DateAndTime [ '2018-12-19T20:32:43.304405+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars:  setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Skolemise: setOfLinkedVar CorrespondingValue: aMap.\r\t\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars:  setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) skolemise: setOfLinkedVar CorrespondingValue: aMap.\r\t\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ],		#time : DateAndTime [ '2018-12-19T20:32:43.310459+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars:  setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Skolemise: setOfLinkedVar CorrespondingValue: aMap.\r\t\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars:  setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) skolemise: setOfLinkedVar CorrespondingValue: aMap.\r\t\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ],		#time : DateAndTime [ '2018-12-19T20:32:43.315227+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #StartSkolemnisation,			#protocol : #Skoleminsation,			#sourceCode : 'StartSkolemnisation\r\t| set aMap |\r\tset:=MinimalOrderedSet new.\r\taMap:=Dictionary new.\r\t^self Skolemise: set CorrespondingValue: aMap',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #StartSkolemnisation,			#protocol : #Skoleminsation,			#sourceCode : 'StartSkolemnisation\r\t| set aMap |\r\tset:=MinimalOrderedSet new.\r\taMap:=Dictionary new.\r\t^self skolemise: set CorrespondingValue: aMap',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ],		#time : DateAndTime [ '2018-12-19T20:32:43.322085+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self operand Skolemise: setOfLinkedVar CorrespondingValue: aMap).',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self operand skolemise: setOfLinkedVar CorrespondingValue: aMap).',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ],		#time : DateAndTime [ '2018-12-19T20:32:43.328104+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\r\t^(self operand) Skolemise: setOfLinkedVar CorrespondingValue: aMap.\r\t \r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\r\t^(self operand) skolemise: setOfLinkedVar CorrespondingValue: aMap.\r\t \r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ],		#time : DateAndTime [ '2018-12-19T20:32:43.334262+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\r\t^(self operand) Skolemise: setOfLinkedVar CorrespondingValue: aMap.\r\t \r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\r\t^(self operand) skolemise: setOfLinkedVar CorrespondingValue: aMap.\r\t \r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ],		#time : DateAndTime [ '2018-12-19T20:32:43.339129+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) Skolemise:setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) skolemise:setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ],		#time : DateAndTime [ '2018-12-19T20:32:43.345024+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) Skolemise:setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) skolemise:setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ],		#time : DateAndTime [ '2018-12-19T20:32:43.350006+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Skolemise: (setOfLinkedVar veryDeepCopy)  CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Skolemise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t"Works for Or & And."\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left skolemise: (setOfLinkedVar veryDeepCopy)  CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right skolemise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t"Works for Or & And."\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ],		#time : DateAndTime [ '2018-12-19T20:32:43.355668+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Skolemise: (setOfLinkedVar veryDeepCopy)  CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Skolemise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t"Works for Or & And."\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left skolemise: (setOfLinkedVar veryDeepCopy)  CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right skolemise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t"Works for Or & And."\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ],		#time : DateAndTime [ '2018-12-19T20:32:43.359403+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars:  setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) skolemise: setOfLinkedVar CorrespondingValue: aMap.\r\t\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '72' ],		#self : OmReference [ '73' ],		#time : DateAndTime [ '2018-12-19T20:32:43.361451+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ;space ; show:self ;cr].\r\t\r\t^self updateTerms: setOfLinkedVar CorrespondingValue: aMap.',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '73' ],		#self : OmReference [ '74' ],		#time : DateAndTime [ '2018-12-19T20:32:43.363046+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self operand Herbrandise: setOfLinkedVar CorrespondingValue: aMap).',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '74' ],		#self : OmReference [ '75' ],		#time : DateAndTime [ '2018-12-19T20:32:43.365497+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self class name ;space ; show:self ;cr].\r\t^self.',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '75' ],		#self : OmReference [ '76' ],		#time : DateAndTime [ '2018-12-19T20:32:43.385548+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t^SubclassResponsibility.',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '76' ],		#self : OmReference [ '77' ],		#time : DateAndTime [ '2018-12-19T20:32:43.38774+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left skolemise: (setOfLinkedVar veryDeepCopy)  CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right skolemise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t"Works for Or & And."\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '77' ],		#self : OmReference [ '78' ],		#time : DateAndTime [ '2018-12-19T20:32:43.389542+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) skolemise:setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '78' ],		#self : OmReference [ '79' ],		#time : DateAndTime [ '2018-12-19T20:32:43.391075+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right skolemise: setOfLinkedVar CorrespondingValue: aMap).\r\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '79' ],		#self : OmReference [ '80' ],		#time : DateAndTime [ '2018-12-19T20:32:43.39298+01:00' ],		#trigger : OmReference [ '49' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\r\t^(self operand) skolemise: setOfLinkedVar CorrespondingValue: aMap.\r\t \r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:33:01.112962+01:00' ],		#prior : OmReference [ '80' ],		#self : OmReference [ '81' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #'Herbrandise:CorrespondingValue:',		#newSelector : #'herbrandise:CorrespondingValue:',		#affectedClassName : #Prop	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '81' ],		#self : OmReference [ '82' ],		#time : DateAndTime [ '2018-12-19T20:33:01.133842+01:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\t^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '82' ],		#self : OmReference [ '83' ],		#time : DateAndTime [ '2018-12-19T20:33:01.136936+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\'  ;space ; show:self ;cr].\r\t\r\t^self updateTerms: setOfLinkedVar CorrespondingValue: aMap.',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '83' ],		#self : OmReference [ '84' ],		#time : DateAndTime [ '2018-12-19T20:33:01.139548+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self operand skolemise: setOfLinkedVar CorrespondingValue: aMap).',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '84' ],		#self : OmReference [ '85' ],		#time : DateAndTime [ '2018-12-19T20:33:01.141933+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self class name ;space ; show:self ;cr].\r\t^self.',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '85' ],		#self : OmReference [ '86' ],		#time : DateAndTime [ '2018-12-19T20:33:01.149951+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t^SubclassResponsibility.',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '86' ],		#self : OmReference [ '87' ],		#time : DateAndTime [ '2018-12-19T20:33:01.152812+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Herbrandise: setOfLinkedVar CorrespondingValue: aMap ).\r\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '87' ],		#self : OmReference [ '88' ],		#time : DateAndTime [ '2018-12-19T20:33:01.155224+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\t\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) Herbrandise: setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '88' ],		#self : OmReference [ '89' ],		#time : DateAndTime [ '2018-12-19T20:33:01.157518+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left skolemise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Herbrandise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '89' ],		#self : OmReference [ '90' ],		#time : DateAndTime [ '2018-12-19T20:33:01.160746+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars: setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.\t"(self class) new: ("\t")"\r\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '90' ],		#self : OmReference [ '91' ],		#time : DateAndTime [ '2018-12-19T20:33:01.162945+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left skolemise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Herbrandise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left skolemise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right herbrandise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '91' ],		#self : OmReference [ '92' ],		#time : DateAndTime [ '2018-12-19T20:33:01.169846+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right skolemise: setOfLinkedVar CorrespondingValue: aMap).\r\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right skolemise: setOfLinkedVar CorrespondingValue: aMap).\r\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '92' ],		#self : OmReference [ '93' ],		#time : DateAndTime [ '2018-12-19T20:33:01.175839+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left skolemise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Herbrandise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left skolemise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right herbrandise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '93' ],		#self : OmReference [ '94' ],		#time : DateAndTime [ '2018-12-19T20:33:01.180985+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\t^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/12/2018 16:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\t^(self operand) herbrandise: setOfLinkedVar CorrespondingValue: aMap.\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '94' ],		#self : OmReference [ '95' ],		#time : DateAndTime [ '2018-12-19T20:33:01.186748+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\t^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\t^(self operand) herbrandise: setOfLinkedVar CorrespondingValue: aMap.\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '95' ],		#self : OmReference [ '96' ],		#time : DateAndTime [ '2018-12-19T20:33:01.191916+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self operand Herbrandise: setOfLinkedVar CorrespondingValue: aMap).',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self operand herbrandise: setOfLinkedVar CorrespondingValue: aMap).',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '96' ],		#self : OmReference [ '97' ],		#time : DateAndTime [ '2018-12-19T20:33:01.197679+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars: setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.\t"(self class) new: ("\t")"\r\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/12/2018 16:27',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars: setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) herbrandise: setOfLinkedVar CorrespondingValue: aMap.\t"(self class) new: ("\t")"\r\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '97' ],		#self : OmReference [ '98' ],		#time : DateAndTime [ '2018-12-19T20:33:01.202963+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars: setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.\t"(self class) new: ("\t")"\r\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars: setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) herbrandise: setOfLinkedVar CorrespondingValue: aMap.\t"(self class) new: ("\t")"\r\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '98' ],		#self : OmReference [ '99' ],		#time : DateAndTime [ '2018-12-19T20:33:01.208926+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\t\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) Herbrandise: setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/12/2018 16:28',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\t\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) herbrandise: setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '99' ],		#self : OmReference [ '100' ],		#time : DateAndTime [ '2018-12-19T20:33:01.213822+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\t\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) Herbrandise: setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\t\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) herbrandise: setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '100' ],		#self : OmReference [ '101' ],		#time : DateAndTime [ '2018-12-19T20:33:01.21925+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Herbrandise: setOfLinkedVar CorrespondingValue: aMap ).\r\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/12/2018 17:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right herbrandise: setOfLinkedVar CorrespondingValue: aMap ).\r\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '101' ],		#self : OmReference [ '102' ],		#time : DateAndTime [ '2018-12-19T20:33:01.224371+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Herbrandise: setOfLinkedVar CorrespondingValue: aMap ).\r\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right herbrandise: setOfLinkedVar CorrespondingValue: aMap ).\r\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '102' ],		#self : OmReference [ '103' ],		#time : DateAndTime [ '2018-12-19T20:33:01.228842+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\t^(self operand) herbrandise: setOfLinkedVar CorrespondingValue: aMap.\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '103' ],		#self : OmReference [ '104' ],		#time : DateAndTime [ '2018-12-19T20:33:01.232278+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\'  ;space ; show:self ;cr].\r\t\r\t^self updateTerms: setOfLinkedVar CorrespondingValue: aMap.',			#stamp : 'pm 12/12/2018 16:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '104' ],		#self : OmReference [ '105' ],		#time : DateAndTime [ '2018-12-19T20:33:01.236202+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self operand skolemise: setOfLinkedVar CorrespondingValue: aMap).',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '105' ],		#self : OmReference [ '106' ],		#time : DateAndTime [ '2018-12-19T20:33:01.237993+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self class name ;space ; show:self ;cr].\r\t^self.',			#stamp : 'pm 12/12/2018 16:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '106' ],		#self : OmReference [ '107' ],		#time : DateAndTime [ '2018-12-19T20:33:01.26085+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t^SubclassResponsibility.',			#stamp : 'pm 12/7/2018 13:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '107' ],		#self : OmReference [ '108' ],		#time : DateAndTime [ '2018-12-19T20:33:01.2649+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right herbrandise: setOfLinkedVar CorrespondingValue: aMap ).\r\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '108' ],		#self : OmReference [ '109' ],		#time : DateAndTime [ '2018-12-19T20:33:01.267447+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\t\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) herbrandise: setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '109' ],		#self : OmReference [ '110' ],		#time : DateAndTime [ '2018-12-19T20:33:01.269288+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left skolemise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right herbrandise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '110' ],		#self : OmReference [ '111' ],		#time : DateAndTime [ '2018-12-19T20:33:01.271522+01:00' ],		#trigger : OmReference [ '81' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars: setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) herbrandise: setOfLinkedVar CorrespondingValue: aMap.\t"(self class) new: ("\t")"\r\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:33:12.32523+01:00' ],		#prior : OmReference [ '111' ],		#self : OmReference [ '112' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #StartSkolemnisation,		#newSelector : #startSkolemnisation,		#affectedClassName : #Prop	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '112' ],		#self : OmReference [ '113' ],		#time : DateAndTime [ '2018-12-19T20:33:12.350469+01:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #startSkolemnisation,			#protocol : #Skoleminsation,			#sourceCode : 'startSkolemnisation\r\t| set aMap |\r\tset:=MinimalOrderedSet new.\r\taMap:=Dictionary new.\r\t^self skolemise: set CorrespondingValue: aMap',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '113' ],		#self : OmReference [ '114' ],		#time : DateAndTime [ '2018-12-19T20:33:12.356361+01:00' ],		#trigger : OmReference [ '112' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tresolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\t\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp StartSkolemnisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tresolutionTrace ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tresolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\t\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp startSkolemnisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tresolutionTrace ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '114' ],		#self : OmReference [ '115' ],		#time : DateAndTime [ '2018-12-19T20:33:12.365768+01:00' ],		#trigger : OmReference [ '112' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr.\r\tt:=t resolutionMethod.\r\r\tTranscript show:\'Resolution method:\' ;show:t;cr;cr;cr.\r\t^t ',			#stamp : 'pm 10/26/2018 22:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self startSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr.\r\tt:=t resolutionMethod.\r\r\tTranscript show:\'Resolution method:\' ;show:t;cr;cr;cr.\r\t^t ',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '115' ],		#self : OmReference [ '116' ],		#time : DateAndTime [ '2018-12-19T20:33:12.372928+01:00' ],		#trigger : OmReference [ '112' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testImplyAndNestedForAllWithSameNameForConstAndLinkedVar,			#protocol : #tests,			#sourceCode : 'testImplyAndNestedForAllWithSameNameForConstAndLinkedVar\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTermsForTesting: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 12/12/2018 17:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testImplyAndNestedForAllWithSameNameForConstAndLinkedVar,			#protocol : #tests,			#sourceCode : 'testImplyAndNestedForAllWithSameNameForConstAndLinkedVar\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p startSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTermsForTesting: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '116' ],		#self : OmReference [ '117' ],		#time : DateAndTime [ '2018-12-19T20:33:12.379419+01:00' ],		#trigger : OmReference [ '112' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testBasicForAll,			#protocol : #tests,			#sourceCode : 'testBasicForAll\r\t| p res expected terms |\r\r\tterms:=LinkedList new add:(Term new:\'x\');add:(Term new:\'z\');yourself.\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\r\t\r\tterms:=LinkedList new add:(LinkedTerm new:(Term new:\'x\')); add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Or new: (Predicate new: \'P\' fromList: terms)\r\t\t\t\t\trightProp: (Predicate new: \'P\' fromList: terms).\r\t\r\t\r\tself assert:(res isSameForTesting: expected).',			#stamp : 'pm 12/12/2018 17:53',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testBasicForAll,			#protocol : #tests,			#sourceCode : 'testBasicForAll\r\t| p res expected terms |\r\r\tterms:=LinkedList new add:(Term new:\'x\');add:(Term new:\'z\');yourself.\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p startSkolemnisation.\r\t\r\tterms:=LinkedList new add:(LinkedTerm new:(Term new:\'x\')); add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Or new: (Predicate new: \'P\' fromList: terms)\r\t\t\t\t\trightProp: (Predicate new: \'P\' fromList: terms).\r\t\r\t\r\tself assert:(res isSameForTesting: expected).',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '117' ],		#self : OmReference [ '118' ],		#time : DateAndTime [ '2018-12-19T20:33:12.385226+01:00' ],		#trigger : OmReference [ '112' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testBasicOnlyPredicate,			#protocol : #tests,			#sourceCode : 'testBasicOnlyPredicate\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\');yourself.\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t\r\tself assert:(res isSameForTesting: expected).',			#stamp : 'pm 12/12/2018 17:53',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testBasicOnlyPredicate,			#protocol : #tests,			#sourceCode : 'testBasicOnlyPredicate\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\');yourself.\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p startSkolemnisation.\t\r\t\r\tterms2:=LinkedList new add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t\r\tself assert:(res isSameForTesting: expected).',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '118' ],		#self : OmReference [ '119' ],		#time : DateAndTime [ '2018-12-19T20:33:12.391362+01:00' ],		#trigger : OmReference [ '112' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testUnboundExistReplacedByConsts,			#protocol : #tests,			#sourceCode : 'testUnboundExistReplacedByConsts\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTermsForTesting: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 12/12/2018 17:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testUnboundExistReplacedByConsts,			#protocol : #tests,			#sourceCode : 'testUnboundExistReplacedByConsts\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p startSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTermsForTesting: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '119' ],		#self : OmReference [ '120' ],		#time : DateAndTime [ '2018-12-19T20:33:12.397302+01:00' ],		#trigger : OmReference [ '112' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testImplyAndNestedForAll,			#protocol : #tests,			#sourceCode : 'testImplyAndNestedForAll\r\t| p res expected |\r\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'a\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).',			#stamp : 'pm 12/12/2018 17:54',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testImplyAndNestedForAll,			#protocol : #tests,			#sourceCode : 'testImplyAndNestedForAll\r\t| p res expected |\r\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tres:=p startSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'a\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '120' ],		#self : OmReference [ '121' ],		#time : DateAndTime [ '2018-12-19T20:33:12.42317+01:00' ],		#trigger : OmReference [ '112' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #StartSkolemnisation,			#protocol : #Skoleminsation,			#sourceCode : 'StartSkolemnisation\r\t| set aMap |\r\tset:=MinimalOrderedSet new.\r\taMap:=Dictionary new.\r\t^self skolemise: set CorrespondingValue: aMap',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:33:22.702712+01:00' ],		#prior : OmReference [ '121' ],		#self : OmReference [ '122' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #SkolemnisationTest,		#newSelector : #skolemnisationTest,		#affectedClassName : #Prop	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '122' ],		#self : OmReference [ '123' ],		#time : DateAndTime [ '2018-12-19T20:33:22.722212+01:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #skolemnisationTest,			#protocol : #testing,			#sourceCode : 'skolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self startSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr.\r\tt:=t resolutionMethod.\r\r\tTranscript show:\'Resolution method:\' ;show:t;cr;cr;cr.\r\t^t ',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '123' ],		#self : OmReference [ '124' ],		#time : DateAndTime [ '2018-12-19T20:33:22.72946+01:00' ],		#trigger : OmReference [ '122' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2 |\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\r\tTranscript show: \'basic one #1\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'basic one #2\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'z\').\t\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\r\tTranscript show: \'with imply and nested forall.\'.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\'.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\'.\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' .\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r\tp SkolemnisationTest.\r\t\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest .\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest.\r\t\r\tTranscript show:\'Class exemple.\';cr.\r\tp:=Imply new: (And new: (Predicate new: \'P\' variable:(Term new: \'a\'))\r\t\t\t\t\t\t\trightProp: (Predicate new:\'Q\' variable:(Term new:\'b\')))\r\t rightProp: (Predicate new: \'P\' variable:(Term new: \'a\')).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/26/2018 22:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2 |\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\r\tTranscript show: \'basic one #1\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp skolemnisationTest.\r\r\tTranscript show: \'basic one #2\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'z\').\t\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp skolemnisationTest.\r\r\r\tTranscript show: \'with imply and nested forall.\'.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tp skolemnisationTest.\r\t\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\'.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp skolemnisationTest.\t\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\'.\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp skolemnisationTest.\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' .\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r\tp skolemnisationTest.\r\t\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\tp skolemnisationTest.\r\t\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp skolemnisationTest .\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp skolemnisationTest.\r\t\r\tTranscript show:\'Class exemple.\';cr.\r\tp:=Imply new: (And new: (Predicate new: \'P\' variable:(Term new: \'a\'))\r\t\t\t\t\t\t\trightProp: (Predicate new:\'Q\' variable:(Term new:\'b\')))\r\t rightProp: (Predicate new: \'P\' variable:(Term new: \'a\')).\r\tp skolemnisationTest.\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '124' ],		#self : OmReference [ '125' ],		#time : DateAndTime [ '2018-12-19T20:33:22.753276+01:00' ],		#trigger : OmReference [ '122' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self startSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr.\r\tt:=t resolutionMethod.\r\r\tTranscript show:\'Resolution method:\' ;show:t;cr;cr;cr.\r\t^t ',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:33:39.352835+01:00' ],		#prior : OmReference [ '125' ],		#self : OmReference [ '126' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #HerbranSkolemDocu,		#newSelector : #herbranSkolemDocu,		#affectedClassName : #Prop	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '126' ],		#self : OmReference [ '127' ],		#time : DateAndTime [ '2018-12-19T20:33:39.367122+01:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #herbranSkolemDocu,			#protocol : #Skoleminsation,			#sourceCode : 'herbranSkolemDocu\r\t^Error new:\'documentation of Skolemnisation\'.\r\t"return the proposition skolemnised"\r\t\r\t"Herbrandise: setOfLinkedVar CorrespondingValue: aMap"\r\t"setOfLinkedVar is a set of linked var (incredible, i know)\r\tIt\'s used to know if a variable was linked in that branch, following the rules of Skolemn/Herbran\r\t\r\tCorrespondingValue: aMap \r\tMap containing the correspondance between a variable, and the associated object term that we stored along the way. This will be used in Predicate::UpdateTerms.\r\t\r\tThe rules were taken from the course of David Delahaye, professor, science faculty, university of montpellier\r\t\t\r\t(Not sure the credit is enought)\r\t"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '127' ],		#self : OmReference [ '128' ],		#time : DateAndTime [ '2018-12-19T20:33:39.388127+01:00' ],		#trigger : OmReference [ '126' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #HerbranSkolemDocu,			#protocol : #Skoleminsation,			#sourceCode : 'HerbranSkolemDocu\r\t^Error new:\'documentation of Skolemnisation\'.\r\t"return the proposition skolemnised"\r\t\r\t"Herbrandise: setOfLinkedVar CorrespondingValue: aMap"\r\t"setOfLinkedVar is a set of linked var (incredible, i know)\r\tIt\'s used to know if a variable was linked in that branch, following the rules of Skolemn/Herbran\r\t\r\tCorrespondingValue: aMap \r\tMap containing the correspondance between a variable, and the associated object term that we stored along the way. This will be used in Predicate::UpdateTerms.\r\t\r\tThe rules were taken from the course of David Delahaye, professor, science faculty, university of montpellier\r\t\t\r\t(Not sure the credit is enought)\r\t"',			#stamp : 'pm 11/27/2018 11:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:34:40.862492+01:00' ],		#prior : OmReference [ '128' ],		#self : OmReference [ '129' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t^SubclassResponsibility.',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skolemisation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t^SubclassResponsibility.',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:34:40.871531+01:00' ],		#prior : OmReference [ '129' ],		#self : OmReference [ '130' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t^SubclassResponsibility.',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skolemisation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t^SubclassResponsibility.',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:34:40.87944+01:00' ],		#prior : OmReference [ '130' ],		#self : OmReference [ '131' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #herbranSkolemDocu,			#protocol : #Skoleminsation,			#sourceCode : 'herbranSkolemDocu\r\t^Error new:\'documentation of Skolemnisation\'.\r\t"return the proposition skolemnised"\r\t\r\t"Herbrandise: setOfLinkedVar CorrespondingValue: aMap"\r\t"setOfLinkedVar is a set of linked var (incredible, i know)\r\tIt\'s used to know if a variable was linked in that branch, following the rules of Skolemn/Herbran\r\t\r\tCorrespondingValue: aMap \r\tMap containing the correspondance between a variable, and the associated object term that we stored along the way. This will be used in Predicate::UpdateTerms.\r\t\r\tThe rules were taken from the course of David Delahaye, professor, science faculty, university of montpellier\r\t\t\r\t(Not sure the credit is enought)\r\t"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #herbranSkolemDocu,			#protocol : #Skolemisation,			#sourceCode : 'herbranSkolemDocu\r\t^Error new:\'documentation of Skolemnisation\'.\r\t"return the proposition skolemnised"\r\t\r\t"Herbrandise: setOfLinkedVar CorrespondingValue: aMap"\r\t"setOfLinkedVar is a set of linked var (incredible, i know)\r\tIt\'s used to know if a variable was linked in that branch, following the rules of Skolemn/Herbran\r\t\r\tCorrespondingValue: aMap \r\tMap containing the correspondance between a variable, and the associated object term that we stored along the way. This will be used in Predicate::UpdateTerms.\r\t\r\tThe rules were taken from the course of David Delahaye, professor, science faculty, university of montpellier\r\t\t\r\t(Not sure the credit is enought)\r\t"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:34:40.887421+01:00' ],		#prior : OmReference [ '131' ],		#self : OmReference [ '132' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #startSkolemnisation,			#protocol : #Skoleminsation,			#sourceCode : 'startSkolemnisation\r\t| set aMap |\r\tset:=MinimalOrderedSet new.\r\taMap:=Dictionary new.\r\t^self skolemise: set CorrespondingValue: aMap',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #startSkolemnisation,			#protocol : #Skolemisation,			#sourceCode : 'startSkolemnisation\r\t| set aMap |\r\tset:=MinimalOrderedSet new.\r\taMap:=Dictionary new.\r\t^self skolemise: set CorrespondingValue: aMap',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:34:50.40636+01:00' ],		#prior : OmReference [ '132' ],		#self : OmReference [ '133' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #startSkolemnisation,		#newSelector : #startSkolemisation,		#affectedClassName : #Prop	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '133' ],		#self : OmReference [ '134' ],		#time : DateAndTime [ '2018-12-19T20:34:50.438227+01:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #startSkolemisation,			#protocol : #Skolemisation,			#sourceCode : 'startSkolemisation\r\t| set aMap |\r\tset:=MinimalOrderedSet new.\r\taMap:=Dictionary new.\r\t^self skolemise: set CorrespondingValue: aMap',			#stamp : 'pm 12/19/2018 20:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '134' ],		#self : OmReference [ '135' ],		#time : DateAndTime [ '2018-12-19T20:34:50.442808+01:00' ],		#trigger : OmReference [ '133' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tresolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\t\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp startSkolemnisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tresolutionTrace ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tresolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\t\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp startSkolemisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tresolutionTrace ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/19/2018 20:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '135' ],		#self : OmReference [ '136' ],		#time : DateAndTime [ '2018-12-19T20:34:50.453897+01:00' ],		#trigger : OmReference [ '133' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #skolemnisationTest,			#protocol : #testing,			#sourceCode : 'skolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self startSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr.\r\tt:=t resolutionMethod.\r\r\tTranscript show:\'Resolution method:\' ;show:t;cr;cr;cr.\r\t^t ',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #skolemnisationTest,			#protocol : #testing,			#sourceCode : 'skolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self startSkolemisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr.\r\tt:=t resolutionMethod.\r\r\tTranscript show:\'Resolution method:\' ;show:t;cr;cr;cr.\r\t^t ',			#stamp : 'pm 12/19/2018 20:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '136' ],		#self : OmReference [ '137' ],		#time : DateAndTime [ '2018-12-19T20:34:50.4608+01:00' ],		#trigger : OmReference [ '133' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testImplyAndNestedForAllWithSameNameForConstAndLinkedVar,			#protocol : #tests,			#sourceCode : 'testImplyAndNestedForAllWithSameNameForConstAndLinkedVar\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p startSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTermsForTesting: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testImplyAndNestedForAllWithSameNameForConstAndLinkedVar,			#protocol : #tests,			#sourceCode : 'testImplyAndNestedForAllWithSameNameForConstAndLinkedVar\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p startSkolemisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTermsForTesting: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 12/19/2018 20:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '137' ],		#self : OmReference [ '138' ],		#time : DateAndTime [ '2018-12-19T20:34:50.466146+01:00' ],		#trigger : OmReference [ '133' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testBasicForAll,			#protocol : #tests,			#sourceCode : 'testBasicForAll\r\t| p res expected terms |\r\r\tterms:=LinkedList new add:(Term new:\'x\');add:(Term new:\'z\');yourself.\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p startSkolemnisation.\r\t\r\tterms:=LinkedList new add:(LinkedTerm new:(Term new:\'x\')); add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Or new: (Predicate new: \'P\' fromList: terms)\r\t\t\t\t\trightProp: (Predicate new: \'P\' fromList: terms).\r\t\r\t\r\tself assert:(res isSameForTesting: expected).',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testBasicForAll,			#protocol : #tests,			#sourceCode : 'testBasicForAll\r\t| p res expected terms |\r\r\tterms:=LinkedList new add:(Term new:\'x\');add:(Term new:\'z\');yourself.\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p startSkolemisation.\r\t\r\tterms:=LinkedList new add:(LinkedTerm new:(Term new:\'x\')); add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Or new: (Predicate new: \'P\' fromList: terms)\r\t\t\t\t\trightProp: (Predicate new: \'P\' fromList: terms).\r\t\r\t\r\tself assert:(res isSameForTesting: expected).',			#stamp : 'pm 12/19/2018 20:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '138' ],		#self : OmReference [ '139' ],		#time : DateAndTime [ '2018-12-19T20:34:50.471033+01:00' ],		#trigger : OmReference [ '133' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testBasicOnlyPredicate,			#protocol : #tests,			#sourceCode : 'testBasicOnlyPredicate\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\');yourself.\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p startSkolemnisation.\t\r\t\r\tterms2:=LinkedList new add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t\r\tself assert:(res isSameForTesting: expected).',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testBasicOnlyPredicate,			#protocol : #tests,			#sourceCode : 'testBasicOnlyPredicate\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\');yourself.\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p startSkolemisation.\t\r\t\r\tterms2:=LinkedList new add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t\r\tself assert:(res isSameForTesting: expected).',			#stamp : 'pm 12/19/2018 20:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '139' ],		#self : OmReference [ '140' ],		#time : DateAndTime [ '2018-12-19T20:34:50.476691+01:00' ],		#trigger : OmReference [ '133' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testUnboundExistReplacedByConsts,			#protocol : #tests,			#sourceCode : 'testUnboundExistReplacedByConsts\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p startSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTermsForTesting: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testUnboundExistReplacedByConsts,			#protocol : #tests,			#sourceCode : 'testUnboundExistReplacedByConsts\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p startSkolemisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTermsForTesting: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 12/19/2018 20:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '140' ],		#self : OmReference [ '141' ],		#time : DateAndTime [ '2018-12-19T20:34:50.48171+01:00' ],		#trigger : OmReference [ '133' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testImplyAndNestedForAll,			#protocol : #tests,			#sourceCode : 'testImplyAndNestedForAll\r\t| p res expected |\r\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tres:=p startSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'a\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testImplyAndNestedForAll,			#protocol : #tests,			#sourceCode : 'testImplyAndNestedForAll\r\t| p res expected |\r\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tres:=p startSkolemisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'a\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).',			#stamp : 'pm 12/19/2018 20:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '141' ],		#self : OmReference [ '142' ],		#time : DateAndTime [ '2018-12-19T20:34:50.499267+01:00' ],		#trigger : OmReference [ '133' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #startSkolemnisation,			#protocol : #Skolemisation,			#sourceCode : 'startSkolemnisation\r\t| set aMap |\r\tset:=MinimalOrderedSet new.\r\taMap:=Dictionary new.\r\t^self skolemise: set CorrespondingValue: aMap',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:35:01.178063+01:00' ],		#prior : OmReference [ '142' ],		#self : OmReference [ '143' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skolemisation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t^SubclassResponsibility.',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #skolemisation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t^SubclassResponsibility.',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:35:01.190586+01:00' ],		#prior : OmReference [ '143' ],		#self : OmReference [ '144' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skolemisation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t^SubclassResponsibility.',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #skolemisation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t^SubclassResponsibility.',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:35:01.200639+01:00' ],		#prior : OmReference [ '144' ],		#self : OmReference [ '145' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #startSkolemisation,			#protocol : #Skolemisation,			#sourceCode : 'startSkolemisation\r\t| set aMap |\r\tset:=MinimalOrderedSet new.\r\taMap:=Dictionary new.\r\t^self skolemise: set CorrespondingValue: aMap',			#stamp : 'pm 12/19/2018 20:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #startSkolemisation,			#protocol : #skolemisation,			#sourceCode : 'startSkolemisation\r\t| set aMap |\r\tset:=MinimalOrderedSet new.\r\taMap:=Dictionary new.\r\t^self skolemise: set CorrespondingValue: aMap',			#stamp : 'pm 12/19/2018 20:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:35:01.209196+01:00' ],		#prior : OmReference [ '145' ],		#self : OmReference [ '146' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #herbranSkolemDocu,			#protocol : #Skolemisation,			#sourceCode : 'herbranSkolemDocu\r\t^Error new:\'documentation of Skolemnisation\'.\r\t"return the proposition skolemnised"\r\t\r\t"Herbrandise: setOfLinkedVar CorrespondingValue: aMap"\r\t"setOfLinkedVar is a set of linked var (incredible, i know)\r\tIt\'s used to know if a variable was linked in that branch, following the rules of Skolemn/Herbran\r\t\r\tCorrespondingValue: aMap \r\tMap containing the correspondance between a variable, and the associated object term that we stored along the way. This will be used in Predicate::UpdateTerms.\r\t\r\tThe rules were taken from the course of David Delahaye, professor, science faculty, university of montpellier\r\t\t\r\t(Not sure the credit is enought)\r\t"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #herbranSkolemDocu,			#protocol : #skolemisation,			#sourceCode : 'herbranSkolemDocu\r\t^Error new:\'documentation of Skolemnisation\'.\r\t"return the proposition skolemnised"\r\t\r\t"Herbrandise: setOfLinkedVar CorrespondingValue: aMap"\r\t"setOfLinkedVar is a set of linked var (incredible, i know)\r\tIt\'s used to know if a variable was linked in that branch, following the rules of Skolemn/Herbran\r\t\r\tCorrespondingValue: aMap \r\tMap containing the correspondance between a variable, and the associated object term that we stored along the way. This will be used in Predicate::UpdateTerms.\r\t\r\tThe rules were taken from the course of David Delahaye, professor, science faculty, university of montpellier\r\t\t\r\t(Not sure the credit is enought)\r\t"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:35:12.39453+01:00' ],		#prior : OmReference [ '146' ],		#self : OmReference [ '147' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self class name ;space ; show:self ;cr].\r\t^self.',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self class name ;space ; show:self ;cr].\r\t^self.',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:35:12.401875+01:00' ],		#prior : OmReference [ '147' ],		#self : OmReference [ '148' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self class name ;space ; show:self ;cr].\r\t^self.',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self class name ;space ; show:self ;cr].\r\t^self.',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:35:22.433795+01:00' ],		#prior : OmReference [ '148' ],		#self : OmReference [ '149' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ;space ; show:self ;cr].\r\t\r\t^self updateTerms: setOfLinkedVar CorrespondingValue: aMap.',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ;space ; show:self ;cr].\r\t\r\t^self updateTerms: setOfLinkedVar CorrespondingValue: aMap.',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:35:22.443782+01:00' ],		#prior : OmReference [ '149' ],		#self : OmReference [ '150' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\'  ;space ; show:self ;cr].\r\t\r\t^self updateTerms: setOfLinkedVar CorrespondingValue: aMap.',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\'  ;space ; show:self ;cr].\r\t\r\t^self updateTerms: setOfLinkedVar CorrespondingValue: aMap.',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:35:22.451791+01:00' ],		#prior : OmReference [ '150' ],		#self : OmReference [ '151' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'updateTerms:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'updateTerms: setOfLinkedVar CorrespondingValue: aMap\r\t| res |\r\tres := LinkedList new.\r\tterms do:[ :term | res add: (term WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].\r\t^Predicate new: (self getSymb) fromList:res.\r',			#stamp : 'pm 11/27/2018 21:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'updateTerms:CorrespondingValue:',			#protocol : #skoleminsation,			#sourceCode : 'updateTerms: setOfLinkedVar CorrespondingValue: aMap\r\t| res |\r\tres := LinkedList new.\r\tterms do:[ :term | res add: (term WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].\r\t^Predicate new: (self getSymb) fromList:res.\r',			#stamp : 'pm 11/27/2018 21:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:35:47.797006+01:00' ],		#prior : OmReference [ '151' ],		#self : OmReference [ '152' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right herbrandise: setOfLinkedVar CorrespondingValue: aMap ).\r\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right herbrandise: setOfLinkedVar CorrespondingValue: aMap ).\r\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:35:47.799897+01:00' ],		#prior : OmReference [ '152' ],		#self : OmReference [ '153' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left skolemise: (setOfLinkedVar veryDeepCopy)  CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right skolemise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t"Works for Or & And."\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left skolemise: (setOfLinkedVar veryDeepCopy)  CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right skolemise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t"Works for Or & And."\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:35:58.235667+01:00' ],		#prior : OmReference [ '153' ],		#self : OmReference [ '154' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\t\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) herbrandise: setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\t\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) herbrandise: setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:35:58.238245+01:00' ],		#prior : OmReference [ '154' ],		#self : OmReference [ '155' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) skolemise:setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) skolemise:setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:36:15.915001+01:00' ],		#prior : OmReference [ '155' ],		#self : OmReference [ '156' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left skolemise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right herbrandise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #skolemisation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left skolemise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right herbrandise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:36:15.917604+01:00' ],		#prior : OmReference [ '156' ],		#self : OmReference [ '157' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right skolemise: setOfLinkedVar CorrespondingValue: aMap).\r\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #skolemisation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right skolemise: setOfLinkedVar CorrespondingValue: aMap).\r\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:36:27.668102+01:00' ],		#prior : OmReference [ '157' ],		#self : OmReference [ '158' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\t\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) herbrandise: setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #skolemisation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\t\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) herbrandise: setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:36:27.670648+01:00' ],		#prior : OmReference [ '158' ],		#self : OmReference [ '159' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) skolemise:setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #skolemisation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) skolemise:setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:36:38.33358+01:00' ],		#prior : OmReference [ '159' ],		#self : OmReference [ '160' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right herbrandise: setOfLinkedVar CorrespondingValue: aMap ).\r\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #skolemisation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right herbrandise: setOfLinkedVar CorrespondingValue: aMap ).\r\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:36:38.342602+01:00' ],		#prior : OmReference [ '160' ],		#self : OmReference [ '161' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left skolemise: (setOfLinkedVar veryDeepCopy)  CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right skolemise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t"Works for Or & And."\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #skolemisation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left skolemise: (setOfLinkedVar veryDeepCopy)  CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right skolemise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t"Works for Or & And."\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:36:48.963376+01:00' ],		#prior : OmReference [ '161' ],		#self : OmReference [ '162' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ;space ; show:self ;cr].\r\t\r\t^self updateTerms: setOfLinkedVar CorrespondingValue: aMap.',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #skolemisation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ;space ; show:self ;cr].\r\t\r\t^self updateTerms: setOfLinkedVar CorrespondingValue: aMap.',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:36:48.972302+01:00' ],		#prior : OmReference [ '162' ],		#self : OmReference [ '163' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\'  ;space ; show:self ;cr].\r\t\r\t^self updateTerms: setOfLinkedVar CorrespondingValue: aMap.',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #skolemisation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\'  ;space ; show:self ;cr].\r\t\r\t^self updateTerms: setOfLinkedVar CorrespondingValue: aMap.',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:36:48.980202+01:00' ],		#prior : OmReference [ '163' ],		#self : OmReference [ '164' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'updateTerms:CorrespondingValue:',			#protocol : #skoleminsation,			#sourceCode : 'updateTerms: setOfLinkedVar CorrespondingValue: aMap\r\t| res |\r\tres := LinkedList new.\r\tterms do:[ :term | res add: (term WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].\r\t^Predicate new: (self getSymb) fromList:res.\r',			#stamp : 'pm 11/27/2018 21:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'updateTerms:CorrespondingValue:',			#protocol : #skolemisation,			#sourceCode : 'updateTerms: setOfLinkedVar CorrespondingValue: aMap\r\t| res |\r\tres := LinkedList new.\r\tterms do:[ :term | res add: (term WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].\r\t^Predicate new: (self getSymb) fromList:res.\r',			#stamp : 'pm 11/27/2018 21:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:36:59.749967+01:00' ],		#prior : OmReference [ '164' ],		#self : OmReference [ '165' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self class name ;space ; show:self ;cr].\r\t^self.',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #skolemination,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self class name ;space ; show:self ;cr].\r\t^self.',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:36:59.758733+01:00' ],		#prior : OmReference [ '165' ],		#self : OmReference [ '166' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self class name ;space ; show:self ;cr].\r\t^self.',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #skolemination,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self class name ;space ; show:self ;cr].\r\t^self.',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:37:19.431578+01:00' ],		#prior : OmReference [ '166' ],		#self : OmReference [ '167' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self operand skolemise: setOfLinkedVar CorrespondingValue: aMap).',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #skolemisation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self operand skolemise: setOfLinkedVar CorrespondingValue: aMap).',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:37:19.434229+01:00' ],		#prior : OmReference [ '167' ],		#self : OmReference [ '168' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self operand herbrandise: setOfLinkedVar CorrespondingValue: aMap).',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #skolemisation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self operand herbrandise: setOfLinkedVar CorrespondingValue: aMap).',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:37:29.701858+01:00' ],		#prior : OmReference [ '168' ],		#self : OmReference [ '169' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\t^(self operand) herbrandise: setOfLinkedVar CorrespondingValue: aMap.\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #skolemisation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\t^(self operand) herbrandise: setOfLinkedVar CorrespondingValue: aMap.\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:37:29.704248+01:00' ],		#prior : OmReference [ '169' ],		#self : OmReference [ '170' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars:  setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) skolemise: setOfLinkedVar CorrespondingValue: aMap.\r\t\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #skolemisation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars:  setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) skolemise: setOfLinkedVar CorrespondingValue: aMap.\r\t\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:37:37.097385+01:00' ],		#prior : OmReference [ '170' ],		#self : OmReference [ '171' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars: setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) herbrandise: setOfLinkedVar CorrespondingValue: aMap.\t"(self class) new: ("\t")"\r\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars: setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) herbrandise: setOfLinkedVar CorrespondingValue: aMap.\t"(self class) new: ("\t")"\r\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:37:37.099912+01:00' ],		#prior : OmReference [ '171' ],		#self : OmReference [ '172' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\r\t^(self operand) skolemise: setOfLinkedVar CorrespondingValue: aMap.\r\t \r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\r\t^(self operand) skolemise: setOfLinkedVar CorrespondingValue: aMap.\r\t \r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:37:55.09519+01:00' ],		#prior : OmReference [ '172' ],		#self : OmReference [ '173' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #skoleminsation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars: setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) herbrandise: setOfLinkedVar CorrespondingValue: aMap.\t"(self class) new: ("\t")"\r\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'herbrandise:CorrespondingValue:',			#protocol : #skolemisation,			#sourceCode : 'herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars: setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) herbrandise: setOfLinkedVar CorrespondingValue: aMap.\t"(self class) new: ("\t")"\r\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:37:55.097765+01:00' ],		#prior : OmReference [ '173' ],		#self : OmReference [ '174' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #skoleminsation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\r\t^(self operand) skolemise: setOfLinkedVar CorrespondingValue: aMap.\r\t \r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'skolemise:CorrespondingValue:',			#protocol : #skolemisation,			#sourceCode : 'skolemise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\r\t^(self operand) skolemise: setOfLinkedVar CorrespondingValue: aMap.\r\t \r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/19/2018 20:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:38:33.824689+01:00' ],		#prior : OmReference [ '174' ],		#self : OmReference [ '175' ]	},	#content : EpMonticelloVersionSave {		#versionName : '_resolution_1erOrdre-pm.8',		#repositoryDescription : '/home/ariale/FORM/pharo6.1-64/shared/pharo-local/package-cache'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:38:33.919983+01:00' ],		#prior : OmReference [ '175' ],		#self : OmReference [ '176' ]	},	#content : EpMonticelloVersionSave {		#versionName : '_resolution_1erOrdre-pm.8',		#repositoryDescription : '/home/ariale/FORM/pharo6.1-64/Sources'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:39:43.438057+01:00' ],		#prior : OmReference [ '176' ],		#self : OmReference [ '177' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: aClause\r\t"add a new clause in self."\r\t(aClause isKindOf: Clause)\r\tifTrue: [ super add: aClause ]\r\tifFalse:[Error new: \'Tried to add a non clause object to a clausaleForm\'].\r\t^self "enable chaining operation"',			#stamp : 'pm 12/15/2018 16:36',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: aClause\r\t"add a new clause in self."\r\t(aClause isKindOf: Clause)\r\tifTrue: [ super add: aClause ]\r\tifFalse:[Error new: \'Tried to add a non clause object to a clausalForm\'].\r\t^self "enable chaining operation"',			#stamp : 'pm 12/19/2018 20:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:39:56.958023+01:00' ],		#prior : OmReference [ '177' ],		#self : OmReference [ '178' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'PackageManifest',				#traitCompositionSource : '{}',				#definitionSource : 'PackageManifest subclass: #ManifestresolutionerOrdre\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ManifestresolutionerOrdre,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ManifestresolutionerOrdre class\r\tinstanceVariableNames: \'\''				},				#name : #'ManifestresolutionerOrdre class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ManifestresolutionerOrdre,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:39:56.968301+01:00' ],		#prior : OmReference [ '178' ],		#self : OmReference [ '179' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'PackageManifest',				#traitCompositionSource : '{}',				#definitionSource : 'PackageManifest subclass: #ManifestresolutionerOrdre\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ManifestresolutionerOrdre,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ManifestresolutionerOrdre class\r\tinstanceVariableNames: \'\''				},				#name : #'ManifestresolutionerOrdre class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ManifestresolutionerOrdre,					#isMetaSide : false				},				#parent : @7,				#content : 'I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser',				#stamp : '<historical>'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser',		#newStamp : '<historical>'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:39:56.994286+01:00' ],		#prior : OmReference [ '179' ],		#self : OmReference [ '180' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestresolutionerOrdre class',				#isMetaSide : true			},			#name : #ruleCodeCruftLeftInMethodsRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleCodeCruftLeftInMethodsRuleV1FalsePositive\r\t^ #()',			#stamp : 'pm 12/19/2018 20:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:39:57.010694+01:00' ],		#prior : OmReference [ '180' ],		#self : OmReference [ '181' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestresolutionerOrdre class',				#isMetaSide : true			},			#name : #ruleCodeCruftLeftInMethodsRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleCodeCruftLeftInMethodsRuleV1FalsePositive\r\t^ #()',			#stamp : 'pm 12/19/2018 20:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestresolutionerOrdre class',				#isMetaSide : true			},			#name : #ruleCodeCruftLeftInMethodsRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleCodeCruftLeftInMethodsRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#\'Prop class\' #testEverything #true)) #\'2018-12-19T20:39:57.001145+01:00\') #(#(#RGMethodDefinition #(#\'Prop class\' #testingMatch #true)) #\'2018-12-19T20:39:57.001483+01:00\') #(#(#RGMethodDefinition #(#\'Prop class\' #testingSkolemn #true)) #\'2018-12-19T20:39:57.001316+01:00\') )',			#stamp : 'pm 12/19/2018 20:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:40:10.288278+01:00' ],		#prior : OmReference [ '181' ],		#self : OmReference [ '182' ]	},	#content : EpCategoryAddition {		#classCategoryName : '_resolution_1erOrdre-metadata',		#affectedPackageName : #_resolution_1erOrdre	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:40:16.600766+01:00' ],		#prior : OmReference [ '182' ],		#self : OmReference [ '183' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #_resolution_1erOrdre,		#newCategory : #'_resolution_1erOrdre-Testing class',		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'PackageManifest',				#traitCompositionSource : '{}',				#definitionSource : 'PackageManifest subclass: #ManifestresolutionerOrdre\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #ManifestresolutionerOrdre,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ManifestresolutionerOrdre class\r\tinstanceVariableNames: \'\''				},				#name : #'ManifestresolutionerOrdre class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ManifestresolutionerOrdre,					#isMetaSide : false				},				#parent : @7,				#content : 'I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser',				#stamp : '<historical>'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:40:20.92969+01:00' ],		#prior : OmReference [ '183' ],		#self : OmReference [ '184' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #'_resolution_1erOrdre-Testing class',		#newCategory : #_resolution_1erOrdre-metadata,		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'PackageManifest',				#traitCompositionSource : '{}',				#definitionSource : 'PackageManifest subclass: #ManifestresolutionerOrdre\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-metadata\''			},			#name : #ManifestresolutionerOrdre,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ManifestresolutionerOrdre class\r\tinstanceVariableNames: \'\''				},				#name : #'ManifestresolutionerOrdre class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ManifestresolutionerOrdre,					#isMetaSide : false				},				#parent : @7,				#content : 'I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser',				#stamp : '<historical>'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-metadata,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:45:37.310217+01:00' ],		#prior : OmReference [ '184' ],		#self : OmReference [ '185' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #_resolution_1erOrdre-metadata,		#newCategory : #_resolution_1erOrdre,		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'PackageManifest',				#traitCompositionSource : '{}',				#definitionSource : 'PackageManifest subclass: #ManifestresolutionerOrdre\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ManifestresolutionerOrdre,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ManifestresolutionerOrdre class\r\tinstanceVariableNames: \'\''				},				#name : #'ManifestresolutionerOrdre class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ManifestresolutionerOrdre,					#isMetaSide : false				},				#parent : @7,				#content : 'I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser',				#stamp : '<historical>'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:45:37.331998+01:00' ],		#prior : OmReference [ '185' ],		#self : OmReference [ '186' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestresolutionerOrdre class',				#isMetaSide : true			},			#name : #ruleLongMethodsRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleLongMethodsRuleV1FalsePositive\r\t^ #()',			#stamp : 'pm 12/19/2018 20:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:45:37.335252+01:00' ],		#prior : OmReference [ '186' ],		#self : OmReference [ '187' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestresolutionerOrdre class',				#isMetaSide : true			},			#name : #ruleLongMethodsRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleLongMethodsRuleV1FalsePositive\r\t^ #()',			#stamp : 'pm 12/19/2018 20:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestresolutionerOrdre class',				#isMetaSide : true			},			#name : #ruleLongMethodsRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleLongMethodsRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#\'Prop class\' #testingUnification #true)) #\'2018-12-19T20:45:37.332231+01:00\') #(#(#RGMethodDefinition #(#\'Prop class\' #testingResolutionMethod #true)) #\'2018-12-19T20:45:37.332318+01:00\') )',			#stamp : 'pm 12/19/2018 20:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:46:35.290858+01:00' ],		#prior : OmReference [ '187' ],		#self : OmReference [ '188' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'UnaryTerm',				#traitCompositionSource : '{}',				#definitionSource : 'UnaryTerm subclass: #ConstTerm\r\tinstanceVariableNames: \'anonymous\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Terms\''			},			#name : #ConstTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ConstTerm,						#isMetaSide : false					},					#name : #anonymous,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ConstTerm class\r\tinstanceVariableNames: \'factoryVar factoryNum\''				},				#name : #'ConstTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'ConstTerm class',							#isMetaSide : true						},						#name : #factoryVar,						#parent : @14					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'ConstTerm class',							#isMetaSide : true						},						#name : #factoryNum,						#parent : @14					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ConstTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Const term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable wasn\'t bound by anything OR if i\'m bound by an exists which isn\'t bound by a previous forall.\r\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with the character \'c\' as a start. To differenciate it from the rest visually.\r\r',				#stamp : 'pm 10/9/2018 10:44'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Terms,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'UnaryTerm',				#traitCompositionSource : '{}',				#definitionSource : 'UnaryTerm subclass: #ConstTerm\r\tinstanceVariableNames: \'anonymous\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Terms\''			},			#name : #ConstTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ConstTerm,						#isMetaSide : false					},					#name : #anonymous,					#parent : @27				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ConstTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'ConstTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @27			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ConstTerm,					#isMetaSide : false				},				#parent : @27,				#content : 'I represent a Const term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable wasn\'t bound by anything OR if i\'m bound by an exists which isn\'t bound by a previous forall.\r\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with the character \'c\' as a start. To differenciate it from the rest visually.\r\r',				#stamp : 'pm 10/9/2018 10:44'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Terms,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:46:41.160363+01:00' ],		#prior : OmReference [ '188' ],		#self : OmReference [ '189' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'UnaryTerm',				#traitCompositionSource : '{}',				#definitionSource : 'UnaryTerm subclass: #ConstTerm\r\tinstanceVariableNames: \'anonymous\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Terms\''			},			#name : #ConstTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ConstTerm,						#isMetaSide : false					},					#name : #anonymous,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ConstTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'ConstTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ConstTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Const term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable wasn\'t bound by anything OR if i\'m bound by an exists which isn\'t bound by a previous forall.\r\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with the character \'c\' as a start. To differenciate it from the rest visually.\r\r',				#stamp : 'pm 10/9/2018 10:44'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Terms,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'UnaryTerm',				#traitCompositionSource : '{}',				#definitionSource : 'UnaryTerm subclass: #ConstTerm\r\tinstanceVariableNames: \'anonymous\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Terms\''			},			#name : #ConstTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ConstTerm,						#isMetaSide : false					},					#name : #anonymous,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ConstTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'ConstTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ConstTerm,					#isMetaSide : false				},				#parent : @23,				#content : 'I represent a Const term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable wasn\'t bound by anything OR if i\'m bound by an exists which isn\'t bound by a previous forall.\r\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with the character \'c\' as a start. To differenciate it from the rest visually.\r\r',				#stamp : 'pm 10/9/2018 10:44'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Terms,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:46:54.52857+01:00' ],		#prior : OmReference [ '189' ],		#self : OmReference [ '190' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'UnaryTerm',				#traitCompositionSource : '{}',				#definitionSource : 'UnaryTerm subclass: #ConstTerm\r\tinstanceVariableNames: \'anonymous\'\r\tclassVariableNames: \'\'\' classVariableNames:\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Terms\''			},			#name : #ConstTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ConstTerm,						#isMetaSide : false					},					#name : #anonymous,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ConstTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'ConstTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ConstTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Const term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable wasn\'t bound by anything OR if i\'m bound by an exists which isn\'t bound by a previous forall.\r\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with the character \'c\' as a start. To differenciate it from the rest visually.\r\r',				#stamp : 'pm 10/9/2018 10:44'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #ConstTerm,						#isMetaSide : false					},					#name : #'\'',					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #ConstTerm,						#isMetaSide : false					},					#name : #'classVariableNames:',					#parent : @7				}			],			#category : #_resolution_1erOrdre-Terms,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'UnaryTerm',				#traitCompositionSource : '{}',				#definitionSource : 'UnaryTerm subclass: #ConstTerm\r\tinstanceVariableNames: \'anonymous\'\r\tclassVariableNames: \'\'\' classVariableNames:\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Terms\''			},			#name : #ConstTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ConstTerm,						#isMetaSide : false					},					#name : #anonymous,					#parent : @27				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ConstTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'ConstTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @27			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ConstTerm,					#isMetaSide : false				},				#parent : @27,				#content : 'I represent a Const term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable wasn\'t bound by anything OR if i\'m bound by an exists which isn\'t bound by a previous forall.\r\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with the character \'c\' as a start. To differenciate it from the rest visually.\r\r',				#stamp : 'pm 10/9/2018 10:44'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #ConstTerm,						#isMetaSide : false					},					#name : #'\'',					#parent : @27				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #ConstTerm,						#isMetaSide : false					},					#name : #'classVariableNames:',					#parent : @27				}			],			#category : #_resolution_1erOrdre-Terms,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:47:09.787269+01:00' ],		#prior : OmReference [ '190' ],		#self : OmReference [ '191' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'AbstractTerm',				#traitCompositionSource : '{}',				#definitionSource : 'AbstractTerm subclass: #FuncTerm\r\tinstanceVariableNames: \'symb terms anonymous\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Terms\''			},			#name : #FuncTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #symb,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #terms,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #anonymous,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'FuncTerm class\r\tinstanceVariableNames: \'currentFuncNumber anonymousFuncSymb\''				},				#name : #'FuncTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'FuncTerm class',							#isMetaSide : true						},						#name : #currentFuncNumber,						#parent : @18					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'FuncTerm class',							#isMetaSide : true						},						#name : #anonymousFuncSymb,						#parent : @18					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #FuncTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Func term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable was bound by an Exists, with a forall binding the said Exists beforehand.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with a standart name \'f\' for the function, and a list of terms.\r\r',				#stamp : 'pm 10/9/2018 10:43'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Terms,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'AbstractTerm',				#traitCompositionSource : '{}',				#definitionSource : 'AbstractTerm subclass: #FuncTerm\r\tinstanceVariableNames: \'symb terms anonymous\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Terms\''			},			#name : #FuncTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #symb,					#parent : @31				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #terms,					#parent : @31				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #anonymous,					#parent : @31				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'FuncTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'FuncTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @31			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #FuncTerm,					#isMetaSide : false				},				#parent : @31,				#content : 'I represent a Func term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable was bound by an Exists, with a forall binding the said Exists beforehand.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with a standart name \'f\' for the function, and a list of terms.\r\r',				#stamp : 'pm 10/9/2018 10:43'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Terms,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:47:13.097566+01:00' ],		#prior : OmReference [ '191' ],		#self : OmReference [ '192' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'AbstractTerm',				#traitCompositionSource : '{}',				#definitionSource : 'AbstractTerm subclass: #FuncTerm\r\tinstanceVariableNames: \'symb terms anonymous\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Terms\''			},			#name : #FuncTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #symb,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #terms,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #anonymous,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'FuncTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'FuncTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #FuncTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Func term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable was bound by an Exists, with a forall binding the said Exists beforehand.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with a standart name \'f\' for the function, and a list of terms.\r\r',				#stamp : 'pm 10/9/2018 10:43'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Terms,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'AbstractTerm',				#traitCompositionSource : '{}',				#definitionSource : 'AbstractTerm subclass: #FuncTerm\r\tinstanceVariableNames: \'symb terms anonymous\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Terms\''			},			#name : #FuncTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #symb,					#parent : @27				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #terms,					#parent : @27				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #anonymous,					#parent : @27				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'FuncTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'FuncTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @27			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #FuncTerm,					#isMetaSide : false				},				#parent : @27,				#content : 'I represent a Func term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable was bound by an Exists, with a forall binding the said Exists beforehand.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with a standart name \'f\' for the function, and a list of terms.\r\r',				#stamp : 'pm 10/9/2018 10:43'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Terms,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:48:50.315392+01:00' ],		#prior : OmReference [ '192' ],		#self : OmReference [ '193' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'AbstractTerm class',				#isMetaSide : true			},			#name : #new,			#protocol : #'as yet unclassified',			#sourceCode : 'new\r\t^self error:\'Abstract Term shouldn\'\'t be instantiated, it\'\'s abstract\'',			#stamp : 'pm 12/19/2018 20:48',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:48:50.337813+01:00' ],		#prior : OmReference [ '193' ],		#self : OmReference [ '194' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'AbstractTerm class',				#isMetaSide : true			},			#name : #new,			#protocol : #'as yet unclassified',			#sourceCode : 'new\r\t^self error:\'Abstract Term shouldn\'\'t be instantiated, it\'\'s abstract\'',			#stamp : 'pm 12/19/2018 20:48',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'AbstractTerm class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t^self error:\'Abstract Term shouldn\'\'t be instantiated, it\'\'s abstract\'',			#stamp : 'pm 12/19/2018 20:48',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:49:00.352768+01:00' ],		#prior : OmReference [ '194' ],		#self : OmReference [ '195' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'AbstractTerm class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t^self error:\'Abstract Term shouldn\'\'t be instantiated, it\'\'s abstract\'',			#stamp : 'pm 12/19/2018 20:48',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'AbstractTerm class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"abstract \'constructor"\r\t^self error:\'Abstract Term shouldn\'\'t be instantiated, it\'\'s abstract\'',			#stamp : 'pm 12/19/2018 20:49',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:49:01.556369+01:00' ],		#prior : OmReference [ '195' ],		#self : OmReference [ '196' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'AbstractTerm class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"abstract \'constructor"\r\t^self error:\'Abstract Term shouldn\'\'t be instantiated, it\'\'s abstract\'',			#stamp : 'pm 12/19/2018 20:49',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'AbstractTerm class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"abstract \'constructor\'"\r\t^self error:\'Abstract Term shouldn\'\'t be instantiated, it\'\'s abstract\'',			#stamp : 'pm 12/19/2018 20:49',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:49:42.250485+01:00' ],		#prior : OmReference [ '196' ],		#self : OmReference [ '197' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #'as yet unclassified',			#sourceCode : 'renameVars: aDictionary with:aMap',			#stamp : 'pm 12/19/2018 20:49',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:49:57.369226+01:00' ],		#prior : OmReference [ '197' ],		#self : OmReference [ '198' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #'as yet unclassified',			#sourceCode : 'renameVars: aDictionary with:aMap',			#stamp : 'pm 12/19/2018 20:49',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #'as yet unclassified',			#sourceCode : 'renameVars: aDictionary with:aMap\r\t',			#stamp : 'pm 12/19/2018 20:49',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:50:02.619007+01:00' ],		#prior : OmReference [ '198' ],		#self : OmReference [ '199' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #'as yet unclassified',			#sourceCode : 'renameVars: aDictionary with:aMap\r\t',			#stamp : 'pm 12/19/2018 20:49',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t',			#stamp : 'pm 12/19/2018 20:49',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T20:51:30.446584+01:00' ],		#prior : OmReference [ '199' ],		#self : OmReference [ '200' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t',			#stamp : 'pm 12/19/2018 20:49',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"',			#stamp : 'pm 12/19/2018 20:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T21:19:50.837934+01:00' ],		#prior : OmReference [ '200' ],		#self : OmReference [ '201' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"',			#stamp : 'pm 12/19/2018 20:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| x |',			#stamp : 'pm 12/19/2018 21:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T21:21:29.348102+01:00' ],		#prior : OmReference [ '201' ],		#self : OmReference [ '202' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #'as yet unclassified',			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| x |',			#stamp : 'pm 12/19/2018 21:21',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T21:21:29.373273+01:00' ],		#prior : OmReference [ '202' ],		#self : OmReference [ '203' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #'as yet unclassified',			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| x |',			#stamp : 'pm 12/19/2018 21:21',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| x |',			#stamp : 'pm 12/19/2018 21:21',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:09:08.859542+01:00' ],		#prior : OmReference [ '203' ],		#self : OmReference [ '204' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| x |',			#stamp : 'pm 12/19/2018 21:21',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self term.\r\toldVal:=aMap get:term ifAbsent:[nil].\r\tassoc:=aDictionary at:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: assoc value +1.\r\t\r\taMap at:self put:newVal.\r\toperand renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/19/2018 22:09',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:12:43.363462+01:00' ],		#prior : OmReference [ '204' ],		#self : OmReference [ '205' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #'as yet unclassified',			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self term.\r\toldVal:=aMap get:term ifAbsent:[nil].\r\tassoc:=aDictionary at:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: assoc value +1.\r\t',			#stamp : 'pm 12/19/2018 22:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:12:43.390109+01:00' ],		#prior : OmReference [ '205' ],		#self : OmReference [ '206' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #'as yet unclassified',			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self term.\r\toldVal:=aMap get:term ifAbsent:[nil].\r\tassoc:=aDictionary at:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: assoc value +1.\r\t',			#stamp : 'pm 12/19/2018 22:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self term.\r\toldVal:=aMap get:term ifAbsent:[nil].\r\tassoc:=aDictionary at:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: assoc value +1.\r\t',			#stamp : 'pm 12/19/2018 22:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:20:03.352465+01:00' ],		#prior : OmReference [ '206' ],		#self : OmReference [ '207' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self term.\r\toldVal:=aMap get:term ifAbsent:[nil].\r\tassoc:=aDictionary at:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: assoc value +1.\r\t',			#stamp : 'pm 12/19/2018 22:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\tself left renameVars: aDictionary  with: aMap.\r\tself right renameVars: aDictionary  with: aMap',			#stamp : 'pm 12/19/2018 22:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:22:46.214069+01:00' ],		#prior : OmReference [ '207' ],		#self : OmReference [ '208' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| x |',			#stamp : 'pm 12/19/2018 21:19',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t\t^SubclassResponsibility.',			#stamp : 'pm 12/19/2018 22:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:23:13.658641+01:00' ],		#prior : OmReference [ '208' ],		#self : OmReference [ '209' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Operator,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #'as yet unclassified',			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\tself operand renameVars: aDictionary with:aMap.',			#stamp : 'pm 12/19/2018 22:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:23:13.685182+01:00' ],		#prior : OmReference [ '209' ],		#self : OmReference [ '210' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Operator,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #'as yet unclassified',			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\tself operand renameVars: aDictionary with:aMap.',			#stamp : 'pm 12/19/2018 22:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Operator,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\tself operand renameVars: aDictionary with:aMap.',			#stamp : 'pm 12/19/2018 22:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:23:32.370498+01:00' ],		#prior : OmReference [ '210' ],		#self : OmReference [ '211' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Operator,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\tself operand renameVars: aDictionary with:aMap.',			#stamp : 'pm 12/19/2018 22:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:23:48.683605+01:00' ],		#prior : OmReference [ '211' ],		#self : OmReference [ '212' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #'as yet unclassified',			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\tself operand renameVars: aDictionary with:aMap.',			#stamp : 'pm 12/19/2018 22:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:23:48.708188+01:00' ],		#prior : OmReference [ '212' ],		#self : OmReference [ '213' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #'as yet unclassified',			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\tself operand renameVars: aDictionary with:aMap.',			#stamp : 'pm 12/19/2018 22:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\tself operand renameVars: aDictionary with:aMap.',			#stamp : 'pm 12/19/2018 22:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:24:03.919035+01:00' ],		#prior : OmReference [ '213' ],		#self : OmReference [ '214' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\tself operand renameVars: aDictionary with:aMap.',			#stamp : 'pm 12/19/2018 22:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:24:10.463231+01:00' ],		#prior : OmReference [ '214' ],		#self : OmReference [ '215' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #'as yet unclassified',			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\tself operand renameVars: aDictionary with:aMap.',			#stamp : 'pm 12/19/2018 22:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:24:10.491421+01:00' ],		#prior : OmReference [ '215' ],		#self : OmReference [ '216' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #'as yet unclassified',			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\tself operand renameVars: aDictionary with:aMap.',			#stamp : 'pm 12/19/2018 22:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\tself operand renameVars: aDictionary with:aMap.',			#stamp : 'pm 12/19/2018 22:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:26:34.261055+01:00' ],		#prior : OmReference [ '216' ],		#self : OmReference [ '217' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self term.\r\toldVal:=aMap get:term ifAbsent:[nil].\r\tassoc:=aDictionary at:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: assoc value +1.\r\t\r\taMap at:self put:newVal.\r\toperand renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/19/2018 22:09',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self term.\r\toldVal:=aMap get:term ifAbsent:[nil].\r\tassoc:=aDictionary at:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: assoc value + 1.\r\tnewVal:=assoc key , assoc value.\r\t\r\taMap at:self put:newVal.\r\toperand renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/19/2018 22:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:27:25.217331+01:00' ],		#prior : OmReference [ '217' ],		#self : OmReference [ '218' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self term.\r\toldVal:=aMap get:term ifAbsent:[nil].\r\tassoc:=aDictionary at:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: assoc value + 1.\r\tnewVal:=assoc key , assoc value.\r\t\r\taMap at:self put:newVal.\r\toperand renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/19/2018 22:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self term.\r\toldVal:=aMap get:term ifAbsent:[nil].\r\tassoc:=aDictionary at:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: assoc value + 1.\r\tnewVal:=assoc key , assoc value.\r\t\r\taMap at:self put:newVal.\r\t\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/19/2018 22:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:27:50.616112+01:00' ],		#prior : OmReference [ '218' ],		#self : OmReference [ '219' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self term.\r\toldVal:=aMap get:term ifAbsent:[nil].\r\tassoc:=aDictionary at:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: assoc value + 1.\r\tnewVal:=assoc key , assoc value.\r\t\r\taMap at:self put:newVal.\r\t\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/19/2018 22:27',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self term.\r\toldVal:=aMap get:term ifAbsent:[nil].\r\tassoc:=aDictionary at:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: assoc value + 1.\r\tnewVal:=assoc key , assoc value.\r\t\r\taMap at:self put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/19/2018 22:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:30:09.907816+01:00' ],		#prior : OmReference [ '219' ],		#self : OmReference [ '220' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #'as yet unclassified',			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t\r\t"no replacement to do, no behavior needed"',			#stamp : 'pm 12/19/2018 22:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:30:09.933905+01:00' ],		#prior : OmReference [ '220' ],		#self : OmReference [ '221' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #'as yet unclassified',			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t\r\t"no replacement to do, no behavior needed"',			#stamp : 'pm 12/19/2018 22:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t\r\t"no replacement to do, no behavior needed"',			#stamp : 'pm 12/19/2018 22:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:34:40.663942+01:00' ],		#prior : OmReference [ '221' ],		#self : OmReference [ '222' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #'as yet unclassified',			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t\r\taMap do:[:each|\r\t\tself replace: each key by: each value.\r\t]',			#stamp : 'pm 12/19/2018 22:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:34:40.689453+01:00' ],		#prior : OmReference [ '222' ],		#self : OmReference [ '223' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #'as yet unclassified',			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t\r\taMap do:[:each|\r\t\tself replace: each key by: each value.\r\t]',			#stamp : 'pm 12/19/2018 22:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t\r\taMap do:[:each|\r\t\tself replace: each key by: each value.\r\t]',			#stamp : 'pm 12/19/2018 22:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:35:34.003027+01:00' ],		#prior : OmReference [ '223' ],		#self : OmReference [ '224' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestGeneral\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestGeneral,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestGeneral class\r\tinstanceVariableNames: \'\''				},				#name : #'TestGeneral class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestGeneral,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:36:04.687109+01:00' ],		#prior : OmReference [ '224' ],		#self : OmReference [ '225' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestGeneral,				#isMetaSide : false			},			#name : #setUp,			#protocol : #'as yet unclassified',			#sourceCode : 'setUp\r\tProp initEverything.',			#stamp : 'pm 12/19/2018 22:36',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:36:04.707484+01:00' ],		#prior : OmReference [ '225' ],		#self : OmReference [ '226' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestGeneral,				#isMetaSide : false			},			#name : #setUp,			#protocol : #'as yet unclassified',			#sourceCode : 'setUp\r\tProp initEverything.',			#stamp : 'pm 12/19/2018 22:36',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestGeneral,				#isMetaSide : false			},			#name : #setUp,			#protocol : #initialization,			#sourceCode : 'setUp\r\tProp initEverything.',			#stamp : 'pm 12/19/2018 22:36',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:38:18.542091+01:00' ],		#prior : OmReference [ '226' ],		#self : OmReference [ '227' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestGeneral,				#isMetaSide : false			},			#name : #testRename,			#protocol : #initialization,			#sourceCode : 'testRename\r\t\r\t| initial expected |\r\tinitial:=ForAll new:\'x\' Property:\r \t  (ForAll new:\'x\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x\');\r \t      yourself)\r \t   )\r \t  ).\r\t\r\texpected:=Prop.',			#stamp : 'pm 12/19/2018 22:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:39:19.687152+01:00' ],		#prior : OmReference [ '227' ],		#self : OmReference [ '228' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestGeneral,				#isMetaSide : false			},			#name : #testRename,			#protocol : #initialization,			#sourceCode : 'testRename\r\t\r\t| initial expected |\r\tinitial:=ForAll new:\'x\' Property:\r \t  (ForAll new:\'x\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x\');\r \t      yourself)\r \t   )\r \t  ).\r\t\r\texpected:=Prop.',			#stamp : 'pm 12/19/2018 22:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestGeneral,				#isMetaSide : false			},			#name : #testRename,			#protocol : #initialization,			#sourceCode : 'testRename\r\t\r\t| initial expected |\r\tinitial:=ForAll new:\'x\' Property:\r \t  (ForAll new:\'x\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x\');\r \t      yourself)\r \t   )\r \t  ).\r\t\r\texpected:=Prop.\r\tself assert: initial launchRenameVariables equals:expected.',			#stamp : 'pm 12/19/2018 22:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:42:34.696119+01:00' ],		#prior : OmReference [ '228' ],		#self : OmReference [ '229' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #launchRenameVariables,			#protocol : #testing-properties,			#sourceCode : 'launchRenameVariables\r\tself renameVars: Dictionary new with: Dictionary new.',			#stamp : 'pm 12/19/2018 22:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:44:09.604038+01:00' ],		#prior : OmReference [ '229' ],		#self : OmReference [ '230' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestGeneral,				#isMetaSide : false			},			#name : #testRename,			#protocol : #initialization,			#sourceCode : 'testRename\r\t\r\t| initial expected |\r\tinitial:=ForAll new:\'x\' Property:\r \t  (ForAll new:\'x\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x\');\r \t      yourself)\r \t   )\r \t  ).\r\t\r\texpected:=Prop.\r\tself assert: initial launchRenameVariables equals:expected.',			#stamp : 'pm 12/19/2018 22:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestGeneral,				#isMetaSide : false			},			#name : #testRename,			#protocol : #initialization,			#sourceCode : 'testRename\r\t\r\t| initial expected |\r\tinitial:=ForAll new:\'x\' Property:\r \t  (ForAll new:\'x\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x\');\r \t      yourself)\r \t   )\r \t  ).\r\t\r\texpected:=ForAll new:\'x\' Property:\r \t  (ForAll new:\'x1\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x1\');\r \t      yourself)\r \t   )\r \t  )..\r\tself assert: initial launchRenameVariables equals:expected.',			#stamp : 'pm 12/19/2018 22:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:45:17.341218+01:00' ],		#prior : OmReference [ '230' ],		#self : OmReference [ '231' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self term.\r\toldVal:=aMap get:term ifAbsent:[nil].\r\tassoc:=aDictionary at:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: assoc value + 1.\r\tnewVal:=assoc key , assoc value.\r\t\r\taMap at:self put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/19/2018 22:27',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self var.\r\toldVal:=aMap get:term ifAbsent:[nil].\r\tassoc:=aDictionary at:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: assoc value + 1.\r\tnewVal:=assoc key , assoc value.\r\t\r\taMap at:self put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/19/2018 22:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:45:30.474827+01:00' ],		#prior : OmReference [ '231' ],		#self : OmReference [ '232' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self var.\r\toldVal:=aMap get:term ifAbsent:[nil].\r\tassoc:=aDictionary at:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: assoc value + 1.\r\tnewVal:=assoc key , assoc value.\r\t\r\taMap at:self put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/19/2018 22:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary at:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: assoc value + 1.\r\tnewVal:=assoc key , assoc value.\r\t\r\taMap at:self put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/19/2018 22:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:46:21.710184+01:00' ],		#prior : OmReference [ '232' ],		#self : OmReference [ '233' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary at:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: assoc value + 1.\r\tnewVal:=assoc key , assoc value.\r\t\r\taMap at:self put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/19/2018 22:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary at:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: assoc value + 1.\r\tnewVal:=assoc key , assoc value asString.\r\t\r\taMap at:self put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/19/2018 22:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:48:18.905268+01:00' ],		#prior : OmReference [ '233' ],		#self : OmReference [ '234' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary at:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: assoc value + 1.\r\tnewVal:=assoc key , assoc value asString.\r\t\r\taMap at:self put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/19/2018 22:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary at:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVal:=assoc key , assoc value asString.\r\t\r\taMap at:self put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/19/2018 22:48',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:50:21.634361+01:00' ],		#prior : OmReference [ '234' ],		#self : OmReference [ '235' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary at:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVal:=assoc key , assoc value asString.\r\t\r\taMap at:self put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/19/2018 22:48',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVal:=assoc key , assoc value asString.\r\t\r\taMap at:self put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/19/2018 22:50',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:53:48.395546+01:00' ],		#prior : OmReference [ '235' ],		#self : OmReference [ '236' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVal:=assoc key , assoc value asString.\r\t\r\taMap at:self put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/19/2018 22:50',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVal:=assoc key , assoc value asString.\r\t\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/19/2018 22:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:57:21.283984+01:00' ],		#prior : OmReference [ '236' ],		#self : OmReference [ '237' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t\r\taMap do:[:each|\r\t\tself replace: each key by: each value.\r\t]',			#stamp : 'pm 12/19/2018 22:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t\r\taMap do:[:each|\r\t\tself halt.\r\t\tself replace: each key by: each value.\r\t]',			#stamp : 'pm 12/19/2018 22:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T22:58:23.863914+01:00' ],		#prior : OmReference [ '237' ],		#self : OmReference [ '238' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t\r\taMap do:[:each|\r\t\tself halt.\r\t\tself replace: each key by: each value.\r\t]',			#stamp : 'pm 12/19/2018 22:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t\r\taMap keysAndValuesDo:[:each|\r\t\tself replace: each key by: each value.\r\t]',			#stamp : 'pm 12/19/2018 22:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-19T23:03:39.697579+01:00' ],		#prior : OmReference [ '238' ],		#self : OmReference [ '239' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t\r\taMap keysAndValuesDo:[:each|\r\t\tself replace: each key by: each value.\r\t]',			#stamp : 'pm 12/19/2018 22:58',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t\r\taMap keysAndValuesDo:[:key :value|\r\t\tself replace: key by: value.\r\t]',			#stamp : 'pm 12/19/2018 23:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T09:27:39.18753+01:00' ],		#prior : OmReference [ '239' ],		#self : OmReference [ '240' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'renameVars:with:replace:by:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t\r\treplace:x by:t\r\t| i |\r\ti:=1.\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t((terms at:i) isFuncTerm)\r\t\tifTrue: [\r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(((terms at:i) getSymb)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].\r\t^self',			#stamp : 'pm 12/20/2018 09:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T09:28:03.956098+01:00' ],		#prior : OmReference [ '240' ],		#self : OmReference [ '241' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'renameVars:with:replace:by:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t\r\treplace:x by:t\r\t| i |\r\ti:=1.\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t((terms at:i) isFuncTerm)\r\t\tifTrue: [\r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(((terms at:i) getSymb)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].\r\t^self',			#stamp : 'pm 12/20/2018 09:27',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'renameVars:with:replace:by:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t\r\treplace:x by:t\r\t| i |\r\ti:=1.\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t((terms at:i) isFuncTerm)\r\t\tifTrue: [\r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(((terms at:i) getSymb)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:(Term new:t).\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].\r\t^self',			#stamp : 'pm 12/20/2018 09:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T09:28:38.47306+01:00' ],		#prior : OmReference [ '241' ],		#self : OmReference [ '242' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t\r\taMap keysAndValuesDo:[:key :value|\r\t\tself replace: key by: value.\r\t]',			#stamp : 'pm 12/19/2018 23:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t\r\t| i x t |\r\ti:=1.\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t((terms at:i) isFuncTerm)\r\t\tifTrue: [\r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(((terms at:i) getSymb)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:(Term new:t).\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].\r\t^self',			#stamp : 'pm 12/20/2018 09:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T09:30:07.536773+01:00' ],		#prior : OmReference [ '242' ],		#self : OmReference [ '243' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t\r\t| i x t |\r\ti:=1.\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t((terms at:i) isFuncTerm)\r\t\tifTrue: [\r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(((terms at:i) getSymb)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:(Term new:t).\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].\r\t^self',			#stamp : 'pm 12/20/2018 09:28',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\taMap keysAndValuesDo:[:key :value |\r\t\tself replace:key by:value.\r\t\t].',			#stamp : 'pm 12/20/2018 09:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T09:30:29.276061+01:00' ],		#prior : OmReference [ '243' ],		#self : OmReference [ '244' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVal:=assoc key , assoc value asString.\r\t\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/19/2018 22:53',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVal:=Term new:(assoc key , assoc value asString).\r\t\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 09:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T09:31:12.906545+01:00' ],		#prior : OmReference [ '244' ],		#self : OmReference [ '245' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVal:=Term new:(assoc key , assoc value asString).\r\t\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 09:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: (Term new:term) value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVal:=Term new:(assoc key , assoc value asString).\r\t\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 09:31',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T09:31:29.102135+01:00' ],		#prior : OmReference [ '245' ],		#self : OmReference [ '246' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: (Term new:term) value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVal:=Term new:(assoc key , assoc value asString).\r\t\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 09:31',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: (Term new:term) value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVal:=Term new:(assoc key , assoc value asString)asString.\r\t\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 09:31',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T09:35:55.333983+01:00' ],		#prior : OmReference [ '246' ],		#self : OmReference [ '247' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: (Term new:term) value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVal:=Term new:(assoc key , assoc value asString)asString.\r\t\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 09:31',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: (Term new:term) value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tself halt.\r\tnewVal:=Term new:(assoc key , assoc value asString)asString.\r\t\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 09:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T10:02:39.798144+01:00' ],		#prior : OmReference [ '247' ],		#self : OmReference [ '248' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: (Term new:term) value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tself halt.\r\tnewVal:=Term new:(assoc key , assoc value asString)asString.\r\t\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 09:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: (Term new:term) value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVal:=Term new:((assoc key , assoc value asString) asString).\r\t\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 10:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T10:03:23.974365+01:00' ],		#prior : OmReference [ '248' ],		#self : OmReference [ '249' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: (Term new:term) value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVal:=Term new:((assoc key , assoc value asString) asString).\r\t\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 10:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: (Term new:term) value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVal:=Term new:((assoc key getSymb , assoc value asString) asString).\r\t\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 10:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T10:19:39.839736+01:00' ],		#prior : OmReference [ '249' ],		#self : OmReference [ '250' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: (Term new:term) value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVal:=Term new:((assoc key getSymb , assoc value asString) asString).\r\t\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 10:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: (Term new:term) value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVal:=Term new:((assoc key getSymb, assoc value asString) asString).\r\t\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 10:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T10:27:41.452154+01:00' ],		#prior : OmReference [ '250' ],		#self : OmReference [ '251' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\taMap keysAndValuesDo:[:key :value |\r\t\tself replace:key by:value.\r\t\t].',			#stamp : 'pm 12/20/2018 09:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t\r\taMap keysAndValuesDo:[:key :value|\r\t\tself replace: key by: value\r\t\t].',			#stamp : 'pm 12/20/2018 10:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T10:30:29.21095+01:00' ],		#prior : OmReference [ '251' ],		#self : OmReference [ '252' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: (Term new:term) value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVal:=Term new:((assoc key getSymb, assoc value asString) asString).\r\t\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 10:19',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=Term new:self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVal:=Term new:((assoc key getSymb, assoc value asString) asString).\r\t\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 10:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T10:30:59.406913+01:00' ],		#prior : OmReference [ '252' ],		#self : OmReference [ '253' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestGeneral,				#isMetaSide : false			},			#name : #testRename,			#protocol : #initialization,			#sourceCode : 'testRename\r\t\r\t| initial expected |\r\tinitial:=ForAll new:\'x\' Property:\r \t  (ForAll new:\'x\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x\');\r \t      yourself)\r \t   )\r \t  ).\r\t\r\texpected:=ForAll new:\'x\' Property:\r \t  (ForAll new:\'x1\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x1\');\r \t      yourself)\r \t   )\r \t  )..\r\tself assert: initial launchRenameVariables equals:expected.',			#stamp : 'pm 12/19/2018 22:44',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestGeneral,				#isMetaSide : false			},			#name : #testRename,			#protocol : #initialization,			#sourceCode : 'testRename\r\t\r\t| initial expected |\r\tinitial:=ForAll new:\'x\' Property:\r \t  (ForAll new:\'x\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x\');\r \t      yourself)\r \t   )\r \t  ).\r\t\r\texpected:=ForAll new:\'x1\' Property:\r \t  (ForAll new:\'x2\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x2\');\r \t      yourself)\r \t   )\r \t  )..\r\tself assert: initial launchRenameVariables equals:expected.',			#stamp : 'pm 12/20/2018 10:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T10:32:09.956551+01:00' ],		#prior : OmReference [ '253' ],		#self : OmReference [ '254' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term |\r\t\r\tterm:=Term new:self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVal:=Term new:((assoc key getSymb, assoc value asString) asString).\r\t\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 10:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term newVar |\r\t\r\tterm:=Term new:self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVar:=((assoc key getSymb, assoc value asString) asString).\r\tnewVal:=Term new:newVar.\r\tself var:newVar.\r\t\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 10:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T10:32:35.819096+01:00' ],		#prior : OmReference [ '254' ],		#self : OmReference [ '255' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'var:',			#protocol : #accessing,			#sourceCode : 'var: aString\r\t"accessor"\r\tvar:=aString.',			#stamp : 'pm 12/20/2018 10:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T10:33:09.294149+01:00' ],		#prior : OmReference [ '255' ],		#self : OmReference [ '256' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term newVar |\r\t\r\tterm:=Term new:self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVar:=((assoc key getSymb, assoc value asString) asString).\r\tnewVal:=Term new:newVar.\r\tself var:newVar.\r\t\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 10:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term newVar |\r\t\r\tterm:=Term new:self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVar:=((assoc key getSymb, assoc value asString) asString).\r\tnewVal:=Term new:newVar.\r\tself var:newVar.\r\tself halt.\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 10:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T10:34:11.70478+01:00' ],		#prior : OmReference [ '256' ],		#self : OmReference [ '257' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term newVar |\r\t\r\tterm:=Term new:self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVar:=((assoc key getSymb, assoc value asString) asString).\r\tnewVal:=Term new:newVar.\r\tself var:newVar.\r\tself halt.\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 10:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term newVar |\r\t\r\tterm:=Term new:self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVar:=((assoc key getSymb, assoc value asString) asString).\r\tnewVal:=Term new:newVar.\r\tself var:newVar.\r\r\taMap at:term put:newVal.\r\t\tself halt.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 10:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T10:38:42.478861+01:00' ],		#prior : OmReference [ '257' ],		#self : OmReference [ '258' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term newVar |\r\t\r\tterm:=Term new:self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVar:=((assoc key getSymb, assoc value asString) asString).\r\tnewVal:=Term new:newVar.\r\tself var:newVar.\r\r\taMap at:term put:newVal.\r\t\tself halt.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 10:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term newVar |\r\t\r\tterm:=Term new:self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVar:=((assoc key getSymb, assoc value asString) asString).\r\tnewVal:=Term new:newVar.\r\tself var:newVar.\r\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 10:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T10:38:56.190754+01:00' ],		#prior : OmReference [ '258' ],		#self : OmReference [ '259' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t"default comparing for terms."\r\t^(self getSymb)=(anotherTerm getSymb).',			#stamp : 'pm 10/21/2018 13:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t"default comparing for terms."\r\tself halt.\r\t^(self getSymb)=(anotherTerm getSymb).',			#stamp : 'pm 12/20/2018 10:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T10:39:22.464188+01:00' ],		#prior : OmReference [ '259' ],		#self : OmReference [ '260' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t"default comparing for terms."\r\tself halt.\r\t^(self getSymb)=(anotherTerm getSymb).',			#stamp : 'pm 12/20/2018 10:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t"default comparing for terms."\r\t(self getSymb)=(anotherTerm getSymb).\r\tself halt.\r\t^(self getSymb)=(anotherTerm getSymb).',			#stamp : 'pm 12/20/2018 10:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T10:40:00.561903+01:00' ],		#prior : OmReference [ '260' ],		#self : OmReference [ '261' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t"default comparing for terms."\r\t(self getSymb)=(anotherTerm getSymb).\r\tself halt.\r\t^(self getSymb)=(anotherTerm getSymb).',			#stamp : 'pm 12/20/2018 10:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t"default comparing for terms."\r\tTranscript show:(self getSymb)=(anotherTerm getSymb);cr.\r\tself halt.\r\t^(self getSymb)=(anotherTerm getSymb).',			#stamp : 'pm 12/20/2018 10:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T10:40:45.179231+01:00' ],		#prior : OmReference [ '261' ],		#self : OmReference [ '262' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t"default comparing for terms."\r\tTranscript show:(self getSymb)=(anotherTerm getSymb);cr.\r\tself halt.\r\t^(self getSymb)=(anotherTerm getSymb).',			#stamp : 'pm 12/20/2018 10:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t"default comparing for terms."\r\tTranscript show:(self getSymb)=(anotherTerm getSymb);cr.\r\t^(self getSymb)=(anotherTerm getSymb).',			#stamp : 'pm 12/20/2018 10:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T10:41:25.953364+01:00' ],		#prior : OmReference [ '262' ],		#self : OmReference [ '263' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t"default comparing for terms."\r\tTranscript show:(self getSymb)=(anotherTerm getSymb);cr.\r\t^(self getSymb)=(anotherTerm getSymb).',			#stamp : 'pm 12/20/2018 10:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t"default comparing for terms."\r\t(self getSymb)=(anotherTerm getSymb)\r\tifFalse:[\r\t\tself halt.\r\t\t].\r\t^(self getSymb)=(anotherTerm getSymb).',			#stamp : 'pm 12/20/2018 10:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T10:44:11.375771+01:00' ],		#prior : OmReference [ '263' ],		#self : OmReference [ '264' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t"default comparing for terms."\r\t(self getSymb)=(anotherTerm getSymb)\r\tifFalse:[\r\t\tself halt.\r\t\t].\r\t^(self getSymb)=(anotherTerm getSymb).',			#stamp : 'pm 12/20/2018 10:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t"default comparing for terms."\r\t^(self getSymb)=(anotherTerm getSymb).',			#stamp : 'pm 12/20/2018 10:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T10:53:43.861307+01:00' ],		#prior : OmReference [ '264' ],		#self : OmReference [ '265' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t"default comparing for terms."\r\t^(self getSymb)=(anotherTerm getSymb).',			#stamp : 'pm 12/20/2018 10:44',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t"default comparing for terms."\r\tTranscript show:(self getSymb)=(anotherTerm getSymb);cr.\r\t^(self getSymb)=(anotherTerm getSymb).',			#stamp : 'pm 12/20/2018 10:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T11:23:26.589189+01:00' ],		#prior : OmReference [ '265' ],		#self : OmReference [ '266' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t"default comparing for terms."\r\tTranscript show:(self getSymb)=(anotherTerm getSymb);cr.\r\t^(self getSymb)=(anotherTerm getSymb).',			#stamp : 'pm 12/20/2018 10:53',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t"default comparing for terms."\r\tTranscript show:(self getSymb)=(anotherTerm getSymb);cr.\r\t^((self getSymb)=(anotherTerm getSymb) not).',			#stamp : 'pm 12/20/2018 11:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T11:23:47.252429+01:00' ],		#prior : OmReference [ '266' ],		#self : OmReference [ '267' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t"default comparing for terms."\r\tTranscript show:(self getSymb)=(anotherTerm getSymb);cr.\r\t^((self getSymb)=(anotherTerm getSymb) not).',			#stamp : 'pm 12/20/2018 11:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t"default comparing for terms."\r\tTranscript show:(self getSymb)=(anotherTerm getSymb);cr.\r\t^((self getSymb)=(anotherTerm getSymb))not.',			#stamp : 'pm 12/20/2018 11:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T11:39:13.475467+01:00' ],		#prior : OmReference [ '267' ],		#self : OmReference [ '268' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t"default comparing for terms."\r\tTranscript show:(self getSymb)=(anotherTerm getSymb);cr.\r\t^((self getSymb)=(anotherTerm getSymb))not.',			#stamp : 'pm 12/20/2018 11:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t"default comparing for terms."\r\t^((self getSymb)=(anotherTerm getSymb))not.',			#stamp : 'pm 12/20/2018 11:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T11:58:40.385979+01:00' ],		#prior : OmReference [ '268' ],		#self : OmReference [ '269' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term newVar |\r\t\r\tterm:=Term new:self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVar:=((assoc key getSymb, assoc value asString) asString).\r\tnewVal:=Term new:newVar.\r\tself var:newVar.\r\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 10:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term newVar |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVar:=((assoc key getSymb, assoc value asString) asString).\r\tnewVal:=Term new:newVar.\r\tself var:newVar.\r\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 11:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:00:05.599615+01:00' ],		#prior : OmReference [ '269' ],		#self : OmReference [ '270' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'renameVars:with:replace:by:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t\r\treplace:x by:t\r\t| i |\r\ti:=1.\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t((terms at:i) isFuncTerm)\r\t\tifTrue: [\r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(((terms at:i) getSymb)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:(Term new:t).\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].\r\t^self',			#stamp : 'pm 12/20/2018 09:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:00:20.386134+01:00' ],		#prior : OmReference [ '270' ],		#self : OmReference [ '271' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t\r\taMap keysAndValuesDo:[:key :value|\r\t\tself replace: key by: value\r\t\t].',			#stamp : 'pm 12/20/2018 10:27',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t\r\taMap keysAndValuesDo:[:key :value|\r\t\tself replace: (Term new:key) by: value\r\t\t].',			#stamp : 'pm 12/20/2018 12:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:00:44.20967+01:00' ],		#prior : OmReference [ '271' ],		#self : OmReference [ '272' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term newVar |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVar:=((assoc key getSymb, assoc value asString) asString).\r\tnewVal:=Term new:newVar.\r\tself var:newVar.\r\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 11:58',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term newVar |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVar:=((assoc key , assoc value asString) asString).\r\tnewVal:=Term new:newVar.\r\tself var:newVar.\r\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 12:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:05:07.750629+01:00' ],		#prior : OmReference [ '272' ],		#self : OmReference [ '273' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t"default comparing for terms."\r\t^((self getSymb)=(anotherTerm getSymb))not.',			#stamp : 'pm 12/20/2018 11:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t"default comparing for terms."\r\t^(self getSymb)=(anotherTerm getSymb).',			#stamp : 'pm 12/20/2018 12:05',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:10:42.347963+01:00' ],		#prior : OmReference [ '273' ],		#self : OmReference [ '274' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestGeneral,				#isMetaSide : false			},			#name : #testRename,			#protocol : #initialization,			#sourceCode : 'testRename\r\t\r\t| initial expected |\r\tinitial:=ForAll new:\'x\' Property:\r \t  (ForAll new:\'x\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x\');\r \t      yourself)\r \t   )\r \t  ).\r\t\r\texpected:=ForAll new:\'x1\' Property:\r \t  (ForAll new:\'x2\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x2\');\r \t      yourself)\r \t   )\r \t  )..\r\tself assert: initial launchRenameVariables equals:expected.',			#stamp : 'pm 12/20/2018 10:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestGeneral,				#isMetaSide : false			},			#name : #testRename,			#protocol : #initialization,			#sourceCode : 'testRename\r\t\r\t| initial expected |\r\tinitial:=ForAll new:\'x\' Property:\r \t  (ForAll new:\'x\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x\');\r \t      yourself)\r \t   )\r \t  ).\r\t\r\texpected:=ForAll new:\'x1\' Property:\r \t  (ForAll new:\'x2\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x2\');\r \t      yourself)\r \t   )\r \t  ).\r\tself assert: initial launchRenameVariables equals:expected.\r\t\r\tinitial:=ForAll new:\'x\' Property:\r   (Or new:\r    (ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x\');\r        yourself)\r     )\r    )\r   rightProp:\r    (ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x\');\r        yourself)\r     )\r    )\r   ).\r\r\texpected:=ForAll new:\'x1\' Property:\r   (Or new:\r    (ForAll new:\'x2\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x2\');\r        yourself)\r     )\r    )\r   rightProp:\r    (ForAll new:\'x3\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x3\');\r        yourself)\r     )\r    )\r   ).\t\r\t\r\tself assert: initial launchRenameVariables equals:expected.',			#stamp : 'pm 12/20/2018 12:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:45:01.636349+01:00' ],		#prior : OmReference [ '274' ],		#self : OmReference [ '275' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestGeneral,				#isMetaSide : false			},			#name : #testRename,			#protocol : #initialization,			#sourceCode : 'testRename\r\t\r\t| initial expected |\r\tinitial:=ForAll new:\'x\' Property:\r \t  (ForAll new:\'x\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x\');\r \t      yourself)\r \t   )\r \t  ).\r\t\r\texpected:=ForAll new:\'x1\' Property:\r \t  (ForAll new:\'x2\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x2\');\r \t      yourself)\r \t   )\r \t  ).\r\tself assert: initial launchRenameVariables equals:expected.\r\t\r\tinitial:=ForAll new:\'x\' Property:\r   (Or new:\r    (ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x\');\r        yourself)\r     )\r    )\r   rightProp:\r    (ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x\');\r        yourself)\r     )\r    )\r   ).\r\r\texpected:=ForAll new:\'x1\' Property:\r   (Or new:\r    (ForAll new:\'x2\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x2\');\r        yourself)\r     )\r    )\r   rightProp:\r    (ForAll new:\'x3\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x3\');\r        yourself)\r     )\r    )\r   ).\t\r\t\r\tself assert: initial launchRenameVariables equals:expected.',			#stamp : 'pm 12/20/2018 12:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestGeneral,				#isMetaSide : false			},			#name : #testRename,			#protocol : #initialization,			#sourceCode : 'testRename\r\t\r\t| initial expected |\r\tinitial:=ForAll new:\'x\' Property:\r \t  (ForAll new:\'x\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x\');\r \t      yourself)\r \t   )\r \t  ).\r\t\r\texpected:=ForAll new:\'x1\' Property:\r \t  (ForAll new:\'x2\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x2\');\r \t      yourself)\r \t   )\r \t  ).\r\tself assert: initial launchRenameVariables equals:expected.\r\t\r\tinitial:=ForAll new:\'x\' Property:\r   (Or new:\r    (ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x\');\r        yourself)\r     )\r    )\r   rightProp:\r    (ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x\');\r        yourself)\r     )\r    )\r   ).\r\r\texpected:=ForAll new:\'x1\' Property:\r   (Or new:\r    (ForAll new:\'x2\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x2\');\r        yourself)\r     )\r    )\r   rightProp:\r    (ForAll new:\'x3\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x4\');\r        yourself)\r     )\r    )\r   ).\t\r\t\r\tself assert: initial launchRenameVariables equals:expected.',			#stamp : 'pm 12/20/2018 12:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:45:13.433922+01:00' ],		#prior : OmReference [ '275' ],		#self : OmReference [ '276' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestGeneral,				#isMetaSide : false			},			#name : #testRename,			#protocol : #initialization,			#sourceCode : 'testRename\r\t\r\t| initial expected |\r\tinitial:=ForAll new:\'x\' Property:\r \t  (ForAll new:\'x\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x\');\r \t      yourself)\r \t   )\r \t  ).\r\t\r\texpected:=ForAll new:\'x1\' Property:\r \t  (ForAll new:\'x2\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x2\');\r \t      yourself)\r \t   )\r \t  ).\r\tself assert: initial launchRenameVariables equals:expected.\r\t\r\tinitial:=ForAll new:\'x\' Property:\r   (Or new:\r    (ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x\');\r        yourself)\r     )\r    )\r   rightProp:\r    (ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x\');\r        yourself)\r     )\r    )\r   ).\r\r\texpected:=ForAll new:\'x1\' Property:\r   (Or new:\r    (ForAll new:\'x2\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x2\');\r        yourself)\r     )\r    )\r   rightProp:\r    (ForAll new:\'x3\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x4\');\r        yourself)\r     )\r    )\r   ).\t\r\t\r\tself assert: initial launchRenameVariables equals:expected.',			#stamp : 'pm 12/20/2018 12:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestGeneral,				#isMetaSide : false			},			#name : #testRename,			#protocol : #initialization,			#sourceCode : 'testRename\r\t\r\t| initial expected |\r\tinitial:=ForAll new:\'x\' Property:\r \t  (ForAll new:\'x\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x\');\r \t      yourself)\r \t   )\r \t  ).\r\t\r\texpected:=ForAll new:\'x1\' Property:\r \t  (ForAll new:\'x2\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x2\');\r \t      yourself)\r \t   )\r \t  ).\r\tself assert: initial launchRenameVariables equals:expected.\r\t\r\tinitial:=ForAll new:\'x\' Property:\r   (Or new:\r    (ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x\');\r        yourself)\r     )\r    )\r   rightProp:\r    (ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x\');\r        yourself)\r     )\r    )\r   ).\r\r\texpected:=ForAll new:\'x1\' Property:\r   (Or new:\r    (ForAll new:\'x2\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x2\');\r        yourself)\r     )\r    )\r   rightProp:\r    (ForAll new:\'x3\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x3\');\r        yourself)\r     )\r    )\r   ).\t\r\t\r\tself assert: initial launchRenameVariables equals:expected.',			#stamp : 'pm 12/20/2018 12:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:35.265477+01:00' ],		#prior : OmReference [ '276' ],		#self : OmReference [ '277' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tresolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\t\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp startSkolemisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tresolutionTrace ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/19/2018 20:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tresolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\ttreatedProp:=\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp startSkolemisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tresolutionTrace ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/20/2018 12:50',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:35.358371+01:00' ],		#prior : OmReference [ '277' ],		#self : OmReference [ '278' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #factorisationUnitTest,			#protocol : #testing,			#sourceCode : 'factorisationUnitTest\r\t|r fc|\r\tProp testInc.\r\tself assert:[self isClause.].\r\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\t\r\tfc:=ClausalForm new:self.\r\tr:=Resolvante new.\r\tr factorisation: (fc at:1).\r\t\r\t\r\tTranscript show:r;cr;cr;cr.',			#stamp : 'pm 10/26/2018 18:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #factorisationUnitTest,			#protocol : #unit-testing,			#sourceCode : 'factorisationUnitTest\r\t|r fc|\r\tProp testInc.\r\tself assert:[self isClause.].\r\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\t\r\tfc:=ClausalForm new:self.\r\tr:=Resolvante new.\r\tr factorisation: (fc at:1).\r\t\r\t\r\tTranscript show:r;cr;cr;cr.',			#stamp : 'pm 10/26/2018 18:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:35.371178+01:00' ],		#prior : OmReference [ '278' ],		#self : OmReference [ '279' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'matchingUnitTest:',			#protocol : #testing,			#sourceCode : 'matchingUnitTest: prop\r\t"self will be considered as a pattern"\r\tTranscript cr;\r\t\tshow: \'prop : \' ; \r\t\tshow: (prop prettyPrint);\r\t\tcr;\r\t\tshow: \'pattern : \';\r\t\tshow: (self prettyPrint);\r\t\tcr.\r\t\t(self matchPatternWith: prop)\r\t\t\tifTrue:[ Transcript show: \'matched!\';cr.]\r\t\t\tifFalse:[ Transcript show: \'didn\'\'t match!\';cr]\r\t',			#stamp : 'pm 9/30/2018 12:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'matchingUnitTest:',			#protocol : #unit-testing,			#sourceCode : 'matchingUnitTest: prop\r\t"self will be considered as a pattern"\r\tTranscript cr;\r\t\tshow: \'prop : \' ; \r\t\tshow: (prop prettyPrint);\r\t\tcr;\r\t\tshow: \'pattern : \';\r\t\tshow: (self prettyPrint);\r\t\tcr.\r\t\t(self matchPatternWith: prop)\r\t\t\tifTrue:[ Transcript show: \'matched!\';cr.]\r\t\t\tifFalse:[ Transcript show: \'didn\'\'t match!\';cr]\r\t',			#stamp : 'pm 9/30/2018 12:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:35.380852+01:00' ],		#prior : OmReference [ '279' ],		#self : OmReference [ '280' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isPredicateOrFuncTerm,			#protocol : #testing,			#sourceCode : 'isPredicateOrFuncTerm\r\t"Class tester"\r\t"Necessary because we don\'t distinguish them in the unification process"\r\t^false',			#stamp : 'pm 12/14/2018 13:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isPredicateOrFuncTerm,			#protocol : #unit-testing,			#sourceCode : 'isPredicateOrFuncTerm\r\t"Class tester"\r\t"Necessary because we don\'t distinguish them in the unification process"\r\t^false',			#stamp : 'pm 12/14/2018 13:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:35.389343+01:00' ],		#prior : OmReference [ '280' ],		#self : OmReference [ '281' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'unificationUnitTest:',			#protocol : #testing,			#sourceCode : 'unificationUnitTest: otherPredicate\r\t|t newPair|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tnewPair:=t unifiedPair.\r\t(t hasFailed)\r\tifFalse:[\r\t\tTranscript show:newPair;cr;cr.\r\t]\r\tifTrue:[\r\t\tTranscript show: \'Unification failed.\';cr;cr.\r\t\t].\r\t^t',			#stamp : 'pm 10/25/2018 08:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'unificationUnitTest:',			#protocol : #unit-testing,			#sourceCode : 'unificationUnitTest: otherPredicate\r\t|t newPair|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tnewPair:=t unifiedPair.\r\t(t hasFailed)\r\tifFalse:[\r\t\tTranscript show:newPair;cr;cr.\r\t]\r\tifTrue:[\r\t\tTranscript show: \'Unification failed.\';cr;cr.\r\t\t].\r\t^t',			#stamp : 'pm 10/25/2018 08:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:35.394677+01:00' ],		#prior : OmReference [ '281' ],		#self : OmReference [ '282' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #skolemnisationTest,			#protocol : #testing,			#sourceCode : 'skolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self startSkolemisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr.\r\tt:=t resolutionMethod.\r\r\tTranscript show:\'Resolution method:\' ;show:t;cr;cr;cr.\r\t^t ',			#stamp : 'pm 12/19/2018 20:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #skolemnisationTest,			#protocol : #unit-testing,			#sourceCode : 'skolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self startSkolemisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr.\r\tt:=t resolutionMethod.\r\r\tTranscript show:\'Resolution method:\' ;show:t;cr;cr;cr.\r\t^t ',			#stamp : 'pm 12/19/2018 20:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:35.399467+01:00' ],		#prior : OmReference [ '282' ],		#self : OmReference [ '283' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'resolvanteUnitTest:',			#protocol : #testing,			#sourceCode : 'resolvanteUnitTest: anotherClause\r\t"We expect self and anotherClause to be clauses, or at minimal a clausal form."\r\t|r fc1 fc2|\r\tself assert: [ self isClause ].\r\tanotherClause assert:[ self isClause ].\r\t\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tfc1:=ClausalForm new:self.\r\tfc2:=ClausalForm new:anotherClause.\r\tTranscript show: \'Trying to resolve \';show: fc1 ; show:\' with \';show: fc2; cr.\r\tr:=Resolvante new.\r\t\r\tr resolvante: (fc1 at:1) with: (fc2 at:1).\r\tTranscript show:r;cr;cr;cr.',			#stamp : 'pm 10/26/2018 18:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'resolvanteUnitTest:',			#protocol : #unit-testing,			#sourceCode : 'resolvanteUnitTest: anotherClause\r\t"We expect self and anotherClause to be clauses, or at minimal a clausal form."\r\t|r fc1 fc2|\r\tself assert: [ self isClause ].\r\tanotherClause assert:[ self isClause ].\r\t\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tfc1:=ClausalForm new:self.\r\tfc2:=ClausalForm new:anotherClause.\r\tTranscript show: \'Trying to resolve \';show: fc1 ; show:\' with \';show: fc2; cr.\r\tr:=Resolvante new.\r\t\r\tr resolvante: (fc1 at:1) with: (fc2 at:1).\r\tTranscript show:r;cr;cr;cr.',			#stamp : 'pm 10/26/2018 18:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:35.404409+01:00' ],		#prior : OmReference [ '283' ],		#self : OmReference [ '284' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #clausificationUnitTest,			#protocol : #testing,			#sourceCode : 'clausificationUnitTest\r\t|t|\r\tTranscript show: self prettyPrint; show: \'  \' ;show: self isClause; cr.\r\tt:=self fullClausification.\r\tTranscript show: t prettyPrint; show: \'  \' ;show: t isClause; cr;cr.\r\t^t.',			#stamp : 'pm 10/9/2018 13:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #clausificationUnitTest,			#protocol : #unit-testing,			#sourceCode : 'clausificationUnitTest\r\t|t|\r\tTranscript show: self prettyPrint; show: \'  \' ;show: self isClause; cr.\r\tt:=self fullClausification.\r\tTranscript show: t prettyPrint; show: \'  \' ;show: t isClause; cr;cr.\r\t^t.',			#stamp : 'pm 10/9/2018 13:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:35.408766+01:00' ],		#prior : OmReference [ '284' ],		#self : OmReference [ '285' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #propUnitTest,			#protocol : #testing,			#sourceCode : 'propUnitTest\r\tTranscript show: self prettyPrint; show: \'  \' ;show: self isClause; cr; cr.\r\t^self',			#stamp : 'pm 10/9/2018 12:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #propUnitTest,			#protocol : #unit-testing,			#sourceCode : 'propUnitTest\r\tTranscript show: self prettyPrint; show: \'  \' ;show: self isClause; cr; cr.\r\t^self',			#stamp : 'pm 10/9/2018 12:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:43.625324+01:00' ],		#prior : OmReference [ '285' ],		#self : OmReference [ '286' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isAtome,			#protocol : #testing-properties,			#sourceCode : 'isAtome\r\t"Class tester"\r\t^false.',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isAtome,			#protocol : #testing,			#sourceCode : 'isAtome\r\t"Class tester"\r\t^false.',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:43.630292+01:00' ],		#prior : OmReference [ '286' ],		#self : OmReference [ '287' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isTrueConst,			#protocol : #testing-properties,			#sourceCode : 'isTrueConst\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 11:08',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isTrueConst,			#protocol : #testing,			#sourceCode : 'isTrueConst\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 11:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:43.635847+01:00' ],		#prior : OmReference [ '287' ],		#self : OmReference [ '288' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isVar,			#protocol : #testing-properties,			#sourceCode : 'isVar\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isVar,			#protocol : #testing,			#sourceCode : 'isVar\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:43.640989+01:00' ],		#prior : OmReference [ '288' ],		#self : OmReference [ '289' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isQuantifier,			#protocol : #testing-properties,			#sourceCode : 'isQuantifier\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isQuantifier,			#protocol : #testing,			#sourceCode : 'isQuantifier\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:43.645806+01:00' ],		#prior : OmReference [ '289' ],		#self : OmReference [ '290' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isExists,			#protocol : #testing-properties,			#sourceCode : 'isExists\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isExists,			#protocol : #testing,			#sourceCode : 'isExists\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:43.650903+01:00' ],		#prior : OmReference [ '290' ],		#self : OmReference [ '291' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isConstant,			#protocol : #testing-properties,			#sourceCode : 'isConstant\r\t"Class tester"\r\t^false.',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isConstant,			#protocol : #testing,			#sourceCode : 'isConstant\r\t"Class tester"\r\t^false.',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:43.655977+01:00' ],		#prior : OmReference [ '291' ],		#self : OmReference [ '292' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isEqual,			#protocol : #testing-properties,			#sourceCode : 'isEqual\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isEqual,			#protocol : #testing,			#sourceCode : 'isEqual\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:43.660347+01:00' ],		#prior : OmReference [ '292' ],		#self : OmReference [ '293' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isConst,			#protocol : #testing-properties,			#sourceCode : 'isConst\r\t"Class tester"\r\t^false.',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isConst,			#protocol : #testing,			#sourceCode : 'isConst\r\t"Class tester"\r\t^false.',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:43.665982+01:00' ],		#prior : OmReference [ '293' ],		#self : OmReference [ '294' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isNotPredicate,			#protocol : #testing-properties,			#sourceCode : 'isNotPredicate\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isNotPredicate,			#protocol : #testing,			#sourceCode : 'isNotPredicate\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:43.671012+01:00' ],		#prior : OmReference [ '294' ],		#self : OmReference [ '295' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isOperator,			#protocol : #testing-properties,			#sourceCode : 'isOperator\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isOperator,			#protocol : #testing,			#sourceCode : 'isOperator\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:43.675284+01:00' ],		#prior : OmReference [ '295' ],		#self : OmReference [ '296' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isImply,			#protocol : #testing-properties,			#sourceCode : 'isImply\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isImply,			#protocol : #testing,			#sourceCode : 'isImply\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:43.680345+01:00' ],		#prior : OmReference [ '296' ],		#self : OmReference [ '297' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isNot,			#protocol : #testing-properties,			#sourceCode : 'isNot\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isNot,			#protocol : #testing,			#sourceCode : 'isNot\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:43.684735+01:00' ],		#prior : OmReference [ '297' ],		#self : OmReference [ '298' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isAnd,			#protocol : #testing-properties,			#sourceCode : 'isAnd\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isAnd,			#protocol : #testing,			#sourceCode : 'isAnd\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:43.689748+01:00' ],		#prior : OmReference [ '298' ],		#self : OmReference [ '299' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isFalseConst,			#protocol : #testing-properties,			#sourceCode : 'isFalseConst\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 11:08',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isFalseConst,			#protocol : #testing,			#sourceCode : 'isFalseConst\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 11:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:43.694734+01:00' ],		#prior : OmReference [ '299' ],		#self : OmReference [ '300' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isBinaryOperator,			#protocol : #testing-properties,			#sourceCode : 'isBinaryOperator\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isBinaryOperator,			#protocol : #testing,			#sourceCode : 'isBinaryOperator\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:43.698961+01:00' ],		#prior : OmReference [ '300' ],		#self : OmReference [ '301' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isPredicate,			#protocol : #testing-properties,			#sourceCode : 'isPredicate\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isPredicate,			#protocol : #testing,			#sourceCode : 'isPredicate\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:43.704064+01:00' ],		#prior : OmReference [ '301' ],		#self : OmReference [ '302' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isNotVar,			#protocol : #testing-properties,			#sourceCode : 'isNotVar\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isNotVar,			#protocol : #testing,			#sourceCode : 'isNotVar\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:43.709725+01:00' ],		#prior : OmReference [ '302' ],		#self : OmReference [ '303' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isProp,			#protocol : #testing-properties,			#sourceCode : 'isProp\r\t"Class tester"\r\t^true.',			#stamp : 'pm 11/27/2018 07:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isProp,			#protocol : #testing,			#sourceCode : 'isProp\r\t"Class tester"\r\t^true.',			#stamp : 'pm 11/27/2018 07:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:43.714027+01:00' ],		#prior : OmReference [ '303' ],		#self : OmReference [ '304' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isOr,			#protocol : #testing-properties,			#sourceCode : 'isOr\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isOr,			#protocol : #testing,			#sourceCode : 'isOr\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:43.719177+01:00' ],		#prior : OmReference [ '304' ],		#self : OmReference [ '305' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #launchRenameVariables,			#protocol : #testing-properties,			#sourceCode : 'launchRenameVariables\r\tself renameVars: Dictionary new with: Dictionary new.',			#stamp : 'pm 12/19/2018 22:42',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #launchRenameVariables,			#protocol : #testing,			#sourceCode : 'launchRenameVariables\r\tself renameVars: Dictionary new with: Dictionary new.',			#stamp : 'pm 12/19/2018 22:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:43.723993+01:00' ],		#prior : OmReference [ '305' ],		#self : OmReference [ '306' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isForAll,			#protocol : #testing-properties,			#sourceCode : 'isForAll\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isForAll,			#protocol : #testing,			#sourceCode : 'isForAll\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:43.728233+01:00' ],		#prior : OmReference [ '306' ],		#self : OmReference [ '307' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isPositivePredicate,			#protocol : #testing-properties,			#sourceCode : 'isPositivePredicate\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isPositivePredicate,			#protocol : #testing,			#sourceCode : 'isPositivePredicate\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:43.733464+01:00' ],		#prior : OmReference [ '307' ],		#self : OmReference [ '308' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isUnaryOperator,			#protocol : #testing-properties,			#sourceCode : 'isUnaryOperator\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isUnaryOperator,			#protocol : #testing,			#sourceCode : 'isUnaryOperator\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:43.738486+01:00' ],		#prior : OmReference [ '308' ],		#self : OmReference [ '309' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isNegativePredicate,			#protocol : #testing-properties,			#sourceCode : 'isNegativePredicate\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isNegativePredicate,			#protocol : #testing,			#sourceCode : 'isNegativePredicate\r\t"Class tester"\r\t^false',			#stamp : 'pm 11/27/2018 07:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:50:51.238464+01:00' ],		#prior : OmReference [ '309' ],		#self : OmReference [ '310' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #launchRenameVariables,			#protocol : #testing,			#sourceCode : 'launchRenameVariables\r\tself renameVars: Dictionary new with: Dictionary new.',			#stamp : 'pm 12/19/2018 22:42',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #launchRenameVariables,			#protocol : #skolemisation,			#sourceCode : 'launchRenameVariables\r\tself renameVars: Dictionary new with: Dictionary new.',			#stamp : 'pm 12/19/2018 22:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:51:16.712221+01:00' ],		#prior : OmReference [ '310' ],		#self : OmReference [ '311' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tresolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\ttreatedProp:=\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp startSkolemisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tresolutionTrace ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/20/2018 12:50',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tresolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\ttreatedProp:=treatedProp launchRenameVariable.\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp startSkolemisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tresolutionTrace ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/20/2018 12:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:51:23.783824+01:00' ],		#prior : OmReference [ '311' ],		#self : OmReference [ '312' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tresolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\ttreatedProp:=treatedProp launchRenameVariable.\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp startSkolemisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tresolutionTrace ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/20/2018 12:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tresolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\ttreatedProp:=treatedProp launchRenameVariables.\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp startSkolemisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tresolutionTrace ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/20/2018 12:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:51:56.123996+01:00' ],		#prior : OmReference [ '312' ],		#self : OmReference [ '313' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see a program trace"\r\r\t"Variable to activate traces or not."\r\tskolemnTrace:=false.\r\tclausificationTrace:=false.\r\tunificationTrace:=false.\r\tresolutionTrace:=false.\r\t\r\t"Used to provided context during the textual tests available in the Prop class "\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/19/2018 20:31',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see a program trace"\r\r\t"Variable to activate traces or not."\r\tskolemnTrace:=false.\r\tclausificationTrace:=false.\r\tunificationTrace:=false.\r\tresolutionTrace:=true.\r\t\r\t"Used to provided context during the textual tests available in the Prop class "\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/20/2018 12:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:54:03.916913+01:00' ],		#prior : OmReference [ '313' ],		#self : OmReference [ '314' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tresolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\ttreatedProp:=treatedProp launchRenameVariables.\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp startSkolemisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tresolutionTrace ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/20/2018 12:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tresolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\ttreatedProp launchRenameVariables.\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp startSkolemisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tresolutionTrace ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/20/2018 12:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:54:54.044101+01:00' ],		#prior : OmReference [ '314' ],		#self : OmReference [ '315' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestGeneral,				#isMetaSide : false			},			#name : #testlaunchRenameVariables,			#protocol : #initialization,			#sourceCode : 'testlaunchRenameVariables \r\t\r\t| initial expected |\r\tinitial:=ForAll new:\'x\' Property:\r \t  (ForAll new:\'x\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x\');\r \t      yourself)\r \t   )\r \t  ).\r\t\r\texpected:=ForAll new:\'x1\' Property:\r \t  (ForAll new:\'x2\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x2\');\r \t      yourself)\r \t   )\r \t  ).\r\tself assert: initial launchRenameVariables equals:expected.\r\t\r\tinitial:=ForAll new:\'x\' Property:\r   (Or new:\r    (ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x\');\r        yourself)\r     )\r    )\r   rightProp:\r    (ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x\');\r        yourself)\r     )\r    )\r   ).\r\r\texpected:=ForAll new:\'x1\' Property:\r   (Or new:\r    (ForAll new:\'x2\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x2\');\r        yourself)\r     )\r    )\r   rightProp:\r    (ForAll new:\'x3\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x3\');\r        yourself)\r     )\r    )\r   ).\t\r\t\r\tself assert: initial launchRenameVariables equals:expected.',			#stamp : 'pm 12/20/2018 12:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:55:05.895179+01:00' ],		#prior : OmReference [ '315' ],		#self : OmReference [ '316' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tresolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\ttreatedProp launchRenameVariables.\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp startSkolemisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tresolutionTrace ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/20/2018 12:54',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tresolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\ttreatedProp launchRenameVariables.\r\tself halt.\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp startSkolemisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tresolutionTrace ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/20/2018 12:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:56:39.655582+01:00' ],		#prior : OmReference [ '316' ],		#self : OmReference [ '317' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestGeneral,				#isMetaSide : false			},			#name : #testLaunchRenameVariables,			#protocol : #initialization,			#sourceCode : 'testLaunchRenameVariables \r\t\r\t| initial expected |\r\tinitial:=ForAll new:\'x\' Property:\r \t  (ForAll new:\'x\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x\');\r \t      yourself)\r \t   )\r \t  ).\r\t\r\texpected:=ForAll new:\'x1\' Property:\r \t  (ForAll new:\'x2\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x2\');\r \t      yourself)\r \t   )\r \t  ).\r\tself assert: initial launchRenameVariables equals:expected.\r\t\r\tinitial:=ForAll new:\'x\' Property:\r   (Or new:\r    (ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x\');\r        yourself)\r     )\r    )\r   rightProp:\r    (ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x\');\r        yourself)\r     )\r    )\r   ).\r\r\texpected:=ForAll new:\'x1\' Property:\r   (Or new:\r    (ForAll new:\'x2\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x2\');\r        yourself)\r     )\r    )\r   rightProp:\r    (ForAll new:\'x3\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x3\');\r        yourself)\r     )\r    )\r   ).\t\r\t\r\tself assert: initial launchRenameVariables equals:expected.',			#stamp : 'pm 12/20/2018 12:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:56:42.842325+01:00' ],		#prior : OmReference [ '317' ],		#self : OmReference [ '318' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestGeneral,				#isMetaSide : false			},			#name : #testlaunchRenameVariables,			#protocol : #initialization,			#sourceCode : 'testlaunchRenameVariables \r\t\r\t| initial expected |\r\tinitial:=ForAll new:\'x\' Property:\r \t  (ForAll new:\'x\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x\');\r \t      yourself)\r \t   )\r \t  ).\r\t\r\texpected:=ForAll new:\'x1\' Property:\r \t  (ForAll new:\'x2\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x2\');\r \t      yourself)\r \t   )\r \t  ).\r\tself assert: initial launchRenameVariables equals:expected.\r\t\r\tinitial:=ForAll new:\'x\' Property:\r   (Or new:\r    (ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x\');\r        yourself)\r     )\r    )\r   rightProp:\r    (ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x\');\r        yourself)\r     )\r    )\r   ).\r\r\texpected:=ForAll new:\'x1\' Property:\r   (Or new:\r    (ForAll new:\'x2\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x2\');\r        yourself)\r     )\r    )\r   rightProp:\r    (ForAll new:\'x3\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x3\');\r        yourself)\r     )\r    )\r   ).\t\r\t\r\tself assert: initial launchRenameVariables equals:expected.',			#stamp : 'pm 12/20/2018 12:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:57:07.867172+01:00' ],		#prior : OmReference [ '318' ],		#self : OmReference [ '319' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestGeneral,				#isMetaSide : false			},			#name : #testRename,			#protocol : #initialization,			#sourceCode : 'testRename\r\t\r\t| initial expected |\r\tinitial:=ForAll new:\'x\' Property:\r \t  (ForAll new:\'x\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x\');\r \t      yourself)\r \t   )\r \t  ).\r\t\r\texpected:=ForAll new:\'x1\' Property:\r \t  (ForAll new:\'x2\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x2\');\r \t      yourself)\r \t   )\r \t  ).\r\tself assert: initial launchRenameVariables equals:expected.\r\t\r\tinitial:=ForAll new:\'x\' Property:\r   (Or new:\r    (ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x\');\r        yourself)\r     )\r    )\r   rightProp:\r    (ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x\');\r        yourself)\r     )\r    )\r   ).\r\r\texpected:=ForAll new:\'x1\' Property:\r   (Or new:\r    (ForAll new:\'x2\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x2\');\r        yourself)\r     )\r    )\r   rightProp:\r    (ForAll new:\'x3\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x3\');\r        yourself)\r     )\r    )\r   ).\t\r\t\r\tself assert: initial launchRenameVariables equals:expected.',			#stamp : 'pm 12/20/2018 12:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T12:59:11.860459+01:00' ],		#prior : OmReference [ '319' ],		#self : OmReference [ '320' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tresolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\ttreatedProp launchRenameVariables.\r\tself halt.\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp startSkolemisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tresolutionTrace ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/20/2018 12:55',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tresolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\ttreatedProp launchRenameVariables.\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp startSkolemisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tresolutionTrace ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/20/2018 12:59',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T13:32:01.397393+01:00' ],		#prior : OmReference [ '320' ],		#self : OmReference [ '321' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tresolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\ttreatedProp launchRenameVariables.\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp startSkolemisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tresolutionTrace ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/20/2018 12:59',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tresolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\ttreatedProp launchRenameVariables.\r\tresolutionTrace ifTrue:[Transcript show: \'renamed: \'; show: treatedProp ; cr.].\r\tt:=treatedProp startSkolemisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tresolutionTrace ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/20/2018 13:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-20T13:32:08.144101+01:00' ],		#prior : OmReference [ '321' ],		#self : OmReference [ '322' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tresolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\ttreatedProp launchRenameVariables.\r\tresolutionTrace ifTrue:[Transcript show: \'renamed: \'; show: treatedProp ; cr.].\r\tt:=treatedProp startSkolemisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tresolutionTrace ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/20/2018 13:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tresolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\tresolutionTrace ifTrue:[Transcript show: \'Initial: \'; show: treatedProp ; cr.].\r\ttreatedProp launchRenameVariables.\r\tresolutionTrace ifTrue:[Transcript show: \'Renamed: \'; show: treatedProp ; cr.].\r\tt:=treatedProp startSkolemisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tresolutionTrace ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/20/2018 13:32',			#package : #_resolution_1erOrdre		}	}}