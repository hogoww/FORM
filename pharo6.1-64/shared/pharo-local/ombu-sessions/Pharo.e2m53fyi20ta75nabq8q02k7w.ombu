OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:10:25.482522+02:00' ],		#prior : OmReference [ 'Pharo.40g5ey2lcsueevljasptmid5r', '39' ],		#self : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified|\r\tmodified:=true.\r\tmodified whileTrue:[\t\t\r\t\tsetOfPairs do:[:each |\r\t\t\t\tmodified:=self tryOperations: each.\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/18/2018 15:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:10:29.266319+02:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #UnifyMe,			#protocol : #unification,			#sourceCode : 'UnifyMe\r\t|modified|\r\tmodified:=true.\r\tmodified whileTrue:[\t\t\r\t\tsetOfPairs do:[:each |\r\t\t\t\tmodified:=self tryOperations: each.\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/18/2018 14:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:10:30.747456+02:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr;cr.\r\t^t',			#stamp : 'pm 10/11/2018 16:42',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr;cr.\r\tt:=Unifier new: t.\r\tt unifyMe.\r\t^t',			#stamp : 'pm 10/18/2018 15:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:13:23.638342+02:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr;cr.\r\tt:=Unifier new: t.\r\tt unifyMe.\r\t^t',			#stamp : 'pm 10/18/2018 15:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr;cr.\r\t^t',			#stamp : 'pm 10/18/2018 15:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:23:51.783298+02:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tt unifyMe.\r\t\t\r\r\t^t',			#stamp : 'pm 10/18/2018 15:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:24:09.073159+02:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tt unifyMe.\r\t\t\r\r\t^t',			#stamp : 'pm 10/18/2018 15:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tt unifyMe.\r\tTranscript show:t.\r\t\t\r\r\t^t',			#stamp : 'pm 10/18/2018 15:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:26:01.826582+02:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t| t |\r\tt:=\'{\'.\r\tsetOfPairs do: [:each| t:=t,each prettyPrint.] separatedBy: [ t:=t,\',\'.]',			#stamp : 'pm 10/15/2018 16:50',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t| t |\r\tt:=\'{\'.\r\tsetOfPairs do: [:each| t:=t,each prettyPrint.] separatedBy: [ t:=t,\',\'.].\r\tt:=t,\'}\'.\r\t^t',			#stamp : 'pm 10/18/2018 15:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:27:41.752257+02:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #prettyPrintUnifier,			#protocol : #printing,			#sourceCode : 'prettyPrintUnifier\r\t^\'(\',(self left prettyPrint),\'=\',(self right prettyPrint),\')\'.',			#stamp : 'pm 10/18/2018 15:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:30:14.837267+02:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tt unifyMe.\r\tTranscript show:t.\r\t\t\r\r\t^t',			#stamp : 'pm 10/18/2018 15:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tt unifyMe.\r\tTranscript show:t.\r\r\t^t',			#stamp : 'pm 10/18/2018 15:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:39:15.5627+02:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing prop related stuff\';cr.\r\t\r\t\r\tl:=Predicate new: \'P\' variable: \'a\'.\r\tr:=Predicate new: \'P\' variable: \'b\'.\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 15:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:39:19.893766+02:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing prop related stuff\';cr.\r\t\r\t\r\tl:=Predicate new: \'P\' variable: \'a\'.\r\tr:=Predicate new: \'P\' variable: \'b\'.\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 15:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing prop related stuff\';cr.\r\t\r\t\r\tl:=Predicate new: \'P\' variable: \'a\'.\r\tr:=Predicate new: \'P\' variable: \'b\'.\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 15:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:40:23.700312+02:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing prop related stuff\';cr.\r\t\r\t\r\tl:=Predicate new: \'P\' variable: \'a\'.\r\tr:=Predicate new: \'P\' variable: \'b\'.\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 15:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing prop related stuff\';cr.\r\t\r\t\r\tl:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tr:=Predicate new: \'P\' variable: (Term new:\'b\').\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 15:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:41:16.92797+02:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing prop related stuff\';cr.\r\t\r\t\r\tl:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tr:=Predicate new: \'P\' variable: (Term new:\'b\').\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 15:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show: \'Basics\';cr.\r\tl:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tr:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tl UnificationUnitTest:r.\r\t\r\tl:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tr:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 15:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:44:43.353987+02:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t| t |\r\tt:=\'{\'.\r\tsetOfPairs do: [:each| t:=t,each prettyPrint.] separatedBy: [ t:=t,\',\'.].\r\tt:=t,\'}\'.\r\t^t',			#stamp : 'pm 10/18/2018 15:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t| t |\r\tt:=\'{\'.\r\tsetOfPairs do: [:each| t:=t,each prettyPrintUnifier.] separatedBy: [ t:=t,\',\'.].\r\tt:=t,\'}\'.\r\t^t',			#stamp : 'pm 10/18/2018 15:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:45:18.023112+02:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: stream\r\tsuper printOn:stream.\r\tstream nextPutAll: (self prettyPrint).',			#stamp : 'pm 10/14/2018 15:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\tsuper printOn:aStream.\r\taStream nextPutAll: (self prettyPrint).',			#stamp : 'pm 10/18/2018 15:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:45:49.511554+02:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tt unifyMe.\r\tTranscript show:t.\r\r\t^t',			#stamp : 'pm 10/18/2018 15:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: (self prettyPrint); show:\' and \';show: otherPredicate.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tt unifyMe.\r\tTranscript show:t.\r\r\t^t',			#stamp : 'pm 10/18/2018 15:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:46:03.902156+02:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\tsuper printOn:aStream.\r\tself prettyPrint.',			#stamp : 'pm 10/15/2018 16:50',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\tsuper printOn:aStream.\r\taStream nextPutAll: (self prettyPrint)',			#stamp : 'pm 10/18/2018 15:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:46:20.752256+02:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\tsuper printOn:aStream.\r\taStream nextPutAll: (self prettyPrint).',			#stamp : 'pm 10/18/2018 15:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\t"super printOn:aStream."\r\taStream nextPutAll: (self prettyPrint).',			#stamp : 'pm 10/18/2018 15:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:46:29.859457+02:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\t"super printOn:aStream."\r\taStream nextPutAll: (self prettyPrint).',			#stamp : 'pm 10/18/2018 15:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\taStream nextPutAll: (self prettyPrint).',			#stamp : 'pm 10/18/2018 15:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:46:39.705615+02:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: (self prettyPrint); show:\' and \';show: otherPredicate.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tt unifyMe.\r\tTranscript show:t.\r\r\t^t',			#stamp : 'pm 10/18/2018 15:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tt unifyMe.\r\tTranscript show:t.\r\r\t^t',			#stamp : 'pm 10/18/2018 15:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:48:10.258688+02:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified|\r\tmodified:=true.\r\tmodified whileTrue:[\t\t\r\t\tsetOfPairs do:[:each |\r\t\t\t\tmodified:=self tryOperations: each.\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/18/2018 15:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified|\r\tmodified:=true.\r\t(modified) whileTrue:[\t\t\r\t\tsetOfPairs do:[:each |\r\t\t\t\tmodified:=self tryOperations: each.\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/18/2018 15:48',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:49:29.067049+02:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified|\r\tmodified:=true.\r\t(modified) whileTrue:[\t\t\r\t\tsetOfPairs do:[:each |\r\t\t\t\tmodified:=self tryOperations: each.\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/18/2018 15:48',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified|\r\tmodified:=true.\r\t(modified and:[false]) whileTrue:[\t\t\r\t\tsetOfPairs do:[:each |\r\t\t\t\tmodified:=self tryOperations: each.\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/18/2018 15:49',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:49:32.054584+02:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified|\r\tmodified:=true.\r\t(modified and:[false]) whileTrue:[\t\t\r\t\tsetOfPairs do:[:each |\r\t\t\t\tmodified:=self tryOperations: each.\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/18/2018 15:49',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified|\r\tmodified:=true.\r\t(modified and:[true]) whileTrue:[\t\t\r\t\tsetOfPairs do:[:each |\r\t\t\t\tmodified:=self tryOperations: each.\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/18/2018 15:49',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:50:35.694548+02:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified|\r\tmodified:=true.\r\t(modified and:[true]) whileTrue:[\t\t\r\t\tsetOfPairs do:[:each |\r\t\t\t\tmodified:=self tryOperations: each.\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/18/2018 15:49',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified|\r\tmodified:=true.\r\tmodified whileTrue:[\t\t\r\t\tsetOfPairs do:[:each |\r\t\t\t\tmodified:=self tryOperations: each.\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/18/2018 15:50',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:51:46.218664+02:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified|\r\tmodified:=true.\r\tmodified whileTrue:[\t\t\r\t\tsetOfPairs do:[:each |\r\t\t\t\tmodified:=self tryOperations: each.\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/18/2018 15:50',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified|\r\tmodified:=true.\r\t[modified] whileTrue:[\t\t\r\t\tsetOfPairs do:[:each |\r\t\t\t\tmodified:=self tryOperations: each.\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/18/2018 15:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:56:40.256731+02:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #arity,			#protocol : #accessing,			#sourceCode : 'arity\r\t^terms size.',			#stamp : 'pm 10/18/2018 15:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T15:57:06.491662+02:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right i|\r\tleft:=aPair left.\r\tright:=aPair right.\r\ti:=0.\r\t(i<(left arity))"arity is the same, as we tested in the caller."\r\twhileTrue:[\r\t\tself add: (Pair left: (left at: i) right: (right at: i)).\r\t\ti:=i+1.\r\t\t].\r\t',			#stamp : 'pm 10/18/2018 09:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right i|\r\tleft:=aPair left.\r\tright:=aPair right.\r\ti:=0.\r\t[i<(left arity)]"arity is the same, as we tested in the caller."\r\twhileTrue:[\r\t\tself add: (Pair left: (left at: i) right: (right at: i)).\r\t\ti:=i+1.\r\t\t].\r\t',			#stamp : 'pm 10/18/2018 15:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:00:37.095548+02:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right i|\r\tleft:=aPair left.\r\tright:=aPair right.\r\ti:=0.\r\t[i<(left arity)]"arity is the same, as we tested in the caller."\r\twhileTrue:[\r\t\tself add: (Pair left: (left at: i) right: (right at: i)).\r\t\ti:=i+1.\r\t\t].\r\t',			#stamp : 'pm 10/18/2018 15:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right i|\r\tleft:=aPair left.\r\tright:=aPair right.\r\ti:=1.\r\t[i<=(left arity)]"arity is the same, as we tested in the caller."\r\twhileTrue:[\r\t\tself add: (Pair left: (left at: i) right: (right at: i)).\r\t\ti:=i+1.\r\t\t].\r\t',			#stamp : 'pm 10/18/2018 16:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:01:02.435733+02:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameArity:',			#protocol : #'as yet unclassified',			#sourceCode : 'isSameArity:anotherFuncTerm\r\t^(self arity)=(anotherFuncTerm arity).',			#stamp : 'pm 10/18/2018 16:01',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:01:02.542342+02:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameArity:',			#protocol : #'as yet unclassified',			#sourceCode : 'isSameArity:anotherFuncTerm\r\t^(self arity)=(anotherFuncTerm arity).',			#stamp : 'pm 10/18/2018 16:01',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameArity:',			#protocol : #testing,			#sourceCode : 'isSameArity:anotherFuncTerm\r\t^(self arity)=(anotherFuncTerm arity).',			#stamp : 'pm 10/18/2018 16:01',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:03:16.811583+02:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameArity:',			#protocol : #testing,			#sourceCode : 'isSameArity:anotherFuncTerm\r\t^(self arity)=(anotherFuncTerm arity).',			#stamp : 'pm 10/18/2018 16:01',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameArity:',			#protocol : #testing,			#sourceCode : 'isSameArity:anotherPredicate\r\t^(self arity)=(anotherPredicate arity).',			#stamp : 'pm 10/18/2018 16:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:03:44.98527+02:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=AnotherPredicate\r\t| res |\r\tres:=AnotherPredicate isKindOf: Predicate."checking the input"\r\tres:=res or:[(self isSameSymb: AnotherPredicate)]."comparing the function symbol"\r\tres:=res or:[self isSameArity: AnotherPredicate]."comparing arity"\r\tres:=res or:[(self isSameTerms: AnotherPredicate).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 10/17/2018 12:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=AnotherPredicate\r\t| res |\r\tres:=AnotherPredicate isKindOf: Predicate."checking the input"\r\tres:=res and:[(self isSameSymb: AnotherPredicate)]."comparing the function symbol"\r\tres:=res and:[self isSameArity: AnotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTerms: AnotherPredicate).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 10/18/2018 16:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:03:56.429652+02:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherFuncTerm\r\t| res |\r\tres:=anotherFuncTerm isKindOf: FuncTerm."checking the input"\r\tres:=res or:[(self isSameSymb: anotherFuncTerm)]."comparing the function symbol"\r\tres:=res or:[self isSameArity: anotherFuncTerm]."comparing arity"\r\tres:=res or:[(self isSameTerms: anotherFuncTerm).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 10/17/2018 12:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherFuncTerm\r\t| res |\r\tres:=anotherFuncTerm isKindOf: FuncTerm."checking the input"\r\tres:=res and:[(self isSameSymb: anotherFuncTerm)]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherFuncTerm]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherFuncTerm).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 10/18/2018 16:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:04:27.249075+02:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tt unifyMe.\r\tTranscript show:t.\r\r\t^t',			#stamp : 'pm 10/18/2018 15:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tt unifyMe.\r\tTranscript show:t;cr.\r\r\t^t',			#stamp : 'pm 10/18/2018 16:04',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:04:56.497534+02:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show: \'Basics\';cr.\r\tl:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tr:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tl UnificationUnitTest:r.\r\t\r\tl:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tr:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 15:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show: \'Basics\';cr.\r\tl:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tr:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tl UnificationUnitTest:r.\r\t\r\tl:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tr:=Predicate new: \'P\' variable: (Term new:\'b\').\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 16:04',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:17:45.18996+02:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified|\r\tmodified:=true.\r\t[modified] whileTrue:[\t\t\r\t\tsetOfPairs do:[:each |\r\t\t\t\tmodified:=self tryOperations: each.\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/18/2018 15:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified OperationAnswer|\r\tmodified:=true.\r\t[modified] whileTrue:[\t\t\r\t\tsetOfPairs do:[:each |\r\t\t\t\tOperationAnswer:=self tryOperations: each.\r\t\t\t\tmodified:=OperationAnswer left."Arbitrary put in left"\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/18/2018 16:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:21:23.224604+02:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[setOfPairs remove:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t\t"FAIRE UN THROW ERROR & CATCH"\r\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isKindOf: FuncTerm )and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[right isConst])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check"\r\t\t\t\t\t(((left isConst) not) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself check: aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^modified.',			#stamp : 'pm 10/18/2018 14:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[setOfPairs remove:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t\tnotPossible:=true.\r\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isKindOf: FuncTerm )and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[right isConst])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t(((left isConst) not) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"notPossible:=true.self check: aPair."\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^modified.',			#stamp : 'pm 10/18/2018 16:21',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:21:54.201587+02:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[setOfPairs remove:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t\tnotPossible:=true.\r\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isKindOf: FuncTerm )and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[right isConst])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t(((left isConst) not) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"notPossible:=true.self check: aPair."\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^modified.',			#stamp : 'pm 10/18/2018 16:21',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[setOfPairs remove:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t\tnotPossible:=true.\r\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isKindOf: FuncTerm )and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[right isConst])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t(((left isConst) not) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"notPossible:=true.self check: aPair."\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^Pair left: modified right: notPossible.',			#stamp : 'pm 10/18/2018 16:21',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:23:52.396459+02:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified OperationAnswer|\r\tmodified:=true.\r\t[modified] whileTrue:[\t\t\r\t\tsetOfPairs do:[:each |\r\t\t\t\tOperationAnswer:=self tryOperations: each.\r\t\t\t\tmodified:=OperationAnswer left."Arbitrary put in left"\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/18/2018 16:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified OperationAnswer|\r\tmodified:=true.\r\t[modified] whileTrue:[\t\t\r\t\tsetOfPairs do:[:each |\r\t\t\t\tOperationAnswer:=self tryOperations: each.\r\t\t\t\tmodified:=OperationAnswer left."Arbitrary put in left"\r\t\t\t\t(OperationAnswer right)"NotPossible to unify?"\r\t\t\t\tifTrue:["On a conflict or a fail check"\r\t\t\t\t\t^nil\r\t\t\t\t\t]."else we go on till we didn\'t do anything more"\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/18/2018 16:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:25:14.070702+02:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right i|\r\tleft:=aPair left.\r\tright:=aPair right.\r\ti:=1.\r\t[i<=(left arity)]"arity is the same, as we tested in the caller."\r\twhileTrue:[\r\t\tself add: (Pair left: (left at: i) right: (right at: i)).\r\t\ti:=i+1.\r\t\t].\r\t',			#stamp : 'pm 10/18/2018 16:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right i|\r\tleft:=aPair left.\r\tright:=aPair right.\r\ti:=1.\r\tsetOfPairs remove: aPair.\r\t[i<=(left arity)]"arity is the same, as we tested in the caller."\r\twhileTrue:[\r\t\tself add: (Pair left: (left at: i) right: (right at: i)).\r\t\ti:=i+1.\r\t\t].\t',			#stamp : 'pm 10/18/2018 16:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:28:39.096327+02:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right i|\r\tleft:=aPair left.\r\tright:=aPair right.\r\ti:=1.\r\tsetOfPairs remove: aPair.\r\t[i<=(left arity)]"arity is the same, as we tested in the caller."\r\twhileTrue:[\r\t\tself add: (Pair left: (left at: i) right: (right at: i)).\r\t\ti:=i+1.\r\t\t].\t',			#stamp : 'pm 10/18/2018 16:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right i|\r\tleft:=aPair left.\r\tright:=aPair right.\r\ti:=1.\r\tTranscript show:aPair;show:\' \';show: self;cr.\r\tsetOfPairs remove: aPair.\r\t[i<=(left arity)]"arity is the same, as we tested in the caller."\r\twhileTrue:[\r\t\tself add: (Pair left: (left at: i) right: (right at: i)).\r\t\ti:=i+1.\r\t\t].\t',			#stamp : 'pm 10/18/2018 16:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:29:33.081328+02:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\taStream nextPutAll: (self prettyPrint)',			#stamp : 'pm 10/18/2018 16:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:31:10.82466+02:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherPair\r\t^(self right)=(anotherPair left) and:[(self right)=(anotherPair right)].',			#stamp : 'pm 10/15/2018 16:42',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherPair\r\t^(self left)=(anotherPair left) and:[(self right)=(anotherPair right)].',			#stamp : 'pm 10/18/2018 16:31',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:31:36.76699+02:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right i|\r\tleft:=aPair left.\r\tright:=aPair right.\r\ti:=1.\r\tTranscript show:aPair;show:\' \';show: self;cr.\r\tsetOfPairs remove: aPair.\r\t[i<=(left arity)]"arity is the same, as we tested in the caller."\r\twhileTrue:[\r\t\tself add: (Pair left: (left at: i) right: (right at: i)).\r\t\ti:=i+1.\r\t\t].\t',			#stamp : 'pm 10/18/2018 16:28',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right i|\r\tleft:=aPair left.\r\tright:=aPair right.\r\ti:=1.\r\t"Transcript show:aPair;show:\' \';show: self;cr."\r\tsetOfPairs remove: aPair.\r\t[i<=(left arity)]"arity is the same, as we tested in the caller."\r\twhileTrue:[\r\t\tself add: (Pair left: (left at: i) right: (right at: i)).\r\t\ti:=i+1.\r\t\t].\t',			#stamp : 'pm 10/18/2018 16:31',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:35:46.479018+02:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right i|\r\tleft:=aPair left.\r\tright:=aPair right.\r\ti:=1.\r\t"Transcript show:aPair;show:\' \';show: self;cr."\r\tsetOfPairs remove: aPair.\r\t[i<=(left arity)]"arity is the same, as we tested in the caller."\r\twhileTrue:[\r\t\tself add: (Pair left: (left at: i) right: (right at: i)).\r\t\ti:=i+1.\r\t\t].\t',			#stamp : 'pm 10/18/2018 16:31',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right i|\r\tleft:=aPair left.\r\tright:=aPair right.\r\ti:=1.\r\tsetOfPairs remove: aPair.\r\t[i<=(left arity)]"arity is the same, as we tested in the caller."\r\twhileTrue:[\r\t\tself add: (Pair left: (left at: i) right: (right at: i)).\r\t\ti:=i+1.\r\t\t].\t',			#stamp : 'pm 10/18/2018 16:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:37:30.70998+02:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show: \'Basics\';cr.\r\tl:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tr:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tl UnificationUnitTest:r.\r\t\r\tl:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tr:=Predicate new: \'P\' variable: (Term new:\'b\').\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 16:04',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tl:=ConstTerm new:\'a\'.\r\tr:=ConstTerm new:\'a\'.\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Basics decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tr:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tl UnificationUnitTest:r.\r\t\r\tl:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tr:=Predicate new: \'P\' variable: (Term new:\'b\').\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 16:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:37:43.564654+02:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tl:=ConstTerm new:\'a\'.\r\tr:=ConstTerm new:\'a\'.\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Basics decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tr:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tl UnificationUnitTest:r.\r\t\r\tl:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tr:=Predicate new: \'P\' variable: (Term new:\'b\').\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 16:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tl:=ConstTerm new:\'a\'.\r\tr:=ConstTerm new:\'a\'.\r\tl UnificationUnitTest:r.\r\t\r\tl:=ConstTerm new:\'a\'.\r\tr:=ConstTerm new:\'b\'.\r\tl UnificationUnitTest:r.\r\r\t\r\tTranscript show: \'Basics decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tr:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tl UnificationUnitTest:r.\r\t\r\tl:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tr:=Predicate new: \'P\' variable: (Term new:\'b\').\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 16:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:38:27.739164+02:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tl:=ConstTerm new:\'a\'.\r\tr:=ConstTerm new:\'a\'.\r\tl UnificationUnitTest:r.\r\t\r\tl:=ConstTerm new:\'a\'.\r\tr:=ConstTerm new:\'b\'.\r\tl UnificationUnitTest:r.\r\r\t\r\tTranscript show: \'Basics decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tr:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tl UnificationUnitTest:r.\r\t\r\tl:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tr:=Predicate new: \'P\' variable: (Term new:\'b\').\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 16:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tl:=ConstTerm new:(Term new:\'a\').\r\tr:=ConstTerm new:(Term new:\'a\').\r\tl UnificationUnitTest:r.\r\t\r\tl:=ConstTerm new:(Term new:\'a\').\r\tr:=ConstTerm new:(Term new:\'b\').\r\tl UnificationUnitTest:r.\r\r\t\r\tTranscript show: \'Basics decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tr:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tl UnificationUnitTest:r.\r\t\r\tl:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tr:=Predicate new: \'P\' variable: (Term new:\'b\').\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 16:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:40:18.357109+02:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tl:=ConstTerm new:(Term new:\'a\').\r\tr:=ConstTerm new:(Term new:\'a\').\r\tl UnificationUnitTest:r.\r\t\r\tl:=ConstTerm new:(Term new:\'a\').\r\tr:=ConstTerm new:(Term new:\'b\').\r\tl UnificationUnitTest:r.\r\r\t\r\tTranscript show: \'Basics decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tr:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tl UnificationUnitTest:r.\r\t\r\tl:=Predicate new: \'P\' variable: (Term new:\'a\').\r\tr:=Predicate new: \'P\' variable: (Term new:\'b\').\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 16:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tl:=ConstTerm new:(Term new:\'a\').\r\tr:=ConstTerm new:(Term new:\'a\').\r\tl UnificationUnitTest:r.\r\t\r\tl:=ConstTerm new:(Term new:\'a\').\r\tr:=ConstTerm new:(Term new:\'b\').\r\tl UnificationUnitTest:r.\r\r\t\r\tTranscript show: \'Basics decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 16:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:40:40.554068+02:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tl:=ConstTerm new:(Term new:\'a\').\r\tr:=ConstTerm new:(Term new:\'a\').\r\tl UnificationUnitTest:r.\r\t\r\tl:=ConstTerm new:(Term new:\'a\').\r\tr:=ConstTerm new:(Term new:\'b\').\r\tl UnificationUnitTest:r.\r\r\t\r\tTranscript show: \'Basics decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 16:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tl:=ConstTerm new:(Term new:\'a\').\r\tr:=ConstTerm new:(Term new:\'a\').\r\tl UnificationUnitTest:r.\r\t\r\tl:=ConstTerm new:(Term new:\'a\').\r\tr:=ConstTerm new:(Term new:\'b\').\r\tl UnificationUnitTest:r.\r\r\t\r\tTranscript show: \'Basics decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 16:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:40:50.762724+02:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tl:=ConstTerm new:(Term new:\'a\').\r\tr:=ConstTerm new:(Term new:\'a\').\r\tl UnificationUnitTest:r.\r\t\r\tl:=ConstTerm new:(Term new:\'a\').\r\tr:=ConstTerm new:(Term new:\'b\').\r\tl UnificationUnitTest:r.\r\r\t\r\tTranscript show: \'Basics decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 16:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show: \'Basics decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 16:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:42:13.300169+02:00' ],		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'initialize:Variable:',			#protocol : #initialization,			#sourceCode : 'initialize: symbl Variable: aTerm\r\t(aTerm isKindOf: Term)\r\tifFalse:[Error new:\'Predicates needs terms as arguments.\'].\r\tsymb:=symbl.\r\tterms:=LinkedList new.\r\tterms add:aTerm.\r',			#stamp : 'pm 10/9/2018 11:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'initialize:Variable:',			#protocol : #initialization,			#sourceCode : 'initialize: symbl Variable: aTerm\r\t(aTerm isKindOf: AbstractTerm)\r\tifFalse:[Error new:\'Predicates needs terms as arguments.\'].\r\tsymb:=symbl.\r\tterms:=LinkedList new.\r\tterms add:aTerm.\r',			#stamp : 'pm 10/18/2018 16:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:43:57.805211+02:00' ],		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'initialize:Variables:',			#protocol : #initialization,			#sourceCode : 'initialize: symbl Variables: aLinkedListOfTerm\r\tsymb:=symbl.\r\tterms:=aLinkedListOfTerm.',			#stamp : 'pm 10/8/2018 17:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'initialize:Variables:',			#protocol : #initialization,			#sourceCode : 'initialize: symbl Variables: aLinkedListOfTerm\r\tsymb:=symbl.\r\t\r\t\r\t\r\taLinkedListOfTerm do:[:each| \r\t\t(each isKindOf: AbstractTerm)\r\t\tifFalse:[Error new:\'Predicates needs terms as arguments.\'].\r\t\t].\r\tterms:=aLinkedListOfTerm.',			#stamp : 'pm 10/18/2018 16:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:44:13.228606+02:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'initialize:Variables:',			#protocol : #initialization,			#sourceCode : 'initialize: symbl Variables: aLinkedListOfTerm\r\tsymb:=symbl.\r\t\r\t\r\t\r\taLinkedListOfTerm do:[:each| \r\t\t(each isKindOf: AbstractTerm)\r\t\tifFalse:[Error new:\'Predicates needs terms as arguments.\'].\r\t\t].\r\tterms:=aLinkedListOfTerm.',			#stamp : 'pm 10/18/2018 16:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'initialize:Variables:',			#protocol : #initialization,			#sourceCode : 'initialize: symbl Variables: aLinkedListOfTerm\r\tsymb:=symbl.\r\t\r\taLinkedListOfTerm do:[:each| \r\t\t(each isKindOf: AbstractTerm)\r\t\tifFalse:[Error new:\'Predicates needs terms as arguments.\'].\r\t\t].\r\tterms:=aLinkedListOfTerm.',			#stamp : 'pm 10/18/2018 16:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:44:20.748998+02:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'initialize:Variables:',			#protocol : #initialization,			#sourceCode : 'initialize: symbl Variables: aLinkedListOfTerm\r\tsymb:=symbl.\r\t\r\taLinkedListOfTerm do:[:each| \r\t\t(each isKindOf: AbstractTerm)\r\t\tifFalse:[Error new:\'Predicates needs terms as arguments.\'].\r\t\t].\r\tterms:=aLinkedListOfTerm.',			#stamp : 'pm 10/18/2018 16:44',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'initialize:Variables:',			#protocol : #initialization,			#sourceCode : 'initialize: symbl Variables: aLinkedListOfTerm\r\tsymb:=symbl.\r\taLinkedListOfTerm do:[:each| \r\t\t(each isKindOf: AbstractTerm)\r\t\tifFalse:[Error new:\'Predicates needs terms as arguments.\'].\r\t\t].\r\tterms:=aLinkedListOfTerm.',			#stamp : 'pm 10/18/2018 16:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:54:50.242822+02:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified OperationAnswer|\r\tmodified:=true.\r\t[modified] whileTrue:[\t\t\r\t\tsetOfPairs do:[:each |\r\t\t\t\tOperationAnswer:=self tryOperations: each.\r\t\t\t\tmodified:=OperationAnswer left."Arbitrary put in left"\r\t\t\t\t(OperationAnswer right)"NotPossible to unify?"\r\t\t\t\tifTrue:["On a conflict or a fail check"\r\t\t\t\t\t^nil\r\t\t\t\t\t]."else we go on till we didn\'t do anything more"\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/18/2018 16:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified OperationAnswer|\r\tmodified:=true.\r\t[modified] whileTrue:[\t\t\r\t\tsetOfPairs do:[:each |\r\t\t\t\tOperationAnswer:=self tryOperations: each.\r\t\t\t\t(OperationAnswer right)"NotPossible to unify?"\r\t\t\t\tifTrue:["On a conflict or a fail check"\r\t\t\t\t\t^nil\r\t\t\t\t\t]."else we go on till we didn\'t do anything more"\r\t\t\t\tmodified:=OperationAnswer left."Arbitrary put in left"\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/18/2018 16:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:57:49.031613+02:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified OperationAnswer|\r\tmodified:=true.\r\t[modified] whileTrue:[\t\t\r\t\tsetOfPairs do:[:each |\r\t\t\t\tOperationAnswer:=self tryOperations: each.\r\t\t\t\t(OperationAnswer right)"NotPossible to unify?"\r\t\t\t\tifTrue:["On a conflict or a fail check"\r\t\t\t\t\t^nil\r\t\t\t\t\t]."else we go on till we didn\'t do anything more"\r\t\t\t\tmodified:=OperationAnswer left."Arbitrary put in left"\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/18/2018 16:54',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified OperationAnswer|\r\tmodified:=true.\r\t[modified] whileTrue:[\r\t\tmodified:=false\r\t\tsetOfPairs do:[:each |\r\t\t\t\tOperationAnswer:=self tryOperations: each.\r\t\t\t\t(OperationAnswer right)"NotPossible to unify?"\r\t\t\t\tifTrue:["On a conflict or a fail check"\r\t\t\t\t\t^nil\r\t\t\t\t\t]."else we go on till we didn\'t do anything more"\r\t\t\t\tmodified:=modified or:[OperationAnswer left.]."Arbitrary put in left"\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/18/2018 16:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T16:59:48.841933+02:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified OperationAnswer|\r\tmodified:=true.\r\t[modified] whileTrue:[\r\t\tmodified:=false\r\t\tsetOfPairs do:[:each |\r\t\t\t\tOperationAnswer:=self tryOperations: each.\r\t\t\t\t(OperationAnswer right)"NotPossible to unify?"\r\t\t\t\tifTrue:["On a conflict or a fail check"\r\t\t\t\t\t^nil\r\t\t\t\t\t]."else we go on till we didn\'t do anything more"\r\t\t\t\tmodified:=modified or:[OperationAnswer left.]."Arbitrary put in left"\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/18/2018 16:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified OperationAnswer|\r\tmodified:=true.\r\t[modified] whileTrue:[\r\t\tmodified:=false.\r\t\tsetOfPairs do:[:each |\r\t\t\t\tOperationAnswer:=self tryOperations: each.\r\t\t\t\t(OperationAnswer right)"NotPossible to unify?"\r\t\t\t\tifTrue:["On a conflict or a fail check"\r\t\t\t\t\t^nil\r\t\t\t\t\t]."else we go on till we didn\'t do anything more"\r\t\t\t\tmodified:=modified or:[OperationAnswer left.]."Arbitrary put in left"\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/18/2018 16:59',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T17:03:57.281897+02:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show: \'Basics decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 16:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show: \'Basics decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 17:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T17:04:45.328169+02:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified OperationAnswer|\r\tmodified:=true.\r\t[modified] whileTrue:[\r\t\tmodified:=false.\r\t\tsetOfPairs do:[:each |\r\t\t\t\tOperationAnswer:=self tryOperations: each.\r\t\t\t\t(OperationAnswer right)"NotPossible to unify?"\r\t\t\t\tifTrue:["On a conflict or a fail check"\r\t\t\t\t\t^nil\r\t\t\t\t\t]."else we go on till we didn\'t do anything more"\r\t\t\t\tmodified:=modified or:[OperationAnswer left.]."Arbitrary put in left"\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/18/2018 16:59',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified OperationAnswer|\r\tmodified:=true.\r\t[modified] whileTrue:[\r\t\tmodified:=false.\r\t\tsetOfPairs do:[:each |\r\t\t\t\tOperationAnswer:=self tryOperations: each.\r\t\t\t\t(OperationAnswer right)"NotPossible to unify?"\r\t\t\t\tifTrue:["On a conflict or a fail check"\r\t\t\t\t\t^nil\r\t\t\t\t\t]."else we go on till we didn\'t do anything more"\r\t\t\t\tmodified:=modified or:[OperationAnswer left.]."Arbitrary put in left"\r\t\t\t]\r\t\t].\r\t^setOfPairs.\r\t',			#stamp : 'pm 10/18/2018 17:04',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T17:06:25.409166+02:00' ],		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tt unifyMe.\r\tTranscript show:t;cr.\r\r\t^t',			#stamp : 'pm 10/18/2018 16:04',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tt unifyMe.\r\tTranscript show:t;cr.\r\t^t',			#stamp : 'pm 10/18/2018 17:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T17:07:25.276029+02:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified OperationAnswer|\r\tmodified:=true.\r\t[modified] whileTrue:[\r\t\tmodified:=false.\r\t\tsetOfPairs do:[:each |\r\t\t\t\tOperationAnswer:=self tryOperations: each.\r\t\t\t\t(OperationAnswer right)"NotPossible to unify?"\r\t\t\t\tifTrue:["On a conflict or a fail check"\r\t\t\t\t\t^nil\r\t\t\t\t\t]."else we go on till we didn\'t do anything more"\r\t\t\t\tmodified:=modified or:[OperationAnswer left.]."Arbitrary put in left"\r\t\t\t]\r\t\t].\r\t^setOfPairs.\r\t',			#stamp : 'pm 10/18/2018 17:04',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified OperationAnswer|\r\tmodified:=true.\r\t[modified] whileTrue:[\r\t\tmodified:=false.\r\t\tsetOfPairs do:[:each |\r\t\t\t\tOperationAnswer:=self tryOperations: each.\r\t\t\t\t(OperationAnswer right)"NotPossible to unify?"\r\t\t\t\tifTrue:["On a conflict or a fail check"\r\t\t\t\t\tTranscript show:\'Unification impossible\'."TEMPORARY"\r\t\t\t\t\t^nil.\r\t\t\t\t\t]."else we go on till we didn\'t do anything more"\r\t\t\t\tmodified:=modified or:[OperationAnswer left.]."Arbitrary put in left"\r\t\t\t]\r\t\t].\r\t^setOfPairs.\r\t',			#stamp : 'pm 10/18/2018 17:07',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T17:07:34.188415+02:00' ],		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified OperationAnswer|\r\tmodified:=true.\r\t[modified] whileTrue:[\r\t\tmodified:=false.\r\t\tsetOfPairs do:[:each |\r\t\t\t\tOperationAnswer:=self tryOperations: each.\r\t\t\t\t(OperationAnswer right)"NotPossible to unify?"\r\t\t\t\tifTrue:["On a conflict or a fail check"\r\t\t\t\t\tTranscript show:\'Unification impossible\'."TEMPORARY"\r\t\t\t\t\t^nil.\r\t\t\t\t\t]."else we go on till we didn\'t do anything more"\r\t\t\t\tmodified:=modified or:[OperationAnswer left.]."Arbitrary put in left"\r\t\t\t]\r\t\t].\r\t^setOfPairs.\r\t',			#stamp : 'pm 10/18/2018 17:07',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified OperationAnswer|\r\tmodified:=true.\r\t[modified] whileTrue:[\r\t\tmodified:=false.\r\t\tsetOfPairs do:[:each |\r\t\t\t\tOperationAnswer:=self tryOperations: each.\r\t\t\t\t(OperationAnswer right)"NotPossible to unify?"\r\t\t\t\tifTrue:["On a conflict or a fail check"\r\t\t\t\t\tTranscript show:\'Unification impossible\';cr."TEMPORARY"\r\t\t\t\t\t^nil.\r\t\t\t\t\t]."else we go on till we didn\'t do anything more"\r\t\t\t\tmodified:=modified or:[OperationAnswer left.]."Arbitrary put in left"\r\t\t\t]\r\t\t].\r\t^setOfPairs.\r\t',			#stamp : 'pm 10/18/2018 17:07',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T17:13:38.400703+02:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show: \'Basics decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 17:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'Conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 17:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T17:13:42.031912+02:00' ],		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'Conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 17:13',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 17:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T17:13:50.673467+02:00' ],		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tt unifyMe.\r\tTranscript show:t;cr.\r\t^t',			#stamp : 'pm 10/18/2018 17:06',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tt unifyMe.\r\tTranscript show:t;cr;cr.\r\t^t',			#stamp : 'pm 10/18/2018 17:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T17:17:17.343+02:00' ],		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 17:13',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new:(ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 17:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T17:17:55.854651+02:00' ],		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'swap:',			#protocol : #unification,			#sourceCode : 'swap: aPair\r\t|left right|\r\tleft:=aPair left.\r\tright:=aPair right.\r\t(self setOfPairs) remove:aPair.\r\tself add: Pair left: right right: left.\r\t',			#stamp : 'pm 10/18/2018 09:05',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'swap:',			#protocol : #unification,			#sourceCode : 'swap: aPair\r\t|left right|\r\tleft:=aPair left.\r\tright:=aPair right.\r\tsetOfPairs remove:aPair.\r\tself add: Pair left: right right: left.\r\t',			#stamp : 'pm 10/18/2018 17:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T17:20:34.579249+02:00' ],		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: stream\r\tsuper printOn:stream.\r\tstream nextPutAll: (self prettyPrint).',			#stamp : 'pm 10/14/2018 15:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: stream\r\tstream nextPutAll: (self prettyPrint).',			#stamp : 'pm 10/18/2018 17:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T17:23:24.83099+02:00' ],		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\tsuper printOn:aStream.\r\taStream nextPutAll: (self prettyPrint)',			#stamp : 'pm 10/18/2018 15:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\taStream nextPutAll: (self prettyPrint)',			#stamp : 'pm 10/18/2018 17:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T17:37:48.609454+02:00' ],		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new:(ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 17:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tTranscript show:l;cr.\r\tTranscript show:r;cr.\r\t\r\tl:=Predicate new: \'P\' variable: (FuncTerm new:(ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 17:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T17:38:17.176122+02:00' ],		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tTranscript show:l;cr.\r\tTranscript show:r;cr.\r\t\r\tl:=Predicate new: \'P\' variable: (FuncTerm new:(ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 17:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| l r|\r\t\r\tTranscript clear.\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tTranscript show:l;cr.\r\tTranscript show:r;cr.\r\t\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 17:38',			#package : #_resolution_1erOrdre		}	}}