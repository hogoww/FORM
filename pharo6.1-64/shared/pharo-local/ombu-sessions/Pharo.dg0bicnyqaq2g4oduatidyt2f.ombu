OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T11:06:31.190078+02:00' ],		#prior : OmReference [ 'Pharo.2y4okq0agqg9z8x9ta2e7xq2w', '66' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl UnificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\t\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'x\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/20/2018 10:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl UnificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\t\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\r\t\r\t"should replace x by y at the end of the unification"\r\t"Transcript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'x\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r."\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/20/2018 11:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T11:49:51.883425+02:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl UnificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\t\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\r\t\r\t"should replace x by y at the end of the unification"\r\t"Transcript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'x\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r."\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/20/2018 11:06',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl UnificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\t\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\r\t\r\t\r\t"should replace x by y at the end of the unification"\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'x\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/20/2018 11:49',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T11:52:36.538419+02:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl UnificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\t\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\r\t\r\t\r\t"should replace x by y at the end of the unification"\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'x\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/20/2018 11:49',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl UnificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\t\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\r\t\r\t\r\t"should replace x by y at the end of the unification"\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/20/2018 11:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T12:29:59.290124+02:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl UnificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\t\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\r\t\r\t\r\t"should replace x by y at the end of the unification"\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/20/2018 11:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl unificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\t\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t\r\t"should replace x by y at the end of the unification"\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/20/2018 12:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T12:30:08.847823+02:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'unificationUnitTest:',			#protocol : #testing,			#sourceCode : 'unificationUnitTest: otherPredicate\r\t|t newPair|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tnewPair:=t unifyThis.\r\t(t hasFailed)\r\tifFalse:[\r\t\tTranscript show:newPair;cr;cr.\r\t]\r\tifTrue:[\r\t\tTranscript show: \'Unification failed.\';cr;cr.\r\t\t].\r\t^t',			#stamp : 'pm 10/20/2018 12:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T12:30:12.550505+02:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t newPair|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tnewPair:=t unifyThis.\r\t(t hasFailed)\r\tifFalse:[\r\t\tTranscript show:newPair;cr;cr.\r\t]\r\tifTrue:[\r\t\tTranscript show: \'Unification failed.\';cr;cr.\r\t\t].\r\t^t',			#stamp : 'pm 10/20/2018 09:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T14:37:49.427806+02:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl unificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\t\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t\r\t"should replace x by y at the end of the unification"\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/20/2018 12:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl unificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\t\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t\r\t"should replace x by y at the end of the unification"\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:( LinkedTerm new:(Term new:\'x\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/20/2018 14:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T14:51:09.954733+02:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t(term = x term)\r\tifTrue:[term:=t.]',			#stamp : 'pm 10/19/2018 18:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t^self error:\'shouldn\'\'t be able to get here\'.\r\t"(term = x term)\r\tifTrue:[term:=t.]"',			#stamp : 'pm 10/20/2018 14:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T15:34:44.80316+02:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right previousSet newSet |\r\t\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'eliminate\';cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\t\r\tpreviousSet:=setOfPairs veryDeepCopy."we need to work on a copy, to avoid having another iteration"\r\tpreviousSet remove:aPair.\r\t\r\tpreviousSet do:[:each |\r\t\t"tempVar:=each veryDeepCopy.""since we modify the underlying data, we work on a copy"\r\t\tnewSet add:(Pair left: ((each left) replace: left by:right)\r\t\t\t\t\t\t\t\tright:((each right) replace:left by:right)).].\r\t(previousSet = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r',			#stamp : 'pm 10/19/2018 17:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right previousSet newSet |\r\t\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'eliminate\';cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\t\r\tpreviousSet:=setOfPairs veryDeepCopy."we need to work on a copy, to avoid having another iteration"\r\tpreviousSet remove:aPair.\r\t\r\tpreviousSet do:[:each |\r\t\t"tempVar:=each veryDeepCopy.""since we modify the underlying data, we work on a copy"\r\t\tnewSet add:\r\t\t\r\t\t\r\t\t\t\t\t\t(Pair left: ((each left) replace: left by:right)\r\t\t\t\t\t\t\t\tright:((each right) replace:left by:right)).].\r\t(previousSet = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r',			#stamp : 'pm 10/20/2018 15:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T15:40:10.68707+02:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacementPair:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacementPair:each replaced:left by:right\r\t\r\t"(Pair left: ((each left) replace: left by:right)\r\tright:((each right) replace:left by:right)).]."',			#stamp : 'pm 10/20/2018 15:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T15:40:14.355153+02:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right previousSet newSet |\r\t\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'eliminate\';cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\t\r\tpreviousSet:=setOfPairs veryDeepCopy."we need to work on a copy, to avoid having another iteration"\r\tpreviousSet remove:aPair.\r\t\r\tpreviousSet do:[:each |\r\t\t"tempVar:=each veryDeepCopy.""since we modify the underlying data, we work on a copy"\r\t\tnewSet add:\r\t\t\r\t\t\r\t\t\t\t\t\t(Pair left: ((each left) replace: left by:right)\r\t\t\t\t\t\t\t\tright:((each right) replace:left by:right)).].\r\t(previousSet = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r',			#stamp : 'pm 10/20/2018 15:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right previousSet newSet |\r\t\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'eliminate\';cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\t\r\tpreviousSet:=setOfPairs veryDeepCopy."we need to work on a copy, to avoid having another iteration"\r\tpreviousSet remove:aPair.\r\t\r\tpreviousSet do:[:each |\r\t\t"tempVar:=each veryDeepCopy.""since we modify the underlying data, we work on a copy"\r\t\tnewSet add: (self replacementPair:each replaced:left by:right).\r\t\t\r\t\t\r\t\t\t\t\t\t(Pair left: ((each left) replace: left by:right)\r\t\t\t\t\t\t\t\tright:((each right) replace:left by:right)).].\r\t(previousSet = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r ',			#stamp : 'pm 10/20/2018 15:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T15:42:06.13729+02:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacementPair:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacementPair:each replaced:left by:right\r\t\r\t"(Pair left: ((each left) replace: left by:right)\r\tright:((each right) replace:left by:right)).]."',			#stamp : 'pm 10/20/2018 15:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacementPair:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacementPair:aPair replaced:left by:right\r\taPair left\r\t"(Pair left: ((each left) replace: left by:right)\r\tright:((each right) replace:left by:right)).]."',			#stamp : 'pm 10/20/2018 15:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T15:42:11.60203+02:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right previousSet newSet |\r\t\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'eliminate\';cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\t\r\tpreviousSet:=setOfPairs veryDeepCopy."we need to work on a copy, to avoid having another iteration"\r\tpreviousSet remove:aPair.\r\t\r\tpreviousSet do:[:each |\r\t\t"tempVar:=each veryDeepCopy.""since we modify the underlying data, we work on a copy"\r\t\tnewSet add: (self replacementPair:each replaced:left by:right).\r\t\t\r\t\t\r\t\t\t\t\t\t(Pair left: ((each left) replace: left by:right)\r\t\t\t\t\t\t\t\tright:((each right) replace:left by:right)).].\r\t(previousSet = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r ',			#stamp : 'pm 10/20/2018 15:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right previousSet newSet |\r\t\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'eliminate\';cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\t\r\tpreviousSet:=setOfPairs veryDeepCopy."we need to work on a copy, to avoid having another iteration"\r\tpreviousSet remove:aPair.\r\t\r\tpreviousSet do:[:each |\r\t\t"tempVar:=each veryDeepCopy.""since we modify the underlying data, we work on a copy"\r\t\tnewSet add: (self replacementPair:each replaced:left by:right).\r\t\t].\r\t(previousSet = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r ',			#stamp : 'pm 10/20/2018 15:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T15:43:25.161622+02:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacement:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacement:aTerm replaced:left by:right\r\t\r\t\r ',			#stamp : 'pm 10/20/2018 15:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T15:47:27.58821+02:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacementPair:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacementPair:aPair replaced:left by:right\r\taPair left\r\t"(Pair left: ((each left) replace: left by:right)\r\tright:((each right) replace:left by:right)).]."',			#stamp : 'pm 10/20/2018 15:42',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacementPair:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacementPair:aPair replaced:left by:right\r\tPair left:(self replacement: (aPair left) replaced:left by:right)\r\t\t  right:(self replacement: (aPair right) replaced:left by:right)\r',			#stamp : 'pm 10/20/2018 15:47',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T15:47:59.204244+02:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacement:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacement:aTerm replaced:left by:right\r\t\r\t\r ',			#stamp : 'pm 10/20/2018 15:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacement:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacement:aTerm replaced:left by:right\r\t(aTerm=left)\r\tifTrue:[right]\r\tifFalse:[aTerm].\r\t\r ',			#stamp : 'pm 10/20/2018 15:47',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T15:57:01.320975+02:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacement:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacement:aTerm replaced:left by:right\r\t(aTerm=left)\r\tifTrue:[right]\r\tifFalse:[aTerm].\r\t\r ',			#stamp : 'pm 10/20/2018 15:47',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacement:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacement:aTerm replaced:left by:right\r\t(aTerm isKindOf: FuncTerm)\r\tifTrue:[\r\t\t^aTerm replace:left by:right.\r\t\t]\r\tifFalse:[\r\t\t(aTerm=left)\r\t\tifTrue:[right]\r\t\tifFalse:[aTerm].\r\t\t]\r ',			#stamp : 'pm 10/20/2018 15:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T16:29:21.056518+02:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacement:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacement:aTerm replaced:left by:right\r\t(aTerm isKindOf: FuncTerm)\r\tifTrue:[\r\t\t^aTerm replace:left by:right.\r\t\t]\r\tifFalse:[\r\t\t(aTerm=left)\r\t\tifTrue:[right]\r\t\tifFalse:[aTerm].\r\t\t]\r ',			#stamp : 'pm 10/20/2018 15:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacement:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacement:aTerm replaced:left by:right\r\t(aTerm isKindOf: FuncTerm)\r\tifTrue:[\r\t\t^aTerm replace:left by:right.\r\t\t]"if it\'s something else than a functerm, "\r\tifFalse:[\r\t\t(aTerm=left)\r\t\tifTrue:[^right]\r\t\tifFalse:[^aTerm].\r\t\t].\r ',			#stamp : 'pm 10/20/2018 16:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T16:46:03.599085+02:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right previousSet newSet |\r\t\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'eliminate\';cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\t\r\tpreviousSet:=setOfPairs veryDeepCopy."we need to work on a copy, to avoid having another iteration"\r\tpreviousSet remove:aPair.\r\t\r\tpreviousSet do:[:each |\r\t\t"tempVar:=each veryDeepCopy.""since we modify the underlying data, we work on a copy"\r\t\tnewSet add: (self replacementPair:each replaced:left by:right).\r\t\t].\r\t(previousSet = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r ',			#stamp : 'pm 10/20/2018 15:42',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right previousSet newSet |\r\t\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'eliminate\';cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\t\r\tpreviousSet:=setOfPairs veryDeepCopy."we need to work on a copy, to avoid having another iteration"\r\tpreviousSet remove:aPair.\r\t\r\tTranscript cr;cr;show: setOfPairs class;show:\' \';  show:previousSet class;show:\' \'; show: newSet class;cr;cr.\r\tpreviousSet do:[:each |\r\t\t"tempVar:=each veryDeepCopy.""since we modify the underlying data, we work on a copy"\r\t\tnewSet add: (self replacementPair:each replaced:left by:right).\r\t\t].\r\t(previousSet = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r ',			#stamp : 'pm 10/20/2018 16:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T16:50:41.178514+02:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right previousSet newSet |\r\t\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'eliminate\';cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\t\r\tpreviousSet:=setOfPairs veryDeepCopy."we need to work on a copy, to avoid having another iteration"\r\tpreviousSet remove:aPair.\r\t\r\tTranscript cr;cr;show: setOfPairs class;show:\' \';  show:previousSet class;show:\' \'; show: newSet class;cr;cr.\r\tpreviousSet do:[:each |\r\t\t"tempVar:=each veryDeepCopy.""since we modify the underlying data, we work on a copy"\r\t\tnewSet add: (self replacementPair:each replaced:left by:right).\r\t\t].\r\t(previousSet = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r ',			#stamp : 'pm 10/20/2018 16:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right previousSet newSet |\r\t\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'eliminate\';cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\t\r\tpreviousSet:=setOfPairs veryDeepCopy."we need to work on a copy, to avoid having another iteration"\r\tpreviousSet remove:aPair.\r\t\r\t"Transcript cr;cr;show: setOfPairs class;show:\' \';  show:previousSet class;show:\' \'; show: newSet class;cr;cr."\r\tpreviousSet do:[:each |\r\t\t"tempVar:=each veryDeepCopy.""since we modify the underlying data, we work on a copy"\r\t\tnewSet add: (self replacementPair:each replaced:left by:right).\r\t\t].\r\t(previousSet = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r ',			#stamp : 'pm 10/20/2018 16:50',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T16:52:56.301705+02:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacementPair:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacementPair:aPair replaced:left by:right\r\tPair left:(self replacement: (aPair left) replaced:left by:right)\r\t\t  right:(self replacement: (aPair right) replaced:left by:right)\r',			#stamp : 'pm 10/20/2018 15:47',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacementPair:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacementPair:aPair replaced:left by:right\r\t^Pair left:(self replacement: (aPair left) replaced:left by:right)\r\t\t  right:(self replacement: (aPair right) replaced:left by:right)\r',			#stamp : 'pm 10/20/2018 16:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T16:58:15.516516+02:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tdebug:=false.\r\tdebugUnification:=false.\r\ttestNumber:=0.',			#stamp : 'pm 10/19/2018 17:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tdebug:=false.\r\tdebugUnification:=true.\r\ttestNumber:=0.',			#stamp : 'pm 10/20/2018 16:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T17:00:36.737881+02:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right previousSet newSet |\r\t\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'eliminate\';cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\t\r\tpreviousSet:=setOfPairs veryDeepCopy."we need to work on a copy, to avoid having another iteration"\r\tpreviousSet remove:aPair.\r\t\r\t"Transcript cr;cr;show: setOfPairs class;show:\' \';  show:previousSet class;show:\' \'; show: newSet class;cr;cr."\r\tpreviousSet do:[:each |\r\t\t"tempVar:=each veryDeepCopy.""since we modify the underlying data, we work on a copy"\r\t\tnewSet add: (self replacementPair:each replaced:left by:right).\r\t\t].\r\t(previousSet = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r ',			#stamp : 'pm 10/20/2018 16:50',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right previousSet newSet |\r\t\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'eliminate\';cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\t\r\tpreviousSet:=setOfPairs veryDeepCopy."we need to work on a copy, to avoid having another iteration"\r\tpreviousSet remove:aPair.\r\t\r\tpreviousSet do:[:each |\r\t\t"tempVar:=each veryDeepCopy.""since we modify the underlying data, we work on a copy"\r\t\tnewSet add: (self replacementPair:each replaced:left by:right).\r\t\t].\r\t(previousSet = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r ',			#stamp : 'pm 10/20/2018 17:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T17:10:45.234348+02:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right previousSet newSet |\r\t\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'eliminate\';cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\t\r\tpreviousSet:=setOfPairs veryDeepCopy."we need to work on a copy, to avoid having another iteration"\r\tpreviousSet remove:aPair.\r\t\r\tpreviousSet do:[:each |\r\t\t"tempVar:=each veryDeepCopy.""since we modify the underlying data, we work on a copy"\r\t\tnewSet add: (self replacementPair:each replaced:left by:right).\r\t\t].\r\t(previousSet = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r ',			#stamp : 'pm 10/20/2018 17:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right previousSet newSet |\r\t\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'eliminate with \';show: aPair;cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\t\r\tpreviousSet:=setOfPairs veryDeepCopy."we need to work on a copy, to avoid having another iteration"\r\tpreviousSet remove:aPair.\r\t\r\tpreviousSet do:[:each |\r\t\t"tempVar:=each veryDeepCopy.""since we modify the underlying data, we work on a copy"\r\t\tnewSet add: (self replacementPair:each replaced:left by:right).\r\t\t].\r\t(previousSet = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r ',			#stamp : 'pm 10/20/2018 17:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T17:14:14.209829+02:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified operationAnswer|\r\tmodified:=true.\r\t[modified] whileTrue:[\r\t\tmodified:=false.\r\t\tsetOfPairs do:[:each |\r\t\t\t\t(Prop debugUnification)\r\t\t\t\tifTrue:[Transcript show:self;cr.].\r\r\t\t\t\toperationAnswer:=self tryOperations: each.\r\t\t\t\t(operationAnswer right)"NotPossible to unify?"\r\t\t\t\tifTrue:["On a conflict or a fail check"\r\t\t\t\t\tTranscript show:\'Unification impossible\';cr."TEMPORARY"\r\t\t\t\t\tsetOfPairs:=nil.\r\t\t\t\t\t^0"return value doesn\'t matter, we just want to break out"\r\t\t\t\t\t].\r\t\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\t\tmodified:=modified or:[operationAnswer left.]."isModified was put arbitrily= in left"\r\t\t\t]\r\t\t].\r\t',			#stamp : 'pm 10/20/2018 17:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified operationAnswer i|\r\tmodified:=true.\r\t[modified] whileTrue:[\r\t\tmodified:=false.\r\t\ti:=1.\r\t\t(i<=setOfPairs size and:[i!=-1])\r\t\tsetOfPairs do:[:each |\r\t\t\t\t(Prop debugUnification)\r\t\t\t\tifTrue:[Transcript show:self;cr.].\r\r\t\t\t\toperationAnswer:=self tryOperations: each.\r\t\t\t\t(operationAnswer right)"NotPossible to unify?"\r\t\t\t\tifTrue:["On a conflict or a fail check"\r\t\t\t\t\tTranscript show:\'Unification impossible\';cr."TEMPORARY"\r\t\t\t\t\tsetOfPairs:=nil.\r\t\t\t\t\t^0"return value doesn\'t matter, we just want to break out"\r\t\t\t\t\t].\r\t\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\t\tmodified:=modified or:[operationAnswer left.]."isModified was put arbitrily= in left"\r\t\t\t]\r\t\t].\r\t',			#stamp : 'pm 10/20/2018 17:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T17:17:42.884215+02:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified operationAnswer i|\r\tmodified:=true.\r\t[modified] whileTrue:[\r\t\tmodified:=false.\r\t\ti:=1.\r\t\t(i<=setOfPairs size and:[i!=-1])\r\t\tsetOfPairs do:[:each |\r\t\t\t\t(Prop debugUnification)\r\t\t\t\tifTrue:[Transcript show:self;cr.].\r\r\t\t\t\toperationAnswer:=self tryOperations: each.\r\t\t\t\t(operationAnswer right)"NotPossible to unify?"\r\t\t\t\tifTrue:["On a conflict or a fail check"\r\t\t\t\t\tTranscript show:\'Unification impossible\';cr."TEMPORARY"\r\t\t\t\t\tsetOfPairs:=nil.\r\t\t\t\t\t^0"return value doesn\'t matter, we just want to break out"\r\t\t\t\t\t].\r\t\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\t\tmodified:=modified or:[operationAnswer left.]."isModified was put arbitrily= in left"\r\t\t\t]\r\t\t].\r\t',			#stamp : 'pm 10/20/2018 17:14',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified operationAnswer i|\r\tmodified:=true.\r\t\r\t[modified] whileTrue:[\r\t\tmodified:=false.\r\t\ti:=1.\r\t\t(i<=setOfPairs size and:[i!=-1])"-1 is for when we won\'t break."\r\t\twhileTrue:[\r\t\t\t\t(Prop debugUnification)\r\t\t\t\tifTrue:[Transcript show:self;cr.].\r\r\t\t\t\toperationAnswer:=self tryOperations: (setOfPairs at:i).\r\t\t\t\t(operationAnswer right)"NotPossible to unify?"\r\t\t\t\tifTrue:["On a conflict or a fail check"\r\t\t\t\t\tTranscript show:\'Unification impossible\';cr."TEMPORARY"\r\t\t\t\t\tsetOfPairs:=nil.\r\t\t\t\t\t^0"return value doesn\'t matter, we just want to break out"\r\t\t\t\t\t].\r\t\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\t\tmodified:=modified or:[operationAnswer left.]."isModified was put arbitrily in left"\r\t\t\t\t(modified)\r\t\t\t\tifTrue:[i:=-1.]"we want to get to the next iteration"\r\t\t\t\tifFalse:[i:=i+1.].\r\t\t\t\t].\r\t\t].\r\t',			#stamp : 'pm 10/20/2018 17:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T17:20:27.198395+02:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified operationAnswer i|\r\tmodified:=true.\r\t\r\t[modified] whileTrue:[\r\t\tmodified:=false.\r\t\ti:=1.\r\t\t(i<=setOfPairs size and:[i!=-1])"-1 is for when we won\'t break."\r\t\twhileTrue:[\r\t\t\t\t(Prop debugUnification)\r\t\t\t\tifTrue:[Transcript show:self;cr.].\r\r\t\t\t\toperationAnswer:=self tryOperations: (setOfPairs at:i).\r\t\t\t\t(operationAnswer right)"NotPossible to unify?"\r\t\t\t\tifTrue:["On a conflict or a fail check"\r\t\t\t\t\tTranscript show:\'Unification impossible\';cr."TEMPORARY"\r\t\t\t\t\tsetOfPairs:=nil.\r\t\t\t\t\t^0"return value doesn\'t matter, we just want to break out"\r\t\t\t\t\t].\r\t\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\t\tmodified:=modified or:[operationAnswer left.]."isModified was put arbitrily in left"\r\t\t\t\t(modified)\r\t\t\t\tifTrue:[i:=-1.]"we want to get to the next iteration"\r\t\t\t\tifFalse:[i:=i+1.].\r\t\t\t\t].\r\t\t].\r\t',			#stamp : 'pm 10/20/2018 17:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified operationAnswer i|\r\tmodified:=true.\r\t\r\t[modified] whileTrue:[\r\t\tmodified:=false.\r\t\ti:=1.\r\t\t(i<=setOfPairs size and:[(i=-1)not.])"-1 is for when we won\'t break."\r\t\twhileTrue:[\r\t\t\t\t(Prop debugUnification)\r\t\t\t\tifTrue:[Transcript show:self;cr.].\r\r\t\t\t\toperationAnswer:=self tryOperations: (setOfPairs at:i).\r\t\t\t\t(operationAnswer right)"NotPossible to unify?"\r\t\t\t\tifTrue:["On a conflict or a fail check"\r\t\t\t\t\tTranscript show:\'Unification impossible\';cr."TEMPORARY"\r\t\t\t\t\tsetOfPairs:=nil.\r\t\t\t\t\t^0"return value doesn\'t matter, we just want to break out"\r\t\t\t\t\t].\r\t\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\t\tmodified:=modified or:[operationAnswer left.]."isModified was put arbitrily in left"\r\t\t\t\t(modified)\r\t\t\t\tifTrue:[i:=-1.]"we want to get to the next iteration"\r\t\t\t\tifFalse:[i:=i+1.].\r\t\t\t\t].\r\t\t].\r\t',			#stamp : 'pm 10/20/2018 17:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T17:20:36.437315+02:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified operationAnswer i|\r\tmodified:=true.\r\t\r\t[modified] whileTrue:[\r\t\tmodified:=false.\r\t\ti:=1.\r\t\t(i<=setOfPairs size and:[(i=-1)not.])"-1 is for when we won\'t break."\r\t\twhileTrue:[\r\t\t\t\t(Prop debugUnification)\r\t\t\t\tifTrue:[Transcript show:self;cr.].\r\r\t\t\t\toperationAnswer:=self tryOperations: (setOfPairs at:i).\r\t\t\t\t(operationAnswer right)"NotPossible to unify?"\r\t\t\t\tifTrue:["On a conflict or a fail check"\r\t\t\t\t\tTranscript show:\'Unification impossible\';cr."TEMPORARY"\r\t\t\t\t\tsetOfPairs:=nil.\r\t\t\t\t\t^0"return value doesn\'t matter, we just want to break out"\r\t\t\t\t\t].\r\t\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\t\tmodified:=modified or:[operationAnswer left.]."isModified was put arbitrily in left"\r\t\t\t\t(modified)\r\t\t\t\tifTrue:[i:=-1.]"we want to get to the next iteration"\r\t\t\t\tifFalse:[i:=i+1.].\r\t\t\t\t].\r\t\t].\r\t',			#stamp : 'pm 10/20/2018 17:20',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified operationAnswer i|\r\tmodified:=true.\r\t\r\t[modified] whileTrue:[\r\t\tmodified:=false.\r\t\ti:=1.\r\t\t(i<=setOfPairs size and:[(i=(-1))not.])"-1 is for when we won\'t break."\r\t\twhileTrue:[\r\t\t\t\t(Prop debugUnification)\r\t\t\t\tifTrue:[Transcript show:self;cr.].\r\r\t\t\t\toperationAnswer:=self tryOperations: (setOfPairs at:i).\r\t\t\t\t(operationAnswer right)"NotPossible to unify?"\r\t\t\t\tifTrue:["On a conflict or a fail check"\r\t\t\t\t\tTranscript show:\'Unification impossible\';cr."TEMPORARY"\r\t\t\t\t\tsetOfPairs:=nil.\r\t\t\t\t\t^0"return value doesn\'t matter, we just want to break out"\r\t\t\t\t\t].\r\t\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\t\tmodified:=modified or:[operationAnswer left.]."isModified was put arbitrily in left"\r\t\t\t\t(modified)\r\t\t\t\tifTrue:[i:=-1.]"we want to get to the next iteration"\r\t\t\t\tifFalse:[i:=i+1.].\r\t\t\t\t].\r\t\t].\r\t',			#stamp : 'pm 10/20/2018 17:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T17:20:41.304748+02:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ],		#time : DateAndTime [ '2018-10-20T17:20:41.33837+02:00' ],		#trigger : @3	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified operationAnswer i|\r\tmodified:=true.\r\t\r\t[modified] whileTrue:[\r\t\tmodified:=false.\r\t\ti:=1.\r\t\t(i<=setOfPairs size and:[(i=(-1))not.])"-1 is for when we won\'t break."\r\t\twhileTrue:[\r\t\t\t\t(Prop debugUnification)\r\t\t\t\tifTrue:[Transcript show:self;cr.].\r\r\t\t\t\toperationAnswer:=self tryOperations: (setOfPairs at:i).\r\t\t\t\t(operationAnswer right)"NotPossible to unify?"\r\t\t\t\tifTrue:["On a conflict or a fail check"\r\t\t\t\t\tTranscript show:\'Unification impossible\';cr."TEMPORARY"\r\t\t\t\t\tsetOfPairs:=nil.\r\t\t\t\t\t^0"return value doesn\'t matter, we just want to break out"\r\t\t\t\t\t].\r\t\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\t\tmodified:=modified or:[operationAnswer left.]."isModified was put arbitrily in left"\r\t\t\t\t(modified)\r\t\t\t\tifTrue:[i:=-1.]"we want to get to the next iteration"\r\t\t\t\tifFalse:[i:=i+1.].\r\t\t\t\t].\r\t\t].\r\t',			#stamp : 'pm 10/20/2018 17:20',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\t[ modified ]\r\t\twhileTrue: [ modified := false.\r\t\t\ti := 1.\r\t\t\t(i <= setOfPairs size and: [ i ~= -1 ])\r\t\t\t\twhileTrue: [ Prop debugUnification\r\t\t\t\t\t\tifTrue: [ Transcript\r\t\t\t\t\t\t\t\tshow: self;\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\t\t\toperationAnswer right\r\t\t\t\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'Unification impossible\';\r\t\t\t\t\t\t\t\tcr.\t"TEMPORARY"\r\t\t\t\t\t\t\tsetOfPairs := nil.\r\t\t\t\t\t\t\t^ 0\t"return value doesn\'t matter, we just want to break out" ].\t"NotPossible to unify?"\r\t\t\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\t\t\tmodified\r\t\t\t\t\t\tifTrue: [ "we want to get to the next iteration" i := -1 ]\r\t\t\t\t\t\tifFalse: [ i := i + 1 ] ]\t"-1 is for when we won\'t break." ]',			#stamp : 'pm 10/20/2018 17:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T17:21:17.965557+02:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\t[ modified ]\r\t\twhileTrue: [ modified := false.\r\t\t\ti := 1.\r\t\t\t(i <= setOfPairs size and: [ i ~= -1 ])\r\t\t\t\twhileTrue: [ Prop debugUnification\r\t\t\t\t\t\tifTrue: [ Transcript\r\t\t\t\t\t\t\t\tshow: self;\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\t\t\toperationAnswer right\r\t\t\t\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'Unification impossible\';\r\t\t\t\t\t\t\t\tcr.\t"TEMPORARY"\r\t\t\t\t\t\t\tsetOfPairs := nil.\r\t\t\t\t\t\t\t^ 0\t"return value doesn\'t matter, we just want to break out" ].\t"NotPossible to unify?"\r\t\t\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\t\t\tmodified\r\t\t\t\t\t\tifTrue: [ "we want to get to the next iteration" i := -1 ]\r\t\t\t\t\t\tifFalse: [ i := i + 1 ] ]\t"-1 is for when we won\'t break." ]',			#stamp : 'pm 10/20/2018 17:20',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\t[ modified ]\r\t\twhileTrue: [ modified := false.\r\t\t\ti := 1.\r\t\t\t[(i <= setOfPairs size and: [ i ~= -1 ])]\r\t\t\t\twhileTrue: [ Prop debugUnification\r\t\t\t\t\t\tifTrue: [ Transcript\r\t\t\t\t\t\t\t\tshow: self;\r\t\t\t\t\t\t\t\tcr ].\r\t\t\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\t\t\toperationAnswer right\r\t\t\t\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\t\t\t\tTranscript\r\t\t\t\t\t\t\t\tshow: \'Unification impossible\';\r\t\t\t\t\t\t\t\tcr.\t"TEMPORARY"\r\t\t\t\t\t\t\tsetOfPairs := nil.\r\t\t\t\t\t\t\t^ 0\t"return value doesn\'t matter, we just want to break out" ].\t"NotPossible to unify?"\r\t\t\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\t\t\tmodified\r\t\t\t\t\t\tifTrue: [ "we want to get to the next iteration" i := -1 ]\r\t\t\t\t\t\tifFalse: [ i := i + 1 ] ]\t"-1 is for when we won\'t break." ]',			#stamp : 'pm 10/20/2018 17:21',			#package : #_resolution_1erOrdre		}	}}