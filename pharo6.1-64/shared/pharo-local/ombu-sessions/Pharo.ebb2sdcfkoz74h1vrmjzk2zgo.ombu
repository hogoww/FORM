OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T07:34:40.092355+02:00' ],		#prior : OmReference [ 'Pharo.514xrhylgxnsk712ue8dqdquh', '26' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:(self getSymb))\r\tifTrue:[^LinkedTerm new:(self getSymb).]\r\tifFalse:[\r\t\telem:=aMap at:(self getSymb)ifAbsent:[(ConstTerm new:(self getSymb))].\r\t\t^elem.\r\t\t]\r\t\t\t\t"Weird formulation which means: \r\t\tifFalse:[^elem]\r\t\tifTrue:[^(ConstTerm new:(self getSymb))].\r\t\t]."',			#stamp : 'pm 10/9/2018 09:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\telem:=aMap at:(self getSymb)ifAbsent:[(ConstTerm new: self getSymb)].\r\t\t^elem.\r\t\t]\r\t\t\t\t"Weird formulation which means: \r\t\tifFalse:[^elem]\r\t\tifTrue:[^(ConstTerm new:(self getSymb))].\r\t\t]."',			#stamp : 'pm 10/11/2018 07:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T07:55:28.552872+02:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\telem:=aMap at:(self getSymb)ifAbsent:[(ConstTerm new: self getSymb)].\r\t\t^elem.\r\t\t]\r\t\t\t\t"Weird formulation which means: \r\t\tifFalse:[^elem]\r\t\tifTrue:[^(ConstTerm new:(self getSymb))].\r\t\t]."',			#stamp : 'pm 10/11/2018 07:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\telem:=aMap at:(self getSymb)ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.\r\t\t].\r\t\t"Weird formulation which means: \r\t\tifFalse:[^elem]\r\t\tifTrue:[^(ConstTerm new:(self getSymb))].\r\t\t]."',			#stamp : 'pm 10/11/2018 07:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T07:56:31.196185+02:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Term',				#traitCompositionSource : '{}',				#definitionSource : 'Term subclass: #ConstTerm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ConstTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ConstTerm class\r\tinstanceVariableNames: \'factoryNum\''				},				#name : #'ConstTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'ConstTerm class',							#isMetaSide : true						},						#name : #factoryNum,						#parent : @12					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ConstTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Const term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable wasn\'t bound by anything OR if i\'m bound by an exists which isn\'t bound by a previous forall.\r\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with the character \'c\' as a start. To differenciate it from the rest visually.\r\r',				#stamp : 'pm 10/9/2018 10:44'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Term',				#traitCompositionSource : '{}',				#definitionSource : 'Term subclass: #ConstTerm\r\tinstanceVariableNames: \'term\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ConstTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ConstTerm,						#isMetaSide : false					},					#name : #term,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ConstTerm class\r\tinstanceVariableNames: \'factoryNum\''				},				#name : #'ConstTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'ConstTerm class',							#isMetaSide : true						},						#name : #factoryNum,						#parent : @30					}				],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ConstTerm,					#isMetaSide : false				},				#parent : @23,				#content : 'I represent a Const term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable wasn\'t bound by anything OR if i\'m bound by an exists which isn\'t bound by a previous forall.\r\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with the character \'c\' as a start. To differenciate it from the rest visually.\r\r',				#stamp : 'pm 10/9/2018 10:44'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T07:56:38.174394+02:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Term',				#traitCompositionSource : '{}',				#definitionSource : 'Term subclass: #ConstTerm\r\tinstanceVariableNames: \'term\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ConstTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ConstTerm,						#isMetaSide : false					},					#name : #term,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ConstTerm class\r\tinstanceVariableNames: \'factoryNum\''				},				#name : #'ConstTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'ConstTerm class',							#isMetaSide : true						},						#name : #factoryNum,						#parent : @14					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ConstTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Const term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable wasn\'t bound by anything OR if i\'m bound by an exists which isn\'t bound by a previous forall.\r\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with the character \'c\' as a start. To differenciate it from the rest visually.\r\r',				#stamp : 'pm 10/9/2018 10:44'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Term',				#traitCompositionSource : '{}',				#definitionSource : 'Term subclass: #ConstTerm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ConstTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ConstTerm class\r\tinstanceVariableNames: \'factoryNum\''				},				#name : #'ConstTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'ConstTerm class',							#isMetaSide : true						},						#name : #factoryNum,						#parent : @30					}				],				#baseClass : @25			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ConstTerm,					#isMetaSide : false				},				#parent : @25,				#content : 'I represent a Const term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable wasn\'t bound by anything OR if i\'m bound by an exists which isn\'t bound by a previous forall.\r\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with the character \'c\' as a start. To differenciate it from the rest visually.\r\r',				#stamp : 'pm 10/9/2018 10:44'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T07:57:05.372041+02:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Term',				#traitCompositionSource : '{}',				#definitionSource : 'Term subclass: #UnaryTerm\r\tinstanceVariableNames: \'term\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #UnaryTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #UnaryTerm,						#isMetaSide : false					},					#name : #term,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'UnaryTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'UnaryTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #UnaryTerm,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T07:57:16.432281+02:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Term',				#traitCompositionSource : '{}',				#definitionSource : 'Term subclass: #LinkedTerm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #LinkedTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'LinkedTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'LinkedTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #LinkedTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Linked Term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable is bound by a forall earlier in the proposition.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String\r\r',				#stamp : 'pm 10/9/2018 10:42'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Term',				#traitCompositionSource : '{}',				#definitionSource : 'Term subclass: #LinkedTerm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #LinkedTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'LinkedTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'LinkedTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #LinkedTerm,					#isMetaSide : false				},				#parent : @21,				#content : 'I represent a Linked Term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable is bound by a forall earlier in the proposition.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String\r\r',				#stamp : 'pm 10/9/2018 10:42'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T07:57:16.534661+02:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Term',				#traitCompositionSource : '{}',				#definitionSource : 'Term subclass: #LinkedTerm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #LinkedTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'LinkedTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'LinkedTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #LinkedTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Linked Term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable is bound by a forall earlier in the proposition.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String\r\r',				#stamp : 'pm 10/9/2018 10:42'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'UnaryTerm',				#traitCompositionSource : '{}',				#definitionSource : 'UnaryTerm subclass: #LinkedTerm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #LinkedTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'LinkedTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'LinkedTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #LinkedTerm,					#isMetaSide : false				},				#parent : @21,				#content : 'I represent a Linked Term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable is bound by a forall earlier in the proposition.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String\r\r',				#stamp : 'pm 10/9/2018 10:42'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T07:57:26.264017+02:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Term',				#traitCompositionSource : '{}',				#definitionSource : 'Term subclass: #ConstTerm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ConstTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ConstTerm class\r\tinstanceVariableNames: \'factoryNum\''				},				#name : #'ConstTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'ConstTerm class',							#isMetaSide : true						},						#name : #factoryNum,						#parent : @12					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ConstTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Const term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable wasn\'t bound by anything OR if i\'m bound by an exists which isn\'t bound by a previous forall.\r\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with the character \'c\' as a start. To differenciate it from the rest visually.\r\r',				#stamp : 'pm 10/9/2018 10:44'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Term',				#traitCompositionSource : '{}',				#definitionSource : 'Term subclass: #ConstTerm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ConstTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ConstTerm class\r\tinstanceVariableNames: \'factoryNum\''				},				#name : #'ConstTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'ConstTerm class',							#isMetaSide : true						},						#name : #factoryNum,						#parent : @28					}				],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ConstTerm,					#isMetaSide : false				},				#parent : @23,				#content : 'I represent a Const term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable wasn\'t bound by anything OR if i\'m bound by an exists which isn\'t bound by a previous forall.\r\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with the character \'c\' as a start. To differenciate it from the rest visually.\r\r',				#stamp : 'pm 10/9/2018 10:44'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T07:57:26.381469+02:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Term',				#traitCompositionSource : '{}',				#definitionSource : 'Term subclass: #ConstTerm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ConstTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ConstTerm class\r\tinstanceVariableNames: \'factoryNum\''				},				#name : #'ConstTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'ConstTerm class',							#isMetaSide : true						},						#name : #factoryNum,						#parent : @12					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ConstTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Const term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable wasn\'t bound by anything OR if i\'m bound by an exists which isn\'t bound by a previous forall.\r\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with the character \'c\' as a start. To differenciate it from the rest visually.\r\r',				#stamp : 'pm 10/9/2018 10:44'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'UnaryTerm',				#traitCompositionSource : '{}',				#definitionSource : 'UnaryTerm subclass: #ConstTerm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ConstTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ConstTerm class\r\tinstanceVariableNames: \'factoryNum\''				},				#name : #'ConstTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'ConstTerm class',							#isMetaSide : true						},						#name : #factoryNum,						#parent : @28					}				],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ConstTerm,					#isMetaSide : false				},				#parent : @23,				#content : 'I represent a Const term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable wasn\'t bound by anything OR if i\'m bound by an exists which isn\'t bound by a previous forall.\r\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with the character \'c\' as a start. To differenciate it from the rest visually.\r\r',				#stamp : 'pm 10/9/2018 10:44'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T07:57:39.240542+02:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #term,			#protocol : #'as yet unclassified',			#sourceCode : 'term\r\t^term.',			#stamp : 'pm 10/11/2018 07:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T07:57:39.321393+02:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #term,			#protocol : #'as yet unclassified',			#sourceCode : 'term\r\t^term.',			#stamp : 'pm 10/11/2018 07:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #term,			#protocol : #accessing,			#sourceCode : 'term\r\t^term.',			#stamp : 'pm 10/11/2018 07:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T08:01:13.329322+02:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #accessing,			#sourceCode : 'initialize:aTerm\r\t(aTerm isKindOf: Term)\r\tifFalse:[^Error new: (self class),\'Takes only Terms as parameters. This is a\', aTerm class. ]',			#stamp : 'pm 10/11/2018 08:01',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T08:01:24.104212+02:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpProtocolAddition {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Term',				#traitCompositionSource : '{}',				#definitionSource : 'Term subclass: #UnaryTerm\r\tinstanceVariableNames: \'term\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #UnaryTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #UnaryTerm,						#isMetaSide : false					},					#name : #term,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'UnaryTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'UnaryTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #UnaryTerm,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #initialize	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T08:01:28.519925+02:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #accessing,			#sourceCode : 'initialize:aTerm\r\t(aTerm isKindOf: Term)\r\tifFalse:[^Error new: (self class),\'Takes only Terms as parameters. This is a\', aTerm class. ]',			#stamp : 'pm 10/11/2018 08:01',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialize,			#sourceCode : 'initialize:aTerm\r\t(aTerm isKindOf: Term)\r\tifFalse:[^Error new: (self class),\'Takes only Terms as parameters. This is a\', aTerm class. ]',			#stamp : 'pm 10/11/2018 08:01',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T08:02:52.429931+02:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'UnaryTerm class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'as yet unclassified',			#sourceCode : 'new: aTerm\r\t^(self basicNew) initialize:aTerm.',			#stamp : 'pm 10/11/2018 08:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T08:02:52.505158+02:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'UnaryTerm class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'as yet unclassified',			#sourceCode : 'new: aTerm\r\t^(self basicNew) initialize:aTerm.',			#stamp : 'pm 10/11/2018 08:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'UnaryTerm class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: aTerm\r\t^(self basicNew) initialize:aTerm.',			#stamp : 'pm 10/11/2018 08:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T08:06:57.969281+02:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #new,			#protocol : #initialization,			#sourceCode : 'new\r\t^self basicNew initialize.',			#stamp : 'pm 10/7/2018 10:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #new,			#protocol : #initialization,			#sourceCode : 'new "const Factory"\r\t^self basicNew initialize.',			#stamp : 'pm 10/11/2018 08:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T08:11:18.856683+02:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tsymb:=(self class) getNum.',			#stamp : 'pm 10/7/2018 10:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tTerm new:(self class) getNum.\r',			#stamp : 'pm 10/11/2018 08:11',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T08:12:22.503727+02:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tTerm new:(self class) getNum.\r',			#stamp : 'pm 10/11/2018 08:11',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tterm:=Term new:(self class) getNum.\r',			#stamp : 'pm 10/11/2018 08:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T08:14:49.762703+02:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialize,			#sourceCode : 'initialize:aTerm\r\t(aTerm isKindOf: Term)\r\tifFalse:[^Error new: (self class),\'Takes only Terms as parameters. This is a\', aTerm class. ]',			#stamp : 'pm 10/11/2018 08:01',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialize,			#sourceCode : 'initialize:aTerm\r\t(aTerm isKindOf: Term)\r\tifFalse:[^Error new: (self class),\'Takes only Terms as parameters. This is a\', (aTerm class). ]',			#stamp : 'pm 10/11/2018 08:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T08:19:20.815271+02:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\telem:=aMap at:(self getSymb)ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.\r\t\t].\r\t\t"Weird formulation which means: \r\t\tifFalse:[^elem]\r\t\tifTrue:[^(ConstTerm new:(self getSymb))].\r\t\t]."',			#stamp : 'pm 10/11/2018 07:55',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\telem:=aMap at:(self getSymb)ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.\r\t\t\t\t].\r\t\t"Weird formulation which means: \r\t\tifFalse:[^elem]\r\t\tifTrue:[^(ConstTerm new:(self getSymb))].\r\t\t]."',			#stamp : 'pm 10/11/2018 08:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T08:19:22.756269+02:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\telem:=aMap at:(self getSymb)ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.\r\t\t\t\t].\r\t\t"Weird formulation which means: \r\t\tifFalse:[^elem]\r\t\tifTrue:[^(ConstTerm new:(self getSymb))].\r\t\t]."',			#stamp : 'pm 10/11/2018 08:19',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\telem:=aMap at:(self getSymb)ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.\r\t\t].\r\t\t"Weird formulation which means: \r\t\tifFalse:[^elem]\r\t\tifTrue:[^(ConstTerm new:(self getSymb))].\r\t\t]."',			#stamp : 'pm 10/11/2018 08:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T08:27:58.065505+02:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'initialize:Variables:',			#protocol : #initialization,			#sourceCode : 'initialize: symbo Variables: setOfLinkedVar\r\tsuper initialize:symbo.\r\tterms:=LinkedList new.\r\tsetOfLinkedVar  do: [ :each | terms add:each.].',			#stamp : 'pm 10/7/2018 15:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'initialize:Variables:',			#protocol : #initialization,			#sourceCode : 'initialize: symbo Variables: setOfLinkedVar\r\tsuper initialize:symbo.\r\tterms:=LinkedList new.\r\tsetOfLinkedVar  do: [ :each | terms add: (Term new:each).].',			#stamp : 'pm 10/11/2018 08:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T08:29:09.561536+02:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'initialize:Variables:',			#protocol : #initialization,			#sourceCode : 'initialize: symbo Variables: setOfLinkedVar\r\tsuper initialize:symbo.\r\tterms:=LinkedList new.\r\tsetOfLinkedVar  do: [ :each | terms add: (Term new:each).].',			#stamp : 'pm 10/11/2018 08:27',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'initialize:Variables:',			#protocol : #initialization,			#sourceCode : 'initialize: symbo Variables: setOfLinkedVar\r\tsuper initialize:symbo.\r\tterms:=LinkedList new.\r\tsetOfLinkedVar  do: [ :each | terms add: each.].',			#stamp : 'pm 10/11/2018 08:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T08:29:37.639571+02:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\tsetOfLinkedVar add: (self var).\r\t^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.\r\t \r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 10/8/2018 20:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\tsetOfLinkedVar add: (Term new:(self var)).\r\t^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.\r\t \r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 10/11/2018 08:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T08:30:05.952187+02:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\tsetOfLinkedVar add: (self var).\r\t^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 10/8/2018 20:31',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\tsetOfLinkedVar add: (Term new:(self var)).\r\t^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 10/11/2018 08:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T08:39:37.42935+02:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t|t|\r\tt:=(self getSymb),\'(\'.\r\tterms do: [:each| t:=t,each prettyPrint. ] separatedBy:[t:=t,\',\'].\r\tt:=t,\')\'.\r\t^t.\r\t',			#stamp : 'pm 10/10/2018 21:58',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t|t|\r\tt:=(self getSymb),\'(\'.\r\tterms do: [:each| Transcript show: (each class).t:=t,each prettyPrint. ] separatedBy:[t:=t,\',\'].\r\tt:=t,\')\'.\r\t^t.\r\t',			#stamp : 'pm 10/11/2018 08:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T08:40:11.987713+02:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t|t|\r\tt:=(self getSymb),\'(\'.\r\tterms do: [:each| Transcript show: (each class).t:=t,each prettyPrint. ] separatedBy:[t:=t,\',\'].\r\tt:=t,\')\'.\r\t^t.\r\t',			#stamp : 'pm 10/11/2018 08:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t|t|\r\tt:=(self getSymb),\'(\'.\r\tterms do: [:each| Transcript show: (each class);cr.t:=t,each prettyPrint. ] separatedBy:[t:=t,\',\'].\r\tt:=t,\')\'.\r\t^t.\r\t',			#stamp : 'pm 10/11/2018 08:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T08:42:48.909226+02:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #'as yet unclassified',			#sourceCode : 'prettyPrint\r\t^term prettyPrint',			#stamp : 'pm 10/11/2018 08:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T08:42:48.988245+02:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #'as yet unclassified',			#sourceCode : 'prettyPrint\r\t^term prettyPrint',			#stamp : 'pm 10/11/2018 08:42',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t^term prettyPrint',			#stamp : 'pm 10/11/2018 08:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T09:00:19.87708+02:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tdebug:=false.',			#stamp : 'pm 10/1/2018 10:56',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tdebug:=true.',			#stamp : 'pm 10/11/2018 09:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T09:01:14.572458+02:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testEverything,			#protocol : #testing,			#sourceCode : 'testEverything\r\tTranscript clear.\r\tProp initEverything.\r\tProp testingProp.\r\tProp testingMatch.\r\tProp testingClausification.\r\tProp testingSkolemn.',			#stamp : 'pm 10/8/2018 17:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testEverything,			#protocol : #testing,			#sourceCode : 'testEverything\r\tTranscript clear.\r\tProp initEverything.\r\tProp testingProp.\r\t"Prop testingMatch."\r\t"Prop testingClausification."\r\tProp testingSkolemn.',			#stamp : 'pm 10/11/2018 09:01',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T09:02:22.560456+02:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testEverything,			#protocol : #testing,			#sourceCode : 'testEverything\r\tTranscript clear.\r\tProp initEverything.\r\tProp testingProp.\r\t"Prop testingMatch."\r\t"Prop testingClausification."\r\tProp testingSkolemn.',			#stamp : 'pm 10/11/2018 09:01',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testEverything,			#protocol : #testing,			#sourceCode : 'testEverything\r\tTranscript clear.\r\tProp initEverything.\r\t"Prop testingProp."\r\t"Prop testingMatch."\r\t"Prop testingClausification."\r\tProp testingSkolemn.',			#stamp : 'pm 10/11/2018 09:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T09:18:51.286883+02:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LinkedTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #'as yet unclassified',			#sourceCode : 'prettyPrint \r\t^term prettyPrint.',			#stamp : 'pm 10/11/2018 09:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T09:18:51.372965+02:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LinkedTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #'as yet unclassified',			#sourceCode : 'prettyPrint \r\t^term prettyPrint.',			#stamp : 'pm 10/11/2018 09:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LinkedTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint \r\t^term prettyPrint.',			#stamp : 'pm 10/11/2018 09:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T09:23:05.140553+02:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'UnaryTerm class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: aTerm\r\t^(self basicNew) initialize:aTerm.',			#stamp : 'pm 10/11/2018 08:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'UnaryTerm class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: aTerm\r\tTranscript show: aTerm.\r\t^(self basicNew) initialize:aTerm.',			#stamp : 'pm 10/11/2018 09:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T09:23:10.759814+02:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'UnaryTerm class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: aTerm\r\tTranscript show: aTerm.\r\t^(self basicNew) initialize:aTerm.',			#stamp : 'pm 10/11/2018 09:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'UnaryTerm class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: aTerm\r\tTranscript show: aTerm;cr.\r\t^(self basicNew) initialize:aTerm.',			#stamp : 'pm 10/11/2018 09:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T09:23:52.561836+02:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'UnaryTerm class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: aTerm\r\tTranscript show: aTerm;cr.\r\t^(self basicNew) initialize:aTerm.',			#stamp : 'pm 10/11/2018 09:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'UnaryTerm class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: aTerm\r\t^(self basicNew) initialize:aTerm.',			#stamp : 'pm 10/11/2018 09:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T09:24:12.185219+02:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialize,			#sourceCode : 'initialize:aTerm\r\t(aTerm isKindOf: Term)\r\tifFalse:[^Error new: (self class),\'Takes only Terms as parameters. This is a\', (aTerm class). ]',			#stamp : 'pm 10/11/2018 08:14',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialize,			#sourceCode : 'initialize:aTerm\r\t(aTerm isKindOf: Term)\r\tifFalse:[^Error new: (self class),\'Takes only Terms as parameters. This is a\', (aTerm class). ]\r\tifTrue:[term:=aTerm].',			#stamp : 'pm 10/11/2018 09:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T09:25:47.760723+02:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tdebug:=true.',			#stamp : 'pm 10/11/2018 09:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tdebug:=false.',			#stamp : 'pm 10/11/2018 09:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T09:28:28.321199+02:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #PrettyPrint,			#protocol : #accessing,			#sourceCode : 'PrettyPrint\r\t^(self getSymb)',			#stamp : 'pm 10/6/2018 19:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T09:32:13.296559+02:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t|t|\r\tt:=(self getSymb),\'(\'.\r\tterms do: [:each| Transcript show: (each class);cr.t:=t,each prettyPrint. ] separatedBy:[t:=t,\',\'].\r\tt:=t,\')\'.\r\t^t.\r\t',			#stamp : 'pm 10/11/2018 08:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t|t|\r\tt:=(self getSymb),\'(\'.\r\tterms do: [:each| t:=t,each prettyPrint. ] separatedBy:[t:=t,\',\'].\r\tt:=t,\')\'.\r\t^t.\r\t',			#stamp : 'pm 10/11/2018 09:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T09:33:27.038947+02:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t^\'c\',((self getSymb) asString).',			#stamp : 'pm 10/9/2018 09:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t^\'c\', term prettyPrint.',			#stamp : 'pm 10/11/2018 09:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T09:35:28.665568+02:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize:ConstValue\r\tsymb:=ConstValue.',			#stamp : 'pm 10/11/2018 07:56',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize:ConstValue\r\tsymb:=(Term new:ConstValue).',			#stamp : 'pm 10/11/2018 09:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T09:49:36.868588+02:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize:ConstValue\r\tsymb:=(Term new:ConstValue).',			#stamp : 'pm 10/11/2018 09:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize:ConstValue\r\tterm:=(Term new:ConstValue).',			#stamp : 'pm 10/11/2018 09:49',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T09:49:42.9674+02:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Term\r\tinstanceVariableNames: \'symb\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Term,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Term,						#isMetaSide : false					},					#name : #symb,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Term class\r\tinstanceVariableNames: \'\''				},				#name : #'Term class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Term,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Predicate\'s Term.\r\rMy type will be specialized in ConstTerm, FuncTerm, LinkedVar when the propostion my predicate\'s in goes through skolemnisation.\rI look a lot like a proposition, but i\'m conceptually different, hence the new object defined types.\r\rPublic API and Key Messages\r\r-prettyPrint -> print the term as a string.\r-new: aChar -> new instance, with a char as a term.\r ',				#stamp : 'pm 10/9/2018 10:36'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Term\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Term,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Term class\r\tinstanceVariableNames: \'\''				},				#name : #'Term class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Term,					#isMetaSide : false				},				#parent : @23,				#content : 'I represent a Predicate\'s Term.\r\rMy type will be specialized in ConstTerm, FuncTerm, LinkedVar when the propostion my predicate\'s in goes through skolemnisation.\rI look a lot like a proposition, but i\'m conceptually different, hence the new object defined types.\r\rPublic API and Key Messages\r\r-prettyPrint -> print the term as a string.\r-new: aChar -> new instance, with a char as a term.\r ',				#stamp : 'pm 10/9/2018 10:36'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T09:49:46.307177+02:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Term',				#traitCompositionSource : '{}',				#definitionSource : 'Term subclass: #FuncTerm\r\tinstanceVariableNames: \'terms\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #FuncTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #terms,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'FuncTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'FuncTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #FuncTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Func term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable was bound by an Exists, with a forall binding the said Exists beforehand.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with a standart name \'f\' for the function, and a list of terms.\r\r',				#stamp : 'pm 10/9/2018 10:43'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Term',				#traitCompositionSource : '{}',				#definitionSource : 'Term subclass: #FuncTerm\r\tinstanceVariableNames: \'symb terms\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #FuncTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #symb,					#parent : @23				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #terms,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'FuncTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'FuncTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #FuncTerm,					#isMetaSide : false				},				#parent : @23,				#content : 'I represent a Func term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable was bound by an Exists, with a forall binding the said Exists beforehand.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with a standart name \'f\' for the function, and a list of terms.\r\r',				#stamp : 'pm 10/9/2018 10:43'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T09:50:45.613301+02:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #getSymb,			#protocol : #'as yet unclassified',			#sourceCode : 'getSymb',			#stamp : 'pm 10/11/2018 09:50',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T09:50:45.689281+02:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #getSymb,			#protocol : #'as yet unclassified',			#sourceCode : 'getSymb',			#stamp : 'pm 10/11/2018 09:50',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #getSymb,			#protocol : #accessing,			#sourceCode : 'getSymb',			#stamp : 'pm 10/11/2018 09:50',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T09:51:03.565661+02:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #getSymb,			#protocol : #accessing,			#sourceCode : 'getSymb',			#stamp : 'pm 10/11/2018 09:50',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #getSymb,			#protocol : #accessing,			#sourceCode : 'getSymb\r\t^symb',			#stamp : 'pm 10/11/2018 09:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T09:51:12.014528+02:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #getSymb,			#protocol : #accessing,			#sourceCode : 'getSymb\r\t^symb',			#stamp : 'pm 10/6/2018 19:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T09:51:27.565321+02:00' ],		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: symbo\r\tsymb:=symbo.',			#stamp : 'pm 10/7/2018 15:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T09:51:37.425063+02:00' ],		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Term class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: symbo\r\t^self basicNew initialize:symbo.\t',			#stamp : 'pm 10/7/2018 15:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T09:51:40.822952+02:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpProtocolRemoval {		#behavior : RGMetaclassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'Term class\r\tinstanceVariableNames: \'\''			},			#name : #'Term class',			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#baseClass : RGClassDefinition {				#annotations : IdentityDictionary {					#superclassName : 'Object',					#traitCompositionSource : '{}',					#definitionSource : 'Object subclass: #Term\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''				},				#name : #Term,				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#metaClass : @7,				#comment : RGCommentDefinition {					#annotations : IdentityDictionary {						#className : #Term,						#isMetaSide : false					},					#parent : @12,					#content : 'I represent a Predicate\'s Term.\r\rMy type will be specialized in ConstTerm, FuncTerm, LinkedVar when the propostion my predicate\'s in goes through skolemnisation.\rI look a lot like a proposition, but i\'m conceptually different, hence the new object defined types.\r\rPublic API and Key Messages\r\r-prettyPrint -> print the term as a string.\r-new: aChar -> new instance, with a char as a term.\r ',					#stamp : 'pm 10/9/2018 10:36'				},				#classVariables : OrderedCollection [ ],				#category : #_resolution_1erOrdre,				#package : #_resolution_1erOrdre,				#sharedPools : OrderedCollection [ ]			}		},		#protocol : #'instance creation'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T09:52:59.429938+02:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Term\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Term,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Term class\r\tinstanceVariableNames: \'\''				},				#name : #'Term class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Term,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Predicate\'s Term.\r\rMy type will be specialized in ConstTerm, FuncTerm, LinkedVar when the propostion my predicate\'s in goes through skolemnisation.\rI look a lot like a proposition, but i\'m conceptually different, hence the new object defined types.\r\rPublic API and Key Messages\r\r-prettyPrint -> print the term as a string.\r-new: aChar -> new instance, with a char as a term.\r ',				#stamp : 'pm 10/9/2018 10:36'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #accessing	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T09:53:08.960443+02:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Term\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Term,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Term class\r\tinstanceVariableNames: \'\''				},				#name : #'Term class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Term,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Predicate\'s Term.\r\rMy type will be specialized in ConstTerm, FuncTerm, LinkedVar when the propostion my predicate\'s in goes through skolemnisation.\rI look a lot like a proposition, but i\'m conceptually different, hence the new object defined types.\r\rPublic API and Key Messages\r\r-prettyPrint -> print the term as a string.\r-new: aChar -> new instance, with a char as a term.\r ',				#stamp : 'pm 10/9/2018 10:36'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #initialization	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T10:54:44.861413+02:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #AbstractTerm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #AbstractTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'AbstractTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'AbstractTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #AbstractTerm,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T10:55:04.967016+02:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Term',				#traitCompositionSource : '{}',				#definitionSource : 'Term subclass: #FuncTerm\r\tinstanceVariableNames: \'symb terms\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #FuncTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #symb,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #terms,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'FuncTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'FuncTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #FuncTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Func term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable was bound by an Exists, with a forall binding the said Exists beforehand.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with a standart name \'f\' for the function, and a list of terms.\r\r',				#stamp : 'pm 10/9/2018 10:43'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Term',				#traitCompositionSource : '{}',				#definitionSource : 'Term subclass: #FuncTerm\r\tinstanceVariableNames: \'symb terms\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #FuncTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #symb,					#parent : @25				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #terms,					#parent : @25				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'FuncTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'FuncTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @25			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #FuncTerm,					#isMetaSide : false				},				#parent : @25,				#content : 'I represent a Func term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable was bound by an Exists, with a forall binding the said Exists beforehand.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with a standart name \'f\' for the function, and a list of terms.\r\r',				#stamp : 'pm 10/9/2018 10:43'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T10:55:05.075686+02:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Term',				#traitCompositionSource : '{}',				#definitionSource : 'Term subclass: #FuncTerm\r\tinstanceVariableNames: \'symb terms\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #FuncTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #symb,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #terms,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'FuncTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'FuncTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #FuncTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Func term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable was bound by an Exists, with a forall binding the said Exists beforehand.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with a standart name \'f\' for the function, and a list of terms.\r\r',				#stamp : 'pm 10/9/2018 10:43'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'AbstractTerm',				#traitCompositionSource : '{}',				#definitionSource : 'AbstractTerm subclass: #FuncTerm\r\tinstanceVariableNames: \'symb terms\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #FuncTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #symb,					#parent : @25				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #terms,					#parent : @25				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'FuncTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'FuncTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @25			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #FuncTerm,					#isMetaSide : false				},				#parent : @25,				#content : 'I represent a Func term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable was bound by an Exists, with a forall binding the said Exists beforehand.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with a standart name \'f\' for the function, and a list of terms.\r\r',				#stamp : 'pm 10/9/2018 10:43'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T10:55:19.73502+02:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Term',				#traitCompositionSource : '{}',				#definitionSource : 'Term subclass: #UnaryTerm\r\tinstanceVariableNames: \'term\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #UnaryTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #UnaryTerm,						#isMetaSide : false					},					#name : #term,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'UnaryTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'UnaryTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #UnaryTerm,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Term',				#traitCompositionSource : '{}',				#definitionSource : 'Term subclass: #UnaryTerm\r\tinstanceVariableNames: \'term\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #UnaryTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #UnaryTerm,						#isMetaSide : false					},					#name : #term,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'UnaryTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'UnaryTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #UnaryTerm,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T10:55:19.84847+02:00' ],		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Term',				#traitCompositionSource : '{}',				#definitionSource : 'Term subclass: #UnaryTerm\r\tinstanceVariableNames: \'term\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #UnaryTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #UnaryTerm,						#isMetaSide : false					},					#name : #term,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'UnaryTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'UnaryTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #UnaryTerm,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'AbstractTerm',				#traitCompositionSource : '{}',				#definitionSource : 'AbstractTerm subclass: #UnaryTerm\r\tinstanceVariableNames: \'term\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #UnaryTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #UnaryTerm,						#isMetaSide : false					},					#name : #term,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'UnaryTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'UnaryTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #UnaryTerm,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T10:56:25.659826+02:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Term\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Term,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Term class\r\tinstanceVariableNames: \'\''				},				#name : #'Term class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Term,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Predicate\'s Term.\r\rMy type will be specialized in ConstTerm, FuncTerm, LinkedVar when the propostion my predicate\'s in goes through skolemnisation.\rI look a lot like a proposition, but i\'m conceptually different, hence the new object defined types.\r\rPublic API and Key Messages\r\r-prettyPrint -> print the term as a string.\r-new: aChar -> new instance, with a char as a term.\r ',				#stamp : 'pm 10/9/2018 10:36'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Term\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Term,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Term class\r\tinstanceVariableNames: \'\''				},				#name : #'Term class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Term,					#isMetaSide : false				},				#parent : @21,				#content : 'I represent a Predicate\'s Term.\r\rMy type will be specialized in ConstTerm, FuncTerm, LinkedVar when the propostion my predicate\'s in goes through skolemnisation.\rI look a lot like a proposition, but i\'m conceptually different, hence the new object defined types.\r\rPublic API and Key Messages\r\r-prettyPrint -> print the term as a string.\r-new: aChar -> new instance, with a char as a term.\r ',				#stamp : 'pm 10/9/2018 10:36'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T10:56:25.772129+02:00' ],		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Term\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Term,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Term class\r\tinstanceVariableNames: \'\''				},				#name : #'Term class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Term,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Predicate\'s Term.\r\rMy type will be specialized in ConstTerm, FuncTerm, LinkedVar when the propostion my predicate\'s in goes through skolemnisation.\rI look a lot like a proposition, but i\'m conceptually different, hence the new object defined types.\r\rPublic API and Key Messages\r\r-prettyPrint -> print the term as a string.\r-new: aChar -> new instance, with a char as a term.\r ',				#stamp : 'pm 10/9/2018 10:36'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'AbstractTerm',				#traitCompositionSource : '{}',				#definitionSource : 'AbstractTerm subclass: #Term\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Term,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Term class\r\tinstanceVariableNames: \'\''				},				#name : #'Term class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Term,					#isMetaSide : false				},				#parent : @21,				#content : 'I represent a Predicate\'s Term.\r\rMy type will be specialized in ConstTerm, FuncTerm, LinkedVar when the propostion my predicate\'s in goes through skolemnisation.\rI look a lot like a proposition, but i\'m conceptually different, hence the new object defined types.\r\rPublic API and Key Messages\r\r-prettyPrint -> print the term as a string.\r-new: aChar -> new instance, with a char as a term.\r ',				#stamp : 'pm 10/9/2018 10:36'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T10:56:52.621729+02:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #'as yet unclassified',			#sourceCode : 'prettyPrint\r\t^SubclassResponsibility.',			#stamp : 'pm 10/11/2018 10:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T10:56:52.710066+02:00' ],		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #'as yet unclassified',			#sourceCode : 'prettyPrint\r\t^SubclassResponsibility.',			#stamp : 'pm 10/11/2018 10:56',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t^SubclassResponsibility.',			#stamp : 'pm 10/11/2018 10:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:02:13.092176+02:00' ],		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'AbstractTerm',				#traitCompositionSource : '{}',				#definitionSource : 'AbstractTerm subclass: #Term\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Term,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Term class\r\tinstanceVariableNames: \'\''				},				#name : #'Term class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Term,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Predicate\'s Term.\r\rMy type will be specialized in ConstTerm, FuncTerm, LinkedVar when the propostion my predicate\'s in goes through skolemnisation.\rI look a lot like a proposition, but i\'m conceptually different, hence the new object defined types.\r\rPublic API and Key Messages\r\r-prettyPrint -> print the term as a string.\r-new: aChar -> new instance, with a char as a term.\r ',				#stamp : 'pm 10/9/2018 10:36'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'AbstractTerm',				#traitCompositionSource : '{}',				#definitionSource : 'AbstractTerm subclass: #Term\r\tinstanceVariableNames: \'symb\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Term,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Term,						#isMetaSide : false					},					#name : #symb,					#parent : @21				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Term class\r\tinstanceVariableNames: \'\''				},				#name : #'Term class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Term,					#isMetaSide : false				},				#parent : @21,				#content : 'I represent a Predicate\'s Term.\r\rMy type will be specialized in ConstTerm, FuncTerm, LinkedVar when the propostion my predicate\'s in goes through skolemnisation.\rI look a lot like a proposition, but i\'m conceptually different, hence the new object defined types.\r\rPublic API and Key Messages\r\r-prettyPrint -> print the term as a string.\r-new: aChar -> new instance, with a char as a term.\r ',				#stamp : 'pm 10/9/2018 10:36'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:02:40.077813+02:00' ],		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #getSymb,			#protocol : #'as yet unclassified',			#sourceCode : 'getSymb\r\t^symb',			#stamp : 'pm 10/11/2018 11:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:02:40.169374+02:00' ],		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #getSymb,			#protocol : #'as yet unclassified',			#sourceCode : 'getSymb\r\t^symb',			#stamp : 'pm 10/11/2018 11:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #getSymb,			#protocol : #accessing,			#sourceCode : 'getSymb\r\t^symb',			#stamp : 'pm 10/11/2018 11:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:03:07.956112+02:00' ],		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #accessing,			#sourceCode : 'initialize: aName\r\tsymb:=aName.',			#stamp : 'pm 10/11/2018 11:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:03:49.675493+02:00' ],		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Term class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'as yet unclassified',			#sourceCode : 'new: aName\r\t^self basicNew initialize aName.',			#stamp : 'pm 10/11/2018 11:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:03:49.753418+02:00' ],		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Term class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'as yet unclassified',			#sourceCode : 'new: aName\r\t^self basicNew initialize aName.',			#stamp : 'pm 10/11/2018 11:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Term class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: aName\r\t^self basicNew initialize aName.',			#stamp : 'pm 10/11/2018 11:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:04:11.569508+02:00' ],		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Term class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: aName\r\t^self basicNew initialize aName.',			#stamp : 'pm 10/11/2018 11:04',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Term class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: aName\r\t^self basicNew initialize:aName.',			#stamp : 'pm 10/11/2018 11:04',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:05:13.015261+02:00' ],		#prior : OmReference [ '72' ],		#self : OmReference [ '73' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'initialize:Variables:',			#protocol : #initialization,			#sourceCode : 'initialize: symbo Variables: setOfLinkedVar\r\tsuper initialize:symbo.\r\tterms:=LinkedList new.\r\tsetOfLinkedVar  do: [ :each | terms add: each.].',			#stamp : 'pm 10/11/2018 08:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'initialize:Variables:',			#protocol : #initialization,			#sourceCode : 'initialize: symbo Variables: setOfLinkedVar\r\tsymb:=symbo.\r\tterms:=LinkedList new.\r\tsetOfLinkedVar  do: [ :each | terms add: each.].',			#stamp : 'pm 10/11/2018 11:05',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:06:46.905466+02:00' ],		#prior : OmReference [ '73' ],		#self : OmReference [ '74' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t^\'c\', term prettyPrint.',			#stamp : 'pm 10/11/2018 09:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t^\'c\', (term prettyPrint).',			#stamp : 'pm 10/11/2018 11:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:32:08.632816+02:00' ],		#prior : OmReference [ '74' ],		#self : OmReference [ '75' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t^\'c\', (term prettyPrint).',			#stamp : 'pm 10/11/2018 11:06',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\tTranscript show: term class.\r\t^\'c\', (term prettyPrint).',			#stamp : 'pm 10/11/2018 11:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:32:35.416135+02:00' ],		#prior : OmReference [ '75' ],		#self : OmReference [ '76' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint \r\t^self getSymb.\r',			#stamp : 'pm 10/9/2018 08:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint \r\tTranscript show:self getSymb.\r\t^self getSymb.\r',			#stamp : 'pm 10/11/2018 11:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:33:09.408502+02:00' ],		#prior : OmReference [ '76' ],		#self : OmReference [ '77' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint \r\tTranscript show:self getSymb.\r\t^self getSymb.\r',			#stamp : 'pm 10/11/2018 11:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint \r\t"Transcript show:self getSymb."\r\t^self getSymb.\r',			#stamp : 'pm 10/11/2018 11:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:34:10.65674+02:00' ],		#prior : OmReference [ '77' ],		#self : OmReference [ '78' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint \r\t"Transcript show:self getSymb."\r\t^self getSymb.\r',			#stamp : 'pm 10/11/2018 11:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint \r\tTranscript show: (self class);show:self getSymb;cr.\r\t^self getSymb.\r',			#stamp : 'pm 10/11/2018 11:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:37:33.060353+02:00' ],		#prior : OmReference [ '78' ],		#self : OmReference [ '79' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\tTranscript show: term class.\r\t^\'c\', (term prettyPrint).',			#stamp : 'pm 10/11/2018 11:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\tTranscript show: \'Const Term:\';show: term class;cr.\r\t^\'c\', (term prettyPrint).',			#stamp : 'pm 10/11/2018 11:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:38:06.756358+02:00' ],		#prior : OmReference [ '79' ],		#self : OmReference [ '80' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\tTranscript show: \'Const Term:\';show: term class;cr.\r\t^\'c\', (term prettyPrint).',			#stamp : 'pm 10/11/2018 11:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\tTranscript show: \'Const Term:\';show: term class.\r\t^\'c\', (term prettyPrint).',			#stamp : 'pm 10/11/2018 11:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:38:16.186751+02:00' ],		#prior : OmReference [ '80' ],		#self : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint \r\tTranscript show: (self class);show:self getSymb;cr.\r\t^self getSymb.\r',			#stamp : 'pm 10/11/2018 11:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint \r\tTranscript show:\' \';show:self getSymb;cr.\r\t^self getSymb.\r',			#stamp : 'pm 10/11/2018 11:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:40:47.924697+02:00' ],		#prior : OmReference [ '81' ],		#self : OmReference [ '82' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint \r\tTranscript show:\' \';show:self getSymb;cr.\r\t^self getSymb.\r',			#stamp : 'pm 10/11/2018 11:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint \r\tTranscript show:\' \';show:self getSymb;cr;cr.\r\t^self getSymb.\r',			#stamp : 'pm 10/11/2018 11:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:41:14.256504+02:00' ],		#prior : OmReference [ '82' ],		#self : OmReference [ '83' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint \r\tTranscript show:\' \';show:self getSymb;cr;cr.\r\t^self getSymb.\r',			#stamp : 'pm 10/11/2018 11:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint \r\tTranscript show:\' \';show:self getSymb;cr.\r\t^self getSymb.\r',			#stamp : 'pm 10/11/2018 11:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:41:40.717804+02:00' ],		#prior : OmReference [ '83' ],		#self : OmReference [ '84' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #accessing,			#sourceCode : 'initialize: aName\r\tsymb:=aName.',			#stamp : 'pm 10/11/2018 11:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #accessing,			#sourceCode : 'initialize: aName\r\tTranscript show:aName class.\r\tsymb:=aName.',			#stamp : 'pm 10/11/2018 11:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:41:58.616069+02:00' ],		#prior : OmReference [ '84' ],		#self : OmReference [ '85' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #accessing,			#sourceCode : 'initialize: aName\r\tTranscript show:aName class.\r\tsymb:=aName.',			#stamp : 'pm 10/11/2018 11:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #accessing,			#sourceCode : 'initialize: aName\r\tTranscript cr;show:aName class;cr.\r\tsymb:=aName.',			#stamp : 'pm 10/11/2018 11:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:42:20.224765+02:00' ],		#prior : OmReference [ '85' ],		#self : OmReference [ '86' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint \r\tTranscript show:\' \';show:self getSymb;cr.\r\t^self getSymb.\r',			#stamp : 'pm 10/11/2018 11:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint \r\t"Transcript show:\' \';show:self getSymb;cr."\r\t^self getSymb.\r',			#stamp : 'pm 10/11/2018 11:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:42:27.116765+02:00' ],		#prior : OmReference [ '86' ],		#self : OmReference [ '87' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\tTranscript show: \'Const Term:\';show: term class.\r\t^\'c\', (term prettyPrint).',			#stamp : 'pm 10/11/2018 11:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t"Transcript show: \'Const Term:\';show: term class."\r\t^\'c\', (term prettyPrint).',			#stamp : 'pm 10/11/2018 11:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:45:40.356581+02:00' ],		#prior : OmReference [ '87' ],		#self : OmReference [ '88' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Term class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: aName\r\t^self basicNew initialize:aName.',			#stamp : 'pm 10/11/2018 11:04',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Term class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: aName\r\t^(self basicNew) initialize:aName.',			#stamp : 'pm 10/11/2018 11:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:48:44.989367+02:00' ],		#prior : OmReference [ '88' ],		#self : OmReference [ '89' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #accessing,			#sourceCode : 'initialize: aName\r\tTranscript cr;show:aName class;cr.\r\tsymb:=aName.',			#stamp : 'pm 10/11/2018 11:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #accessing,			#sourceCode : 'initialize: aName\r\tTranscript cr;show:aName class; show:\' \';show:aName;cr.\r\tsymb:=aName.',			#stamp : 'pm 10/11/2018 11:48',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:49:10.68784+02:00' ],		#prior : OmReference [ '89' ],		#self : OmReference [ '90' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #accessing,			#sourceCode : 'initialize: aName\r\tTranscript cr;show:aName class; show:\' \';show:aName;cr.\r\tsymb:=aName.',			#stamp : 'pm 10/11/2018 11:48',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #accessing,			#sourceCode : 'initialize: aName\r\tself Halt.\r\tsymb:=aName.',			#stamp : 'pm 10/11/2018 11:49',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:49:12.579963+02:00' ],		#prior : OmReference [ '90' ],		#self : OmReference [ '91' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #accessing,			#sourceCode : 'initialize: aName\r\tself Halt.\r\tsymb:=aName.',			#stamp : 'pm 10/11/2018 11:49',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #accessing,			#sourceCode : 'initialize: aName\r\tself halt.\r\tsymb:=aName.',			#stamp : 'pm 10/11/2018 11:49',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:54:12.855109+02:00' ],		#prior : OmReference [ '91' ],		#self : OmReference [ '92' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint \r\t"Transcript show:\' \';show:self getSymb;cr."\r\t^self getSymb.\r',			#stamp : 'pm 10/11/2018 11:42',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint \r\tTranscript show:\' \';show:self getSymb;cr.\r\t^self getSymb.\r',			#stamp : 'pm 10/11/2018 11:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:55:45.015909+02:00' ],		#prior : OmReference [ '92' ],		#self : OmReference [ '93' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint \r\tTranscript show:\' \';show:self getSymb;cr.\r\t^self getSymb.\r',			#stamp : 'pm 10/11/2018 11:54',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint \r\t^self getSymb.\r',			#stamp : 'pm 10/11/2018 11:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:56:13.792475+02:00' ],		#prior : OmReference [ '93' ],		#self : OmReference [ '94' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #accessing,			#sourceCode : 'initialize: aName\r\tself halt.\r\tsymb:=aName.',			#stamp : 'pm 10/11/2018 11:49',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #accessing,			#sourceCode : 'initialize: aName\r\tTranscript show:\' \';show:self getSymb;cr.\r\tself halt.\r\tsymb:=aName.',			#stamp : 'pm 10/11/2018 11:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:56:46.593713+02:00' ],		#prior : OmReference [ '94' ],		#self : OmReference [ '95' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #accessing,			#sourceCode : 'initialize: aName\r\tTranscript show:\' \';show:self getSymb;cr.\r\tself halt.\r\tsymb:=aName.',			#stamp : 'pm 10/11/2018 11:56',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #accessing,			#sourceCode : 'initialize: aName\r\tself halt.\r\tsymb:=aName.\r\tTranscript show:\' \';show: aName ;cr.',			#stamp : 'pm 10/11/2018 11:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T11:57:14.351506+02:00' ],		#prior : OmReference [ '95' ],		#self : OmReference [ '96' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #accessing,			#sourceCode : 'initialize: aName\r\tself halt.\r\tsymb:=aName.\r\tTranscript show:\' \';show: aName ;cr.',			#stamp : 'pm 10/11/2018 11:56',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #accessing,			#sourceCode : 'initialize: aName\r\tTranscript show: aName ;cr.\r\tself halt.\r\tsymb:=aName.\r',			#stamp : 'pm 10/11/2018 11:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T12:05:04.168339+02:00' ],		#prior : OmReference [ '96' ],		#self : OmReference [ '97' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize:ConstValue\r\tterm:=(Term new:ConstValue).',			#stamp : 'pm 10/11/2018 09:49',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize:ConstValue\r\tterm:=ConstValue.',			#stamp : 'pm 10/11/2018 12:05',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T12:05:09.665103+02:00' ],		#prior : OmReference [ '97' ],		#self : OmReference [ '98' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #accessing,			#sourceCode : 'initialize: aName\r\tTranscript show: aName ;cr.\r\tself halt.\r\tsymb:=aName.\r',			#stamp : 'pm 10/11/2018 11:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #accessing,			#sourceCode : 'initialize: aName\r\r\tsymb:=aName.\r',			#stamp : 'pm 10/11/2018 12:05',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T12:05:11.147694+02:00' ],		#prior : OmReference [ '98' ],		#self : OmReference [ '99' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #accessing,			#sourceCode : 'initialize: aName\r\r\tsymb:=aName.\r',			#stamp : 'pm 10/11/2018 12:05',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #accessing,			#sourceCode : 'initialize: aName\r\tsymb:=aName.\r',			#stamp : 'pm 10/11/2018 12:05',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T12:07:14.923301+02:00' ],		#prior : OmReference [ '99' ],		#self : OmReference [ '100' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t"Transcript show: \'Const Term:\';show: term class."\r\t^\'c\', (term prettyPrint).',			#stamp : 'pm 10/11/2018 11:42',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\tTranscript show: \'Const Term:\';show: term class.\r\t^\'c\', (term prettyPrint).',			#stamp : 'pm 10/11/2018 12:07',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T12:11:17.656354+02:00' ],		#prior : OmReference [ '100' ],		#self : OmReference [ '101' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #getNum,			#protocol : #initialization,			#sourceCode : 'getNum\r\tfactoryNum:=factoryNum+1.\r\t^factoryNum ',			#stamp : 'pm 10/8/2018 17:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #getNum,			#protocol : #initialization,			#sourceCode : 'getNum\r\tfactoryNum:=factoryNum+1.\r\t^factoryNum asString',			#stamp : 'pm 10/11/2018 12:11',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T12:13:26.345333+02:00' ],		#prior : OmReference [ '101' ],		#self : OmReference [ '102' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'initialize:Variable:',			#protocol : #initialization,			#sourceCode : 'initialize: symbo Variable: aTerm\r\tsuper initialize:symbo.\r\tterms:=LinkedList new.\r\tterms add: aTerm.',			#stamp : 'pm 10/10/2018 21:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'initialize:Variable:',			#protocol : #initialization,			#sourceCode : 'initialize: symbo Variable: aTerm\r\t\r\tterms:=LinkedList new.\r\tterms add: aTerm.',			#stamp : 'pm 10/11/2018 12:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T12:13:50.45752+02:00' ],		#prior : OmReference [ '102' ],		#self : OmReference [ '103' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'initialize:Variable:',			#protocol : #initialization,			#sourceCode : 'initialize: symbo Variable: aTerm\r\t\r\tterms:=LinkedList new.\r\tterms add: aTerm.',			#stamp : 'pm 10/11/2018 12:13',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'initialize:Variable:',			#protocol : #initialization,			#sourceCode : 'initialize: symbo Variable: aTerm\r\tsymb:=symbo.\r\tterms:=LinkedList new.\r\tterms add: aTerm.',			#stamp : 'pm 10/11/2018 12:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T12:47:08.711742+02:00' ],		#prior : OmReference [ '103' ],		#self : OmReference [ '104' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #printing,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\telem:=aMap at:(self getSymb)ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 12:47',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T12:48:52.180065+02:00' ],		#prior : OmReference [ '104' ],		#self : OmReference [ '105' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #printing,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\telem:=aMap at:(self getSymb)ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 12:47',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #printing,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\telem:=aMap at:self ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 12:48',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T12:49:07.462818+02:00' ],		#prior : OmReference [ '105' ],		#self : OmReference [ '106' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\telem:=aMap at:(self getSymb)ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.\r\t\t].\r\t\t"Weird formulation which means: \r\t\tifFalse:[^elem]\r\t\tifTrue:[^(ConstTerm new:(self getSymb))].\r\t\t]."',			#stamp : 'pm 10/11/2018 08:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T12:50:59.305396+02:00' ],		#prior : OmReference [ '106' ],		#self : OmReference [ '107' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\tTranscript show: \'Const Term:\';show: term class.\r\t^\'c\', (term prettyPrint).',			#stamp : 'pm 10/11/2018 12:07',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t^\'c\', (term prettyPrint).',			#stamp : 'pm 10/11/2018 12:50',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T12:52:45.818309+02:00' ],		#prior : OmReference [ '107' ],		#self : OmReference [ '108' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t(anotherTerm isKindOf: Term)\r\tifTrue:[\r\t\t^(self getSymb)=(anotherTerm getSymb).\r\t\t]\r\tifFalse:[^false].',			#stamp : 'pm 10/8/2018 21:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T12:52:45.823663+02:00' ],		#prior : OmReference [ '108' ],		#self : OmReference [ '109' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'AbstractTerm',				#traitCompositionSource : '{}',				#definitionSource : 'AbstractTerm subclass: #Term\r\tinstanceVariableNames: \'symb\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Term,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Term,						#isMetaSide : false					},					#name : #symb,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Term class\r\tinstanceVariableNames: \'\''				},				#name : #'Term class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Term,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Predicate\'s Term.\r\rMy type will be specialized in ConstTerm, FuncTerm, LinkedVar when the propostion my predicate\'s in goes through skolemnisation.\rI look a lot like a proposition, but i\'m conceptually different, hence the new object defined types.\r\rPublic API and Key Messages\r\r-prettyPrint -> print the term as a string.\r-new: aChar -> new instance, with a char as a term.\r ',				#stamp : 'pm 10/9/2018 10:36'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #comparing	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T12:52:51.649007+02:00' ],		#prior : OmReference [ '109' ],		#self : OmReference [ '110' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'=',			#protocol : #printing,			#sourceCode : '=anotherTerm\r\t(anotherTerm isKindOf: Term)\r\tifTrue:[\r\t\t^(self getSymb)=(anotherTerm getSymb).\r\t\t]\r\tifFalse:[^false].',			#stamp : 'pm 10/11/2018 12:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T12:53:01.130297+02:00' ],		#prior : OmReference [ '110' ],		#self : OmReference [ '111' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'=',			#protocol : #printing,			#sourceCode : '=anotherTerm\r\t(anotherTerm isKindOf: Term)\r\tifTrue:[\r\t\t^(self getSymb)=(anotherTerm getSymb).\r\t\t]\r\tifFalse:[^false].',			#stamp : 'pm 10/11/2018 12:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'=',			#protocol : #printing,			#sourceCode : '=anotherTerm\r\t(anotherTerm isKindOf: AbstractTerm)\r\tifTrue:[\r\t\t^(self getSymb)=(anotherTerm getSymb).\r\t\t]\r\tifFalse:[^false].',			#stamp : 'pm 10/11/2018 12:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T13:00:10.968176+02:00' ],		#prior : OmReference [ '111' ],		#self : OmReference [ '112' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MinimalOrderedSet,				#isMetaSide : false			},			#name : #'haveYouSeenThisObject:',			#protocol : #search,			#sourceCode : 'haveYouSeenThisObject: anObject \r\t"search for the object"\r\tself do: [ :each | \r\t\t(each=anObject) \r\t\tifTrue:[^true]\r\t\t].\r\t^false.',			#stamp : 'pm 10/8/2018 17:19',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MinimalOrderedSet,				#isMetaSide : false			},			#name : #'haveYouSeenThisObject:',			#protocol : #search,			#sourceCode : 'haveYouSeenThisObject: anObject \r\t"search for the object"\r\tself do: [ :each | \r\t\t(each=anObject) \r\t\tifTrue:[Transcript show:each prettyPrint.^true]\r\t\t\r\t\t].\r\t^false.',			#stamp : 'pm 10/11/2018 13:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T13:00:29.064616+02:00' ],		#prior : OmReference [ '112' ],		#self : OmReference [ '113' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MinimalOrderedSet,				#isMetaSide : false			},			#name : #'haveYouSeenThisObject:',			#protocol : #search,			#sourceCode : 'haveYouSeenThisObject: anObject \r\t"search for the object"\r\tself do: [ :each | \r\t\t(each=anObject) \r\t\tifTrue:[Transcript show:each prettyPrint.^true]\r\t\t\r\t\t].\r\t^false.',			#stamp : 'pm 10/11/2018 13:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MinimalOrderedSet,				#isMetaSide : false			},			#name : #'haveYouSeenThisObject:',			#protocol : #search,			#sourceCode : 'haveYouSeenThisObject: anObject \r\t"search for the object"\r\tself do: [ :each | \r\t\t(each=anObject) \r\t\tifTrue:[Transcript cr;show:each prettyPrint;cr.^true]\r\t\t\r\t\t].\r\t^false.',			#stamp : 'pm 10/11/2018 13:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T13:02:18.463522+02:00' ],		#prior : OmReference [ '113' ],		#self : OmReference [ '114' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MinimalOrderedSet,				#isMetaSide : false			},			#name : #'haveYouSeenThisObject:',			#protocol : #search,			#sourceCode : 'haveYouSeenThisObject: anObject \r\t"search for the object"\r\tself do: [ :each | \r\t\t(each=anObject) \r\t\tifTrue:[Transcript cr;show:each prettyPrint;cr.^true]\r\t\t\r\t\t].\r\t^false.',			#stamp : 'pm 10/11/2018 13:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MinimalOrderedSet,				#isMetaSide : false			},			#name : #'haveYouSeenThisObject:',			#protocol : #search,			#sourceCode : 'haveYouSeenThisObject: anObject \r\t"search for the object"\r\tself do: [ :each | \r\t\t(each=anObject) \r\t\tifTrue:["Transcript cr;show:each prettyPrint;cr".\r\t\t\t^true.]\r\t\t\r\t\t].\r\t^false.',			#stamp : 'pm 10/11/2018 13:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T13:02:43.082619+02:00' ],		#prior : OmReference [ '114' ],		#self : OmReference [ '115' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MinimalOrderedSet,				#isMetaSide : false			},			#name : #'haveYouSeenThisObject:',			#protocol : #search,			#sourceCode : 'haveYouSeenThisObject: anObject \r\t"search for the object"\r\tself do: [ :each | \r\t\t(each=anObject) \r\t\tifTrue:["Transcript cr;show:each prettyPrint;cr".\r\t\t\t^true.]\r\t\t\r\t\t].\r\t^false.',			#stamp : 'pm 10/11/2018 13:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MinimalOrderedSet,				#isMetaSide : false			},			#name : #'haveYouSeenThisObject:',			#protocol : #search,			#sourceCode : 'haveYouSeenThisObject: anObject \r\t"search for the object"\r\tself do: [ :each | \r\t\t(each=anObject) \r\t\tifTrue:["Transcript cr;show:each prettyPrint;cr".\r\t\t\t^true.]\r\t\t].\r\t^false.',			#stamp : 'pm 10/11/2018 13:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T14:52:33.923043+02:00' ],		#prior : OmReference [ '115' ],		#self : OmReference [ '116' ]	},	#content : EpProtocolAddition {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #AbstractTerm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #AbstractTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'AbstractTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'AbstractTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #AbstractTerm,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #comparing	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T14:52:43.273961+02:00' ],		#prior : OmReference [ '116' ],		#self : OmReference [ '117' ]	},	#content : EpProtocolAddition {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #AbstractTerm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #AbstractTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'AbstractTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'AbstractTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #AbstractTerm,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #Skoleminsation	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T14:52:50.294982+02:00' ],		#prior : OmReference [ '117' ],		#self : OmReference [ '118' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #printing,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\telem:=aMap at:self ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 12:48',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\telem:=aMap at:self ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 12:48',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T14:52:52.442194+02:00' ],		#prior : OmReference [ '118' ],		#self : OmReference [ '119' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'=',			#protocol : #printing,			#sourceCode : '=anotherTerm\r\t(anotherTerm isKindOf: AbstractTerm)\r\tifTrue:[\r\t\t^(self getSymb)=(anotherTerm getSymb).\r\t\t]\r\tifFalse:[^false].',			#stamp : 'pm 10/11/2018 12:53',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t(anotherTerm isKindOf: AbstractTerm)\r\tifTrue:[\r\t\t^(self getSymb)=(anotherTerm getSymb).\r\t\t]\r\tifFalse:[^false].',			#stamp : 'pm 10/11/2018 12:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T14:53:04.500162+02:00' ],		#prior : OmReference [ '119' ],		#self : OmReference [ '120' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #'as yet unclassified',			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\telem:=aMap at:self ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 14:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T14:53:04.576739+02:00' ],		#prior : OmReference [ '120' ],		#self : OmReference [ '121' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #'as yet unclassified',			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\telem:=aMap at:self ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 14:53',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\telem:=aMap at:self ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 14:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T14:53:59.967676+02:00' ],		#prior : OmReference [ '121' ],		#self : OmReference [ '122' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\telem:=aMap at:self ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 14:53',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\tterms do: [ :each | ]',			#stamp : 'pm 10/11/2018 14:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T14:57:21.578758+02:00' ],		#prior : OmReference [ '122' ],		#self : OmReference [ '123' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\tterms do: [ :each | ]',			#stamp : 'pm 10/11/2018 14:53',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| newVars |\r\tnewVars:=LinkedList new.\r\tterms do: [ :each | newVars add: (each WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ]',			#stamp : 'pm 10/11/2018 14:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T14:58:28.71052+02:00' ],		#prior : OmReference [ '123' ],		#self : OmReference [ '124' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| newVars |\r\tnewVars:=LinkedList new.\r\tterms do: [ :each | newVars add: (each WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ]',			#stamp : 'pm 10/11/2018 14:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| newVars |\r\tnewVars:=LinkedList new.\r\tterms do: [ :each | newVars add: (each WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].\r\t^(FuncTerm new: (self getSymb) Variables:newVars).',			#stamp : 'pm 10/11/2018 14:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T14:59:22.481765+02:00' ],		#prior : OmReference [ '124' ],		#self : OmReference [ '125' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: symbl\r\tsymb:=symbl.\r\tterms:=LinkedList new.\r',			#stamp : 'pm 10/11/2018 14:59',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T14:59:54.784884+02:00' ],		#prior : OmReference [ '125' ],		#self : OmReference [ '126' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Predicate class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: symb\r\t^self basicNew initialize: symb.',			#stamp : 'pm 10/11/2018 14:59',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:00:22.063737+02:00' ],		#prior : OmReference [ '126' ],		#self : OmReference [ '127' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t^term prettyPrint',			#stamp : 'pm 10/11/2018 08:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:00:22.071624+02:00' ],		#prior : OmReference [ '127' ],		#self : OmReference [ '128' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'AbstractTerm',				#traitCompositionSource : '{}',				#definitionSource : 'AbstractTerm subclass: #UnaryTerm\r\tinstanceVariableNames: \'term\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #UnaryTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #UnaryTerm,						#isMetaSide : false					},					#name : #term,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'UnaryTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'UnaryTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #UnaryTerm,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #printing	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:01:11.996745+02:00' ],		#prior : OmReference [ '128' ],		#self : OmReference [ '129' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: symbo\r\tsymb:=symbo.\r\tterms:=LinkedList new.',			#stamp : 'pm 10/11/2018 15:01',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:01:23.332408+02:00' ],		#prior : OmReference [ '129' ],		#self : OmReference [ '130' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: symbo\r\t^self basicNew initialize:symbo.',			#stamp : 'pm 10/11/2018 15:01',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:01:50.832942+02:00' ],		#prior : OmReference [ '130' ],		#self : OmReference [ '131' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t^self basicNew initialize: (self getNewFuncName).',			#stamp : 'pm 10/11/2018 15:01',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:02:02.180345+02:00' ],		#prior : OmReference [ '131' ],		#self : OmReference [ '132' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #getNewFuncName,			#protocol : #'instance creation',			#sourceCode : 'getNewFuncName\r\t',			#stamp : 'pm 10/11/2018 15:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:02:15.858671+02:00' ],		#prior : OmReference [ '132' ],		#self : OmReference [ '133' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'AbstractTerm',				#traitCompositionSource : '{}',				#definitionSource : 'AbstractTerm subclass: #FuncTerm\r\tinstanceVariableNames: \'symb terms\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #FuncTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #symb,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #terms,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'FuncTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'FuncTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #FuncTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Func term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable was bound by an Exists, with a forall binding the said Exists beforehand.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with a standart name \'f\' for the function, and a list of terms.\r\r',				#stamp : 'pm 10/9/2018 10:43'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'AbstractTerm',				#traitCompositionSource : '{}',				#definitionSource : 'AbstractTerm subclass: #FuncTerm\r\tinstanceVariableNames: \'symb terms\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #FuncTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #symb,					#parent : @25				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #terms,					#parent : @25				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'FuncTerm class\r\tinstanceVariableNames: \'currentFuncNumber\''				},				#name : #'FuncTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'FuncTerm class',							#isMetaSide : true						},						#name : #currentFuncNumber,						#parent : @34					}				],				#baseClass : @25			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #FuncTerm,					#isMetaSide : false				},				#parent : @25,				#content : 'I represent a Func term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable was bound by an Exists, with a forall binding the said Exists beforehand.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with a standart name \'f\' for the function, and a list of terms.\r\r',				#stamp : 'pm 10/9/2018 10:43'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:02:28.21916+02:00' ],		#prior : OmReference [ '133' ],		#self : OmReference [ '134' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #'as yet unclassified',			#sourceCode : 'initialize\r\t',			#stamp : 'pm 10/11/2018 15:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:02:28.296915+02:00' ],		#prior : OmReference [ '134' ],		#self : OmReference [ '135' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #'as yet unclassified',			#sourceCode : 'initialize\r\t',			#stamp : 'pm 10/11/2018 15:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t',			#stamp : 'pm 10/11/2018 15:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:02:35.759376+02:00' ],		#prior : OmReference [ '135' ],		#self : OmReference [ '136' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t',			#stamp : 'pm 10/11/2018 15:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tcurrentFuncNumber :=0.\t',			#stamp : 'pm 10/11/2018 15:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:03:02.575758+02:00' ],		#prior : OmReference [ '136' ],		#self : OmReference [ '137' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #getNewFuncName,			#protocol : #'instance creation',			#sourceCode : 'getNewFuncName\r\t',			#stamp : 'pm 10/11/2018 15:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #getNewFuncName,			#protocol : #'instance creation',			#sourceCode : 'getNewFuncName\r\tcurrentFuncNumber :=currentFuncNumber +1.\r\t^currentFuncNumber asString.',			#stamp : 'pm 10/11/2018 15:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:03:41.48357+02:00' ],		#prior : OmReference [ '137' ],		#self : OmReference [ '138' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint ;cr;cr.\r\r\r\tTranscript show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint ;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint;cr;cr.\r\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' ; cr.\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint;cr;cr.\r\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\t  p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r     Transcript show:p prettyPrint;cr.\t\r\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'\t ; cr.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r   Transcript show:p prettyPrint;cr.\t\r\t\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/10/2018 21:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint ;cr;cr.\r\r"\r\tTranscript show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint ;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint;cr;cr.\r\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' ; cr.\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint;cr;cr.\r\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\t  p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r     Transcript show:p prettyPrint;cr.\t\r\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'\t ; cr.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r   Transcript show:p prettyPrint;cr.\t\r"\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/11/2018 15:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:05:57.86593+02:00' ],		#prior : OmReference [ '138' ],		#self : OmReference [ '139' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'newFunc:',			#protocol : #'instance creation',			#sourceCode : 'newFunc: variable\r\t^self basicNew initialize: (self getNewFuncName) Variable:variable.',			#stamp : 'pm 10/11/2018 15:05',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:06:09.028161+02:00' ],		#prior : OmReference [ '139' ],		#self : OmReference [ '140' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'newFunc:',			#protocol : #'instance creation',			#sourceCode : 'newFunc: variable\r\t^self basicNew initialize: (self getNewFuncName) Variable:variable.',			#stamp : 'pm 10/11/2018 15:05',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'newFunc:',			#protocol : #'instance creation',			#sourceCode : 'newFunc: varList\r\t^self basicNew initialize: (self getNewFuncName) Variables:varList.',			#stamp : 'pm 10/11/2018 15:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:06:34.08149+02:00' ],		#prior : OmReference [ '140' ],		#self : OmReference [ '141' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'newFuncWithVars:',			#protocol : #'instance creation',			#sourceCode : 'newFuncWithVars: varList\r\t^self basicNew initialize: (self getNewFuncName) Variables:varList.',			#stamp : 'pm 10/11/2018 15:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:07:38.498582+02:00' ],		#prior : OmReference [ '141' ],		#self : OmReference [ '142' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'newFunc:',			#protocol : #'instance creation',			#sourceCode : 'newFunc: varList\r\t^self basicNew initialize: (self getNewFuncName) Variables:varList.',			#stamp : 'pm 10/11/2018 15:06',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'newFunc:',			#protocol : #'instance creation',			#sourceCode : 'newFunc: variable\r\t^self basicNew initialize: (self getNewFuncName) Variable:variable.',			#stamp : 'pm 10/11/2018 15:07',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:09:13.975428+02:00' ],		#prior : OmReference [ '142' ],		#self : OmReference [ '143' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t| t |\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm new: \'f\' Variables: setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.\r\t\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 10/8/2018 20:31',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t| t |\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm new: setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.\r\t\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 10/11/2018 15:09',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:09:32.674296+02:00' ],		#prior : OmReference [ '143' ],		#self : OmReference [ '144' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t| t |\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm new: \'f\' Variables: setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.\t"(self class) new: ("\t")"\r\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 10/8/2018 20:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t| t |\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars: setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.\t"(self class) new: ("\t")"\r\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 10/11/2018 15:09',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:09:43.08485+02:00' ],		#prior : OmReference [ '144' ],		#self : OmReference [ '145' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t| t |\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm new: setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.\r\t\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 10/11/2018 15:09',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t| t |\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars:  setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.\r\t\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 10/11/2018 15:09',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:10:50.251576+02:00' ],		#prior : OmReference [ '145' ],		#self : OmReference [ '146' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'AbstractTerm',				#traitCompositionSource : '{}',				#definitionSource : 'AbstractTerm subclass: #FuncTerm\r\tinstanceVariableNames: \'symb terms\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #FuncTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #symb,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #terms,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'FuncTerm class\r\tinstanceVariableNames: \'currentFuncNumber\''				},				#name : #'FuncTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'FuncTerm class',							#isMetaSide : true						},						#name : #currentFuncNumber,						#parent : @16					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #FuncTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Func term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable was bound by an Exists, with a forall binding the said Exists beforehand.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with a standart name \'f\' for the function, and a list of terms.\r\r',				#stamp : 'pm 10/9/2018 10:43'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'AbstractTerm',				#traitCompositionSource : '{}',				#definitionSource : 'AbstractTerm subclass: #FuncTerm\r\tinstanceVariableNames: \'symb terms\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #FuncTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #symb,					#parent : @27				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #terms,					#parent : @27				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'FuncTerm class\r\tinstanceVariableNames: \'currentFuncNumber anonymousFuncSymb\''				},				#name : #'FuncTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'FuncTerm class',							#isMetaSide : true						},						#name : #currentFuncNumber,						#parent : @36					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'FuncTerm class',							#isMetaSide : true						},						#name : #anonymousFuncSymb,						#parent : @36					}				],				#baseClass : @27			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #FuncTerm,					#isMetaSide : false				},				#parent : @27,				#content : 'I represent a Func term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable was bound by an Exists, with a forall binding the said Exists beforehand.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with a standart name \'f\' for the function, and a list of terms.\r\r',				#stamp : 'pm 10/9/2018 10:43'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:11:01.611753+02:00' ],		#prior : OmReference [ '146' ],		#self : OmReference [ '147' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tcurrentFuncNumber :=0.\t',			#stamp : 'pm 10/11/2018 15:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tcurrentFuncNumber :=0.\r\tanonymousFuncSymb:=\'f\'.',			#stamp : 'pm 10/11/2018 15:11',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:11:15.926238+02:00' ],		#prior : OmReference [ '147' ],		#self : OmReference [ '148' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #getNewFuncName,			#protocol : #'instance creation',			#sourceCode : 'getNewFuncName\r\tcurrentFuncNumber :=currentFuncNumber +1.\r\t^currentFuncNumber asString.',			#stamp : 'pm 10/11/2018 15:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #getNewFuncName,			#protocol : #'instance creation',			#sourceCode : 'getNewFuncName\r\tcurrentFuncNumber :=currentFuncNumber +1.\r\t^anonymousFuncSymb,(currentFuncNumber asString).',			#stamp : 'pm 10/11/2018 15:11',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:15:13.819793+02:00' ],		#prior : OmReference [ '148' ],		#self : OmReference [ '149' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\telem:=aMap at:self ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 12:48',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\tTranscript show: aMap;cr.\r\t\telem:=aMap at:self ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 15:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:15:40.251471+02:00' ],		#prior : OmReference [ '149' ],		#self : OmReference [ '150' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\tTranscript show: aMap;cr.\r\t\telem:=aMap at:self ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 15:15',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\tTranscript show: aMap at:self;cr.\r\t\telem:=aMap at:self ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 15:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:15:45.66785+02:00' ],		#prior : OmReference [ '150' ],		#self : OmReference [ '151' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\tTranscript show: aMap at:self;cr.\r\t\telem:=aMap at:self ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 15:15',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\tTranscript show: (aMap at:self);cr.\r\t\telem:=aMap at:self ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 15:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:16:02.950823+02:00' ],		#prior : OmReference [ '151' ],		#self : OmReference [ '152' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\tTranscript show: (aMap at:self);cr.\r\t\telem:=aMap at:self ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 15:15',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\tTranscript show: self prettyPrint;cr.\r\t\telem:=aMap at:self ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 15:16',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:16:40.308455+02:00' ],		#prior : OmReference [ '152' ],		#self : OmReference [ '153' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\tTranscript show: self prettyPrint;cr.\r\t\telem:=aMap at:self ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 15:16',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\tTranscript show: aMap ; show:\'  \';show: self prettyPrint ;cr.\r\t\telem:=aMap at:self ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 15:16',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:17:24.211154+02:00' ],		#prior : OmReference [ '153' ],		#self : OmReference [ '154' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\tTranscript show: aMap ; show:\'  \';show: self prettyPrint ;cr.\r\t\telem:=aMap at:self ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 15:16',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\tTranscript show: aMap ; show:\'  \';show: self prettyPrint ; show: self class; cr.\r\t\telem:=aMap at:self ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 15:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:17:36.624968+02:00' ],		#prior : OmReference [ '154' ],		#self : OmReference [ '155' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\tTranscript show: aMap ; show:\'  \';show: self prettyPrint ; show: self class; cr.\r\t\telem:=aMap at:self ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 15:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\tTranscript show: aMap ; show:\'  \';show: self prettyPrint ; show: self class; cr.\r\t\telem:=aMap at:(self prettyPrint) ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 15:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:17:42.13694+02:00' ],		#prior : OmReference [ '155' ],		#self : OmReference [ '156' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\tTranscript show: aMap ; show:\'  \';show: self prettyPrint ; show: self class; cr.\r\t\telem:=aMap at:(self prettyPrint) ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 15:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\r\t\telem:=aMap at:(self prettyPrint) ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 15:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:17:43.341585+02:00' ],		#prior : OmReference [ '156' ],		#self : OmReference [ '157' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\r\t\telem:=aMap at:(self prettyPrint) ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 15:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\telem:=aMap at:(self prettyPrint) ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 15:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:18:24.865628+02:00' ],		#prior : OmReference [ '157' ],		#self : OmReference [ '158' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint ;cr;cr.\r\r"\r\tTranscript show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint ;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint;cr;cr.\r\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' ; cr.\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint;cr;cr.\r\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\t  p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r     Transcript show:p prettyPrint;cr.\t\r\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'\t ; cr.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r   Transcript show:p prettyPrint;cr.\t\r"\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/11/2018 15:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint ;cr;cr.\r\r\r\tTranscript show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint ;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint;cr;cr.\r\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' ; cr.\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint;cr;cr.\r\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\t  p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r     Transcript show:p prettyPrint;cr.\t\r\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'\t ; cr.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r   Transcript show:p prettyPrint;cr.\t\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/11/2018 15:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:27:55.720548+02:00' ],		#prior : OmReference [ '158' ],		#self : OmReference [ '159' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint ;cr;cr.\r\r\r\tTranscript show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint ;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint;cr;cr.\r\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' ; cr.\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint;cr;cr.\r\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\t  p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r     Transcript show:p prettyPrint;cr.\t\r\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'\t ; cr.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r   Transcript show:p prettyPrint;cr.\t\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/11/2018 15:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint ;cr;cr.\r\r\r\tTranscript show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint ;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint;cr;cr.\r\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' ; cr.\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint;cr;cr.\r\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\t  p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r     Transcript show:p prettyPrint;cr.\t\r\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'\t ; cr.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r   Transcript show:p prettyPrint;cr.\t\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'; cr.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms))).\r\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r   Transcript show:p prettyPrint;cr.\t\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/11/2018 15:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:47:46.825687+02:00' ],		#prior : OmReference [ '159' ],		#self : OmReference [ '160' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| newVars |\r\tnewVars:=LinkedList new.\r\tterms do: [ :each | newVars add: (each WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].\r\t^(FuncTerm new: (self getSymb) Variables:newVars).',			#stamp : 'pm 10/11/2018 14:58',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| newVars t|\r\tnewVars:=LinkedList new.\r\tterms do: [ :each | newVars add: (each WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].\r\tTranscript show:self prettyPrint;cr.\r\tt:=(FuncTerm new: (self getSymb) Variables:newVars).\r\tTranscript show:t prettyPrint;cr.\r\t^t.',			#stamp : 'pm 10/11/2018 15:47',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:49:26.03919+02:00' ],		#prior : OmReference [ '160' ],		#self : OmReference [ '161' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| newVars t|\r\tnewVars:=LinkedList new.\r\tterms do: [ :each | newVars add: (each WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].\r\tTranscript show:self prettyPrint;cr.\r\tt:=(FuncTerm new: (self getSymb) Variables:newVars).\r\tTranscript show:t prettyPrint;cr.\r\t^t.',			#stamp : 'pm 10/11/2018 15:47',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| newVars t|\r\tnewVars:=LinkedList new.\r\tTranscript show:setOfLinkedVar ;show:aMap.\r\tterms do: [ :each | newVars add: (each WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].\r\tTranscript show:self prettyPrint;cr.\r\tt:=(FuncTerm new: (self getSymb) Variables:newVars).\r\tTranscript show:t prettyPrint;cr.\r\t^t.',			#stamp : 'pm 10/11/2018 15:49',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:49:29.493868+02:00' ],		#prior : OmReference [ '161' ],		#self : OmReference [ '162' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| newVars t|\r\tnewVars:=LinkedList new.\r\tTranscript show:setOfLinkedVar ;show:aMap.\r\tterms do: [ :each | newVars add: (each WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].\r\tTranscript show:self prettyPrint;cr.\r\tt:=(FuncTerm new: (self getSymb) Variables:newVars).\r\tTranscript show:t prettyPrint;cr.\r\t^t.',			#stamp : 'pm 10/11/2018 15:49',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| newVars t|\r\tnewVars:=LinkedList new.\r\tTranscript show:setOfLinkedVar ;show:aMap cr.\r\tterms do: [ :each | newVars add: (each WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].\r\tTranscript show:self prettyPrint;cr.\r\tt:=(FuncTerm new: (self getSymb) Variables:newVars).\r\tTranscript show:t prettyPrint;cr.\r\t^t.',			#stamp : 'pm 10/11/2018 15:49',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:49:31.717114+02:00' ],		#prior : OmReference [ '162' ],		#self : OmReference [ '163' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| newVars t|\r\tnewVars:=LinkedList new.\r\tTranscript show:setOfLinkedVar ;show:aMap cr.\r\tterms do: [ :each | newVars add: (each WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].\r\tTranscript show:self prettyPrint;cr.\r\tt:=(FuncTerm new: (self getSymb) Variables:newVars).\r\tTranscript show:t prettyPrint;cr.\r\t^t.',			#stamp : 'pm 10/11/2018 15:49',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| newVars t|\r\tnewVars:=LinkedList new.\r\tTranscript show:setOfLinkedVar ;show:aMap ;cr.\r\tterms do: [ :each | newVars add: (each WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].\r\tTranscript show:self prettyPrint;cr.\r\tt:=(FuncTerm new: (self getSymb) Variables:newVars).\r\tTranscript show:t prettyPrint;cr.\r\t^t.',			#stamp : 'pm 10/11/2018 15:49',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T15:57:59.901372+02:00' ],		#prior : OmReference [ '163' ],		#self : OmReference [ '164' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t| t |\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars:  setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.\r\t\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 10/11/2018 15:09',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t| t |\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars:  setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\tTranscript show:aMap;cr.\r\t^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.\r\t\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 10/11/2018 15:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T16:02:13.209345+02:00' ],		#prior : OmReference [ '164' ],		#self : OmReference [ '165' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t| t |\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars:  setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\tTranscript show:aMap;cr.\r\t^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.\r\t\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 10/11/2018 15:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t| t |\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars:  setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.\r\t\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 10/11/2018 16:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T16:02:21.948673+02:00' ],		#prior : OmReference [ '165' ],		#self : OmReference [ '166' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t| t |\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars: setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.\t"(self class) new: ("\t")"\r\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 10/11/2018 15:09',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t| t |\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars: setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\tTranscript show:aMap;cr.\r\t^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.\t"(self class) new: ("\t")"\r\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 10/11/2018 16:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T16:10:18.177211+02:00' ],		#prior : OmReference [ '166' ],		#self : OmReference [ '167' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint ;cr;cr.\r\r\r\tTranscript show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint ;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint;cr;cr.\r\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' ; cr.\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint;cr;cr.\r\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\t  p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r     Transcript show:p prettyPrint;cr.\t\r\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'\t ; cr.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r   Transcript show:p prettyPrint;cr.\t\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'; cr.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms))).\r\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r   Transcript show:p prettyPrint;cr.\t\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/11/2018 15:27',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint ;cr;cr.\r\r\r\tTranscript show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint ;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint;cr;cr.\r\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' ; cr.\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint;cr;cr.\r\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\t  p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r     Transcript show:p prettyPrint;cr.\t\r\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'\t ; cr.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r   Transcript show:p prettyPrint;cr.\t\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'; cr.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r   Transcript show:p prettyPrint;cr.\t\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/11/2018 16:10',			#package : #_resolution_1erOrdre		}	}}