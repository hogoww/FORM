OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-27T23:34:00.239278+01:00' ],		#prior : OmReference [ 'Pharo.1gig92xmppp44kose4oi1ysy3', '275' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tdebug:=false.\r\tSkolemnTrace:=false.\r\tdebugUnification:=false.\r\tresolutionTrace:=true.\r\ttestNumber:=0.',			#stamp : 'pm 11/27/2018 21:27',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tdebug:=false.\r\tSkolemnTrace:=false.\r\tdebugUnification:=false.\r\tresolutionTrace:=true.\r\t',			#stamp : 'pm 11/27/2018 23:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:02:07.973722+01:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Binary class',				#isMetaSide : true			},			#name : #'new:rightProp:',			#protocol : #initialize,			#sourceCode : 'new: leftProp rightProp: rp\r\t^self basicNew initialize: leftProp rightProp: rp.',			#stamp : 'pm 9/28/2018 20:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Binary class',				#isMetaSide : true			},			#name : #'new:rightProp:',			#protocol : #initialize,			#sourceCode : 'new: leftProp rightProp: rightProp\r\t^self basicNew initialize: leftProp rightProp: rightProp.',			#stamp : 'pm 11/28/2018 00:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:02:21.754996+01:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Binary class',				#isMetaSide : true			},			#name : #'new:rightProp:',			#protocol : #initialize,			#sourceCode : 'new: leftProp rightProp: rightProp\r\t^self basicNew initialize: leftProp rightProp: rightProp.',			#stamp : 'pm 11/28/2018 00:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Binary class',				#isMetaSide : true			},			#name : #'new:rightProp:',			#protocol : #initialize,			#sourceCode : 'new: leftProp rightProp: rightProp\r\t\r\t^self basicNew initialize: leftProp rightProp: rightProp.',			#stamp : 'pm 11/28/2018 00:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:04:41.666426+01:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Binary class',				#isMetaSide : true			},			#name : #'new:rightProp:',			#protocol : #initialize,			#sourceCode : 'new: leftProp rightProp: rightProp\r\t\r\t^self basicNew initialize: leftProp rightProp: rightProp.',			#stamp : 'pm 11/28/2018 00:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Binary class',				#isMetaSide : true			},			#name : #'new:rightProp:',			#protocol : #initialize,			#sourceCode : 'new: leftProp rightProp: rightProp\r\t"Standart new for Unary Operators"\r\t"leftProp & rightProp should be subclass of the abstract class Prop"\r\t\r\t^self basicNew initialize: leftProp rightProp: rightProp.',			#stamp : 'pm 11/28/2018 00:04',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:06:17.524892+01:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'initialize:rightProp:',			#protocol : #initialize,			#sourceCode : 'initialize: leftProp rightProp: rightProp\r\t\r\tleft:=leftProp.\r\tright:=rightProp.\r\t',			#stamp : 'pm 11/27/2018 11:14',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'initialize:rightProp:',			#protocol : #initialize,			#sourceCode : 'initialize: leftProp rightProp: rightProp\r\t\t"Standart initialization for Unary Operators"\r\t"leftProp & rightProp should be subclass of the abstract class Prop"\r\r\tleft:=leftProp.\r\tright:=rightProp.\r\t',			#stamp : 'pm 11/28/2018 00:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:06:19.21554+01:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'initialize:rightProp:',			#protocol : #initialize,			#sourceCode : 'initialize: leftProp rightProp: rightProp\r\t\t"Standart initialization for Unary Operators"\r\t"leftProp & rightProp should be subclass of the abstract class Prop"\r\r\tleft:=leftProp.\r\tright:=rightProp.\r\t',			#stamp : 'pm 11/28/2018 00:06',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'initialize:rightProp:',			#protocol : #initialize,			#sourceCode : 'initialize: leftProp rightProp: rightProp\r\t"Standart initialization for Unary Operators"\r\t"leftProp & rightProp should be subclass of the abstract class Prop"\r\r\tleft:=leftProp.\r\tright:=rightProp.\r\t',			#stamp : 'pm 11/28/2018 00:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:07:04.668105+01:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\t(SkolemnTrace)ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Skolemnise: (setOfLinkedVar veryDeepCopy)  CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Skolemnise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t"Works for at least Or & And. Maybe Equal?"\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 11/27/2018 21:16',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\t(SkolemnTrace)ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Skolemnise: (setOfLinkedVar veryDeepCopy)  CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Skolemnise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t"Works for Or & And."\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 11/28/2018 00:07',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:08:11.397954+01:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Operator,				#isMetaSide : false			},			#name : #getSymb,			#protocol : #print,			#sourceCode : 'getSymb\r\t^(self class symb)',			#stamp : 'pm 9/28/2018 20:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Operator,				#isMetaSide : false			},			#name : #getSymb,			#protocol : #print,			#sourceCode : 'getSymb\r\t"accessor"\r\t^(self class symb)',			#stamp : 'pm 11/28/2018 00:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:08:38.758414+01:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Operator,				#isMetaSide : false			},			#name : #getSymb,			#protocol : #print,			#sourceCode : 'getSymb\r\t"accessor"\r\t^(self class symb)',			#stamp : 'pm 11/28/2018 00:08',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Operator,				#isMetaSide : false			},			#name : #getSymb,			#protocol : #print,			#sourceCode : 'getSymb\r\t"general accessor"\r\t^(self class symb)',			#stamp : 'pm 11/28/2018 00:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:09:40.835367+01:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherPredicate\r\t| res |\r\tres:=anotherPredicate isKindOf: self class."checking the input"\r\tres:=res and:[(self isSameSymb: anotherPredicate)]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherPredicate).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 10/24/2018 07:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherPredicate\r\t| res |\r\t"comparaison operator"\r\t\r\tres:=anotherPredicate isKindOf: self class."checking the input"\r\tres:=res and:[(self isSameSymb: anotherPredicate)]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherPredicate).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 11/28/2018 00:09',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:09:52.66966+01:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #arity,			#protocol : #accessing,			#sourceCode : 'arity\r\t^terms size.',			#stamp : 'pm 10/18/2018 15:56',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #arity,			#protocol : #accessing,			#sourceCode : 'arity\r\t"arity of underlying attribute"\r\t^terms size.',			#stamp : 'pm 11/28/2018 00:09',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:10:01.722937+01:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'contains:',			#protocol : #testing,			#sourceCode : 'contains: aTerm\r\t^ terms anySatisfy: [ :each | each contains: aTerm ]',			#stamp : 'pm 10/18/2018 22:08',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'contains:',			#protocol : #testing,			#sourceCode : 'contains: aTerm\r\t\r\t^ terms anySatisfy: [ :each | each contains: aTerm ]',			#stamp : 'pm 11/28/2018 00:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:11:28.782885+01:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'contains:',			#protocol : #testing,			#sourceCode : 'contains: aTerm\r\t\r\t^ terms anySatisfy: [ :each | each contains: aTerm ]',			#stamp : 'pm 11/28/2018 00:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'contains:',			#protocol : #testing,			#sourceCode : 'contains: aTerm\r\t"check if that predicate contains aTerm"\r\t^ terms anySatisfy: [ :each | each contains: aTerm ]',			#stamp : 'pm 11/28/2018 00:11',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:13:20.259589+01:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: symbl\r\tsymb:=symbl.\r\tterms:=LinkedListFix new.\r',			#stamp : 'pm 10/22/2018 09:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: symbl\r\t"Standart initialization for empty predicate"\r\t"symbl is the name of the predicate, as a string"\r\r\tsymb:=symbl.\r\tterms:=LinkedListFix new.\r',			#stamp : 'pm 11/28/2018 00:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:13:33.1576+01:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'initialize:Variable:',			#protocol : #initialization,			#sourceCode : 'initialize: symbl Variable: aTerm\r\t(aTerm isKindOf: AbstractTerm)\r\tifFalse:[Error new:\'Predicates needs terms as arguments.\'].\r\tsymb:=symbl.\r\tterms:=LinkedListFix new.\r\tterms add:aTerm.\r',			#stamp : 'pm 10/22/2018 09:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'initialize:Variable:',			#protocol : #initialization,			#sourceCode : 'initialize: symbl Variable: aTerm\r\t"Standart initialization for empty predicate"\r\t"symbl is the name of the predicate, as a string"\r\r\t(aTerm isKindOf: AbstractTerm)\r\tifFalse:[Error new:\'Predicates needs terms as arguments.\'].\r\tsymb:=symbl.\r\tterms:=LinkedListFix new.\r\tterms add:aTerm.\r',			#stamp : 'pm 11/28/2018 00:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:19:03.788066+01:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'initialize:Variable:',			#protocol : #initialization,			#sourceCode : 'initialize: symbl Variable: aTerm\r\t"Standart initialization for empty predicate"\r\t"symbl is the name of the predicate, as a string"\r\r\t(aTerm isKindOf: AbstractTerm)\r\tifFalse:[Error new:\'Predicates needs terms as arguments.\'].\r\tsymb:=symbl.\r\tterms:=LinkedListFix new.\r\tterms add:aTerm.\r',			#stamp : 'pm 11/28/2018 00:13',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'initialize:Variable:',			#protocol : #initialization,			#sourceCode : 'initialize: symbl Variable: aTerm\r\t"Standart initialization for unary predicate"\r\t"symbl is the name of the predicate, as a string"\r\t"aTerm has to be a kind of Abstract term, depending on when you want to use it for"\r\t"if it\'s pre skolemnisation, you should give a Term, otherwise a specialisation of a Abstract Term\r\t(functerm/constterm/linkedterm)"\r\r\t(aTerm isKindOf: AbstractTerm)\r\tifFalse:[Error new:\'Predicates needs terms as arguments.\'].\r\tsymb:=symbl.\r\tterms:=LinkedListFix new.\r\tterms add:aTerm.\r',			#stamp : 'pm 11/28/2018 00:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:22:50.543997+01:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'initialize:Variables:',			#protocol : #initialization,			#sourceCode : 'initialize: symbl Variables: aLinkedListOfTerm\r\tsymb:=symbl.\r\taLinkedListOfTerm do:[:each| \r\t\t(each isKindOf: AbstractTerm)\r\t\tifFalse:[Error new:\'Predicates needs terms as arguments.\'].\r\t\t].\r\tterms:=aLinkedListOfTerm.',			#stamp : 'pm 10/18/2018 16:44',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'initialize:Variables:',			#protocol : #initialization,			#sourceCode : 'initialize: symbl Variables: aLinkedListOfTerm\r\t"Standart initialization for unary predicate"\r\t"symbl is the name of the predicate, as a string"\r\t"aLinkedListOfTerm has to be a LinkedList of kind of Abstract term, depending on when you want to use it for"\r\t"if it\'s pre skolemnisation, you should give Terms, otherwise a specialisation of a Abstract Terms\r\t(functerm/constterm/linkedterm)"\r\t\r\tsymb:=symbl.\r\taLinkedListOfTerm do:[:each| \r\t\t(each isKindOf: AbstractTerm)\r\t\tifFalse:[Error new:\'Predicates needs terms as arguments.\'].\r\t\t].\r\tterms:=aLinkedListOfTerm.',			#stamp : 'pm 11/28/2018 00:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:23:25.58576+01:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Atome',				#traitCompositionSource : '{}',				#definitionSource : 'Atome subclass: #Predicate\r\tinstanceVariableNames: \'symb terms\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Predicate,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Predicate,						#isMetaSide : false					},					#name : #symb,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Predicate,						#isMetaSide : false					},					#name : #terms,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Predicate class\r\tinstanceVariableNames: \'\''				},				#name : #'Predicate class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Predicate,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Predicate with a list of terms,\r\rAlso in ClausaleForm we\'ll be representing a Positive predicate.\r\rPublic API and Key Messages\r\rCan be created two ways :\r-new: PredicateName\r-new: PredicateName Variable:aTerm\r-new: PredicateName Variables: aListOfTerm\r\r\t"aTerm has to be a kind of Abstract term, depending on when you want to use it for"\r\t"if it\'s pre skolemnisation, you should give a Term, otherwise a specialisation of a Abstract Term\r\t(functerm/constterm/linkedterm)"\r',				#stamp : 'pm 11/28/2018 00:23'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'I represent a Predicate with a list of terms,\r\rAlso in ClausaleForm we\'ll be representing a Positive predicate.\r\rPublic API and Key Messages\r\rCan be created two ways :\r-new: PredicateName Variable:aTerm\r-new: PredicateName Variables: aListOfTerm\r\r',		#newComment : 'I represent a Predicate with a list of terms,\r\rAlso in ClausaleForm we\'ll be representing a Positive predicate.\r\rPublic API and Key Messages\r\rCan be created two ways :\r-new: PredicateName\r-new: PredicateName Variable:aTerm\r-new: PredicateName Variables: aListOfTerm\r\r\t"aTerm has to be a kind of Abstract term, depending on when you want to use it for"\r\t"if it\'s pre skolemnisation, you should give a Term, otherwise a specialisation of a Abstract Term\r\t(functerm/constterm/linkedterm)"\r',		#oldStamp : 'pm 10/9/2018 11:29',		#newStamp : 'pm 11/28/2018 00:23'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:25:12.709633+01:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Atome',				#traitCompositionSource : '{}',				#definitionSource : 'Atome subclass: #Predicate\r\tinstanceVariableNames: \'symb terms\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Predicate,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Predicate,						#isMetaSide : false					},					#name : #symb,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Predicate,						#isMetaSide : false					},					#name : #terms,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Predicate class\r\tinstanceVariableNames: \'\''				},				#name : #'Predicate class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Predicate,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Predicate with a list of terms,\r\rAlso in ClausaleForm we\'ll be representing a Positive predicate.\r\rPublic API and Key Messages\r\rCan be created two ways :\r-new: PredicateName\r-new: PredicateName Variable:aTerm\r-new: PredicateName Variables: aListOfTerm\r\rIf it\'s a pre skolemnisation you should give a Term, \rOtherwise you should give a specialisation of abstract term\r(functerm/constterm/linkedterm) depending on what you need (of course)\r',				#stamp : 'pm 11/28/2018 00:25'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'I represent a Predicate with a list of terms,\r\rAlso in ClausaleForm we\'ll be representing a Positive predicate.\r\rPublic API and Key Messages\r\rCan be created two ways :\r-new: PredicateName\r-new: PredicateName Variable:aTerm\r-new: PredicateName Variables: aListOfTerm\r\r\t"aTerm has to be a kind of Abstract term, depending on when you want to use it for"\r\t"if it\'s pre skolemnisation, you should give a Term, otherwise a specialisation of a Abstract Term\r\t(functerm/constterm/linkedterm)"\r',		#newComment : 'I represent a Predicate with a list of terms,\r\rAlso in ClausaleForm we\'ll be representing a Positive predicate.\r\rPublic API and Key Messages\r\rCan be created two ways :\r-new: PredicateName\r-new: PredicateName Variable:aTerm\r-new: PredicateName Variables: aListOfTerm\r\rIf it\'s a pre skolemnisation you should give a Term, \rOtherwise you should give a specialisation of abstract term\r(functerm/constterm/linkedterm) depending on what you need (of course)\r',		#oldStamp : 'pm 11/28/2018 00:23',		#newStamp : 'pm 11/28/2018 00:25'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:25:19.00452+01:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Atome',				#traitCompositionSource : '{}',				#definitionSource : 'Atome subclass: #Predicate\r\tinstanceVariableNames: \'symb terms\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Predicate,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Predicate,						#isMetaSide : false					},					#name : #symb,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Predicate,						#isMetaSide : false					},					#name : #terms,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Predicate class\r\tinstanceVariableNames: \'\''				},				#name : #'Predicate class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Predicate,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Predicate with a list of terms,\r\rAlso in ClausaleForm we\'ll be representing a Positive predicate.\r\rCan be created two ways :\r-new: PredicateName\r-new: PredicateName Variable:aTerm\r-new: PredicateName Variables: aListOfTerm\r\rIf it\'s a pre skolemnisation you should give a Term, \rOtherwise you should give a specialisation of abstract term\r(functerm/constterm/linkedterm) depending on what you need (of course)\r',				#stamp : 'pm 11/28/2018 00:25'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'I represent a Predicate with a list of terms,\r\rAlso in ClausaleForm we\'ll be representing a Positive predicate.\r\rPublic API and Key Messages\r\rCan be created two ways :\r-new: PredicateName\r-new: PredicateName Variable:aTerm\r-new: PredicateName Variables: aListOfTerm\r\rIf it\'s a pre skolemnisation you should give a Term, \rOtherwise you should give a specialisation of abstract term\r(functerm/constterm/linkedterm) depending on what you need (of course)\r',		#newComment : 'I represent a Predicate with a list of terms,\r\rAlso in ClausaleForm we\'ll be representing a Positive predicate.\r\rCan be created two ways :\r-new: PredicateName\r-new: PredicateName Variable:aTerm\r-new: PredicateName Variables: aListOfTerm\r\rIf it\'s a pre skolemnisation you should give a Term, \rOtherwise you should give a specialisation of abstract term\r(functerm/constterm/linkedterm) depending on what you need (of course)\r',		#oldStamp : 'pm 11/28/2018 00:25',		#newStamp : 'pm 11/28/2018 00:25'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:26:30.261772+01:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #isConst,			#protocol : #testing,			#sourceCode : 'isConst\r\tterms do:[:each | (each isConst)ifFalse:[^false]].\r\t^true',			#stamp : 'pm 10/20/2018 09:14',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #isConst,			#protocol : #testing,			#sourceCode : 'isConst\r\t"check if every term in the list of terms is const"\r\tterms do:[:each | (each isConst)ifFalse:[^false]].\r\t^true',			#stamp : 'pm 11/28/2018 00:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:27:20.035139+01:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isOpposite:',			#protocol : #comparing,			#sourceCode : 'isOpposite: anotherPredicate\r\t| res |\r\tres:=((anotherPredicate isPredicate) and:[(anotherPredicate isKindOf: self class) not])."checking the input"\r\tres:=res and:[(self isSameSymb: anotherPredicate)]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherPredicate).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 10/24/2018 07:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isOpposite:',			#protocol : #comparing,			#sourceCode : 'isOpposite: anotherPredicate\r\t"Check if this predicate is the equal to anotherPredicate, but is the opposite polarity"\r\t| res |\r\tres:=((anotherPredicate isPredicate) and:[(anotherPredicate isKindOf: self class) not])."checking the input"\r\tres:=res and:[(self isSameSymb: anotherPredicate)]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherPredicate).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 11/28/2018 00:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:29:02.281776+01:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isOppositePolarity:',			#protocol : #comparing,			#sourceCode : 'isOppositePolarity: anotherPredicate\r\t^ anotherPredicate isPredicate\tand: [ anotherPredicate class ~= self class ]',			#stamp : 'pm 10/26/2018 16:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isOppositePolarity:',			#protocol : #comparing,			#sourceCode : 'isOppositePolarity: anotherPredicate\r\t\r\t^ anotherPredicate isPredicate\tand: [ anotherPredicate class ~= self class ]',			#stamp : 'pm 11/28/2018 00:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:30:10.176753+01:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isOpposite:',			#protocol : #comparing,			#sourceCode : 'isOpposite: anotherPredicate\r\t"Check if this predicate is the equal to anotherPredicate, but is the opposite polarity"\r\t| res |\r\tres:=((anotherPredicate isPredicate) and:[(anotherPredicate isKindOf: self class) not])."checking the input"\r\tres:=res and:[(self isSameSymb: anotherPredicate)]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherPredicate).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 11/28/2018 00:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isOpposite:',			#protocol : #comparing,			#sourceCode : 'isOpposite: anotherPredicate\r\t"Check if this predicate is the equal to anotherPredicate, but is the opposite polarity"\r\t| res |\r\tres:=self isOppositePolarity: anotherPredicate.\r\tres:=res and:[(self isSameSymb: anotherPredicate)]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherPredicate).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 11/28/2018 00:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:30:56.661582+01:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isOpposite:',			#protocol : #comparing,			#sourceCode : 'isOpposite: anotherPredicate\r\t"Check if this predicate is the equal to anotherPredicate, but is the opposite polarity"\r\t| res |\r\tres:=self isOppositePolarity: anotherPredicate.\r\tres:=res and:[(self isSameSymb: anotherPredicate)]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherPredicate).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 11/28/2018 00:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isOpposite:',			#protocol : #comparing,			#sourceCode : 'isOpposite: anotherPredicate\r\t"Check if this predicate is the equal to anotherPredicate, but is the opposite polarity"\r\t| res |\r\tres:=self isOppositePolarity: anotherPredicate."checking if they are opposite polarity"\r\tres:=res and:[(self isSameSymb: anotherPredicate)]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherPredicate).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 11/28/2018 00:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:32:27.665328+01:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isOppositePolarity:',			#protocol : #comparing,			#sourceCode : 'isOppositePolarity: anotherPredicate\r\t\r\t^ anotherPredicate isPredicate\tand: [ anotherPredicate class ~= self class ]',			#stamp : 'pm 11/28/2018 00:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isOppositePolarity:',			#protocol : #comparing,			#sourceCode : 'isOppositePolarity: anotherPredicate\r\t"check if it\'s the opposite polarity"\r\t^ anotherPredicate isPredicate\tand: [ anotherPredicate class ~= self class ]',			#stamp : 'pm 11/28/2018 00:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:32:46.122744+01:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameArity:',			#protocol : #testing,			#sourceCode : 'isSameArity:anotherPredicate\r\t^(self arity)=(anotherPredicate arity).',			#stamp : 'pm 10/18/2018 16:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameArity:',			#protocol : #testing,			#sourceCode : 'isSameArity:anotherPredicate\r\t"check if the two predicate have the same arity"\r\t^(self arity)=(anotherPredicate arity).',			#stamp : 'pm 11/28/2018 00:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:33:09.823749+01:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting: anotherPredicate\r\t"Comparaison Operator, without carring for anonymous stuff."\r\t| res |\r\tself assert:(anotherPredicate class=self class)."checking the input"\r\tres:=self isSameSymb: anotherPredicate."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTermsForTesting: anotherPredicate).].\r\t^res.',			#stamp : 'pm 11/5/2018 09:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting: anotherPredicate\r\t"Comparaison Operator, without carring for anonymous const/functerm."\r\t| res |\r\tself assert:(anotherPredicate class=self class)."checking the input"\r\tres:=self isSameSymb: anotherPredicate."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTermsForTesting: anotherPredicate).].\r\t^res.',			#stamp : 'pm 11/28/2018 00:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:45:19.111596+01:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [\r\t\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].\r\t^self',			#stamp : 'pm 10/24/2018 07:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [\r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].\r\t^self',			#stamp : 'pm 11/28/2018 00:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:56:18.225354+01:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #isClause,			#protocol : #clausification,			#sourceCode : 'isClause\r\t^true',			#stamp : 'pm 9/29/2018 08:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #isClause,			#protocol : #clausification,			#sourceCode : 'isClause\r\t"tester"\r\t^true',			#stamp : 'pm 11/28/2018 00:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T00:58:56.414275+01:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #isSkolem,			#protocol : #testing,			#sourceCode : 'isSkolem\r\t^true.',			#stamp : 'pm 10/5/2018 23:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T01:04:29.993365+01:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting:prop2\r\t^self=prop2',			#stamp : 'pm 11/5/2018 09:28',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting:prop2\r\t"comparaison operator for automated testing"\r\t^self=prop2',			#stamp : 'pm 11/28/2018 01:04',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T01:09:16.240673+01:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'compareSymbol:',			#protocol : #matching,			#sourceCode : 'compareSymbol: otherProp\r\t^(self getSymb = otherProp getSymb) ',			#stamp : 'pm 9/30/2018 10:16',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'compareSymbol:',			#protocol : #matching,			#sourceCode : 'compareSymbol: otherProp\r\t"comparaison operator for proposition, which all have symbols"\r\t^(self getSymb = otherProp getSymb) ',			#stamp : 'pm 11/28/2018 01:09',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T01:10:00.278576+01:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Operator class',				#isMetaSide : true			},			#name : #symb,			#protocol : #accessing,			#sourceCode : 'symb\r\t^symb.',			#stamp : 'pm 10/4/2018 23:44',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Operator class',				#isMetaSide : true			},			#name : #symb,			#protocol : #accessing,			#sourceCode : 'symb\r\t"accessor"\r\t^symb.',			#stamp : 'pm 11/28/2018 01:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T01:10:42.565037+01:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Predicate class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: symb\r\t^self basicNew initialize: symb.',			#stamp : 'pm 10/11/2018 14:59',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Predicate class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: symb\r\t"Standart new for empty predicate"\r\t"symbl is the name of the predicate, as a string"\r\t^self basicNew initialize: symb.',			#stamp : 'pm 11/28/2018 01:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T01:11:02.654926+01:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Predicate class',				#isMetaSide : true			},			#name : #'new:fromList:',			#protocol : #'instance creation',			#sourceCode : 'new: symb fromList: aList\r\t^self basicNew initialize: symb Variables: aList.',			#stamp : 'pm 10/8/2018 17:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Predicate class',				#isMetaSide : true			},			#name : #'new:fromList:',			#protocol : #'instance creation',			#sourceCode : 'new: symb fromList: aList\r\t"Standart new for unary predicate"\r\t"symbl is the name of the predicate, as a string"\r\t"aTerm has to be a kind of Abstract term, depending on when you want to use it for"\r\t"if it\'s pre skolemnisation, you should give a Term, otherwise a specialisation of a Abstract Term\r\t(functerm/constterm/linkedterm)"\r\t^self basicNew initialize: symb Variables: aList.',			#stamp : 'pm 11/28/2018 01:11',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T01:11:17.656883+01:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Predicate class',				#isMetaSide : true			},			#name : #'new:variable:',			#protocol : #'instance creation',			#sourceCode : 'new: symb variable: aVar\r\t^self basicNew initialize: symb Variable:aVar.',			#stamp : 'pm 10/5/2018 20:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Predicate class',				#isMetaSide : true			},			#name : #'new:variable:',			#protocol : #'instance creation',			#sourceCode : 'new: symb variable: aVar\r\t"Standart initialization for unary predicate"\r\t"symbl is the name of the predicate, as a string"\r\t"aLinkedListOfTerm has to be a LinkedList of kind of Abstract term, depending on when you want to use it for"\r\t"if it\'s pre skolemnisation, you should give Terms, otherwise a specialisation of a Abstract Terms\r\t(functerm/constterm/linkedterm)"\r\t\r\t^self basicNew initialize: symb Variable:aVar.',			#stamp : 'pm 11/28/2018 01:11',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T01:11:34.530122+01:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Predicate class',				#isMetaSide : true			},			#name : #'new:variable:',			#protocol : #'instance creation',			#sourceCode : 'new: symb variable: aVar\r\t"Standart initialization for unary predicate"\r\t"symbl is the name of the predicate, as a string"\r\t"aLinkedListOfTerm has to be a LinkedList of kind of Abstract term, depending on when you want to use it for"\r\t"if it\'s pre skolemnisation, you should give Terms, otherwise a specialisation of a Abstract Terms\r\t(functerm/constterm/linkedterm)"\r\t\r\t^self basicNew initialize: symb Variable:aVar.',			#stamp : 'pm 11/28/2018 01:11',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Predicate class',				#isMetaSide : true			},			#name : #'new:variable:',			#protocol : #'instance creation',			#sourceCode : 'new: symb variable: aVar\r\t"Standart new for variadic predicate"\r\t"symbl is the name of the predicate, as a string"\r\t"aLinkedListOfTerm has to be a LinkedList of kind of Abstract term, depending on when you want to use it for"\r\t"if it\'s pre skolemnisation, you should give Terms, otherwise a specialisation of a Abstract Terms\r\t(functerm/constterm/linkedterm)"\r\t\r\t^self basicNew initialize: symb Variable:aVar.',			#stamp : 'pm 11/28/2018 01:11',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T01:11:39.948692+01:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'initialize:Variables:',			#protocol : #initialization,			#sourceCode : 'initialize: symbl Variables: aLinkedListOfTerm\r\t"Standart initialization for unary predicate"\r\t"symbl is the name of the predicate, as a string"\r\t"aLinkedListOfTerm has to be a LinkedList of kind of Abstract term, depending on when you want to use it for"\r\t"if it\'s pre skolemnisation, you should give Terms, otherwise a specialisation of a Abstract Terms\r\t(functerm/constterm/linkedterm)"\r\t\r\tsymb:=symbl.\r\taLinkedListOfTerm do:[:each| \r\t\t(each isKindOf: AbstractTerm)\r\t\tifFalse:[Error new:\'Predicates needs terms as arguments.\'].\r\t\t].\r\tterms:=aLinkedListOfTerm.',			#stamp : 'pm 11/28/2018 00:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'initialize:Variables:',			#protocol : #initialization,			#sourceCode : 'initialize: symbl Variables: aLinkedListOfTerm\r\t"Standart initialization for variadic predicate"\r\t"symbl is the name of the predicate, as a string"\r\t"aLinkedListOfTerm has to be a LinkedList of kind of Abstract term, depending on when you want to use it for"\r\t"if it\'s pre skolemnisation, you should give Terms, otherwise a specialisation of a Abstract Terms\r\t(functerm/constterm/linkedterm)"\r\t\r\tsymb:=symbl.\r\taLinkedListOfTerm do:[:each| \r\t\t(each isKindOf: AbstractTerm)\r\t\tifFalse:[Error new:\'Predicates needs terms as arguments.\'].\r\t\t].\r\tterms:=aLinkedListOfTerm.',			#stamp : 'pm 11/28/2018 01:11',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T01:13:00.151872+01:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Constant class',				#isMetaSide : true			},			#name : #symb,			#protocol : #'as yet unclassified',			#sourceCode : 'symb\r\t^symb',			#stamp : 'pm 11/28/2018 01:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T01:13:00.373635+01:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Constant class',				#isMetaSide : true			},			#name : #symb,			#protocol : #'as yet unclassified',			#sourceCode : 'symb\r\t^symb',			#stamp : 'pm 11/28/2018 01:13',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Constant class',				#isMetaSide : true			},			#name : #symb,			#protocol : #accessing,			#sourceCode : 'symb\r\t^symb',			#stamp : 'pm 11/28/2018 01:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T01:13:09.800115+01:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'False_Const class',				#isMetaSide : true			},			#name : #symb,			#protocol : #accessing,			#sourceCode : 'symb\r\t^symb',			#stamp : 'pm 9/28/2018 21:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T01:13:16.708562+01:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpProtocolRemoval {		#behavior : RGMetaclassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'False_Const class\r\tinstanceVariableNames: \'\''			},			#name : #'False_Const class',			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#baseClass : RGClassDefinition {				#annotations : IdentityDictionary {					#superclassName : 'Constant',					#traitCompositionSource : '{}',					#definitionSource : 'Constant subclass: #False_Const\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''				},				#name : #False_Const,				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#metaClass : @7,				#comment : RGCommentDefinition {					#annotations : IdentityDictionary {						#className : #False_Const,						#isMetaSide : false					},					#parent : @12,					#content : 'False const',					#stamp : '<historical>'				},				#classVariables : OrderedCollection [ ],				#category : #_resolution_1erOrdre-Propositions,				#package : #_resolution_1erOrdre,				#sharedPools : OrderedCollection [ ]			}		},		#protocol : #accessing	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T01:13:24.476013+01:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'True_Const class',				#isMetaSide : true			},			#name : #symb,			#protocol : #accessing,			#sourceCode : 'symb\r\t^symb',			#stamp : 'pm 9/28/2018 21:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T01:13:28.709651+01:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpProtocolRemoval {		#behavior : RGMetaclassDefinition {			#annotations : IdentityDictionary {				#traitCompositionSource : '{}',				#definitionSource : 'True_Const class\r\tinstanceVariableNames: \'\''			},			#name : #'True_Const class',			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#baseClass : RGClassDefinition {				#annotations : IdentityDictionary {					#superclassName : 'Constant',					#traitCompositionSource : '{}',					#definitionSource : 'Constant subclass: #True_Const\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''				},				#name : #True_Const,				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#metaClass : @7,				#comment : RGCommentDefinition {					#annotations : IdentityDictionary {						#className : #True_Const,						#isMetaSide : false					},					#parent : @12,					#content : 'True Const\r',					#stamp : '<historical>'				},				#classVariables : OrderedCollection [ ],				#category : #_resolution_1erOrdre-Propositions,				#package : #_resolution_1erOrdre,				#sharedPools : OrderedCollection [ ]			}		},		#protocol : #accessing	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T01:13:44.330058+01:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #'new:variable:',			#protocol : #'instance creation',			#sourceCode : 'new: symb variable: aVar\r\t"Standart new for variadic predicate"\r\t"symbl is the name of the predicate, as a string"\r\t"aLinkedListOfTerm has to be a LinkedList of kind of Abstract term, depending on when you want to use it for"\r\t"if it\'s pre skolemnisation, you should give Terms, otherwise a specialisation of a Abstract Terms\r\t(functerm/constterm/linkedterm)"\r\t\r\t^self basicNew initialize: symb Variable:aVar.',			#stamp : 'pm 11/28/2018 01:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T01:13:44.373653+01:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Predicate class',				#isMetaSide : true			},			#name : #'new:variable:',			#protocol : #'instance creation',			#sourceCode : 'new: symb variable: aVar\r\t"Standart new for variadic predicate"\r\t"symbl is the name of the predicate, as a string"\r\t"aLinkedListOfTerm has to be a LinkedList of kind of Abstract term, depending on when you want to use it for"\r\t"if it\'s pre skolemnisation, you should give Terms, otherwise a specialisation of a Abstract Terms\r\t(functerm/constterm/linkedterm)"\r\t\r\t^self basicNew initialize: symb Variable:aVar.',			#stamp : 'pm 11/28/2018 01:11',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T01:19:08.448577+01:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"abstract class, not meant to be instanciated"\r\t^SubclassResponsibility \r',			#stamp : 'pm 11/28/2018 01:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T01:19:13.180806+01:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #'new:variable:',			#protocol : #'instance creation',			#sourceCode : 'new: symb variable: aVar\r\t"Standart new for variadic predicate"\r\t"symbl is the name of the predicate, as a string"\r\t"aLinkedListOfTerm has to be a LinkedList of kind of Abstract term, depending on when you want to use it for"\r\t"if it\'s pre skolemnisation, you should give Terms, otherwise a specialisation of a Abstract Terms\r\t(functerm/constterm/linkedterm)"\r\t\r\t^self basicNew initialize: symb Variable:aVar.',			#stamp : 'pm 11/28/2018 01:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T01:21:19.2046+01:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'UnaryTerm class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: aTerm\r\t"Creation of a term, with a symbol"\r\t^(self basicNew) initialize:aTerm.',			#stamp : 'pm 10/28/2018 15:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'UnaryTerm class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: aTerm\r\t"Creation of a specialized term, with a symbol"\r\t^(self basicNew) initialize:aTerm.',			#stamp : 'pm 11/28/2018 01:21',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-28T01:23:18.311457+01:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Pair class',				#isMetaSide : true			},			#name : #'left:right:',			#protocol : #initialize-release,			#sourceCode : 'left:l right:r\r\t^(self basicNew) left:l right:r.',			#stamp : 'pm 10/15/2018 16:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Pair class',				#isMetaSide : true			},			#name : #'left:right:',			#protocol : #initialize-release,			#sourceCode : 'left:l right:r\r\t"Basic new for a pair"\r\t^(self basicNew) left:l right:r.',			#stamp : 'pm 11/28/2018 01:23',			#package : #_resolution_1erOrdre		}	}}