OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:11:02.093961+01:00' ],		#prior : OmReference [ 'Pharo.6rda8ucwzyefhe46r3i2nejdz', '134' ],		#self : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemn2,			#protocol : #basic,			#sourceCode : 'testBasicSkolemn2\r\t| p res expected terms terms2 |\r\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'z\').\t\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\r\tterms2:=LinkedList new.\r\tterms2 add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\')).\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\tTranscript show:res;cr.\r\tTranscript show:expected;cr.\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:11',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:11:11.453194+01:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemn1,			#protocol : #basic,			#sourceCode : 'testBasicSkolemn1\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new.\r\tterms2 add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\')).\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\tTranscript show:res;cr.\r\tTranscript show:expected;cr.\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:11',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:11:21.265962+01:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemnTest1,			#protocol : #basic,			#sourceCode : 'testBasicSkolemnTest1\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new.\r\tterms2 add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\')).\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\tTranscript show:res;cr.\r\tTranscript show:expected;cr.\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 09:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:11:50.051104+01:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemn1,			#protocol : #basic,			#sourceCode : 'testBasicSkolemn1\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new.\r\tterms2 add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\')).\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\tTranscript show:res;cr.\r\tTranscript show:expected;cr.\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:11',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemn1,			#protocol : #basic,			#sourceCode : 'testBasicSkolemn1\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new.\r\tterms2 add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\')).\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:11',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:13:30.170805+01:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemn2,			#protocol : #basic,			#sourceCode : 'testBasicSkolemn2\r\t| p res expected terms terms2 |\r\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'z\').\t\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\r\tterms2:=LinkedList new.\r\tterms2 add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\')).\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\tTranscript show:res;cr.\r\tTranscript show:expected;cr.\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:11',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemn2,			#protocol : #basic,			#sourceCode : 'testBasicSkolemn2\r\t| p res expected terms terms2 |\r\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'z\').\t\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\r\t\r\tterms2:=LinkedList new.\r\tterms2 add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\')).\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:15:42.683305+01:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemn2,			#protocol : #basic,			#sourceCode : 'testBasicSkolemn2\r\t| p res expected terms terms2 |\r\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'z\').\t\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\r\t\r\tterms2:=LinkedList new.\r\tterms2 add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\')).\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:13',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemn2,			#protocol : #basic,			#sourceCode : 'testBasicSkolemn2\r\t| p res expected terms terms2 |\r\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'z\').\t\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\r\t\r\tterms2:=LinkedList new.\r\tterms2 add:(LinkedTerm new:(Term new:\'x\')); add:(LinkedTerm new:(Term new:\'z\')).\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:16:15.138089+01:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemn2,			#protocol : #basic,			#sourceCode : 'testBasicSkolemn2\r\t| p res expected terms terms2 |\r\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'z\').\t\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\r\t\r\tterms2:=LinkedList new.\r\tterms2 add:(LinkedTerm new:(Term new:\'x\')); add:(LinkedTerm new:(Term new:\'z\')).\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:15',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemn2,			#protocol : #basic,			#sourceCode : 'testBasicSkolemn2\r\t| p res expected terms terms2 |\r\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'z\').\t\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\r\t\r\tterms2:=LinkedList new.\r\tterms2 add:(LinkedTerm new:(Term new:\'x\')); add:(LinkedTerm new:(Term new:\'z\')).\r\texpected:=Or new: (Predicate new: \'P\' fromList: terms2)\r\t\t\t\t\trightProp: (Predicate new: \'P\' fromList: terms2).\r\t\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:16',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:22:04.909788+01:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemn2,			#protocol : #basic,			#sourceCode : 'testBasicSkolemn2\r\t| p res expected terms terms2 |\r\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'z\').\t\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\r\t\r\tterms2:=LinkedList new.\r\tterms2 add:(LinkedTerm new:(Term new:\'x\')); add:(LinkedTerm new:(Term new:\'z\')).\r\texpected:=Or new: (Predicate new: \'P\' fromList: terms2)\r\t\t\t\t\trightProp: (Predicate new: \'P\' fromList: terms2).\r\t\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:16',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemn2,			#protocol : #basic,			#sourceCode : 'testBasicSkolemn2\r\t| p res expected terms |\r\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tres:=p StartSkolemnisation.\r\t\r\tterms:=LinkedList new add:(LinkedTerm new:(Term new:\'x\')); add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\tself halt.\r\texpected:=Or new: (Predicate new: \'P\' fromList: terms)\r\t\t\t\t\trightProp: (Predicate new: \'P\' fromList: terms).\r\t\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:22:59.514662+01:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemn2,			#protocol : #basic,			#sourceCode : 'testBasicSkolemn2\r\t| p res expected terms |\r\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tres:=p StartSkolemnisation.\r\t\r\tterms:=LinkedList new add:(LinkedTerm new:(Term new:\'x\')); add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\tself halt.\r\texpected:=Or new: (Predicate new: \'P\' fromList: terms)\r\t\t\t\t\trightProp: (Predicate new: \'P\' fromList: terms).\r\t\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemn2,			#protocol : #basic,			#sourceCode : 'testBasicSkolemn2\r\t| p res expected terms |\r\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'z\').\t\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\r\t\r\tterms:=LinkedList new add:(LinkedTerm new:(Term new:\'x\')); add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Or new: (Predicate new: \'P\' fromList: terms)\r\t\t\t\t\trightProp: (Predicate new: \'P\' fromList: terms).\r\t\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:30:19.357839+01:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAll,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAll\r\t| p res expected |\r\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tres:=p StartSkolemnisation.\r\r\t"( ( P(cx) \\/ Q(cx) ) -> ( P(ca) \\/ Q(ca) ) )"\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Imply new:(\r\t\t\t\t\tOr new:(Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new:(Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))).\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:30:28.614202+01:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAll,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAll\r\t| p res expected |\r\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tres:=p StartSkolemnisation.\r\r\t"( ( P(cx) \\/ Q(cx) ) -> ( P(ca) \\/ Q(ca) ) )"\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Imply new:(\r\t\t\t\t\tOr new:(Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new:(Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))).\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAll,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAll\r\t| p res expected |\r\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tres:=p StartSkolemnisation.\r\r\t"( ( P(cx) \\/ Q(cx) ) -> ( P(ca) \\/ Q(ca) ) )"\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Imply new:(\r\t\t\t\t\tOr new:(Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new:(Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\trightProp: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'a\')))).\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:30:53.947746+01:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAll,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAll\r\t| p res expected |\r\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tres:=p StartSkolemnisation.\r\r\t"( ( P(cx) \\/ Q(cx) ) -> ( P(ca) \\/ Q(ca) ) )"\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Imply new:(\r\t\t\t\t\tOr new:(Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new:(Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\trightProp: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'a\')))).\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAll,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAll\r\t| p res expected |\r\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tres:=p StartSkolemnisation.\r\r\t"( ( P(cx) \\/ Q(cx) ) -> ( P(ca) \\/ Q(ca) ) )"\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'a\')))).\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:32:17.421689+01:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAll,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAll\r\t| p res expected |\r\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tres:=p StartSkolemnisation.\r\r\t"( ( P(cx) \\/ Q(cx) ) -> ( P(ca) \\/ Q(ca) ) )"\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'a\')))).\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAll,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAll\r\t| p res expected |\r\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tres:=p StartSkolemnisation.\r\r\t"( ( P(cx) \\/ Q(cx) ) -> ( P(ca) \\/ Q(ca) ) )"\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'a\')))).\r\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:33:42.664753+01:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Not class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #Initialize,			#sourceCode : 'initialize\r\tsymb:=\'!\'.\r\tpatternNot:=Not new:(Var new: \'a\').\r\tpatternTrue:=True_Const new.\r\tpatternFalse:=False_Const new.\r\tpatternOr:=Or new:(Var new: \'a\') rightProp: (Var new: \'a\').\r\tpatternAnd:=And new:(Var new: \'a\') rightProp: (Var new: \'a\').',			#stamp : 'pm 9/30/2018 18:50',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Not class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #Initialize,			#sourceCode : 'initialize\r\tsymb:=\'~\'.\r\tpatternNot:=Not new:(Var new: \'a\').\r\tpatternTrue:=True_Const new.\r\tpatternFalse:=False_Const new.\r\tpatternOr:=Or new:(Var new: \'a\') rightProp: (Var new: \'a\').\r\tpatternAnd:=And new:(Var new: \'a\') rightProp: (Var new: \'a\').',			#stamp : 'pm 11/5/2018 18:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:34:33.980695+01:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAll,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAll\r\t| p res expected |\r\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tres:=p StartSkolemnisation.\r\r\t"( ( P(cx) \\/ Q(cx) ) -> ( P(ca) \\/ Q(ca) ) )"\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'a\')))).\r\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAll,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAll\r\t| p res expected |\r\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tres:=p StartSkolemnisation.\r\r\t"( ( P(cx) \\/ Q(cx) ) -> ( P(ca) \\/ Q(ca) ) )"\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'a\'))))).\r\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:35:23.236944+01:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting:prop2\r\t^self class = prop2 class and:[(self operand) isSameForTesing: (prop2 operand)].',			#stamp : 'pm 11/5/2018 09:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting:prop2\r\t^self class = prop2 class and:[(self operand) isSameForTesting: (prop2 operand)].',			#stamp : 'pm 11/5/2018 18:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:35:38.157366+01:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAll,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAll\r\t| p res expected |\r\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tres:=p StartSkolemnisation.\r\r\t"( ( P(cx) \\/ Q(cx) ) -> ( P(ca) \\/ Q(ca) ) )"\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'a\'))))).\r\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAll,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAll\r\t| p res expected |\r\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'a\'))))).\r\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:36:55.542786+01:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAllWithSameNameForConstAndLinkedVar,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAllWithSameNameForConstAndLinkedVar\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:36',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:39:45.17211+01:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAllWithSameNameForConstAndLinkedVar,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAllWithSameNameForConstAndLinkedVar\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:36',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAllWithSameNameForConstAndLinkedVar,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAllWithSameNameForConstAndLinkedVar\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) terms) ~= ((((res operand) right) right) terms)',			#stamp : 'pm 11/5/2018 18:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:50:15.877183+01:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAllWithSameNameForConstAndLinkedVar,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAllWithSameNameForConstAndLinkedVar\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) terms) ~= ((((res operand) right) right) terms)',			#stamp : 'pm 11/5/2018 18:49',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAllWithSameNameForConstAndLinkedVar,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAllWithSameNameForConstAndLinkedVar\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) terms) isSameTerms: ((((res operand) right) right) terms)',			#stamp : 'pm 11/5/2018 18:50',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:50:23.719086+01:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAllWithSameNameForConstAndLinkedVar,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAllWithSameNameForConstAndLinkedVar\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) terms) isSameTerms: ((((res operand) right) right) terms)',			#stamp : 'pm 11/5/2018 18:50',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAllWithSameNameForConstAndLinkedVar,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAllWithSameNameForConstAndLinkedVar\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:(((((res operand) left) left) terms) isSameTerms: ((((res operand) right) right) terms))',			#stamp : 'pm 11/5/2018 18:50',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:50:58.259662+01:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAllWithSameNameForConstAndLinkedVar,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAllWithSameNameForConstAndLinkedVar\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:(((((res operand) left) left) terms) isSameTerms: ((((res operand) right) right) terms))',			#stamp : 'pm 11/5/2018 18:50',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAllWithSameNameForConstAndLinkedVar,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAllWithSameNameForConstAndLinkedVar\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTerms: (((res operand) right) right))',			#stamp : 'pm 11/5/2018 18:50',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:52:55.90998+01:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAllWithSameNameForConstAndLinkedVar,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAllWithSameNameForConstAndLinkedVar\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTerms: (((res operand) right) right))',			#stamp : 'pm 11/5/2018 18:50',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAllWithSameNameForConstAndLinkedVar,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAllWithSameNameForConstAndLinkedVar\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTerms: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm"',			#stamp : 'pm 11/5/2018 18:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:54:08.485762+01:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAllWithSameNameForConstAndLinkedVar,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAllWithSameNameForConstAndLinkedVar\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTerms: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm"',			#stamp : 'pm 11/5/2018 18:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAllWithSameNameForConstAndLinkedVar,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAllWithSameNameForConstAndLinkedVar\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTerms: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 11/5/2018 18:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:54:29.853331+01:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t^self getSymb,\r\t\t((operand isKindOf: Atome) ifTrue:[\' \'] ifFalse:[\' (\']) ,\r\t\toperand prettyPrint,\r\t\t((operand isKindOf: Atome) ifTrue:[\' \'] ifFalse:[\') \']).',			#stamp : 'pm 9/30/2018 19:21',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t^self getSymb,\r\t\t((operand isKindOf: Atome) ifFalse:[\'(\']) ,\r\t\toperand prettyPrint,\r\t\t((operand isKindOf: Atome) ifFalse:[\')\']).',			#stamp : 'pm 11/5/2018 18:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:54:53.420897+01:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t^self getSymb,\r\t\t((operand isKindOf: Atome) ifFalse:[\'(\']) ,\r\t\toperand prettyPrint,\r\t\t((operand isKindOf: Atome) ifFalse:[\')\']).',			#stamp : 'pm 11/5/2018 18:54',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t^self getSymb,\r\t\t((operand isKindOf: Atome) ifFalse:[\'(\']),\r\t\toperand prettyPrint,\r\t\t((operand isKindOf: Atome) ifFalse:[\')\']).',			#stamp : 'pm 11/5/2018 18:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:55:15.387054+01:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t^self getSymb,\r\t\t((operand isKindOf: Atome) ifFalse:[\'(\']),\r\t\toperand prettyPrint,\r\t\t((operand isKindOf: Atome) ifFalse:[\')\']).',			#stamp : 'pm 11/5/2018 18:54',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t^self getSymb,\r\t\t((operand isKindOf: Atome) ifTrue:[\'\'] ifFalse:[\'(\']),\r\t\toperand prettyPrint,\r\t\t((operand isKindOf: Atome) ifTrue:[\'\'] ifFalse:[\')\']).',			#stamp : 'pm 11/5/2018 18:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T18:55:47.031523+01:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t^self getSymb,\r\t\t((operand isKindOf: Atome) ifTrue:[\'\'] ifFalse:[\'(\']),\r\t\toperand prettyPrint,\r\t\t((operand isKindOf: Atome) ifTrue:[\'\'] ifFalse:[\')\']).',			#stamp : 'pm 11/5/2018 18:55',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t^self getSymb,\r\t\t((operand isKindOf: Atome) ifTrue:[\' \'] ifFalse:[\' (\']),\r\t\toperand prettyPrint,\r\t\t((operand isKindOf: Atome) ifTrue:[\' \'] ifFalse:[\') \']).',			#stamp : 'pm 11/5/2018 18:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T19:16:56.134758+01:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAllWithSameNameForConstAndLinkedVar,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAllWithSameNameForConstAndLinkedVar\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTerms: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 11/5/2018 18:54',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAllWithSameNameForConstAndLinkedVar,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAllWithSameNameForConstAndLinkedVar\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTerms: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 11/5/2018 19:16',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T19:29:53.389984+01:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testUnboundExistReplacedByConsts,			#protocol : #basic,			#sourceCode : 'testUnboundExistReplacedByConsts\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTerms: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 11/5/2018 19:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T19:30:14.555063+01:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemn2,			#protocol : #basic,			#sourceCode : 'testBasicSkolemn2\r\t| p res expected terms |\r\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'z\').\t\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\r\t\r\tterms:=LinkedList new add:(LinkedTerm new:(Term new:\'x\')); add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Or new: (Predicate new: \'P\' fromList: terms)\r\t\t\t\t\trightProp: (Predicate new: \'P\' fromList: terms).\r\t\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemn2,			#protocol : #basic,			#sourceCode : 'testBasicSkolemn2\r\t| p res expected terms |\r\r\tterms:=LinkedList new add:(Term new:\'x\');add:(Term new:\'z\');yourself.\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\r\t\r\tterms:=LinkedList new add:(LinkedTerm new:(Term new:\'x\')); add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Or new: (Predicate new: \'P\' fromList: terms)\r\t\t\t\t\trightProp: (Predicate new: \'P\' fromList: terms).\r\t\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 19:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T19:30:26.827543+01:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemn1,			#protocol : #basic,			#sourceCode : 'testBasicSkolemn1\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new.\r\tterms2 add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\')).\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:11',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemn1,			#protocol : #basic,			#sourceCode : 'testBasicSkolemn1\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 19:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T19:30:36.811917+01:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemn1,			#protocol : #basic,			#sourceCode : 'testBasicSkolemn1\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 19:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemn1,			#protocol : #basic,			#sourceCode : 'testBasicSkolemn1\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\');yourself.\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 19:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T19:30:54.523461+01:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testUnboundExistReplacedByConsts,			#protocol : #basic,			#sourceCode : 'testUnboundExistReplacedByConsts\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTerms: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 11/5/2018 19:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testUnboundExistReplacedByConsts,			#protocol : #basic,			#sourceCode : 'testUnboundExistReplacedByConsts\r\t| p res expected |\r\tself halt.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTerms: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 11/5/2018 19:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T19:31:12.237846+01:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testOnlyAPredicate,			#protocol : #basic,			#sourceCode : 'testOnlyAPredicate\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\');yourself.\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 19:31',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T19:31:19.353594+01:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemn1,			#protocol : #basic,			#sourceCode : 'testBasicSkolemn1\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\');yourself.\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 19:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T19:31:57.613134+01:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicForAll,			#protocol : #basic,			#sourceCode : 'testBasicForAll\r\t| p res expected terms |\r\r\tterms:=LinkedList new add:(Term new:\'x\');add:(Term new:\'z\');yourself.\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\r\t\r\tterms:=LinkedList new add:(LinkedTerm new:(Term new:\'x\')); add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Or new: (Predicate new: \'P\' fromList: terms)\r\t\t\t\t\trightProp: (Predicate new: \'P\' fromList: terms).\r\t\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 19:31',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T19:32:01.994778+01:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemn2,			#protocol : #basic,			#sourceCode : 'testBasicSkolemn2\r\t| p res expected terms |\r\r\tterms:=LinkedList new add:(Term new:\'x\');add:(Term new:\'z\');yourself.\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\r\t\r\tterms:=LinkedList new add:(LinkedTerm new:(Term new:\'x\')); add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Or new: (Predicate new: \'P\' fromList: terms)\r\t\t\t\t\trightProp: (Predicate new: \'P\' fromList: terms).\r\t\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 19:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T19:32:22.666755+01:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicOnlyPredicate,			#protocol : #basic,			#sourceCode : 'testBasicOnlyPredicate\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\');yourself.\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 19:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T19:32:25.782061+01:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testOnlyAPredicate,			#protocol : #basic,			#sourceCode : 'testOnlyAPredicate\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\');yourself.\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 19:31',			#package : #_resolution_1erOrdre		}	}}