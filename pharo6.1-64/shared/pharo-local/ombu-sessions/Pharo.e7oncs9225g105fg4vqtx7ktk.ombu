OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:36:53.635175+01:00' ],		#prior : OmReference [ 'Pharo.a4x0207jo3e6wk2voqi3absmq', '38' ],		#self : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof1,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof1\r\t| p |\r\tp:=Exists new: \'x\' Property: (\r\t\tImply new:\r\t\t\t(Predicate new: \'P\' variable: (Term new:\'x\'))\r\t\trightProp:\r\t\t\t(And new: (Predicate new: \'P\' variable: (Term new:\'a\'))\r\t\t\trightProp:(Predicate new:\'P\' variable: (Term new:\'b\')))).\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 09:36',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:37:25.914782+01:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof2,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof2\r\t| p |\r\tp:=ForAll new: \'x\' Property: (\r\t\tImply new:\r\t\t\t(Predicate new: \'P\' variable: (Term new:\'x\'))\r\t\trightProp:\r\t\t\t(Exists new: \'y\' Property: \r\t\t\t(And new: (Predicate new: \'P\' variable: (Term new:\'y\'))\r\t\t\trightProp:(Predicate new:\'P\' variable: (Term new:\'y\'))))).\r\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 09:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:37:45.940844+01:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof3,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof3\r\t| p |\r\tp:=Imply new:\r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new: (Predicate new: \'P\' variable: (Term new:\'x\'))\r\t\t\t\trightProp: (Predicate new: \'Q\' variable: (Term new:\'x\'))))\r\t\trightProp: \r\t\t\t\t(Or new:\r\t\t\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t\t\t (Predicate new: \'P\' variable: (Term new:\'x\')))\r\t\t\t\trightProp:\r\t\t\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t\t\t (Predicate new: \'Q\' variable: (Term new:\'x\')))).\r\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 09:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:38:04.040482+01:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof4,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof4\r\t| p |\r\tp:=Imply new:\r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(And new: (Predicate new: \'P\' variable: (Term new:\'x\'))\r\t\t\t\trightProp: (Predicate new: \'Q\' variable: (Term new:\'x\'))))\r\t\trightProp: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(And new: (Predicate new: \'P\' variable: (Term new:\'x\'))\r\t\t\t\trightProp: (Predicate new: \'Q\' variable: (Term new:\'x\')))).\r\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 09:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:38:18.908794+01:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof5,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof5\r\t| p |\r\tp:=Imply new:\r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(And new: (Predicate new: \'P\' variable: (Term new:\'x\'))\r\t\t\t\trightProp: (Predicate new: \'Q\' variable: (Term new:\'x\'))))\r\t\trightProp: \r\t\t\t\t(And new:\r\t\t\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t\t\t (Predicate new: \'P\' variable: (Term new:\'x\')))\r\t\t\t\trightProp:\r\t\t\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t\t\t (Predicate new: \'Q\' variable: (Term new:\'x\')))).\r\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 09:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:38:43.925154+01:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof6,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof6\r\t| p |\r\tp:=Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Not new:\r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))))\r\t\trightProp: \r\t\t\t(Not new:\r\t\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\')))).\r\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 09:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:38:59.1984+01:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof7,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof7\r\t| p |\r\tp:=Imply new:\r\t\t\t(Not new: \r\t\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))))\r\t\trightProp: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Not new:\r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\')))).\r\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 09:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:39:34.975584+01:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tTranscript show:\'Is \';show: self; show:\' valid?\';cr.\r\t\r\ttreatedProp:=Not new:self.\r\t\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp StartSkolemnisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tTranscript show:\'Resolution method:\' ; show:t ; cr; cr; cr.\r\t^t ',			#stamp : 'pm 12/12/2018 16:09',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tresolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\t\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp StartSkolemnisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tTranscript show:\'Resolution method:\' ; show:t ; cr; cr; cr.\r\t^t ',			#stamp : 'pm 12/15/2018 09:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:39:46.252271+01:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tresolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\t\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp StartSkolemnisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tTranscript show:\'Resolution method:\' ; show:t ; cr; cr; cr.\r\t^t ',			#stamp : 'pm 12/15/2018 09:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tresolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\t\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp StartSkolemnisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tresolutionTrace ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/15/2018 09:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:41:59.568684+01:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionResolvanteReplacement,			#protocol : #tests,			#sourceCode : 'testResolutionResolvanteReplacement\r\t| prop |\r\tprop:=And new:\r\t  (Or new:\r\t   (Predicate new:\'P\' fromList:\r\t     (LinkedList new \r\t      add:(LinkedTerm new:(Term new:\'x\'));\r\t      yourself)\r\t   )\r\t  rightProp:\r\t   (Predicate new:\'Q\' fromList:\r\t     (LinkedList new \r\t      add:(LinkedTerm new:(Term new:\'x\'));\r\t      yourself)\r\t   )\r\t  )\r\t rightProp:\r\t  (And new:\r\t   (Not new:(Predicate new:\'P\' fromList:\r\t     (LinkedList new \r\t      add:(ConstTerm new:(Term new:\'a\'));\r      yourself))\r\t   )\r\t\t  rightProp:\r\t   (Not new:(Predicate new:\'Q\' fromList:\r\t     (LinkedList new \r\t      add:(ConstTerm new:(Term new:\'b\'));\r\t      yourself))\r\t   )\r\t  ).\r\t\r\t^self deny:(ClausalForm new:prop) resolutionMethod.',			#stamp : 'pm 12/15/2018 09:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:43:10.333406+01:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionLimitCase,			#protocol : #tests,			#sourceCode : 'testResolutionLimitCase\r\t| prop |\r\tprop:=And new:\r\t  (Or new:\r\t   (Predicate new:\'P\' fromList:\r\t     (LinkedList new \r\t      add:(LinkedTerm new:(Term new:\'x\'));\r\t      yourself)\r\t   )\r\t  rightProp:\r\t   (Predicate new:\'Q\' fromList:\r\t     (LinkedList new \r\t      add:(LinkedTerm new:(Term new:\'x\'));\r\t      yourself)\r\t   )\r\t  )\r\t rightProp:\r\t  (And new:\r\t   (Not new:(Predicate new:\'P\' fromList:\r\t     (LinkedList new \r\t      add:(ConstTerm new:(Term new:\'a\'));\r      yourself))\r\t   )\r\t\t  rightProp:\r\t   (Not new:(Predicate new:\'Q\' fromList:\r\t     (LinkedList new \r\t      add:(ConstTerm new:(Term new:\'b\'));\r\t      yourself))\r\t   )\r\t  ).\r\t\r\t^self deny:(ClausalForm new:prop) resolutionMethod.',			#stamp : 'pm 12/14/2018 20:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:43:46.036345+01:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionResolvanteReplacement,			#protocol : #tests,			#sourceCode : 'testResolutionResolvanteReplacement\r\t| prop |\r\tprop:=And new:\r\t  (Or new:\r\t   (Predicate new:\'P\' fromList:\r\t     (LinkedList new \r\t      add:(LinkedTerm new:(Term new:\'x\'));\r\t      yourself)\r\t   )\r\t  rightProp:\r\t   (Predicate new:\'Q\' fromList:\r\t     (LinkedList new \r\t      add:(LinkedTerm new:(Term new:\'x\'));\r\t      yourself)\r\t   )\r\t  )\r\t rightProp:\r\t  (And new:\r\t   (Not new:(Predicate new:\'P\' fromList:\r\t     (LinkedList new \r\t      add:(ConstTerm new:(Term new:\'a\'));\r      yourself))\r\t   )\r\t\t  rightProp:\r\t   (Not new:(Predicate new:\'Q\' fromList:\r\t     (LinkedList new \r\t      add:(ConstTerm new:(Term new:\'b\'));\r\t      yourself))\r\t   )\r\t  ).\r\t\r\t^self deny:(ClausalForm new:prop) resolutionMethod.',			#stamp : 'pm 12/15/2018 09:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionResolvanteReplacement,			#protocol : #tests,			#sourceCode : 'testResolutionResolvanteReplacement\r\t"Proof #1 on the auto-fol.pdf course, 9th slide."\r\t| prop |\r\tprop:=And new:\r\t  (Or new:\r\t   (Predicate new:\'P\' fromList:\r\t     (LinkedList new \r\t      add:(LinkedTerm new:(Term new:\'x\'));\r\t      yourself)\r\t   )\r\t  rightProp:\r\t   (Predicate new:\'Q\' fromList:\r\t     (LinkedList new \r\t      add:(LinkedTerm new:(Term new:\'x\'));\r\t      yourself)\r\t   )\r\t  )\r\t rightProp:\r\t  (And new:\r\t   (Not new:(Predicate new:\'P\' fromList:\r\t     (LinkedList new \r\t      add:(ConstTerm new:(Term new:\'a\'));\r      yourself))\r\t   )\r\t\t  rightProp:\r\t   (Not new:(Predicate new:\'Q\' fromList:\r\t     (LinkedList new \r\t      add:(ConstTerm new:(Term new:\'b\'));\r\t      yourself))\r\t   )\r\t  ).\r\t\r\t^self deny:(ClausalForm new:prop) resolutionMethod.',			#stamp : 'pm 12/15/2018 09:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:43:49.15566+01:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof1,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof1\r\t| p |\r\tp:=Exists new: \'x\' Property: (\r\t\tImply new:\r\t\t\t(Predicate new: \'P\' variable: (Term new:\'x\'))\r\t\trightProp:\r\t\t\t(And new: (Predicate new: \'P\' variable: (Term new:\'a\'))\r\t\t\trightProp:(Predicate new:\'P\' variable: (Term new:\'b\')))).\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 09:36',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof1,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof1\r\t"Proof #1 on the auto-fol.pdf course, 9th slide."\r\t| p |\r\tp:=Exists new: \'x\' Property: (\r\t\tImply new:\r\t\t\t(Predicate new: \'P\' variable: (Term new:\'x\'))\r\t\trightProp:\r\t\t\t(And new: (Predicate new: \'P\' variable: (Term new:\'a\'))\r\t\t\trightProp:(Predicate new:\'P\' variable: (Term new:\'b\')))).\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 09:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:43:55.509484+01:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof2,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof2\r\t| p |\r\tp:=ForAll new: \'x\' Property: (\r\t\tImply new:\r\t\t\t(Predicate new: \'P\' variable: (Term new:\'x\'))\r\t\trightProp:\r\t\t\t(Exists new: \'y\' Property: \r\t\t\t(And new: (Predicate new: \'P\' variable: (Term new:\'y\'))\r\t\t\trightProp:(Predicate new:\'P\' variable: (Term new:\'y\'))))).\r\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 09:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof2,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof2\r\t"Proof #2 on the auto-fol.pdf course, 9th slide."\r\t| p |\r\tp:=ForAll new: \'x\' Property: (\r\t\tImply new:\r\t\t\t(Predicate new: \'P\' variable: (Term new:\'x\'))\r\t\trightProp:\r\t\t\t(Exists new: \'y\' Property: \r\t\t\t(And new: (Predicate new: \'P\' variable: (Term new:\'y\'))\r\t\t\trightProp:(Predicate new:\'P\' variable: (Term new:\'y\'))))).\r\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 09:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:44:01.375141+01:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof3,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof3\r\t| p |\r\tp:=Imply new:\r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new: (Predicate new: \'P\' variable: (Term new:\'x\'))\r\t\t\t\trightProp: (Predicate new: \'Q\' variable: (Term new:\'x\'))))\r\t\trightProp: \r\t\t\t\t(Or new:\r\t\t\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t\t\t (Predicate new: \'P\' variable: (Term new:\'x\')))\r\t\t\t\trightProp:\r\t\t\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t\t\t (Predicate new: \'Q\' variable: (Term new:\'x\')))).\r\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 09:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof3,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof3\r\t"Proof #3 on the auto-fol.pdf course, 9th slide."\r\t| p |\r\tp:=Imply new:\r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new: (Predicate new: \'P\' variable: (Term new:\'x\'))\r\t\t\t\trightProp: (Predicate new: \'Q\' variable: (Term new:\'x\'))))\r\t\trightProp: \r\t\t\t\t(Or new:\r\t\t\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t\t\t (Predicate new: \'P\' variable: (Term new:\'x\')))\r\t\t\t\trightProp:\r\t\t\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t\t\t (Predicate new: \'Q\' variable: (Term new:\'x\')))).\r\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 09:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:44:11.089463+01:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof4,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof4\r\t| p |\r\tp:=Imply new:\r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(And new: (Predicate new: \'P\' variable: (Term new:\'x\'))\r\t\t\t\trightProp: (Predicate new: \'Q\' variable: (Term new:\'x\'))))\r\t\trightProp: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(And new: (Predicate new: \'P\' variable: (Term new:\'x\'))\r\t\t\t\trightProp: (Predicate new: \'Q\' variable: (Term new:\'x\')))).\r\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 09:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof4,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof4\r\t"Proof #4 on the auto-fol.pdf course, 9th slide."\r\t| p |\r\tp:=Imply new:\r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(And new: (Predicate new: \'P\' variable: (Term new:\'x\'))\r\t\t\t\trightProp: (Predicate new: \'Q\' variable: (Term new:\'x\'))))\r\t\trightProp: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(And new: (Predicate new: \'P\' variable: (Term new:\'x\'))\r\t\t\t\trightProp: (Predicate new: \'Q\' variable: (Term new:\'x\')))).\r\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 09:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:44:17.548305+01:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof5,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof5\r\t| p |\r\tp:=Imply new:\r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(And new: (Predicate new: \'P\' variable: (Term new:\'x\'))\r\t\t\t\trightProp: (Predicate new: \'Q\' variable: (Term new:\'x\'))))\r\t\trightProp: \r\t\t\t\t(And new:\r\t\t\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t\t\t (Predicate new: \'P\' variable: (Term new:\'x\')))\r\t\t\t\trightProp:\r\t\t\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t\t\t (Predicate new: \'Q\' variable: (Term new:\'x\')))).\r\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 09:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof5,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof5\r\t"Proof #5 on the auto-fol.pdf course, 9th slide."\r\t| p |\r\tp:=Imply new:\r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(And new: (Predicate new: \'P\' variable: (Term new:\'x\'))\r\t\t\t\trightProp: (Predicate new: \'Q\' variable: (Term new:\'x\'))))\r\t\trightProp: \r\t\t\t\t(And new:\r\t\t\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t\t\t (Predicate new: \'P\' variable: (Term new:\'x\')))\r\t\t\t\trightProp:\r\t\t\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t\t\t (Predicate new: \'Q\' variable: (Term new:\'x\')))).\r\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 09:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:44:23.863839+01:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof6,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof6\r\t| p |\r\tp:=Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Not new:\r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))))\r\t\trightProp: \r\t\t\t(Not new:\r\t\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\')))).\r\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 09:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof6,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof6\r\t"Proof #6 on the auto-fol.pdf course, 9th slide."\r\t| p |\r\tp:=Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Not new:\r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))))\r\t\trightProp: \r\t\t\t(Not new:\r\t\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\')))).\r\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 09:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:44:29.895639+01:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof7,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof7\r\t| p |\r\tp:=Imply new:\r\t\t\t(Not new: \r\t\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))))\r\t\trightProp: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Not new:\r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\')))).\r\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 09:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof7,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof7\r\t"Proof #7 on the auto-fol.pdf course, 9th slide."\r\t| p |\r\tp:=Imply new:\r\t\t\t(Not new: \r\t\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))))\r\t\trightProp: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Not new:\r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\')))).\r\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 09:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:48:22.22702+01:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionResolvanteReplacement,			#protocol : #tests,			#sourceCode : 'testResolutionResolvanteReplacement\r\t"Proof #1 on the auto-fol.pdf course, 9th slide."\r\t| prop |\r\tprop:=And new:\r\t  (Or new:\r\t   (Predicate new:\'P\' fromList:\r\t     (LinkedList new \r\t      add:(LinkedTerm new:(Term new:\'x\'));\r\t      yourself)\r\t   )\r\t  rightProp:\r\t   (Predicate new:\'Q\' fromList:\r\t     (LinkedList new \r\t      add:(LinkedTerm new:(Term new:\'x\'));\r\t      yourself)\r\t   )\r\t  )\r\t rightProp:\r\t  (And new:\r\t   (Not new:(Predicate new:\'P\' fromList:\r\t     (LinkedList new \r\t      add:(ConstTerm new:(Term new:\'a\'));\r      yourself))\r\t   )\r\t\t  rightProp:\r\t   (Not new:(Predicate new:\'Q\' fromList:\r\t     (LinkedList new \r\t      add:(ConstTerm new:(Term new:\'b\'));\r\t      yourself))\r\t   )\r\t  ).\r\t\r\t^self deny:(ClausalForm new:prop) resolutionMethod.',			#stamp : 'pm 12/15/2018 09:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionResolvanteReplacement,			#protocol : #tests,			#sourceCode : 'testResolutionResolvanteReplacement\r\t"When doing the unification, if you don\'t apply the unification on the resolvants, this test will fail"\r\t| prop |\r\tprop:=And new:\r\t  (Or new:\r\t   (Predicate new:\'P\' fromList:\r\t     (LinkedList new \r\t      add:(LinkedTerm new:(Term new:\'x\'));\r\t      yourself)\r\t   )\r\t  rightProp:\r\t   (Predicate new:\'Q\' fromList:\r\t     (LinkedList new \r\t      add:(LinkedTerm new:(Term new:\'x\'));\r\t      yourself)\r\t   )\r\t  )\r\t rightProp:\r\t  (And new:\r\t   (Not new:(Predicate new:\'P\' fromList:\r\t     (LinkedList new \r\t      add:(ConstTerm new:(Term new:\'a\'));\r      yourself))\r\t   )\r\t\t  rightProp:\r\t   (Not new:(Predicate new:\'Q\' fromList:\r\t     (LinkedList new \r\t      add:(ConstTerm new:(Term new:\'b\'));\r\t      yourself))\r\t   )\r\t  ).\r\t\r\t^self deny:(ClausalForm new:prop) resolutionMethod.',			#stamp : 'pm 12/15/2018 09:48',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:51:55.799965+01:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"abstract class, not meant to be instanciated"\r\t^self error: \'Prop is abstract and shouldn\'\'t be implemented\'\r',			#stamp : 'pm 12/12/2018 10:49',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"abstract class, not meant to be instanciated"\r\t^self error: \'Prop is abstract and shouldn\'\'t be instanciated.\'\r',			#stamp : 'pm 12/15/2018 09:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:52:20.627573+01:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #resolutionTrace,			#protocol : #'as yet unclassified',			#sourceCode : 'resolutionTrace\r\t^resolutionTrace',			#stamp : 'pm 12/14/2018 19:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #resolutionTrace,			#protocol : #'as yet unclassified',			#sourceCode : 'resolutionTrace\r\t"accessor, it\'s also used in Clausal Form during the resolution process."\r\t^resolutionTrace',			#stamp : 'pm 12/15/2018 09:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:53:07.355852+01:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testInc,			#protocol : #tests,			#sourceCode : 'testInc\r\ttestNumber:=testNumber+1.',			#stamp : 'pm 10/11/2018 16:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testInc,			#protocol : #tests,			#sourceCode : 'testInc\r\t"incrementor for the testnumber, to give context"\r\ttestNumber:=testNumber+1.',			#stamp : 'pm 12/15/2018 09:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:53:17.050563+01:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testNumber,			#protocol : #accessing,			#sourceCode : 'testNumber\r\t^testNumber',			#stamp : 'pm 10/11/2018 16:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testNumber,			#protocol : #accessing,			#sourceCode : 'testNumber\r\t"incrementor for the testnumber, to give context"\r\t^testNumber',			#stamp : 'pm 12/15/2018 09:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:53:53.593705+01:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tProp initialize.\r\tTranscript clear.\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl unificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t\r\t"should replace x by y at the end of the unification"\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:( LinkedTerm new:(Term new:\'x\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 12/13/2018 20:59',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tProp initialize.\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl unificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t\r\t"should replace x by y at the end of the unification"\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:( LinkedTerm new:(Term new:\'x\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 12/15/2018 09:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:54:19.544393+01:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #debugUnification,			#protocol : #accessing,			#sourceCode : 'debugUnification\r\t^debugUnification',			#stamp : 'pm 12/13/2018 19:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #debugUnification,			#protocol : #accessing,			#sourceCode : 'debugUnification\r\t"accessor for the Unification process"\r\t^debugUnification',			#stamp : 'pm 12/15/2018 09:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:55:00.234387+01:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'clausificationTrace debugUnification resolutionTrace skolemnTrace testNumber unifDone\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @7,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- FullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- PrettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 10/9/2018 10:52'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #debugUnification,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unifDone,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'clausificationTrace debugUnification resolutionTrace skolemnTrace testNumber unifDone\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @33			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @33,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- FullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- PrettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 10/9/2018 10:52'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #debugUnification,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unifDone,					#parent : @33				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:55:04.178994+01:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #unificationTrace,			#protocol : #accessing,			#sourceCode : 'unificationTrace\r\t"accessor for the Unification process"\r\t^unificationTrace',			#stamp : 'pm 12/15/2018 09:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:55:13.039513+01:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #debugUnification,			#protocol : #accessing,			#sourceCode : 'debugUnification\r\t"accessor for the Unification process"\r\t^debugUnification',			#stamp : 'pm 12/15/2018 09:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:55:22.173149+01:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'check:',			#protocol : #unification,			#sourceCode : 'check: aPair\r\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'check\';cr.].\r\t\r\t^aPair right contains: aPair left term',			#stamp : 'pm 12/14/2018 16:54',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'check:',			#protocol : #unification,			#sourceCode : 'check: aPair\r\r\t(Prop unificationTrace)\r\tifTrue:[Transcript show:\'check\';cr.].\r\t\r\t^aPair right contains: aPair left term',			#stamp : 'pm 12/15/2018 09:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:55:30.784731+01:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'conflict:',			#protocol : #unification,			#sourceCode : 'conflict: aPair\r\t(Prop debugUnification) \r\tifTrue:[Transcript show:\'[Unification] conflict between : \'; show:aPair ; cr.].\r',			#stamp : 'pm 12/13/2018 20:50',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'conflict:',			#protocol : #unification,			#sourceCode : 'conflict: aPair\r\tProp unificationTrace\r\tifTrue:[Transcript show:\'[Unification] conflict between : \'; show:aPair ; cr.].\r',			#stamp : 'pm 12/15/2018 09:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:55:42.933288+01:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right i|\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'decompose \'; show:aPair ;cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\ti:=1.\r\tsetOfPairs remove: aPair.\r\t[i<=(left arity)]"arity is the same, as we tested in the caller."\r\twhileTrue:[\r\t\tself add: (Pair left: (left at: i) right: (right at: i)).\r\t\ti:=i+1.\r\t\t].\t',			#stamp : 'pm 12/13/2018 20:56',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right i|\r\tProp unificationTrace\r\tifTrue:[Transcript show:\'decompose \'; show:aPair ;cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\ti:=1.\r\tsetOfPairs remove: aPair.\r\t[i<=(left arity)]"arity is the same, as we tested in the caller."\r\twhileTrue:[\r\t\tself add: (Pair left: (left at: i) right: (right at: i)).\r\t\ti:=i+1.\r\t\t].\t',			#stamp : 'pm 12/15/2018 09:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:55:51.006827+01:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'delete:',			#protocol : #unification,			#sourceCode : 'delete:aPair\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'delete\'; show:aPair ;cr.].\r\tsetOfPairs remove:aPair.',			#stamp : 'pm 12/13/2018 20:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'delete:',			#protocol : #unification,			#sourceCode : 'delete:aPair\r\tProp unificationTrace\r\tifTrue:[Transcript show:\'delete\'; show:aPair ;cr.].\r\tsetOfPairs remove:aPair.',			#stamp : 'pm 12/15/2018 09:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:55:57.220774+01:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right previousSet newSet |\r\t\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'eliminate with \'; show:aPair ;cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\t\r\tpreviousSet:=setOfPairs veryDeepCopy."we need to work on a copy, to avoid having another iteration"\r\tpreviousSet remove:aPair.\r\t\r\tpreviousSet do:[:each |\r\t\t"tempVar:=each veryDeepCopy.""since we modify the underlying data, we work on a copy"\r\t\tnewSet add: (self replacementPair:each replaced:left by:right).\r\t\t].\r\t(previousSet = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r ',			#stamp : 'pm 12/13/2018 20:58',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right previousSet newSet |\r\t\r\tProp unificationTrace\r\tifTrue:[Transcript show:\'eliminate with \'; show:aPair ;cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\t\r\tpreviousSet:=setOfPairs veryDeepCopy."we need to work on a copy, to avoid having another iteration"\r\tpreviousSet remove:aPair.\r\t\r\tpreviousSet do:[:each |\r\t\t"tempVar:=each veryDeepCopy.""since we modify the underlying data, we work on a copy"\r\t\tnewSet add: (self replacementPair:each replaced:left by:right).\r\t\t].\r\t(previousSet = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r ',			#stamp : 'pm 12/15/2018 09:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:56:03.969155+01:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'swap:',			#protocol : #unification,			#sourceCode : 'swap: aPair\r\t|left right|\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'swaping : \'; show:aPair ;cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tsetOfPairs remove:aPair.\r\tself add: (Pair left: right right: left).\r\t',			#stamp : 'pm 12/13/2018 20:54',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'swap:',			#protocol : #unification,			#sourceCode : 'swap: aPair\r\t|left right|\r\tProp unificationTrace\r\tifTrue:[Transcript show:\'swaping : \'; show:aPair ;cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tsetOfPairs remove:aPair.\r\tself add: (Pair left: right right: left).\r\t',			#stamp : 'pm 12/15/2018 09:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:56:12.504146+01:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\t[ modified ]\r\twhileTrue:[\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification ifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right"=not possible"\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\t"Transcript show: \'Unification impossible\'; cr."\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\thasFailed:=true.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t\r\t\t]. ',			#stamp : 'pm 12/14/2018 20:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\t[ modified ]\r\twhileTrue:[\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp unificationTrace ifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right"=not possible"\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\t"Transcript show: \'Unification impossible\'; cr."\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\thasFailed:=true.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t\r\t\t]. ',			#stamp : 'pm 12/15/2018 09:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:56:36.850435+01:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tclausificationTrace:=false.\r\tskolemnTrace:=false.\r\tdebugUnification:=false.\r\tresolutionTrace:=false.\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/14/2018 20:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tclausificationTrace:=false.\r\tskolemnTrace:=false.\r\tunificationTrace:=false.\r\tresolutionTrace:=false.\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/15/2018 09:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:57:45.401934+01:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initEverything,			#protocol : #testing,			#sourceCode : 'initEverything\r\t"classic logic"\r\tProp initialize.\r\tAtome initialize.\r\tConstant initialize.\r\tFalse_Const initialize.\r\tTrue_Const initialize.\r\tVar initialize.\r\tNotVar initialize.\r\tOperator initialize.\r\tBinary initialize.\r\tAnd initialize.\r\tEqual initialize.\r\tImply initialize.\r\tOr initialize.\r\tUnary initialize.\r\tNot initialize.\r\t\r\t"Predicate"\r\tQuantifier initialize.\r\tExists initialize.\r\tForAll initialize.\r\t\r\t"terms"\r\tTerm initialize.\r\tConstTerm initialize.\r\tFuncTerm initialize.\r\tLinkedTerm initialize.',			#stamp : 'pm 10/8/2018 17:11',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initEverything,			#protocol : #testing,			#sourceCode : 'initEverything\r\t"classic logic"\r\tProp initialize.\r\tAtome initialize.\r\tConstant initialize.\r\tFalse_Const initialize.\r\tTrue_Const initialize.\r\tVar initialize.\r\tNotVar initialize.\r\tOperator initialize.\r\tBinary initialize.\r\tAnd initialize.\r\tEqual initialize.\r\tImply initialize.\r\tOr initialize.\r\tUnary initialize.\r\tNot initialize.\r\t\r\t"Predicate"\r\tQuantifier initialize.\r\tExists initialize.\r\tForAll initialize.\r\t\r\t"terms"\r\tAbstractTerm initialize.\r\tFuncTerm initialize.\r\tTerm initialize.\r\tUnaryTerm initialize.\r\tConstTerm initialize.\r\tLinkedTerm initialize.',			#stamp : 'pm 12/15/2018 09:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T09:59:03.155898+01:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initEverything,			#protocol : #testing,			#sourceCode : 'initEverything\r\t"classic logic"\r\tProp initialize.\r\tAtome initialize.\r\tConstant initialize.\r\tFalse_Const initialize.\r\tTrue_Const initialize.\r\tVar initialize.\r\tNotVar initialize.\r\tOperator initialize.\r\tBinary initialize.\r\tAnd initialize.\r\tEqual initialize.\r\tImply initialize.\r\tOr initialize.\r\tUnary initialize.\r\tNot initialize.\r\t\r\t"Predicate"\r\tQuantifier initialize.\r\tExists initialize.\r\tForAll initialize.\r\t\r\t"terms"\r\tAbstractTerm initialize.\r\tFuncTerm initialize.\r\tTerm initialize.\r\tUnaryTerm initialize.\r\tConstTerm initialize.\r\tLinkedTerm initialize.',			#stamp : 'pm 12/15/2018 09:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initEverything,			#protocol : #testing,			#sourceCode : 'initEverything\r\t"classic logic"\r\tProp initialize.\r\tAtome initialize.\r\tConstant initialize.\r\tFalse_Const initialize.\r\tTrue_Const initialize.\r\tVar initialize.\r\tNotVar initialize.\r\tOperator initialize.\r\tBinary initialize.\r\tAnd initialize.\r\tEqual initialize.\r\tImply initialize.\r\tOr initialize.\r\tUnary initialize.\r\tNot initialize.\r\t\r\t"Predicate"\r\tQuantifier initialize.\r\tExists initialize.\r\tForAll initialize.\r\t\r\t"terms"\r\tAbstractTerm initialize.\r\tFuncTerm initialize.\r\tTerm initialize.\r\tUnaryTerm initialize.\r\tConstTerm initialize.\r\tLinkedTerm initialize.\r\t\r\t"DataStructure"\r\tLinkedListFix initialize.\r\tMinimalOrderedSet initialize.\r\tPair initialize.\r\t\r',			#stamp : 'pm 12/15/2018 09:59',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:00:05.403883+01:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initEverything,			#protocol : #testing,			#sourceCode : 'initEverything\r\t"classic logic"\r\tProp initialize.\r\tAtome initialize.\r\tConstant initialize.\r\tFalse_Const initialize.\r\tTrue_Const initialize.\r\tVar initialize.\r\tNotVar initialize.\r\tOperator initialize.\r\tBinary initialize.\r\tAnd initialize.\r\tEqual initialize.\r\tImply initialize.\r\tOr initialize.\r\tUnary initialize.\r\tNot initialize.\r\t\r\t"Predicate"\r\tQuantifier initialize.\r\tExists initialize.\r\tForAll initialize.\r\t\r\t"terms"\r\tAbstractTerm initialize.\r\tFuncTerm initialize.\r\tTerm initialize.\r\tUnaryTerm initialize.\r\tConstTerm initialize.\r\tLinkedTerm initialize.\r\t\r\t"DataStructure"\r\tLinkedListFix initialize.\r\tMinimalOrderedSet initialize.\r\tPair initialize.\r\t\r',			#stamp : 'pm 12/15/2018 09:59',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initEverything,			#protocol : #testing,			#sourceCode : 'initEverything\r\t"classic logic"\r\tProp initialize.\r\tAtome initialize.\r\tConstant initialize.\r\tFalse_Const initialize.\r\tTrue_Const initialize.\r\tVar initialize.\r\tNotVar initialize.\r\tOperator initialize.\r\tBinary initialize.\r\tAnd initialize.\r\tEqual initialize.\r\tImply initialize.\r\tOr initialize.\r\tUnary initialize.\r\tNot initialize.\r\t\r\t"Predicate"\r\tQuantifier initialize.\r\tExists initialize.\r\tForAll initialize.\r\t\r\t"terms"\r\tAbstractTerm initialize.\r\tFuncTerm initialize.\r\tTerm initialize.\r\tUnaryTerm initialize.\r\tConstTerm initialize.\r\tLinkedTerm initialize.\r\t\r\t"Clausal Form stuffs"\r\tClausalForm initialize.\r\tClause initialize.\r\tResolvante initialize.\r\tUnifier resolvante\r\r\t"DataStructure"\r\tLinkedListFix initialize.\r\tMinimalOrderedSet initialize.\r\tPair initialize.\r\t\r',			#stamp : 'pm 12/15/2018 10:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:00:28.688696+01:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initEverything,			#protocol : #testing,			#sourceCode : 'initEverything\r\t"classic logic"\r\tProp initialize.\r\tAtome initialize.\r\tConstant initialize.\r\tFalse_Const initialize.\r\tTrue_Const initialize.\r\tVar initialize.\r\tNotVar initialize.\r\tOperator initialize.\r\tBinary initialize.\r\tAnd initialize.\r\tEqual initialize.\r\tImply initialize.\r\tOr initialize.\r\tUnary initialize.\r\tNot initialize.\r\t\r\t"Predicate"\r\tQuantifier initialize.\r\tExists initialize.\r\tForAll initialize.\r\t\r\t"terms"\r\tAbstractTerm initialize.\r\tFuncTerm initialize.\r\tTerm initialize.\r\tUnaryTerm initialize.\r\tConstTerm initialize.\r\tLinkedTerm initialize.\r\t\r\t"Clausal Form stuffs"\r\tClausalForm initialize.\r\tClause initialize.\r\tResolvante initialize.\r\tUnifier resolvante\r\r\t"DataStructure"\r\tLinkedListFix initialize.\r\tMinimalOrderedSet initialize.\r\tPair initialize.\r\t\r',			#stamp : 'pm 12/15/2018 10:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initEverything,			#protocol : #testing,			#sourceCode : 'initEverything\r\t"Every class initialization, for that  package."\r\t\r\t"classic logic"\r\tProp initialize.\r\tAtome initialize.\r\tConstant initialize.\r\tFalse_Const initialize.\r\tTrue_Const initialize.\r\tVar initialize.\r\tNotVar initialize.\r\tOperator initialize.\r\tBinary initialize.\r\tAnd initialize.\r\tEqual initialize.\r\tImply initialize.\r\tOr initialize.\r\tUnary initialize.\r\tNot initialize.\r\t\r\t"Predicate"\r\tQuantifier initialize.\r\tExists initialize.\r\tForAll initialize.\r\t\r\t"terms"\r\tAbstractTerm initialize.\r\tFuncTerm initialize.\r\tTerm initialize.\r\tUnaryTerm initialize.\r\tConstTerm initialize.\r\tLinkedTerm initialize.\r\t\r\t"Clausal Form stuffs"\r\tClausalForm initialize.\r\tClause initialize.\r\tResolvante initialize.\r\tUnifier resolvante\r\r\t"DataStructure"\r\tLinkedListFix initialize.\r\tMinimalOrderedSet initialize.\r\tPair initialize.\r\t\r',			#stamp : 'pm 12/15/2018 10:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:00:41.474271+01:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initEverything,			#protocol : #testing,			#sourceCode : 'initEverything\r\t"Every class initialization, for that  package."\r\t\r\t"classic logic"\r\tProp initialize.\r\tAtome initialize.\r\tConstant initialize.\r\tFalse_Const initialize.\r\tTrue_Const initialize.\r\tVar initialize.\r\tNotVar initialize.\r\tOperator initialize.\r\tBinary initialize.\r\tAnd initialize.\r\tEqual initialize.\r\tImply initialize.\r\tOr initialize.\r\tUnary initialize.\r\tNot initialize.\r\t\r\t"Predicate"\r\tQuantifier initialize.\r\tExists initialize.\r\tForAll initialize.\r\t\r\t"terms"\r\tAbstractTerm initialize.\r\tFuncTerm initialize.\r\tTerm initialize.\r\tUnaryTerm initialize.\r\tConstTerm initialize.\r\tLinkedTerm initialize.\r\t\r\t"Clausal Form stuffs"\r\tClausalForm initialize.\r\tClause initialize.\r\tResolvante initialize.\r\tUnifier resolvante\r\r\t"DataStructure"\r\tLinkedListFix initialize.\r\tMinimalOrderedSet initialize.\r\tPair initialize.\r\t\r',			#stamp : 'pm 12/15/2018 10:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initEverything,			#protocol : #testing,			#sourceCode : 'initEverything\r\t"Every class initialization, for that  package."\r\t\r\t"classic logic"\r\tProp initialize.\r\tAtome initialize.\r\tConstant initialize.\r\tFalse_Const initialize.\r\tTrue_Const initialize.\r\tVar initialize.\r\tNotVar initialize.\r\tOperator initialize.\r\tBinary initialize.\r\tAnd initialize.\r\tEqual initialize.\r\tImply initialize.\r\tOr initialize.\r\tUnary initialize.\r\tNot initialize.\r\t\r\t"Predicate"\r\tQuantifier initialize.\r\tExists initialize.\r\tForAll initialize.\r\t\r\t"terms"\r\tAbstractTerm initialize.\r\tFuncTerm initialize.\r\tTerm initialize.\r\tUnaryTerm initialize.\r\tConstTerm initialize.\r\tLinkedTerm initialize.\r\t\r\t"Clausal Form stuffs"\r\tClausalForm initialize.\r\tClause initialize.\r\tResolvante initialize.\r\tUnifier initialize.\r\r\t"DataStructure"\r\tLinkedListFix initialize.\r\tMinimalOrderedSet initialize.\r\tPair initialize.\r\t\r',			#stamp : 'pm 12/15/2018 10:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:03:41.642691+01:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'clausificationTrace debugUnification resolutionTrace skolemnTrace testNumber unifDone unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @7,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- FullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- PrettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 10/9/2018 10:52'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #debugUnification,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unifDone,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'clausificationTrace debugUnification resolutionTrace skolemnTrace testNumber unifDone unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @35			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @35,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- FullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- PrettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 10/9/2018 10:52'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #debugUnification,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unifDone,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @35				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:03:46.113784+01:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'clausificationTrace debugUnification resolutionTrace skolemnTrace testNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @7,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- FullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- PrettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 10/9/2018 10:52'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #debugUnification,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'clausificationTrace debugUnification resolutionTrace skolemnTrace testNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @33			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @33,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- FullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- PrettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 10/9/2018 10:52'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #debugUnification,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @33				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:06:31.500389+01:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tclausificationTrace:=false.\r\tskolemnTrace:=false.\r\tunificationTrace:=false.\r\tresolutionTrace:=false.\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/15/2018 09:56',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see the traces process"\r\r\t"Variable to activate traces or not."\r\tclausificationTrace:=false.\r\tskolemnTrace:=false.\r\tunificationTrace:=false.\r\tresolutionTrace:=false.\r\t\r\t""\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/15/2018 10:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:07:45.740156+01:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see the traces process"\r\r\t"Variable to activate traces or not."\r\tclausificationTrace:=false.\r\tskolemnTrace:=false.\r\tunificationTrace:=false.\r\tresolutionTrace:=false.\r\t\r\t""\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/15/2018 10:06',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see the traces process"\r\r\t"Variable to activate traces or not."\r\tclausificationTrace:=false.\r\tskolemnTrace:=false.\r\tunificationTrace:=false.\r\tresolutionTrace:=false.\r\t\r\t"Used to provided context during the textual tests available in the Prop class "\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/15/2018 10:07',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:08:24.431986+01:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testEverything,			#protocol : #testing,			#sourceCode : 'testEverything\r\tTranscript clear.\r\tProp initEverything.\r\t"Prop testingProp."\r\t"Prop testingMatch."\r\t"Prop testingClausification."\r\tProp testingFactorisation.\r\tProp testingResolvante.\r\tProp testingUnification.\r\tProp testingSkolemn.\r\tProp testingResolutionMethod.\r\r',			#stamp : 'pm 10/27/2018 08:27',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testEverything,			#protocol : #testing,			#sourceCode : 'testEverything\r\t"Launch a serie of textual tests"\r\tTranscript clear.\r\tProp initEverything.\r\t"Prop testingProp."\r\t"Prop testingMatch."\r\t"Prop testingClausification."\r\tProp testingFactorisation.\r\tProp testingResolvante.\r\tProp testingUnification.\r\tProp testingSkolemn.\r\tProp testingResolutionMethod.\r\r',			#stamp : 'pm 12/15/2018 10:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:09:48.016088+01:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingClausification,			#protocol : #testing,			#sourceCode : 'testingClausification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p |\r\t\r"\tTranscript clear."\r\tTranscript show: \'Testing clausification related stuff\';cr.\r\t\r\tp:=And new: (Var new: \'a\') rightProp: (False_Const new).\r\tp clausificationUnitTest.\r\r\tp:=Or new: (Var new: \'a\') rightProp: (False_Const new).\r\tp clausificationUnitTest.\r\r\tp:=Equal new: (Var new: \'a\') rightProp: (True_Const new).\r\tp clausificationUnitTest.\r\t\r\tp:=Imply new: (Var new: \'a\') rightProp: (True_Const new).\r\tp clausificationUnitTest.\r\r\t"unary"\r\tp:=Not new: (Var new: \'a\').\r\tp clausificationUnitTest.\r\t\r\tTranscript show: \'Bit more complicated stuff!\';cr.\r\t\r\tp:=Imply new: (Equal new: (Not new: (Var new: \'a\')) rightProp: (Var new: \'b\')) rightProp: (False_Const new).\r\tp clausificationUnitTest.\r\t\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/5/2018 00:09',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingClausification,			#protocol : #testing,			#sourceCode : 'testingClausification\r \t"some tests for the clausification. Obsolete."\r\t"Complete automated tests are now available."\r\t| p |\r\t\r\tTranscript show: \'Testing clausification related stuff\';cr.\r\t\r\tp:=And new: (Var new: \'a\') rightProp: (False_Const new).\r\tp clausificationUnitTest.\r\r\tp:=Or new: (Var new: \'a\') rightProp: (False_Const new).\r\tp clausificationUnitTest.\r\r\tp:=Equal new: (Var new: \'a\') rightProp: (True_Const new).\r\tp clausificationUnitTest.\r\t\r\tp:=Imply new: (Var new: \'a\') rightProp: (True_Const new).\r\tp clausificationUnitTest.\r\r\t"unary"\r\tp:=Not new: (Var new: \'a\').\r\tp clausificationUnitTest.\r\t\r\tTranscript show: \'Bit more complicated stuff!\';cr.\r\t\r\tp:=Imply new: (Equal new: (Not new: (Var new: \'a\')) rightProp: (Var new: \'b\')) rightProp: (False_Const new).\r\tp clausificationUnitTest.\r\t\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 12/15/2018 10:09',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:10:00.284937+01:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\r\tTranscript show:\'Unifiable positive const & linked predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'Unifiable negative const & linked predicate\';cr.\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\t"add multiple possible resolutions clauses next"\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 16:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\r\tTranscript show:\'Unifiable positive const & linked predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'Unifiable negative const & linked predicate\';cr.\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\t"add multiple possible resolutions clauses next"\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 12/15/2018 10:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:23:41.676976+01:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines, with textual output. Not automated"\r\t|t l r|\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl unificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t\r\t"should replace x by y at the end of the unification"\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:( LinkedTerm new:(Term new:\'x\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 12/14/2018 17:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:23:45.43913+01:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestUnification\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestUnification,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestUnification class\r\tinstanceVariableNames: \'\''				},				#name : #'TestUnification class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestUnification,					#isMetaSide : false				},				#parent : @7,				#content : 'Unification test. \rFor reference, the table of possible operations used is:\r\r             =         |     const      |   Linked    |     Func/Pred     \r        Const    |  Conflict     |  Swap       |    Check\r                        |  Delete        |                    |\r                        |                       |                     | \r     Linked     | Eliminate  |  Delete     |    Check\r                        |                       |                     | \rFunc/Pred  | Swap          |  Swap        |   Decompose\r                        |                       |                      |   Conflict\r                        |                       |                      | ',				#stamp : 'pm 12/14/2018 12:33'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #testing	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:25:01.260255+01:00' ],		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnFunc,			#protocol : #tests,			#sourceCode : 'testConstOnFunc\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aFuncTerm"\r\t\r\t"check fail"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair :=nil.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"check ok"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'a\')) right:(FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 16:28',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnFunc,			#protocol : #'tests - binary-resolution',			#sourceCode : 'testConstOnFunc\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aFuncTerm"\r\t\r\t"check fail"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair :=nil.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"check ok"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'a\')) right:(FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 16:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:25:01.264701+01:00' ],		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnLinked,			#protocol : #tests,			#sourceCode : 'testFuncOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=aLinkedTerm"\r\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"Will swap before eliminate and succeed"\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\t\t\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 17:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnLinked,			#protocol : #'tests - binary-resolution',			#sourceCode : 'testFuncOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=aLinkedTerm"\r\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"Will swap before eliminate and succeed"\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\t\t\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 17:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:25:01.268+01:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both test for aConstTerm = anotherConstTerm"\r\t\r\t"conflict rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"The resulting pair is the same as the input, since the unification was unnecessary"\r\texpectedResultPair:=(Pair left:left right:right).\r\t"the delete let us an empty set"\r\texpectedResultSetOfPair:=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 15:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #'tests - binary-resolution',			#sourceCode : 'testConstOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both test for aConstTerm = anotherConstTerm"\r\t\r\t"conflict rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"The resulting pair is the same as the input, since the unification was unnecessary"\r\texpectedResultPair:=(Pair left:left right:right).\r\t"the delete let us an empty set"\r\texpectedResultSetOfPair:=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 15:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:25:01.269657+01:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnLinked,			#protocol : #tests,			#sourceCode : 'testConstOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aLinkedTerm"\r\r\t"since they can\'t be equal. As proven by this assertion. (obviously)"\r\tself deny:(ConstTerm new: ( Term new: \'a\'))=(LinkedTerm new: ( Term new: \'a\'))."S"\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnLinked,			#protocol : #'tests - binary-resolution',			#sourceCode : 'testConstOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aLinkedTerm"\r\r\t"since they can\'t be equal. As proven by this assertion. (obviously)"\r\tself deny:(ConstTerm new: ( Term new: \'a\'))=(LinkedTerm new: ( Term new: \'a\'))."S"\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:25:01.272556+01:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\t"eliminate rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'y\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 11:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #'tests - binary-resolution',			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\t"eliminate rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'y\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 11:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:25:01.327673+01:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testEmptyPredicate,			#protocol : #tests,			#sourceCode : 'testEmptyPredicate\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"tests for empty predicates"\r\t\r\t"Decomposition rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'P\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\texpectedResultPair :=Pair left: left right: right.\r\texpectedResultSetOfPair:=MinimalOrderedSet new. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"Conflict rule on Symbols"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'Q\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"testing will fai, so everything will be nill"\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair:=nil. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 12:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testEmptyPredicate,			#protocol : #'tests - binary-resolution',			#sourceCode : 'testEmptyPredicate\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"tests for empty predicates"\r\t\r\t"Decomposition rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'P\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\texpectedResultPair :=Pair left: left right: right.\r\texpectedResultSetOfPair:=MinimalOrderedSet new. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"Conflict rule on Symbols"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'Q\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"testing will fai, so everything will be nill"\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair:=nil. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 12:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:25:12.131022+01:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnFunc,			#protocol : #'tests - binary-resolution',			#sourceCode : 'testConstOnFunc\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aFuncTerm"\r\t\r\t"check fail"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair :=nil.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"check ok"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'a\')) right:(FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 16:28',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnFunc,			#protocol : #'tests - binary resolution',			#sourceCode : 'testConstOnFunc\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aFuncTerm"\r\t\r\t"check fail"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair :=nil.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"check ok"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'a\')) right:(FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 16:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:25:12.133701+01:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnLinked,			#protocol : #'tests - binary-resolution',			#sourceCode : 'testFuncOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=aLinkedTerm"\r\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"Will swap before eliminate and succeed"\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\t\t\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 17:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnLinked,			#protocol : #'tests - binary resolution',			#sourceCode : 'testFuncOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=aLinkedTerm"\r\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"Will swap before eliminate and succeed"\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\t\t\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 17:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:25:12.135459+01:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #'tests - binary-resolution',			#sourceCode : 'testConstOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both test for aConstTerm = anotherConstTerm"\r\t\r\t"conflict rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"The resulting pair is the same as the input, since the unification was unnecessary"\r\texpectedResultPair:=(Pair left:left right:right).\r\t"the delete let us an empty set"\r\texpectedResultSetOfPair:=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 15:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #'tests - binary resolution',			#sourceCode : 'testConstOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both test for aConstTerm = anotherConstTerm"\r\t\r\t"conflict rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"The resulting pair is the same as the input, since the unification was unnecessary"\r\texpectedResultPair:=(Pair left:left right:right).\r\t"the delete let us an empty set"\r\texpectedResultSetOfPair:=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 15:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:25:12.137157+01:00' ],		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnLinked,			#protocol : #'tests - binary-resolution',			#sourceCode : 'testConstOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aLinkedTerm"\r\r\t"since they can\'t be equal. As proven by this assertion. (obviously)"\r\tself deny:(ConstTerm new: ( Term new: \'a\'))=(LinkedTerm new: ( Term new: \'a\'))."S"\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnLinked,			#protocol : #'tests - binary resolution',			#sourceCode : 'testConstOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aLinkedTerm"\r\r\t"since they can\'t be equal. As proven by this assertion. (obviously)"\r\tself deny:(ConstTerm new: ( Term new: \'a\'))=(LinkedTerm new: ( Term new: \'a\'))."S"\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:25:12.139471+01:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #'tests - binary-resolution',			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\t"eliminate rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'y\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 11:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #'tests - binary resolution',			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\t"eliminate rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'y\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 11:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:25:12.141024+01:00' ],		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testEmptyPredicate,			#protocol : #'tests - binary-resolution',			#sourceCode : 'testEmptyPredicate\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"tests for empty predicates"\r\t\r\t"Decomposition rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'P\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\texpectedResultPair :=Pair left: left right: right.\r\texpectedResultSetOfPair:=MinimalOrderedSet new. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"Conflict rule on Symbols"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'Q\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"testing will fai, so everything will be nill"\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair:=nil. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 12:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testEmptyPredicate,			#protocol : #'tests - binary resolution',			#sourceCode : 'testEmptyPredicate\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"tests for empty predicates"\r\t\r\t"Decomposition rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'P\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\texpectedResultPair :=Pair left: left right: right.\r\texpectedResultSetOfPair:=MinimalOrderedSet new. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"Conflict rule on Symbols"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'Q\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"testing will fai, so everything will be nill"\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair:=nil. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 12:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:25:33.077152+01:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpProtocolAddition {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestUnification\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestUnification,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestUnification class\r\tinstanceVariableNames: \'\''				},				#name : #'TestUnification class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestUnification,					#isMetaSide : false				},				#parent : @7,				#content : 'Unification test. \rFor reference, the table of possible operations used is:\r\r             =         |     const      |   Linked    |     Func/Pred     \r        Const    |  Conflict     |  Swap       |    Check\r                        |  Delete        |                    |\r                        |                       |                     | \r     Linked     | Eliminate  |  Delete     |    Check\r                        |                       |                     | \rFunc/Pred  | Swap          |  Swap        |   Decompose\r                        |                       |                      |   Conflict\r                        |                       |                      | ',				#stamp : 'pm 12/14/2018 12:33'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #'tests - binary factorisation'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:45:02.340035+01:00' ],		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:self.\r\tr:=Resolvante new.\r\t\t\r\texpected:=MinimalOrderedSet new\r\t\tadd:(Pair left:(LinkedTerm new:(Term new:\'x\')) right: (ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\t\t\r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 10:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:45:30.608644+01:00' ],		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:self.\r\tr:=Resolvante new.\r\t\t\r\texpected:=MinimalOrderedSet new\r\t\tadd:(Pair left:(LinkedTerm new:(Term new:\'x\')) right: (ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\t\t\r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 10:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=MinimalOrderedSet new\r\t\tadd:(Pair left:(LinkedTerm new:(Term new:\'x\')) right: (ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\t\t\r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 10:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:47:11.875964+01:00' ],		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherPair\r\t"comparator"\r\tself assert: ((anotherPair class)=(self class)).\r\t^(self left)=(anotherPair left) and:[(self right)=(anotherPair right)].',			#stamp : 'pm 11/11/2018 09:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherPair\r\t"comparator"\r\t^((anotherPair class)=(self class)) and:[\r\t\t(self left)=(anotherPair left) \r\t\tand:[(self right)=(anotherPair right)]].',			#stamp : 'pm 12/15/2018 10:47',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T10:52:10.890521+01:00' ],		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=MinimalOrderedSet new\r\t\tadd:(Pair left:(LinkedTerm new:(Term new:\'x\')) right: (ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\t\t\r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 10:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:((Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t\tyourself.\r\t\t\r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 10:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T11:21:49.541194+01:00' ],		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:((Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t\tyourself.\r\t\t\r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 10:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Or new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\t\trightProp: (False_Const new)));\r\t\tat:1.\r\t\t\r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 11:21',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T11:22:27.243013+01:00' ],		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Or new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\t\trightProp: (False_Const new)));\r\t\tat:1.\r\t\t\r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 11:21',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:((Clause new:(Or new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\t\trightProp: (False_Const new))));\r\t\tat:1.\r\t\t\r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 11:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T11:24:16.310058+01:00' ],		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:((Clause new:(Or new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\t\trightProp: (False_Const new))));\r\t\tat:1.\r\t\t\r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 11:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(((Clause new:(Or new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\t\trightProp: (False_Const new))))at:1).\r\t\t\r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 11:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T11:24:54.924869+01:00' ],		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(((Clause new:(Or new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\t\trightProp: (False_Const new))))at:1).\r\t\t\r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 11:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:((Clause new:(Or new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\t\trightProp: (False_Const new))));\r\t\tyourself.\r\t\t\r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 11:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T11:39:37.546979+01:00' ],		#prior : OmReference [ '72' ],		#self : OmReference [ '73' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:((Clause new:(Or new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\t\trightProp: (False_Const new))));\r\t\tyourself.\r\t\t\r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 11:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:((Clause new:(Or new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\t\trightProp: (False_Const new)))at:1);\r\t\tyourself.\r\t\t\r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 11:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T11:44:03.359515+01:00' ],		#prior : OmReference [ '73' ],		#self : OmReference [ '74' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:((Clause new:(Or new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\t\trightProp: (False_Const new)))at:1);\r\t\tyourself.\r\t\t\r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 11:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:((Clause new:(Or new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\t\trightProp: (False_Const new))) without: (False_Const new));\r\t\tyourself.\r\t\t\r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 11:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T11:45:55.086872+01:00' ],		#prior : OmReference [ '74' ],		#self : OmReference [ '75' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:((Clause new:(Or new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\t\trightProp: (False_Const new))) without: (False_Const new));\r\t\tyourself.\r\t\t\r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 11:44',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:((Clause new:(Or new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\t\trightProp: (False_Const new))) without: (False_Const new));\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 11:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T12:27:34.32118+01:00' ],		#prior : OmReference [ '75' ],		#self : OmReference [ '76' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:((Clause new:(Or new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\t\trightProp: (False_Const new))) without: (False_Const new));\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 11:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=Or new:(\r\tOr new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))))\r\t\trightProp: False_Const.\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:((Clause new:(Or new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\t\trightProp: (False_Const new))) without: (False_Const new));\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 12:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T12:27:37.568114+01:00' ],		#prior : OmReference [ '76' ],		#self : OmReference [ '77' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=Or new:(\r\tOr new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))))\r\t\trightProp: False_Const.\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:((Clause new:(Or new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\t\trightProp: (False_Const new))) without: (False_Const new));\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 12:27',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=Or new:(\r\tOr new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))))\r\t\trightProp: False_Const new.\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:((Clause new:(Or new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\t\trightProp: (False_Const new))) without: (False_Const new));\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 12:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T12:28:18.976222+01:00' ],		#prior : OmReference [ '77' ],		#self : OmReference [ '78' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'replace: aTerm by:anotherTerm\r\t""\r\t^self',			#stamp : 'pm 12/15/2018 12:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T12:28:19.037651+01:00' ],		#prior : OmReference [ '78' ],		#self : OmReference [ '79' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'replace: aTerm by:anotherTerm\r\t""\r\t^self',			#stamp : 'pm 12/15/2018 12:28',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace: aTerm by:anotherTerm\r\t""\r\t^self',			#stamp : 'pm 12/15/2018 12:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T12:34:14.060937+01:00' ],		#prior : OmReference [ '79' ],		#self : OmReference [ '80' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace: aTerm by:anotherTerm\r\t""\r\t^self',			#stamp : 'pm 12/15/2018 12:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T12:54:07.495349+01:00' ],		#prior : OmReference [ '80' ],		#self : OmReference [ '81' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Clause class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"creation of a new clause of a OrProp"\r\t^self basicNew initialize.',			#stamp : 'pm 12/15/2018 12:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T12:54:14.922181+01:00' ],		#prior : OmReference [ '81' ],		#self : OmReference [ '82' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Clause class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"creation of a new clause of a OrProp"\r\t^self basicNew initialize.',			#stamp : 'pm 12/15/2018 12:54',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Clause class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"creation of a new empty clause"\r\t^self basicNew initialize.',			#stamp : 'pm 12/15/2018 12:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T12:54:40.326318+01:00' ],		#prior : OmReference [ '82' ],		#self : OmReference [ '83' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Clause class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"creation of a new empty clause"\r\t^self basicNew initialize.',			#stamp : 'pm 12/15/2018 12:54',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Clause class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"creation of a new empty clause"\r\t^self basicNew.',			#stamp : 'pm 12/15/2018 12:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T12:55:02.407738+01:00' ],		#prior : OmReference [ '83' ],		#self : OmReference [ '84' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=Or new:(\r\tOr new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))))\r\t\trightProp: False_Const new.\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:((Clause new:(Or new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\t\trightProp: (False_Const new))) without: (False_Const new));\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 12:27',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=Or new:(\r\tOr new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))))\r\t\trightProp: False_Const new.\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 12:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T12:55:17.415671+01:00' ],		#prior : OmReference [ '84' ],		#self : OmReference [ '85' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=Or new:(\r\tOr new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))))\r\t\trightProp: False_Const new.\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 12:55',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 12:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T12:57:52.68832+01:00' ],		#prior : OmReference [ '85' ],		#self : OmReference [ '86' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r\r\t"Unifiable negative const & linked predicate"\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.',			#stamp : 'pm 12/15/2018 12:55',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 12:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T12:58:32.753593+01:00' ],		#prior : OmReference [ '86' ],		#self : OmReference [ '87' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testNegativeFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testNegativeFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Not new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp: (Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Not new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 12:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T12:59:02.905492+01:00' ],		#prior : OmReference [ '87' ],		#self : OmReference [ '88' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisationConstOnLink,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisationConstOnLink\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 12:59',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T12:59:39.007966+01:00' ],		#prior : OmReference [ '88' ],		#self : OmReference [ '89' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisationLinkOnLink,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisationLinkOnLink\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\'))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 12:59',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T13:00:01.730012+01:00' ],		#prior : OmReference [ '89' ],		#self : OmReference [ '90' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisationLinkOnLink,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisationLinkOnLink\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\'))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 12:59',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisationLinkOnLink,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisationLinkOnLink\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\'))))\r\t\tyourself.\r\t\t\r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 13:00',			#package : #_resolution_1erOrdre		}	}}