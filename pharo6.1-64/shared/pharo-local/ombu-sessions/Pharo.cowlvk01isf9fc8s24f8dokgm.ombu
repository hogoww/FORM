OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T18:05:07.308136+02:00' ],		#prior : OmReference [ 'Pharo.d76ddxnn5wea5quz9df29j9p6', '4' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\t[i<=(self arity)]\r\twhileTrue: [  \r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [\r\t\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/20/2018 09:49',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\t[i<=(self arity)]\r\twhileTrue: [  \r\t\t((terms at:i) isKindOf: FuncTerm)"No superior order, so no need to check if it\'s a predicate"\r\t\tifTrue: [\r\t\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/20/2018 18:05',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T18:05:32.03292+02:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:oldVersion:',			#protocol : #adding,			#sourceCode : 'replace:x by:t oldVersion:v\r\tterms do:[:each| each replace:x by:t].',			#stamp : 'pm 10/19/2018 18:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T18:06:02.831695+02:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue:[ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/20/2018 09:47',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t((terms at:i) isKindOf: FuncTerm)"No superior order, so no need to check if it\'s a predicate"\r\t\tifTrue:[ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/20/2018 18:06',			#package : #_resolution_1erOrdre		}	}}