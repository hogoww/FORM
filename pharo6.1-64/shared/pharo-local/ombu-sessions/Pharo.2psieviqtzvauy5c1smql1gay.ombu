OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-21T09:13:27.992183+02:00' ],		#prior : OmReference [ 'Pharo.fftfl70l52iog0a90y7we4dv', '4' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacementPair:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacementPair:aPair replaced:left by:right\r\t^Pair left:(self replacement: (aPair left) replaced:left by:right)\r\t\t  right:(self replacement: (aPair right) replaced:left by:right)\r',			#stamp : 'pm 10/20/2018 17:21',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacementPair:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacementPair:aPair replaced:left by:right\r\t^Pair left:(self replacement: (aPair left) replaced:left by:right)\r\t\t  right:(self replacement: (aPair right) replaced:left by:right).\r',			#stamp : 'pm 10/21/2018 09:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-21T09:15:49.771663+02:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacementPair:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacementPair:aPair replaced:left by:right\r\t^Pair left:(self replacement: (aPair left) replaced:left by:right)\r\t\t  right:(self replacement: (aPair right) replaced:left by:right).\r',			#stamp : 'pm 10/21/2018 09:13',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacementPair:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacementPair:aPair replaced:x by:t\r\t^Pair left:(self replacement: (aPair left) replaced:x by:t)\r\t\t  right:(self replacement: (aPair right) replaced:x by:t).\r',			#stamp : 'pm 10/21/2018 09:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-21T09:16:40.020252+02:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacement:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacement:aTerm replaced:left by:right\r\t((aTerm isKindOf: FuncTerm)or:[aTerm isKindOf: Predicate])\r\tifTrue:[\r\t\t^aTerm replace:left by:right.\r\t\t]"if it\'s something else than a functerm, "\r\tifFalse:[\r\t\t(aTerm=left)\r\t\tifTrue:[^right]\r\t\tifFalse:[^aTerm].\r\t\t].\r ',			#stamp : 'pm 10/20/2018 18:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacement:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacement:aTerm replaced:x by:t\r\t((aTerm isKindOf: FuncTerm)or:[aTerm isKindOf: Predicate])\r\tifTrue:[\r\t\t^aTerm replace:x by:t.\r\t\t]"if it\'s something else than a functerm, "\r\tifFalse:[\r\t\t(aTerm=x)\r\t\tifTrue:[^t]\r\t\tifFalse:[^aTerm].\r\t\t].\r ',			#stamp : 'pm 10/21/2018 09:16',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-21T09:24:55.027811+02:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tTranscript cr;cr;show:\'pouet\';cr;cr.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t(Prop debugUnification)\r\t\t\tifTrue:[Transcript show:\'conflict\';cr.].\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[right isConst])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"notPossible:=self check:aPair"\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 10/21/2018 08:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t(Prop debugUnification)\r\t\t\tifTrue:[Transcript show:\'conflict\';cr.].\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[right isConst])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"notPossible:=self check:aPair"\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 10/21/2018 09:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-21T09:33:11.634884+02:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue:[ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/20/2018 09:47',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\r\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue:[ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/21/2018 09:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-21T09:33:16.442979+02:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\r\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue:[ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/21/2018 09:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\r\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue:[ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].\r\t^self',			#stamp : 'pm 10/21/2018 09:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-21T09:33:33.109326+02:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\t[i<=(self arity)]\r\twhileTrue: [  \r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [\r\t\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/20/2018 09:49',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\t[i<=(self arity)]\r\twhileTrue: [  \r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [\r\t\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].\r\t^self',			#stamp : 'pm 10/21/2018 09:33',			#package : #_resolution_1erOrdre		}	}}