OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-19T17:41:46.45701+02:00' ],		#prior : OmReference [ 'Pharo.hswpza4xmtz8tgggsd98vwr4', '20' ],		#self : OmReference [ '1' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '1wfmfgmujdk5v2rvjz3z9mbsy', '1' ],			OmReference [ '1wfmfgmujdk5v2rvjz3z9mbsy', '2' ],			OmReference [ '1wfmfgmujdk5v2rvjz3z9mbsy', '3' ],			OmReference [ '1wfmfgmujdk5v2rvjz3z9mbsy', '4' ],			OmReference [ '1wfmfgmujdk5v2rvjz3z9mbsy', '5' ],			OmReference [ '1wfmfgmujdk5v2rvjz3z9mbsy', '6' ],			OmReference [ '1wfmfgmujdk5v2rvjz3z9mbsy', '7' ],			OmReference [ '1wfmfgmujdk5v2rvjz3z9mbsy', '8' ]		]	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ],		#time : DateAndTime [ '2018-10-19T17:41:46.468551+02:00' ],		#trigger : @3	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified operationAnswer|\r\tmodified:=true.\r\t[modified] whileTrue:[\r\t\tmodified:=false.\r\t\tsetOfPairs do:[:each |\r\t\t\t\t(Prop debugUnification)\r\t\t\t\tifTrue:[Transcript show:self;cr.].\r\r\t\t\t\toperationAnswer:=self tryOperations: each.\r\t\t\t\t(operationAnswer right)"NotPossible to unify?"\r\t\t\t\tifTrue:["On a conflict or a fail check"\r\t\t\t\t\tTranscript show:\'Unification impossible\';cr."TEMPORARY"\r\t\t\t\t\t^nil.\r\t\t\t\t\t]."else we go on till we didn\'t do anything more"\r\t\t\t\tmodified:=modified or:[operationAnswer left.]."isModified was put arbitrily= in left"\r\t\t\t]\r\t\t].\r\t^setOfPairs.\r\t',			#stamp : 'pm 10/18/2018 20:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t|modified operationAnswer|\r\tmodified:=true.\r\t[modified] whileTrue:[\r\t\tmodified:=false.\r\t\tsetOfPairs do:[:each |\r\t\t\t\t(Prop debugUnification)\r\t\t\t\tifTrue:[Transcript show:self;cr.].\r\r\t\t\t\toperationAnswer:=self tryOperations: each.\r\t\t\t\t(operationAnswer right)"NotPossible to unify?"\r\t\t\t\tifTrue:["On a conflict or a fail check"\r\t\t\t\t\tTranscript show:\'Unification impossible\';cr."TEMPORARY"\r\t\t\t\t\tsetOfPairs:=nil.\r\t\t\t\t\t^0"return value doesn\'t matter, we just want to break out"\r\t\t\t\t\t].\r\t\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\t\tmodified:=modified or:[operationAnswer left.]."isModified was put arbitrily= in left"\r\t\t\t]\r\t\t].\r\t',			#stamp : 'pm 10/19/2018 17:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ],		#time : DateAndTime [ '2018-10-19T17:41:46.499695+02:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Unifier\r\tinstanceVariableNames: \'setOfPairs\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Unifier,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #setOfPairs,					#parent : @8				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Unifier class\r\tinstanceVariableNames: \'\''				},				#name : #'Unifier class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Unifier,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Unifier\r\tinstanceVariableNames: \'setOfPairs hasFailed initialPair\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Unifier,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #setOfPairs,					#parent : @24				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #hasFailed,					#parent : @24				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #initialPair,					#parent : @24				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Unifier class\r\tinstanceVariableNames: \'\''				},				#name : #'Unifier class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @24			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Unifier,					#isMetaSide : false				},				#parent : @24,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ],		#time : DateAndTime [ '2018-10-19T17:41:46.617564+02:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'initialize:Predicate2:',			#protocol : #initialization,			#sourceCode : 'initialize: p1 Predicate2: p2\r\tsetOfPairs:=MinimalOrderedSet new.\r\tsetOfPairs add:(Pair left: p1 right: p2).',			#stamp : 'pm 10/15/2018 16:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'initialize:Predicate2:',			#protocol : #initialization,			#sourceCode : 'initialize: p1 Predicate2: p2\r\t"initialized with two predicates, that we\'ll try to unify."\r\r\t"init two different pair to be sure that we have the initial\r\tone to unify at the end."\r\tinitialPair:=(Pair left: p1 right: p2).\r\tsetOfPairs:=MinimalOrderedSet new.\r\tsetOfPairs add:(Pair left: p1 right: p2).\r\thasFailed:=false.\r',			#stamp : 'pm 10/19/2018 17:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ],		#time : DateAndTime [ '2018-10-19T17:41:46.624052+02:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'check:',			#protocol : #unification,			#sourceCode : 'check: aPair\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'check\';cr.].\r\t\r\t^((aPair right) contains: aPair left).',			#stamp : 'pm 10/18/2018 22:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'check:',			#protocol : #unification,			#sourceCode : 'check: aPair\r\t"Not active yet"\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'check\';cr.].\r\t\r\t^((aPair right) contains: aPair left).',			#stamp : 'pm 10/19/2018 17:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ],		#time : DateAndTime [ '2018-10-19T17:41:46.645942+02:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tt unifyMe.\r\tTranscript show:t;cr;cr.\r\t^t',			#stamp : 'pm 10/18/2018 17:13',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tt:=\tt unifyThis.\r\tTranscript show:t;cr;cr.\r\t^t',			#stamp : 'pm 10/19/2018 17:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ],		#time : DateAndTime [ '2018-10-19T17:41:46.652555+02:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tdebug:=false.\r\tdebugUnification:=true.\r\ttestNumber:=0.',			#stamp : 'pm 10/18/2018 21:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tdebug:=false.\r\tdebugUnification:=false.\r\ttestNumber:=0.',			#stamp : 'pm 10/19/2018 17:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ],		#time : DateAndTime [ '2018-10-19T17:41:46.659064+02:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right previousSet newSet |\r\t\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'eliminate\';cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\t\r\tpreviousSet:=setOfPairs veryDeepCopy."we need to work on a copy, to avoid having another iteration"\r\tpreviousSet remove:aPair.\r\t\r\tpreviousSet do:[:each |\r\t\t"tempVar:=each veryDeepCopy.""since we modify the underlying data, we work on a copy"\r\t\tnewSet add:(Pair left: ((each left) replace: left by:right)\r\t\t\t\t\t\t\t\tright:((each right) replace:left by:right)).].\r\tTranscript show:\'Previous Set \';show:previousSet;cr;show:\'newOne \';show:newSet;cr.\r\t(previousSet = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r',			#stamp : 'pm 10/18/2018 21:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right previousSet newSet |\r\t\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'eliminate\';cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\t\r\tpreviousSet:=setOfPairs veryDeepCopy."we need to work on a copy, to avoid having another iteration"\r\tpreviousSet remove:aPair.\r\t\r\tpreviousSet do:[:each |\r\t\t"tempVar:=each veryDeepCopy.""since we modify the underlying data, we work on a copy"\r\t\tnewSet add:(Pair left: ((each left) replace: left by:right)\r\t\t\t\t\t\t\t\tright:((each right) replace:left by:right)).].\r\t(previousSet = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r',			#stamp : 'pm 10/19/2018 17:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ],		#time : DateAndTime [ '2018-10-19T17:41:46.665282+02:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\tsetOfPairs do:[ :each | \r\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t].\r\t^initialPair',			#stamp : 'pm 10/19/2018 17:41',			#package : #_resolution_1erOrdre		}	}}