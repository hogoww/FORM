OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:25:14.265594+01:00' ],		#prior : OmReference [ 'Pharo.a97xex4namomp5c8vvxydrqfg', '19' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\telem:=aMap at:(self prettyPrint) ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/11/2018 15:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t"Part of the skolemnisation process.\r\tStep which determines what kind of term each term in each predicate is (func/const/Linked"\r\t"For argument, see documentation in Prop::SkolemnisationDocu."\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\telem:=aMap at:(self prettyPrint) ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/28/2018 14:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:25:44.367394+01:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t^SubclassResponsibility.',			#stamp : 'pm 10/11/2018 10:56',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t"Does a pretty print of the current object"\r\t^SubclassResponsibility.',			#stamp : 'pm 10/28/2018 14:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:26:26.25623+01:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: stream\r\tstream nextPutAll: (self prettyPrint).',			#stamp : 'pm 10/18/2018 17:20',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: stream\r\t"Override of basic printOn, for use in transcripts.\r\tShows the current object"\r\tstream nextPutAll: (self prettyPrint).',			#stamp : 'pm 10/28/2018 14:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:27:47.679562+01:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherFuncTerm\r\t| res |\r\tres:=anotherFuncTerm isKindOf: FuncTerm."checking the input"\r\tres:=res and:[(self isSameSymb: anotherFuncTerm)]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherFuncTerm]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherFuncTerm).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 10/18/2018 16:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherFuncTerm\r\t"Comparaison Operator."\r\t| res |\r\tself assert:(anotherFuncTerm isKindOf: FuncTerm)."checking the input"\r\tres:=res and:[(self isSameSymb: anotherFuncTerm)]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherFuncTerm]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherFuncTerm).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 10/28/2018 14:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:28:02.230844+01:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| newVars t|\r\tnewVars:=LinkedList new.\r\tterms do: [ :each | newVars add: (each WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].\r\tt:=(FuncTerm new: (self getSymb) Variables:newVars).\r\t^t.',			#stamp : 'pm 10/11/2018 16:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t"CF AbstractTerm"\r\t| newVars t|\r\tnewVars:=LinkedList new.\r\tterms do: [ :each | newVars add: (each WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].\r\tt:=(FuncTerm new: (self getSymb) Variables:newVars).\r\t^t.',			#stamp : 'pm 10/28/2018 14:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:29:00.818305+01:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'addTerm:',			#protocol : #adding,			#sourceCode : 'addTerm: aTerm\r\tterms add:aTerm.',			#stamp : 'pm 10/18/2018 10:58',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'addTerm:',			#protocol : #adding,			#sourceCode : 'addTerm: aTerm\r\t"add aTerm to the list of this predicate or function\'s list."\r\tself assert:(aTerm isKindOf: Term).\r\tterms add:aTerm.',			#stamp : 'pm 10/28/2018 14:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:29:08.925578+01:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'addTerm:',			#protocol : #adding,			#sourceCode : 'addTerm: aTerm\r\t"add aTerm to the list of this predicate or function\'s list."\r\tself assert:(aTerm isKindOf: Term).\r\tterms add:aTerm.',			#stamp : 'pm 10/28/2018 14:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'addTerm:',			#protocol : #adding,			#sourceCode : 'addTerm: aTerm\r\t"add aTerm to the list of this predicate or function\'s list."\r\tself assert:(aTerm isKindOf: AbstractTerm).\r\tterms add:aTerm.',			#stamp : 'pm 10/28/2018 14:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:30:30.114028+01:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherFuncTerm\r\t"Comparaison Operator."\r\t| res |\r\tself assert:(anotherFuncTerm isKindOf: FuncTerm)."checking the input"\r\tres:=res and:[(self isSameSymb: anotherFuncTerm)]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherFuncTerm]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherFuncTerm).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 10/28/2018 14:27',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherFuncTerm\r\t"Comparaison Operator."\r\t| res |\r\tself assert:(anotherFuncTerm isKindOf: FuncTerm)."checking the input"\r\tres:=self isSameSymb: anotherFuncTerm."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherFuncTerm]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherFuncTerm).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 10/28/2018 14:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:30:51.751816+01:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #arity,			#protocol : #accessing,			#sourceCode : 'arity\r\t^terms size.\r\t\r',			#stamp : 'pm 10/18/2018 18:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #arity,			#protocol : #accessing,			#sourceCode : 'arity\r\t"Return the arity of this FuncTerm"\r\t^terms size.\r\t\r',			#stamp : 'pm 10/28/2018 14:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:32:13.47675+01:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'at: index \r\t^ (self terms) at:index.',			#stamp : 'pm 10/18/2018 09:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'at: index \r\t"Transmit the at:index message to the terms attribute"\r\t^ (self terms) at:index.',			#stamp : 'pm 10/28/2018 14:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:32:36.396109+01:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'at: index \r\t"Transmit the at:index message to the terms attribute"\r\t^ (self terms) at:index.',			#stamp : 'pm 10/28/2018 14:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'at: index \r\t"Transmit the at:index message to the terms attribute"\r\tself assert: (index isInteger).\r\t^ (self terms) at:index.',			#stamp : 'pm 10/28/2018 14:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:32:39.560053+01:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'at: index \r\t"Transmit the at:index message to the terms attribute"\r\tself assert: (index isInteger).\r\t^ (self terms) at:index.',			#stamp : 'pm 10/28/2018 14:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'at: index \r\t"Transmit the at:index message to the terms attribute"\r\t^ (self terms) at:index.',			#stamp : 'pm 10/28/2018 14:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:33:37.763433+01:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'at: index \r\t"Transmit the at:index message to the terms attribute"\r\t^ (self terms) at:index.',			#stamp : 'pm 10/28/2018 14:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'at: index \r\t"Transmit the at:index message to the terms attribute\r\treturns the term at the index index."\r\t^ (self terms) at:index.',			#stamp : 'pm 10/28/2018 14:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:34:22.921371+01:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'contains:',			#protocol : #printing,			#sourceCode : 'contains: aTerm\r\t^ terms anySatisfy: [ :each | each contains: aTerm ]',			#stamp : 'pm 10/18/2018 22:07',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'contains:',			#protocol : #printing,			#sourceCode : 'contains: aTerm\r\t"Check if the term has at least one occurence in the current functerm"\r\t^ terms anySatisfy: [ :each | each contains: aTerm ]',			#stamp : 'pm 10/28/2018 14:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:35:53.226911+01:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #getSymb,			#protocol : #accessing,			#sourceCode : 'getSymb\r\t^symb',			#stamp : 'pm 10/11/2018 09:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #getSymb,			#protocol : #accessing,			#sourceCode : 'getSymb\r\t"accessor"\r\t^symb',			#stamp : 'pm 10/28/2018 14:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:36:15.011714+01:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: symbo\r\tsymb:=symbo.\r\tterms:=LinkedListFix new.',			#stamp : 'pm 10/22/2018 09:44',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: symbo\r\t"initialization, for an empty functerm"\r\tsymb:=symbo.\r\tterms:=LinkedListFix new.',			#stamp : 'pm 10/28/2018 14:36',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:37:53.703739+01:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'initialize:Variable:',			#protocol : #initialization,			#sourceCode : 'initialize: symbo Variable: aTerm\r\tsymb:=symbo.\r\tterms:=LinkedListFix new.\r\tterms add: aTerm.',			#stamp : 'pm 10/22/2018 09:44',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'initialize:Variable:',			#protocol : #initialization,			#sourceCode : 'initialize: symbo Variable: aTerm\r\t"initialization with only one term of a funcTerm"\r\tsymb:=symbo.\r\tterms:=LinkedListFix new.\r\tterms add: aTerm.',			#stamp : 'pm 10/28/2018 14:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:38:52.133091+01:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'initialize:Variables:',			#protocol : #initialization,			#sourceCode : 'initialize: symbo Variables: listOfLinkedVar\r\tsymb:=symbo.\r\tterms:=LinkedListFix new.\r\tlistOfLinkedVar  do: [:each | terms add: each.].',			#stamp : 'pm 10/22/2018 09:44',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'initialize:Variables:',			#protocol : #initialization,			#sourceCode : 'initialize: symbo Variables: listOfLinkedVar\r\t"variadic initialization of a funcTerm.\r\tlistOfLinkedVar can actually be any kind of enumerable object."\r\tsymb:=symbo.\r\tterms:=LinkedListFix new.\r\tlistOfLinkedVar  do: [:each | terms add: each.].',			#stamp : 'pm 10/28/2018 14:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:39:07.864626+01:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #isConst,			#protocol : #testing,			#sourceCode : 'isConst\r\tterms do:[:each | (each isConst)ifFalse:[^false]].\r\t^true',			#stamp : 'pm 10/15/2018 16:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #isConst,			#protocol : #testing,			#sourceCode : 'isConst\r \t"is const if every terms of his is const"\r\tterms do:[:each | (each isConst)ifFalse:[^false]].\r\t^true',			#stamp : 'pm 10/28/2018 14:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:39:50.266048+01:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameArity:',			#protocol : #comparing,			#sourceCode : 'isSameArity:anotherFuncTerm\r\t^(self arity)=(anotherFuncTerm arity).',			#stamp : 'pm 10/17/2018 12:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameArity:',			#protocol : #comparing,			#sourceCode : 'isSameArity:anotherFuncTerm\r\t"check if 2 FuncTerm have the same number of arguments"\r\t^(self arity)=(anotherFuncTerm arity).',			#stamp : 'pm 10/28/2018 14:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:40:02.431955+01:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameSymb:',			#protocol : #comparing,			#sourceCode : 'isSameSymb:anotherFuncTerm\r\t^(self getSymb)=(anotherFuncTerm getSymb).',			#stamp : 'pm 10/17/2018 12:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameSymb:',			#protocol : #comparing,			#sourceCode : 'isSameSymb:anotherFuncTerm\r\t"Do both funcTerm have the same symbol"\r\t^(self getSymb)=(anotherFuncTerm getSymb).',			#stamp : 'pm 10/28/2018 14:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:41:14.786178+01:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameTerms:',			#protocol : #comparing,			#sourceCode : 'isSameTerms: anotherFuncTerm\r\t^(self terms) = (anotherFuncTerm terms).',			#stamp : 'pm 10/17/2018 12:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameTerms:',			#protocol : #comparing,			#sourceCode : 'isSameTerms: anotherFuncTerm\r\t"check if every terms are in both FuncTerms."\r\t^(self terms) = (anotherFuncTerm terms).',			#stamp : 'pm 10/28/2018 14:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:41:27.934996+01:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t|t|\r\tt:=(self getSymb),\'(\'.\r\tterms do: [:each| t:=t,each prettyPrint. ] separatedBy:[t:=t,\',\'].\r\tt:=t,\')\'.\r\t^t.\r\t',			#stamp : 'pm 10/11/2018 09:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t"prettyprint of the current FuncTerm"\r\t|t|\r\tt:=(self getSymb),\'(\'.\r\tterms do: [:each| t:=t,each prettyPrint. ] separatedBy:[t:=t,\',\'].\r\tt:=t,\')\'.\r\t^t.\r\t',			#stamp : 'pm 10/28/2018 14:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:41:58.067688+01:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue:[ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].\r\t^self',			#stamp : 'pm 10/22/2018 10:07',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t"replace every occurence of the term \'x\' with the term \'t\'"\r\t| i |\r\ti:=1.\r\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue:[ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].\r\t^self',			#stamp : 'pm 10/28/2018 14:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:42:06.761399+01:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #terms,			#protocol : #accessing,			#sourceCode : 'terms\r\t^terms',			#stamp : 'pm 10/6/2018 19:28',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #terms,			#protocol : #accessing,			#sourceCode : 'terms\r\t"accessor"\r\t^terms',			#stamp : 'pm 10/28/2018 14:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:44:10.875041+01:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #getNewFuncName,			#protocol : #'instance creation',			#sourceCode : 'getNewFuncName\r\tcurrentFuncNumber :=currentFuncNumber +1.\r\t^anonymousFuncSymb,(currentFuncNumber asString).',			#stamp : 'pm 10/11/2018 15:11',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #getNewFuncName,			#protocol : #'instance creation',			#sourceCode : 'getNewFuncName\r\t"Generator of anonymous function names. Used during skolemnisation"\r\tcurrentFuncNumber :=currentFuncNumber +1.\r\t^anonymousFuncSymb,(currentFuncNumber asString).',			#stamp : 'pm 10/28/2018 14:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:45:14.060219+01:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tcurrentFuncNumber:=0.\r\tanonymousFuncSymb:=\'f\'.',			#stamp : 'pm 10/18/2018 21:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialization of the class."\r\tcurrentFuncNumber:=0."we start anonymous functions number at 0."\r\tanonymousFuncSymb:=\'f\'."mutable anonymous function name."',			#stamp : 'pm 10/28/2018 14:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:45:23.993983+01:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t^self basicNew initialize: (self getNewFuncName).',			#stamp : 'pm 10/11/2018 15:01',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t""\r\t^(self basicNew) initialize: (self getNewFuncName).',			#stamp : 'pm 10/28/2018 14:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:45:41.505769+01:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t""\r\t^(self basicNew) initialize: (self getNewFuncName).',			#stamp : 'pm 10/28/2018 14:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"creation of a new anonymous funcTerm"\r\t^(self basicNew) initialize: (self getNewFuncName).',			#stamp : 'pm 10/28/2018 14:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:46:04.390638+01:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: symbo\r\t^self basicNew initialize:symbo.',			#stamp : 'pm 10/11/2018 15:01',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: symbo\r\t"creation of a new named funcTerm "\r\t^self basicNew initialize:symbo.',			#stamp : 'pm 10/28/2018 14:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:46:10.700362+01:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: symbo\r\t"creation of a new named funcTerm "\r\t^self basicNew initialize:symbo.',			#stamp : 'pm 10/28/2018 14:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: symbo\r\t"creation of a new named empty funcTerm "\r\t^self basicNew initialize:symbo.',			#stamp : 'pm 10/28/2018 14:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:46:28.616254+01:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'new:Variable:',			#protocol : #'instance creation',			#sourceCode : 'new: symbo Variable: aVar\r\t^self basicNew initialize:symbo Variable: aVar.',			#stamp : 'pm 10/10/2018 21:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'new:Variable:',			#protocol : #'instance creation',			#sourceCode : 'new: symbo Variable: aVar\r\t"creation of a new named funcTerm, with a term \'f(x)\'"\r\t^self basicNew initialize:symbo Variable: aVar.',			#stamp : 'pm 10/28/2018 14:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:46:39.221938+01:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'new:Variables:',			#protocol : #'instance creation',			#sourceCode : 'new: symbo Variables: setOfLinkedVar\r\t^self basicNew initialize:symbo Variables: setOfLinkedVar.',			#stamp : 'pm 10/7/2018 15:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'new:Variables:',			#protocol : #'instance creation',			#sourceCode : 'new: symbo Variables: setOfLinkedVar\r\t"creation of a new named variadic funcTerm"\r\t^self basicNew initialize:symbo Variables: setOfLinkedVar.',			#stamp : 'pm 10/28/2018 14:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:47:13.576701+01:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'newFunc:',			#protocol : #'instance creation',			#sourceCode : 'newFunc: variable\r\t^self basicNew initialize: (self getNewFuncName) Variable:variable.',			#stamp : 'pm 10/11/2018 15:07',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'newFunc:',			#protocol : #'instance creation',			#sourceCode : 'newFunc: variable\r\t"creation of a new anonymous funcTerm, with a variable"\r\t^self basicNew initialize: (self getNewFuncName) Variable:variable.',			#stamp : 'pm 10/28/2018 14:47',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:47:25.090879+01:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'newFuncWithVars:',			#protocol : #'instance creation',			#sourceCode : 'newFuncWithVars: varList\r\t^self basicNew initialize: (self getNewFuncName) Variables:varList.',			#stamp : 'pm 10/11/2018 15:06',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'newFuncWithVars:',			#protocol : #'instance creation',			#sourceCode : 'newFuncWithVars: varList\r\t"creation of a new anonymous variadic funcTerm"\r\t^self basicNew initialize: (self getNewFuncName) Variables:varList.',			#stamp : 'pm 10/28/2018 14:47',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:47:55.34595+01:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Term class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: aName\r\t^(self basicNew) initialize:aName.',			#stamp : 'pm 10/11/2018 11:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Term class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: aName\r\t"Creation of a term, which are represented by a name"\r\t^(self basicNew) initialize:aName.',			#stamp : 'pm 10/28/2018 14:47',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:48:37.147396+01:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #getSymb,			#protocol : #accessing,			#sourceCode : 'getSymb\r\t^symb',			#stamp : 'pm 10/11/2018 11:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #getSymb,			#protocol : #accessing,			#sourceCode : 'getSymb\r\t"accessor"\r\t^symb',			#stamp : 'pm 10/28/2018 14:48',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T14:48:48.474959+01:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #accessing,			#sourceCode : 'initialize: aName\r\tsymb:=aName.\r',			#stamp : 'pm 10/11/2018 12:05',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #accessing,			#sourceCode : 'initialize: aName\r\t"initialization of a named term"\r\tsymb:=aName.\r',			#stamp : 'pm 10/28/2018 14:48',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:00:11.835267+01:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint \r\t^self getSymb.\r',			#stamp : 'pm 10/11/2018 11:55',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint \r\t"return current term as string"\r\t^self getSymb.\r',			#stamp : 'pm 10/28/2018 15:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:00:38.986191+01:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'UnaryTerm class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: aTerm\r\t^(self basicNew) initialize:aTerm.',			#stamp : 'pm 10/11/2018 09:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'UnaryTerm class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: aTerm\r\t"Creation of a term, with a symbol"\r\t^(self basicNew) initialize:aTerm.',			#stamp : 'pm 10/28/2018 15:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:00:49.548258+01:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t^(anotherTerm isKindOf: (self class)) and:[(self term)=(anotherTerm term).].\r\t\r\t\r\t',			#stamp : 'pm 10/21/2018 13:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t"comparaison operator"\r\t^(anotherTerm isKindOf: (self class)) and:[(self term)=(anotherTerm term).].\r\t\r\t\r\t',			#stamp : 'pm 10/28/2018 15:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:01:07.643277+01:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'contains:',			#protocol : #testing,			#sourceCode : 'contains: aTerm\r\t^term = aTerm.',			#stamp : 'pm 10/18/2018 22:08',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'contains:',			#protocol : #testing,			#sourceCode : 'contains: aTerm\r\t"Check if the contained term is the same as the argument"\r\t^term = aTerm.',			#stamp : 'pm 10/28/2018 15:01',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:01:30.206111+01:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialize,			#sourceCode : 'initialize:aTerm\r\t(aTerm isKindOf: Term)\r\tifFalse:[^self error:\'Takes only Terms as parameters. This is a\', (aTerm class). ]\r\tifTrue:[term:=aTerm].',			#stamp : 'pm 10/26/2018 22:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialize,			#sourceCode : 'initialize:aTerm\r\t"initialize an UnaryTerm with a term under it."\r\t(aTerm isKindOf: Term)\r\tifFalse:[^self error:\'Takes only Terms as parameters. This is a\', (aTerm class). ]\r\tifTrue:[term:=aTerm].',			#stamp : 'pm 10/28/2018 15:01',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:01:34.3575+01:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialize,			#sourceCode : 'initialize:aTerm\r\t"initialize an UnaryTerm with a term under it."\r\t(aTerm isKindOf: Term)\r\tifFalse:[^self error:\'Takes only Terms as parameters. This is a\', (aTerm class). ]\r\tifTrue:[term:=aTerm].',			#stamp : 'pm 10/28/2018 15:01',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialize,			#sourceCode : 'initialize:aTerm\r\t"initialize an UnaryTerm with a term as argument"\r\t(aTerm isKindOf: Term)\r\tifFalse:[^self error:\'Takes only Terms as parameters. This is a\', (aTerm class). ]\r\tifTrue:[term:=aTerm].',			#stamp : 'pm 10/28/2018 15:01',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:02:14.234913+01:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t^self error:\'shouldn\'\'t be able to get here\'.\r\t"(term = x term)\r\tifTrue:[term:=t.]"',			#stamp : 'pm 10/20/2018 17:21',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t"This message is only for predicate & funterms. They both deal with unary terms."\r\t^self error:\'shouldn\'\'t be able to get here\'.',			#stamp : 'pm 10/28/2018 15:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:02:31.275308+01:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t"This message is only for predicate & funterms. They both deal with unary terms."\r\t^self error:\'shouldn\'\'t be able to get here\'.',			#stamp : 'pm 10/28/2018 15:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t"This message is only for predicate & funterms. They both deal with unary terms to be able to modify the type of the terms."\r\t^self error:\'shouldn\'\'t be able to get here\'.',			#stamp : 'pm 10/28/2018 15:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:03:09.793621+01:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #term,			#protocol : #accessing,			#sourceCode : 'term\r\t^term.',			#stamp : 'pm 10/19/2018 18:07',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #term,			#protocol : #accessing,			#sourceCode : 'term\r\t"accessor"\r\t^term.',			#stamp : 'pm 10/28/2018 15:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:03:49.651135+01:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tterm:=Term new:(self class) getNum.\r',			#stamp : 'pm 10/11/2018 08:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialization of an anonymous ConstTerm"\r\tterm:=Term new:(self class) getNum.\r',			#stamp : 'pm 10/28/2018 15:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:04:07.44165+01:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialization of an anonymous ConstTerm"\r\tterm:=Term new:(self class) getNum.\r',			#stamp : 'pm 10/28/2018 15:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialization of an anonymous ConstTerm. Done during the skolemnisation"\r\tterm:=Term new:(self class) getNum.\r',			#stamp : 'pm 10/28/2018 15:04',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:04:24.382638+01:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #isConst,			#protocol : #testing,			#sourceCode : 'isConst\r\t^true.',			#stamp : 'pm 10/15/2018 16:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #isConst,			#protocol : #testing,			#sourceCode : 'isConst\r\t"a const term is const. obvious, right?"\r\t^true.',			#stamp : 'pm 10/28/2018 15:04',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:04:39.609123+01:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t^\'c\', (term prettyPrint).',			#stamp : 'pm 10/11/2018 12:50',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t"print current object as string."\r\t^\'c\', (term prettyPrint).',			#stamp : 'pm 10/28/2018 15:04',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:05:25.568526+01:00' ],		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t"print current object as string."\r\t^\'c\', (term prettyPrint).',			#stamp : 'pm 10/28/2018 15:04',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t"print current object as string."\r\t"we add a c in front of it to be able to differenciate a const term from a linked term while reading."\r\t^\'c\', (term prettyPrint).',			#stamp : 'pm 10/28/2018 15:05',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:06:08.000906+01:00' ],		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #factoryNum,			#protocol : #initialization,			#sourceCode : 'factoryNum\r\t^factoryNum.',			#stamp : 'pm 10/7/2018 10:20',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #factoryNum,			#protocol : #initialization,			#sourceCode : 'factoryNum\r\t"Number of the next anonymous const term"\r\t^factoryNum.',			#stamp : 'pm 10/28/2018 15:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:06:35.980195+01:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #getNum,			#protocol : #initialization,			#sourceCode : 'getNum\r\tfactoryNum:=factoryNum+1.\r\t^factoryNum asString',			#stamp : 'pm 10/11/2018 12:11',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #getNum,			#protocol : #initialization,			#sourceCode : 'getNum\r\t"The number"\r\tfactoryNum:=factoryNum+1.\r\t^factoryNum asString',			#stamp : 'pm 10/28/2018 15:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:06:42.670675+01:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #factoryNum,			#protocol : #initialization,			#sourceCode : 'factoryNum\r\t"Number of the next anonymous const term"\r\t^factoryNum.',			#stamp : 'pm 10/28/2018 15:06',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #factoryNum,			#protocol : #initialization,			#sourceCode : 'factoryNum\r\t"Number of the next anonymous const term"\r\t"accessor"\r\t^factoryNum.',			#stamp : 'pm 10/28/2018 15:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:07:23.624964+01:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #getNum,			#protocol : #initialization,			#sourceCode : 'getNum\r\t"The number"\r\tfactoryNum:=factoryNum+1.\r\t^factoryNum asString',			#stamp : 'pm 10/28/2018 15:06',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #getNum,			#protocol : #initialization,			#sourceCode : 'getNum\r\t"The number of the next anonymous object as string."\r\tfactoryNum:=factoryNum+1.\r\t^factoryNum asString',			#stamp : 'pm 10/28/2018 15:07',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:08:54.69508+01:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tfactoryNum:=0.',			#stamp : 'pm 10/7/2018 10:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"initlize of the class, which is only the number of the first anonymous const term"\r\tfactoryNum:=0.',			#stamp : 'pm 10/28/2018 15:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:09:12.228171+01:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #new,			#protocol : #initialization,			#sourceCode : 'new "const Factory"\r\t^self basicNew initialize.',			#stamp : 'pm 10/11/2018 08:06',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #new,			#protocol : #initialization,			#sourceCode : 'new \r\t"new anonymous const term"\r\t^self basicNew initialize.',			#stamp : 'pm 10/28/2018 15:09',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:09:31.87905+01:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #initialization,			#sourceCode : 'new:Const_Value\r\t^self basicNew initialize:Const_Value.',			#stamp : 'pm 10/7/2018 11:09',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #initialization,			#sourceCode : 'new:Const_Value\r\t"new named const Object"\r\t^self basicNew initialize:Const_Value.',			#stamp : 'pm 10/28/2018 15:09',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:10:24.284841+01:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #nextConst,			#protocol : #initialization,			#sourceCode : 'nextConst\r\t^\'c\',(self getNum).',			#stamp : 'pm 10/7/2018 10:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #nextConst,			#protocol : #initialization,			#sourceCode : 'nextConst\r\t"Used as a anonymous const term name factory"\r\t^\'c\',(self getNum).',			#stamp : 'pm 10/28/2018 15:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:10:52.582252+01:00' ],		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LinkedTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint \r\t^term prettyPrint.',			#stamp : 'pm 10/11/2018 09:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LinkedTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint \r\t"return a representation of the current object as string"\r\t^term prettyPrint.',			#stamp : 'pm 10/28/2018 15:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:12:01.668799+01:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'AbstractTerm',				#traitCompositionSource : '{}',				#definitionSource : 'AbstractTerm subclass: #UnaryTerm\r\tinstanceVariableNames: \'term\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #UnaryTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #UnaryTerm,						#isMetaSide : false					},					#name : #term,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'UnaryTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'UnaryTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #UnaryTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'Abstract factorisation for LinkedTerm & ConstTerm\r\r',				#stamp : 'pm 10/28/2018 15:12'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'Abstract factorisation for LinkedTerm & ConstTerm\r',		#newComment : 'Abstract factorisation for LinkedTerm & ConstTerm\r\r',		#oldStamp : '<historical>',		#newStamp : 'pm 10/28/2018 15:12'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:12:28.469965+01:00' ],		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'UnaryTerm',				#traitCompositionSource : '{}',				#definitionSource : 'UnaryTerm subclass: #LinkedTerm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #LinkedTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'LinkedTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'LinkedTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #LinkedTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Linked Term, for a Predicate or a FuncTerm\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable is bound by a forall earlier in the proposition.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String\r\r',				#stamp : 'pm 10/28/2018 15:12'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'I represent a Linked Term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable is bound by a forall earlier in the proposition.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String\r\r',		#newComment : 'I represent a Linked Term, for a Predicate or a FuncTerm\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable is bound by a forall earlier in the proposition.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String\r\r',		#oldStamp : 'pm 10/9/2018 10:42',		#newStamp : 'pm 10/28/2018 15:12'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:13:26.320086+01:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'UnaryTerm',				#traitCompositionSource : '{}',				#definitionSource : 'UnaryTerm subclass: #LinkedTerm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #LinkedTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'LinkedTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'LinkedTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #LinkedTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Linked Term, for a Predicate or a FuncTerm\r\rMost of my logic is factorised in UnaryTerm and AbstractTerm\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable is bound by a forall earlier in the proposition.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String\r\r',				#stamp : 'pm 10/28/2018 15:13'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'I represent a Linked Term, for a Predicate or a FuncTerm\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable is bound by a forall earlier in the proposition.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String\r\r',		#newComment : 'I represent a Linked Term, for a Predicate or a FuncTerm\r\rMost of my logic is factorised in UnaryTerm and AbstractTerm\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable is bound by a forall earlier in the proposition.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String\r\r',		#oldStamp : 'pm 10/28/2018 15:12',		#newStamp : 'pm 10/28/2018 15:13'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:15:22.657535+01:00' ],		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MinimalOrderedSet,				#isMetaSide : false			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: anObject \r\tself do: [ :each | \r\t\t(each=anObject) \r\t\tifTrue:[^self]"Object\'s already in, we\'re done"\r\t\t].\r\t super add: anObject."we let LinkedList add the object"\r\t^self.',			#stamp : 'pm 10/7/2018 12:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MinimalOrderedSet,				#isMetaSide : false			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: anObject\r\t"Override to add the set component on a linkedList"\r\tself do: [ :each | \r\t\t(each=anObject) \r\t\tifTrue:[^self]"Object\'s already in, we\'re done"\r\t\t].\r\t super add: anObject."we let LinkedList add the object"\r\t^self."to be chainable"',			#stamp : 'pm 10/28/2018 15:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:15:26.810196+01:00' ],		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MinimalOrderedSet,				#isMetaSide : false			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: anObject\r\t"Override to add the set component on a linkedList"\r\tself do: [ :each | \r\t\t(each=anObject) \r\t\tifTrue:[^self]"Object\'s already in, we\'re done"\r\t\t].\r\t super add: anObject."we let LinkedList add the object"\r\t^self."to be chainable"',			#stamp : 'pm 10/28/2018 15:15',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MinimalOrderedSet,				#isMetaSide : false			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: anObject\r\t"Override to add the set component on a LinkedList"\r\tself do: [ :each | \r\t\t(each=anObject) \r\t\tifTrue:[^self]"Object\'s already in, we\'re done"\r\t\t].\r\t super add: anObject."we let LinkedList add the object"\r\t^self."to be chainable"',			#stamp : 'pm 10/28/2018 15:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:16:03.744391+01:00' ],		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MinimalOrderedSet,				#isMetaSide : false			},			#name : #'merge:',			#protocol : #adding,			#sourceCode : 'merge: anotherMinimalOrderedSet\r\tanotherMinimalOrderedSet do:[:each | self add:each.].\r\t^self.',			#stamp : 'pm 10/15/2018 16:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MinimalOrderedSet,				#isMetaSide : false			},			#name : #'merge:',			#protocol : #adding,			#sourceCode : 'merge: anotherMinimalOrderedSet\r\t"Merge of two MinimalOrderedSet"\r\tanotherMinimalOrderedSet do:[:each | self add:each.].\r\t^self.',			#stamp : 'pm 10/28/2018 15:16',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:17:31.578679+01:00' ],		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ClausalForm class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t^self basicNew initialize.',			#stamp : 'pm 10/3/2018 12:50',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ClausalForm class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"Object creation of an empty Clausal Form"\r\t^self basicNew initialize.',			#stamp : 'pm 10/28/2018 15:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:18:04.930841+01:00' ],		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ClausalForm class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: ClausaleProposition\r\t^self basicNew initialize:ClausaleProposition.',			#stamp : 'pm 10/3/2018 12:49',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ClausalForm class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: ClausaleProposition\r\t"Creation of a clausal form, and add everything in a Clausified Prop."\r\t^self basicNew initialize:ClausaleProposition.',			#stamp : 'pm 10/28/2018 15:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:18:34.441585+01:00' ],		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Clause class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: OrProp\r\t^self basicNew initialize:OrProp.',			#stamp : 'pm 10/2/2018 17:31',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Clause class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: OrProp\r\t"creation of a new clause of a OrProp"\r\t^self basicNew initialize:OrProp.',			#stamp : 'pm 10/28/2018 15:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:19:00.257851+01:00' ],		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #adding,			#sourceCode : 'addAll: clausifiedProp\r\t((clausifiedProp  isOr) | (clausifiedProp isAtome))"If i\'m in a or, there\'s only or(s) under him."\r\tifTrue:[self add: (Clause new:clausifiedProp)]\r\tifFalse:[\r\t\t(clausifiedProp isNot)\r\t\tifTrue:[\r\t\t\t((clausifiedProp operand) isAtome)\r\t\t\tifTrue:[^self add:(Clause new:clausifiedProp).]\r\t\t\tifFalse:[^Error new:\'A not isn\'\'t englobing an atome.\'.].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(clausifiedProp isAnd)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (clausifiedProp left).\r\t\t\t\tself addAll: (clausifiedProp right).\r\t\t\t\t]\r\t\tifFalse:[\r\t\t\tError new: \'Tried to add a non clause object to a clausaleForm.\'.].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/25/2018 19:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #adding,			#sourceCode : 'addAll: clausifiedProp\r\t"badly designed, NEED refactor."\t\r\t((clausifiedProp  isOr) | (clausifiedProp isAtome))"If i\'m in a or, there\'s only or(s) under him."\r\tifTrue:[self add: (Clause new:clausifiedProp)]\r\tifFalse:[\r\t\t(clausifiedProp isNot)\r\t\tifTrue:[\r\t\t\t((clausifiedProp operand) isAtome)\r\t\t\tifTrue:[^self add:(Clause new:clausifiedProp).]\r\t\t\tifFalse:[^Error new:\'A not isn\'\'t englobing an atome.\'.].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(clausifiedProp isAnd)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (clausifiedProp left).\r\t\t\t\tself addAll: (clausifiedProp right).\r\t\t\t\t]\r\t\tifFalse:[\r\t\t\tError new: \'Tried to add a non clause object to a clausaleForm.\'.].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/28/2018 15:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:19:12.030323+01:00' ],		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #adding,			#sourceCode : 'addAll: clausifiedProp\r\t"badly designed, NEED refactor."\t\r\t((clausifiedProp  isOr) | (clausifiedProp isAtome))"If i\'m in a or, there\'s only or(s) under him."\r\tifTrue:[self add: (Clause new:clausifiedProp)]\r\tifFalse:[\r\t\t(clausifiedProp isNot)\r\t\tifTrue:[\r\t\t\t((clausifiedProp operand) isAtome)\r\t\t\tifTrue:[^self add:(Clause new:clausifiedProp).]\r\t\t\tifFalse:[^Error new:\'A not isn\'\'t englobing an atome.\'.].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(clausifiedProp isAnd)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (clausifiedProp left).\r\t\t\t\tself addAll: (clausifiedProp right).\r\t\t\t\t]\r\t\tifFalse:[\r\t\t\tError new: \'Tried to add a non clause object to a clausaleForm.\'.].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/28/2018 15:19',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #adding,			#sourceCode : 'addAll: clausifiedProp\r\r\t"badly designed, NEEDS refactor."\t\r\t\r\t\t\t\r\t((clausifiedProp  isOr) | (clausifiedProp isAtome))"If i\'m in a or, there\'s only or(s) under him."\r\tifTrue:[self add: (Clause new:clausifiedProp)]\r\tifFalse:[\r\t\t(clausifiedProp isNot)\r\t\tifTrue:[\r\t\t\t((clausifiedProp operand) isAtome)\r\t\t\tifTrue:[^self add:(Clause new:clausifiedProp).]\r\t\t\tifFalse:[^Error new:\'A not isn\'\'t englobing an atome.\'.].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(clausifiedProp isAnd)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (clausifiedProp left).\r\t\t\t\tself addAll: (clausifiedProp right).\r\t\t\t\t]\r\t\tifFalse:[\r\t\t\tError new: \'Tried to add a non clause object to a clausaleForm.\'.].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/28/2018 15:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:19:14.006105+01:00' ],		#prior : OmReference [ '72' ],		#self : OmReference [ '73' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #adding,			#sourceCode : 'addAll: clausifiedProp\r\r\t"badly designed, NEEDS refactor."\t\r\t\r\t\t\t\r\t((clausifiedProp  isOr) | (clausifiedProp isAtome))"If i\'m in a or, there\'s only or(s) under him."\r\tifTrue:[self add: (Clause new:clausifiedProp)]\r\tifFalse:[\r\t\t(clausifiedProp isNot)\r\t\tifTrue:[\r\t\t\t((clausifiedProp operand) isAtome)\r\t\t\tifTrue:[^self add:(Clause new:clausifiedProp).]\r\t\t\tifFalse:[^Error new:\'A not isn\'\'t englobing an atome.\'.].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(clausifiedProp isAnd)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (clausifiedProp left).\r\t\t\t\tself addAll: (clausifiedProp right).\r\t\t\t\t]\r\t\tifFalse:[\r\t\t\tError new: \'Tried to add a non clause object to a clausaleForm.\'.].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/28/2018 15:19',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #adding,			#sourceCode : 'addAll: clausifiedProp\r\r\t"badly designed, NEEDS a refactor."\t\r\t\r\t\t\t\r\t((clausifiedProp  isOr) | (clausifiedProp isAtome))"If i\'m in a or, there\'s only or(s) under him."\r\tifTrue:[self add: (Clause new:clausifiedProp)]\r\tifFalse:[\r\t\t(clausifiedProp isNot)\r\t\tifTrue:[\r\t\t\t((clausifiedProp operand) isAtome)\r\t\t\tifTrue:[^self add:(Clause new:clausifiedProp).]\r\t\t\tifFalse:[^Error new:\'A not isn\'\'t englobing an atome.\'.].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(clausifiedProp isAnd)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (clausifiedProp left).\r\t\t\t\tself addAll: (clausifiedProp right).\r\t\t\t\t]\r\t\tifFalse:[\r\t\t\tError new: \'Tried to add a non clause object to a clausaleForm.\'.].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/28/2018 15:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:21:02.570911+01:00' ],		#prior : OmReference [ '73' ],		#self : OmReference [ '74' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #ClausalForm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ClausalForm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClausalForm class\r\tinstanceVariableNames: \'\''				},				#name : #'ClausalForm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClausalForm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions(Clauses).\r\rI inherit from a set, because i only want to have one of each clause object inside me.\r\rI\'m conceived to be instanciated by  the method "amIValid, of propositions"\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\rPublic API and Key Messages\r\r- resolutionMethod : I\'m using the resolutionMethod on myself\r\rI can be created empty or with a Prop object as input.\r\rClausalForm new: aFullProp. \r',				#stamp : 'pm 10/28/2018 15:21'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions(Clauses).\r\rI\'m conceived to be instanciated by  the method "amIValid, of propositions"\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\rPublic API and Key Messages\r\r- resolutionMethod : I\'m using the resolutionMethod on myself\r\rI can be created empty or with a Prop object as input.\r\rClausalForm new: aFullProp. \r',		#newComment : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions(Clauses).\r\rI inherit from a set, because i only want to have one of each clause object inside me.\r\rI\'m conceived to be instanciated by  the method "amIValid, of propositions"\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\rPublic API and Key Messages\r\r- resolutionMethod : I\'m using the resolutionMethod on myself\r\rI can be created empty or with a Prop object as input.\r\rClausalForm new: aFullProp. \r',		#oldStamp : 'pm 10/27/2018 22:03',		#newStamp : 'pm 10/28/2018 15:21'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:21:30.08687+01:00' ],		#prior : OmReference [ '74' ],		#self : OmReference [ '75' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #Clause\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Clause,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Clause class\r\tinstanceVariableNames: \'\''				},				#name : #'Clause class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Clause,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a clause, which is a set of predicate (positive or negative)  related by a variadic Or operator.\r\rBuild on top of a Set, to avoid redundancy.\r\rI should be instanciated by ClausalForm only.\r',				#stamp : 'pm 10/28/2018 15:21'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'I represent a clause, which is a set of predicate (positive or negative)  related by a variadic Or operator.\r\rI should be instanciated by ClausalForm only.\r',		#newComment : 'I represent a clause, which is a set of predicate (positive or negative)  related by a variadic Or operator.\r\rBuild on top of a Set, to avoid redundancy.\r\rI should be instanciated by ClausalForm only.\r',		#oldStamp : 'pm 10/27/2018 22:04',		#newStamp : 'pm 10/28/2018 15:21'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:21:51.829563+01:00' ],		#prior : OmReference [ '75' ],		#self : OmReference [ '76' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: aClause\r\t(aClause isKindOf: Clause)\r\tifTrue: [ super add: aClause ]\r\tifFalse:[Error new: \'Tried to add a non clause object to a clausaleForm\'].\r\t^self "enable chaining operation"',			#stamp : 'pm 10/25/2018 19:08',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: aClause\r\t"add a new clause in self."\r\t(aClause isKindOf: Clause)\r\tifTrue: [ super add: aClause ]\r\tifFalse:[Error new: \'Tried to add a non clause object to a clausaleForm\'].\r\t^self "enable chaining operation"',			#stamp : 'pm 10/28/2018 15:21',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:25:50.780733+01:00' ],		#prior : OmReference [ '76' ],		#self : OmReference [ '77' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addFromList:',			#protocol : #adding,			#sourceCode : 'addFromList: aLinkedList\r\taLinkedList do:[:each|\r\t\tself add: each.\r\t\t].',			#stamp : 'pm 10/26/2018 21:20',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addFromList:',			#protocol : #adding,			#sourceCode : 'addFromList: aLinkedList\r\t"add a list of clauses"\r\taLinkedList do:[:each|\r\t\tself add: each.\r\t\t].',			#stamp : 'pm 10/28/2018 15:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:26:23.484328+01:00' ],		#prior : OmReference [ '77' ],		#self : OmReference [ '78' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '78' ],		#self : OmReference [ '79' ],		#time : DateAndTime [ '2018-10-28T15:26:23.507515+01:00' ],		#trigger : @3	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: ClausifiedFormula\r\tself addAll: ClausifiedFormula.',			#stamp : 'pm 10/25/2018 18:59',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: clausifiedFormula\r\tself addAll: clausifiedFormula.',			#stamp : 'pm 10/28/2018 15:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:26:27.409575+01:00' ],		#prior : OmReference [ '79' ],		#self : OmReference [ '80' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: clausifiedFormula\r\tself addAll: clausifiedFormula.',			#stamp : 'pm 10/28/2018 15:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: clausifiedFormula\r\t""\r\tself addAll: clausifiedFormula.',			#stamp : 'pm 10/28/2018 15:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:26:58.067338+01:00' ],		#prior : OmReference [ '80' ],		#self : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: clausifiedFormula\r\t""\r\tself addAll: clausifiedFormula.',			#stamp : 'pm 10/28/2018 15:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: clausifiedFormula\r\t"initialize a clausal form from a Prop object"\r\tself addAll: clausifiedFormula.',			#stamp : 'pm 10/28/2018 15:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:27:01.777371+01:00' ],		#prior : OmReference [ '81' ],		#self : OmReference [ '82' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: clausifiedFormula\r\t"initialize a clausal form from a Prop object"\r\tself addAll: clausifiedFormula.',			#stamp : 'pm 10/28/2018 15:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: clausifiedFormula\r\t"initialize a clausal form from a clausified Prop object"\r\tself addAll: clausifiedFormula.',			#stamp : 'pm 10/28/2018 15:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:27:38.061131+01:00' ],		#prior : OmReference [ '82' ],		#self : OmReference [ '83' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #initialization,			#sourceCode : 'prettyPrint\r\t|t|\r\tt:=\'{\'.\r\t\tself do: [  :each | t:=t,(each prettyPrint). ] separatedBy: [t:=t,\',\'].\r\tt:=t,\'}\'.\r\t^t.',			#stamp : 'pm 10/25/2018 18:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #initialization,			#sourceCode : 'prettyPrint\r\t"toString"\r\t|t|\r\tt:=\'{\'.\r\t\tself do: [  :each | t:=t,(each prettyPrint). ] separatedBy: [t:=t,\',\'].\r\tt:=t,\'}\'.\r\t^t.',			#stamp : 'pm 10/28/2018 15:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:27:52.393946+01:00' ],		#prior : OmReference [ '83' ],		#self : OmReference [ '84' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: stream\r\tstream nextPutAll: (self prettyPrint).',			#stamp : 'pm 10/25/2018 18:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: stream\r\t"override to be shown on transcripts"\r\tstream nextPutAll: (self prettyPrint).',			#stamp : 'pm 10/28/2018 15:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-28T15:28:44.231458+01:00' ],		#prior : OmReference [ '84' ],		#self : OmReference [ '85' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: var\r\t(var isAtome)\r\tifTrue:[\r\t\tsuper add:var.\r\t\t^self."able chaining operation"\r\t\t]\r\tifFalse:[\r\t\t\tError new: \'Trying to add a wrong type in a clause\'.\r\t\t].',			#stamp : 'pm 10/25/2018 19:04',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: var\r\t(var isAtome)\r\tifTrue:[\r\t\tsuper add:var.\r\t\t^self."able chaining operation"\r\t\t]\r\tifFalse:[\r\t\t\t^self error: \'Trying to add a wrong type in a clause\'.\r\t\t].',			#stamp : 'pm 10/28/2018 15:28',			#package : #_resolution_1erOrdre		}	}}