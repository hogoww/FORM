OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T13:24:03.657843+01:00' ],		#prior : OmReference [ 'Pharo.a4x0207jo3e6wk2voqi3absmq', '38' ],		#self : OmReference [ '1' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '1' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '2' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '3' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '4' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '5' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '6' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '7' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '8' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '9' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '10' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '11' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '12' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '13' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '14' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '15' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '16' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '17' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '18' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '19' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '20' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '21' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '22' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '23' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '24' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '25' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '26' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '27' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '28' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '29' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '30' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '31' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '32' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '33' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '34' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '35' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '36' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '37' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '38' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '39' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '40' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '41' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '42' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '43' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '44' ],			OmReference [ 'e7oncs71g2bidsjleifnh0itt', '45' ]		]	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ],		#time : DateAndTime [ '2018-12-15T13:24:03.73181+01:00' ],		#trigger : @3	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tTranscript show:\'Is \';show: self; show:\' valid?\';cr.\r\t\r\ttreatedProp:=Not new:self.\r\t\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp StartSkolemnisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tTranscript show:\'Resolution method:\' ; show:t ; cr; cr; cr.\r\t^t ',			#stamp : 'pm 12/12/2018 16:09',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tresolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\t\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp StartSkolemnisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tresolutionTrace ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ],		#time : DateAndTime [ '2018-12-15T13:24:03.744797+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionLimitCase,			#protocol : #tests,			#sourceCode : 'testResolutionLimitCase\r\t| prop |\r\tprop:=And new:\r\t  (Or new:\r\t   (Predicate new:\'P\' fromList:\r\t     (LinkedList new \r\t      add:(LinkedTerm new:(Term new:\'x\'));\r\t      yourself)\r\t   )\r\t  rightProp:\r\t   (Predicate new:\'Q\' fromList:\r\t     (LinkedList new \r\t      add:(LinkedTerm new:(Term new:\'x\'));\r\t      yourself)\r\t   )\r\t  )\r\t rightProp:\r\t  (And new:\r\t   (Not new:(Predicate new:\'P\' fromList:\r\t     (LinkedList new \r\t      add:(ConstTerm new:(Term new:\'a\'));\r      yourself))\r\t   )\r\t\t  rightProp:\r\t   (Not new:(Predicate new:\'Q\' fromList:\r\t     (LinkedList new \r\t      add:(ConstTerm new:(Term new:\'b\'));\r\t      yourself))\r\t   )\r\t  ).\r\t\r\t^self deny:(ClausalForm new:prop) resolutionMethod.',			#stamp : 'pm 12/14/2018 20:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ],		#time : DateAndTime [ '2018-12-15T13:24:03.750828+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof1,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof1\r\t"Proof #1 on the auto-fol.pdf course, 9th slide."\r\t| p |\r\tp:=Exists new: \'x\' Property: (\r\t\tImply new:\r\t\t\t(Predicate new: \'P\' variable: (Term new:\'x\'))\r\t\trightProp:\r\t\t\t(And new: (Predicate new: \'P\' variable: (Term new:\'a\'))\r\t\t\trightProp:(Predicate new:\'P\' variable: (Term new:\'b\')))).\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ],		#time : DateAndTime [ '2018-12-15T13:24:03.754581+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof2,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof2\r\t"Proof #2 on the auto-fol.pdf course, 9th slide."\r\t| p |\r\tp:=ForAll new: \'x\' Property: (\r\t\tImply new:\r\t\t\t(Predicate new: \'P\' variable: (Term new:\'x\'))\r\t\trightProp:\r\t\t\t(Exists new: \'y\' Property: \r\t\t\t(And new: (Predicate new: \'P\' variable: (Term new:\'y\'))\r\t\t\trightProp:(Predicate new:\'P\' variable: (Term new:\'y\'))))).\r\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ],		#time : DateAndTime [ '2018-12-15T13:24:03.758845+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof3,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof3\r\t"Proof #3 on the auto-fol.pdf course, 9th slide."\r\t| p |\r\tp:=Imply new:\r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new: (Predicate new: \'P\' variable: (Term new:\'x\'))\r\t\t\t\trightProp: (Predicate new: \'Q\' variable: (Term new:\'x\'))))\r\t\trightProp: \r\t\t\t\t(Or new:\r\t\t\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t\t\t (Predicate new: \'P\' variable: (Term new:\'x\')))\r\t\t\t\trightProp:\r\t\t\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t\t\t (Predicate new: \'Q\' variable: (Term new:\'x\')))).\r\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ],		#time : DateAndTime [ '2018-12-15T13:24:03.761868+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof4,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof4\r\t"Proof #4 on the auto-fol.pdf course, 9th slide."\r\t| p |\r\tp:=Imply new:\r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(And new: (Predicate new: \'P\' variable: (Term new:\'x\'))\r\t\t\t\trightProp: (Predicate new: \'Q\' variable: (Term new:\'x\'))))\r\t\trightProp: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(And new: (Predicate new: \'P\' variable: (Term new:\'x\'))\r\t\t\t\trightProp: (Predicate new: \'Q\' variable: (Term new:\'x\')))).\r\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ],		#time : DateAndTime [ '2018-12-15T13:24:03.764816+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof5,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof5\r\t"Proof #5 on the auto-fol.pdf course, 9th slide."\r\t| p |\r\tp:=Imply new:\r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(And new: (Predicate new: \'P\' variable: (Term new:\'x\'))\r\t\t\t\trightProp: (Predicate new: \'Q\' variable: (Term new:\'x\'))))\r\t\trightProp: \r\t\t\t\t(And new:\r\t\t\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t\t\t (Predicate new: \'P\' variable: (Term new:\'x\')))\r\t\t\t\trightProp:\r\t\t\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t\t\t (Predicate new: \'Q\' variable: (Term new:\'x\')))).\r\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ],		#time : DateAndTime [ '2018-12-15T13:24:03.772529+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof6,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof6\r\t"Proof #6 on the auto-fol.pdf course, 9th slide."\r\t| p |\r\tp:=Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Not new:\r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))))\r\t\trightProp: \r\t\t\t(Not new:\r\t\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\')))).\r\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ],		#time : DateAndTime [ '2018-12-15T13:24:03.779325+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionClassProof7,			#protocol : #tests,			#sourceCode : 'testResolutionClassProof7\r\t"Proof #7 on the auto-fol.pdf course, 9th slide."\r\t| p |\r\tp:=Imply new:\r\t\t\t(Not new: \r\t\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))))\r\t\trightProp: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Not new:\r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\')))).\r\r\tself assert: p amIValid.\r',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ],		#time : DateAndTime [ '2018-12-15T13:24:03.78704+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionResolvanteReplacement,			#protocol : #tests,			#sourceCode : 'testResolutionResolvanteReplacement\r\t"When doing the unification, if you don\'t apply the unification on the resolvants, this test will fail"\r\t| prop |\r\tprop:=And new:\r\t  (Or new:\r\t   (Predicate new:\'P\' fromList:\r\t     (LinkedList new \r\t      add:(LinkedTerm new:(Term new:\'x\'));\r\t      yourself)\r\t   )\r\t  rightProp:\r\t   (Predicate new:\'Q\' fromList:\r\t     (LinkedList new \r\t      add:(LinkedTerm new:(Term new:\'x\'));\r\t      yourself)\r\t   )\r\t  )\r\t rightProp:\r\t  (And new:\r\t   (Not new:(Predicate new:\'P\' fromList:\r\t     (LinkedList new \r\t      add:(ConstTerm new:(Term new:\'a\'));\r      yourself))\r\t   )\r\t\t  rightProp:\r\t   (Not new:(Predicate new:\'Q\' fromList:\r\t     (LinkedList new \r\t      add:(ConstTerm new:(Term new:\'b\'));\r\t      yourself))\r\t   )\r\t  ).\r\t\r\t^self deny:(ClausalForm new:prop) resolutionMethod.',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ],		#time : DateAndTime [ '2018-12-15T13:24:03.792041+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"abstract class, not meant to be instanciated"\r\t^self error: \'Prop is abstract and shouldn\'\'t be implemented\'\r',			#stamp : 'pm 12/12/2018 10:49',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"abstract class, not meant to be instanciated"\r\t^self error: \'Prop is abstract and shouldn\'\'t be instanciated.\'\r',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ],		#time : DateAndTime [ '2018-12-15T13:24:03.796386+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #resolutionTrace,			#protocol : #'as yet unclassified',			#sourceCode : 'resolutionTrace\r\t^resolutionTrace',			#stamp : 'pm 12/14/2018 19:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #resolutionTrace,			#protocol : #'as yet unclassified',			#sourceCode : 'resolutionTrace\r\t"accessor, it\'s also used in Clausal Form during the resolution process."\r\t^resolutionTrace',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ],		#time : DateAndTime [ '2018-12-15T13:24:03.800405+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testInc,			#protocol : #tests,			#sourceCode : 'testInc\r\ttestNumber:=testNumber+1.',			#stamp : 'pm 10/11/2018 16:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testInc,			#protocol : #tests,			#sourceCode : 'testInc\r\t"incrementor for the testnumber, to give context"\r\ttestNumber:=testNumber+1.',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ],		#time : DateAndTime [ '2018-12-15T13:24:03.804852+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testNumber,			#protocol : #accessing,			#sourceCode : 'testNumber\r\t^testNumber',			#stamp : 'pm 10/11/2018 16:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testNumber,			#protocol : #accessing,			#sourceCode : 'testNumber\r\t"incrementor for the testnumber, to give context"\r\t^testNumber',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ],		#time : DateAndTime [ '2018-12-15T13:24:03.812043+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tProp initialize.\r\tTranscript clear.\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl unificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t\r\t"should replace x by y at the end of the unification"\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:( LinkedTerm new:(Term new:\'x\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 12/13/2018 20:59',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tProp initialize.\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl unificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t\r\t"should replace x by y at the end of the unification"\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:( LinkedTerm new:(Term new:\'x\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ],		#time : DateAndTime [ '2018-12-15T13:24:03.817804+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #unificationTrace,			#protocol : #accessing,			#sourceCode : 'unificationTrace\r\t"accessor for the Unification process"\r\t^unificationTrace',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ],		#time : DateAndTime [ '2018-12-15T13:24:03.818558+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #debugUnification,			#protocol : #accessing,			#sourceCode : 'debugUnification\r\t^debugUnification',			#stamp : 'pm 12/13/2018 19:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ],		#time : DateAndTime [ '2018-12-15T13:24:03.822556+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'check:',			#protocol : #unification,			#sourceCode : 'check: aPair\r\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'check\';cr.].\r\t\r\t^aPair right contains: aPair left term',			#stamp : 'pm 12/14/2018 16:54',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'check:',			#protocol : #unification,			#sourceCode : 'check: aPair\r\r\t(Prop unificationTrace)\r\tifTrue:[Transcript show:\'check\';cr.].\r\t\r\t^aPair right contains: aPair left term',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ],		#time : DateAndTime [ '2018-12-15T13:24:03.828205+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'conflict:',			#protocol : #unification,			#sourceCode : 'conflict: aPair\r\t(Prop debugUnification) \r\tifTrue:[Transcript show:\'[Unification] conflict between : \'; show:aPair ; cr.].\r',			#stamp : 'pm 12/13/2018 20:50',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'conflict:',			#protocol : #unification,			#sourceCode : 'conflict: aPair\r\tProp unificationTrace\r\tifTrue:[Transcript show:\'[Unification] conflict between : \'; show:aPair ; cr.].\r',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ],		#time : DateAndTime [ '2018-12-15T13:24:03.834326+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right i|\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'decompose \'; show:aPair ;cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\ti:=1.\r\tsetOfPairs remove: aPair.\r\t[i<=(left arity)]"arity is the same, as we tested in the caller."\r\twhileTrue:[\r\t\tself add: (Pair left: (left at: i) right: (right at: i)).\r\t\ti:=i+1.\r\t\t].\t',			#stamp : 'pm 12/13/2018 20:56',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right i|\r\tProp unificationTrace\r\tifTrue:[Transcript show:\'decompose \'; show:aPair ;cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\ti:=1.\r\tsetOfPairs remove: aPair.\r\t[i<=(left arity)]"arity is the same, as we tested in the caller."\r\twhileTrue:[\r\t\tself add: (Pair left: (left at: i) right: (right at: i)).\r\t\ti:=i+1.\r\t\t].\t',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ],		#time : DateAndTime [ '2018-12-15T13:24:03.842551+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'delete:',			#protocol : #unification,			#sourceCode : 'delete:aPair\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'delete\'; show:aPair ;cr.].\r\tsetOfPairs remove:aPair.',			#stamp : 'pm 12/13/2018 20:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'delete:',			#protocol : #unification,			#sourceCode : 'delete:aPair\r\tProp unificationTrace\r\tifTrue:[Transcript show:\'delete\'; show:aPair ;cr.].\r\tsetOfPairs remove:aPair.',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ],		#time : DateAndTime [ '2018-12-15T13:24:03.853907+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right previousSet newSet |\r\t\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'eliminate with \'; show:aPair ;cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\t\r\tpreviousSet:=setOfPairs veryDeepCopy."we need to work on a copy, to avoid having another iteration"\r\tpreviousSet remove:aPair.\r\t\r\tpreviousSet do:[:each |\r\t\t"tempVar:=each veryDeepCopy.""since we modify the underlying data, we work on a copy"\r\t\tnewSet add: (self replacementPair:each replaced:left by:right).\r\t\t].\r\t(previousSet = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r ',			#stamp : 'pm 12/13/2018 20:58',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right previousSet newSet |\r\t\r\tProp unificationTrace\r\tifTrue:[Transcript show:\'eliminate with \'; show:aPair ;cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\t\r\tpreviousSet:=setOfPairs veryDeepCopy."we need to work on a copy, to avoid having another iteration"\r\tpreviousSet remove:aPair.\r\t\r\tpreviousSet do:[:each |\r\t\t"tempVar:=each veryDeepCopy.""since we modify the underlying data, we work on a copy"\r\t\tnewSet add: (self replacementPair:each replaced:left by:right).\r\t\t].\r\t(previousSet = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r ',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ],		#time : DateAndTime [ '2018-12-15T13:24:03.862769+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'swap:',			#protocol : #unification,			#sourceCode : 'swap: aPair\r\t|left right|\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'swaping : \'; show:aPair ;cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tsetOfPairs remove:aPair.\r\tself add: (Pair left: right right: left).\r\t',			#stamp : 'pm 12/13/2018 20:54',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'swap:',			#protocol : #unification,			#sourceCode : 'swap: aPair\r\t|left right|\r\tProp unificationTrace\r\tifTrue:[Transcript show:\'swaping : \'; show:aPair ;cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tsetOfPairs remove:aPair.\r\tself add: (Pair left: right right: left).\r\t',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ],		#time : DateAndTime [ '2018-12-15T13:24:03.872281+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\t[ modified ]\r\twhileTrue:[\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification ifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right"=not possible"\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\t"Transcript show: \'Unification impossible\'; cr."\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\thasFailed:=true.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t\r\t\t]. ',			#stamp : 'pm 12/14/2018 20:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\t[ modified ]\r\twhileTrue:[\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp unificationTrace ifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right"=not possible"\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\t"Transcript show: \'Unification impossible\'; cr."\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\thasFailed:=true.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t\r\t\t]. ',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ],		#time : DateAndTime [ '2018-12-15T13:24:03.876561+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initEverything,			#protocol : #testing,			#sourceCode : 'initEverything\r\t"classic logic"\r\tProp initialize.\r\tAtome initialize.\r\tConstant initialize.\r\tFalse_Const initialize.\r\tTrue_Const initialize.\r\tVar initialize.\r\tNotVar initialize.\r\tOperator initialize.\r\tBinary initialize.\r\tAnd initialize.\r\tEqual initialize.\r\tImply initialize.\r\tOr initialize.\r\tUnary initialize.\r\tNot initialize.\r\t\r\t"Predicate"\r\tQuantifier initialize.\r\tExists initialize.\r\tForAll initialize.\r\t\r\t"terms"\r\tTerm initialize.\r\tConstTerm initialize.\r\tFuncTerm initialize.\r\tLinkedTerm initialize.',			#stamp : 'pm 10/8/2018 17:11',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initEverything,			#protocol : #testing,			#sourceCode : 'initEverything\r\t"Every class initialization, for that  package."\r\t\r\t"classic logic"\r\tProp initialize.\r\tAtome initialize.\r\tConstant initialize.\r\tFalse_Const initialize.\r\tTrue_Const initialize.\r\tVar initialize.\r\tNotVar initialize.\r\tOperator initialize.\r\tBinary initialize.\r\tAnd initialize.\r\tEqual initialize.\r\tImply initialize.\r\tOr initialize.\r\tUnary initialize.\r\tNot initialize.\r\t\r\t"Predicate"\r\tQuantifier initialize.\r\tExists initialize.\r\tForAll initialize.\r\t\r\t"terms"\r\tAbstractTerm initialize.\r\tFuncTerm initialize.\r\tTerm initialize.\r\tUnaryTerm initialize.\r\tConstTerm initialize.\r\tLinkedTerm initialize.\r\t\r\t"Clausal Form stuffs"\r\tClausalForm initialize.\r\tClause initialize.\r\tResolvante initialize.\r\tUnifier initialize.\r\r\t"DataStructure"\r\tLinkedListFix initialize.\r\tMinimalOrderedSet initialize.\r\tPair initialize.\r\t\r',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ],		#time : DateAndTime [ '2018-12-15T13:24:03.9256+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'clausificationTrace debugUnification resolutionTrace skolemnTrace testNumber unifDone\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @8,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- FullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- PrettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 10/9/2018 10:52'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @8				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #debugUnification,					#parent : @8				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @8				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @8				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @8				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unifDone,					#parent : @8				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'clausificationTrace debugUnification resolutionTrace skolemnTrace testNumber unifDone\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @34			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @34,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- FullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- PrettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 10/9/2018 10:52'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @34				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #debugUnification,					#parent : @34				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @34				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @34				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @34				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unifDone,					#parent : @34				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ],		#time : DateAndTime [ '2018-12-15T13:24:04.114032+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'clausificationTrace debugUnification resolutionTrace skolemnTrace testNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @8,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- FullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- PrettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 10/9/2018 10:52'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @8				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #debugUnification,					#parent : @8				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @8				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @8				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @8				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @8				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'clausificationTrace debugUnification resolutionTrace skolemnTrace testNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @34			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @34,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- FullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- PrettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 10/9/2018 10:52'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @34				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #debugUnification,					#parent : @34				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @34				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @34				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @34				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @34				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ],		#time : DateAndTime [ '2018-12-15T13:24:04.255559+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tclausificationTrace:=false.\r\tskolemnTrace:=false.\r\tdebugUnification:=false.\r\tresolutionTrace:=false.\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/14/2018 20:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see the traces process"\r\r\t"Variable to activate traces or not."\r\tclausificationTrace:=false.\r\tskolemnTrace:=false.\r\tunificationTrace:=false.\r\tresolutionTrace:=false.\r\t\r\t"Used to provided context during the textual tests available in the Prop class "\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ],		#time : DateAndTime [ '2018-12-15T13:24:04.258832+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testEverything,			#protocol : #testing,			#sourceCode : 'testEverything\r\tTranscript clear.\r\tProp initEverything.\r\t"Prop testingProp."\r\t"Prop testingMatch."\r\t"Prop testingClausification."\r\tProp testingFactorisation.\r\tProp testingResolvante.\r\tProp testingUnification.\r\tProp testingSkolemn.\r\tProp testingResolutionMethod.\r\r',			#stamp : 'pm 10/27/2018 08:27',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testEverything,			#protocol : #testing,			#sourceCode : 'testEverything\r\t"Launch a serie of textual tests"\r\tTranscript clear.\r\tProp initEverything.\r\t"Prop testingProp."\r\t"Prop testingMatch."\r\t"Prop testingClausification."\r\tProp testingFactorisation.\r\tProp testingResolvante.\r\tProp testingUnification.\r\tProp testingSkolemn.\r\tProp testingResolutionMethod.\r\r',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ],		#time : DateAndTime [ '2018-12-15T13:24:04.262056+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingClausification,			#protocol : #testing,			#sourceCode : 'testingClausification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p |\r\t\r"\tTranscript clear."\r\tTranscript show: \'Testing clausification related stuff\';cr.\r\t\r\tp:=And new: (Var new: \'a\') rightProp: (False_Const new).\r\tp clausificationUnitTest.\r\r\tp:=Or new: (Var new: \'a\') rightProp: (False_Const new).\r\tp clausificationUnitTest.\r\r\tp:=Equal new: (Var new: \'a\') rightProp: (True_Const new).\r\tp clausificationUnitTest.\r\t\r\tp:=Imply new: (Var new: \'a\') rightProp: (True_Const new).\r\tp clausificationUnitTest.\r\r\t"unary"\r\tp:=Not new: (Var new: \'a\').\r\tp clausificationUnitTest.\r\t\r\tTranscript show: \'Bit more complicated stuff!\';cr.\r\t\r\tp:=Imply new: (Equal new: (Not new: (Var new: \'a\')) rightProp: (Var new: \'b\')) rightProp: (False_Const new).\r\tp clausificationUnitTest.\r\t\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/5/2018 00:09',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingClausification,			#protocol : #testing,			#sourceCode : 'testingClausification\r \t"some tests for the clausification. Obsolete."\r\t"Complete automated tests are now available."\r\t| p |\r\t\r\tTranscript show: \'Testing clausification related stuff\';cr.\r\t\r\tp:=And new: (Var new: \'a\') rightProp: (False_Const new).\r\tp clausificationUnitTest.\r\r\tp:=Or new: (Var new: \'a\') rightProp: (False_Const new).\r\tp clausificationUnitTest.\r\r\tp:=Equal new: (Var new: \'a\') rightProp: (True_Const new).\r\tp clausificationUnitTest.\r\t\r\tp:=Imply new: (Var new: \'a\') rightProp: (True_Const new).\r\tp clausificationUnitTest.\r\r\t"unary"\r\tp:=Not new: (Var new: \'a\').\r\tp clausificationUnitTest.\r\t\r\tTranscript show: \'Bit more complicated stuff!\';cr.\r\t\r\tp:=Imply new: (Equal new: (Not new: (Var new: \'a\')) rightProp: (Var new: \'b\')) rightProp: (False_Const new).\r\tp clausificationUnitTest.\r\t\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ],		#time : DateAndTime [ '2018-12-15T13:24:04.268524+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\r\tTranscript show:\'Unifiable positive const & linked predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'Unifiable negative const & linked predicate\';cr.\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\t"add multiple possible resolutions clauses next"\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 16:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\r\tTranscript show:\'Unifiable positive const & linked predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'Unifiable negative const & linked predicate\';cr.\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\t"add multiple possible resolutions clauses next"\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ],		#time : DateAndTime [ '2018-12-15T13:24:04.271369+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines, with textual output. Not automated"\r\t|t l r|\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl unificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t\r\t"should replace x by y at the end of the unification"\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:( LinkedTerm new:(Term new:\'x\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 12/14/2018 17:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ],		#time : DateAndTime [ '2018-12-15T13:24:04.273052+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestUnification\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestUnification,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestUnification class\r\tinstanceVariableNames: \'\''				},				#name : #'TestUnification class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestUnification,					#isMetaSide : false				},				#parent : @8,				#content : 'Unification test. \rFor reference, the table of possible operations used is:\r\r             =         |     const      |   Linked    |     Func/Pred     \r        Const    |  Conflict     |  Swap       |    Check\r                        |  Delete        |                    |\r                        |                       |                     | \r     Linked     | Eliminate  |  Delete     |    Check\r                        |                       |                     | \rFunc/Pred  | Swap          |  Swap        |   Decompose\r                        |                       |                      |   Conflict\r                        |                       |                      | ',				#stamp : 'pm 12/14/2018 12:33'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #testing	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ],		#time : DateAndTime [ '2018-12-15T13:24:04.275901+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnFunc,			#protocol : #tests,			#sourceCode : 'testConstOnFunc\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aFuncTerm"\r\t\r\t"check fail"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair :=nil.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"check ok"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'a\')) right:(FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnFunc,			#protocol : #'tests - binary resolution',			#sourceCode : 'testConstOnFunc\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aFuncTerm"\r\t\r\t"check fail"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair :=nil.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"check ok"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'a\')) right:(FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ],		#time : DateAndTime [ '2018-12-15T13:24:04.278948+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnFunc,			#protocol : #'tests - binary resolution',			#sourceCode : 'testConstOnFunc\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aFuncTerm"\r\t\r\t"check fail"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair :=nil.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"check ok"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'a\')) right:(FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 16:28',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnFunc,			#protocol : #'tests - binary resolution',			#sourceCode : 'testConstOnFunc\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aFuncTerm"\r\t\r\t"check fail"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair :=nil.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"check ok"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'a\')) right:(FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ],		#time : DateAndTime [ '2018-12-15T13:24:04.287519+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnLinked,			#protocol : #tests,			#sourceCode : 'testFuncOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=aLinkedTerm"\r\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"Will swap before eliminate and succeed"\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\t\t\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnLinked,			#protocol : #'tests - binary resolution',			#sourceCode : 'testFuncOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=aLinkedTerm"\r\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"Will swap before eliminate and succeed"\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\t\t\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ],		#time : DateAndTime [ '2018-12-15T13:24:04.289364+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnLinked,			#protocol : #'tests - binary resolution',			#sourceCode : 'testFuncOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=aLinkedTerm"\r\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"Will swap before eliminate and succeed"\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\t\t\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 17:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnLinked,			#protocol : #'tests - binary resolution',			#sourceCode : 'testFuncOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=aLinkedTerm"\r\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"Will swap before eliminate and succeed"\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\t\t\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ],		#time : DateAndTime [ '2018-12-15T13:24:04.293156+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both test for aConstTerm = anotherConstTerm"\r\t\r\t"conflict rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"The resulting pair is the same as the input, since the unification was unnecessary"\r\texpectedResultPair:=(Pair left:left right:right).\r\t"the delete let us an empty set"\r\texpectedResultSetOfPair:=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #'tests - binary resolution',			#sourceCode : 'testConstOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both test for aConstTerm = anotherConstTerm"\r\t\r\t"conflict rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"The resulting pair is the same as the input, since the unification was unnecessary"\r\texpectedResultPair:=(Pair left:left right:right).\r\t"the delete let us an empty set"\r\texpectedResultSetOfPair:=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ],		#time : DateAndTime [ '2018-12-15T13:24:04.294785+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #'tests - binary resolution',			#sourceCode : 'testConstOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both test for aConstTerm = anotherConstTerm"\r\t\r\t"conflict rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"The resulting pair is the same as the input, since the unification was unnecessary"\r\texpectedResultPair:=(Pair left:left right:right).\r\t"the delete let us an empty set"\r\texpectedResultSetOfPair:=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 15:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #'tests - binary resolution',			#sourceCode : 'testConstOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both test for aConstTerm = anotherConstTerm"\r\t\r\t"conflict rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"The resulting pair is the same as the input, since the unification was unnecessary"\r\texpectedResultPair:=(Pair left:left right:right).\r\t"the delete let us an empty set"\r\texpectedResultSetOfPair:=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ],		#time : DateAndTime [ '2018-12-15T13:24:04.302975+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnLinked,			#protocol : #tests,			#sourceCode : 'testConstOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aLinkedTerm"\r\r\t"since they can\'t be equal. As proven by this assertion. (obviously)"\r\tself deny:(ConstTerm new: ( Term new: \'a\'))=(LinkedTerm new: ( Term new: \'a\'))."S"\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnLinked,			#protocol : #'tests - binary resolution',			#sourceCode : 'testConstOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aLinkedTerm"\r\r\t"since they can\'t be equal. As proven by this assertion. (obviously)"\r\tself deny:(ConstTerm new: ( Term new: \'a\'))=(LinkedTerm new: ( Term new: \'a\'))."S"\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ],		#time : DateAndTime [ '2018-12-15T13:24:04.305132+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnLinked,			#protocol : #'tests - binary resolution',			#sourceCode : 'testConstOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aLinkedTerm"\r\r\t"since they can\'t be equal. As proven by this assertion. (obviously)"\r\tself deny:(ConstTerm new: ( Term new: \'a\'))=(LinkedTerm new: ( Term new: \'a\'))."S"\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnLinked,			#protocol : #'tests - binary resolution',			#sourceCode : 'testConstOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aLinkedTerm"\r\r\t"since they can\'t be equal. As proven by this assertion. (obviously)"\r\tself deny:(ConstTerm new: ( Term new: \'a\'))=(LinkedTerm new: ( Term new: \'a\'))."S"\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ],		#time : DateAndTime [ '2018-12-15T13:24:04.310325+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\t"eliminate rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'y\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #'tests - binary resolution',			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\t"eliminate rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'y\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ],		#time : DateAndTime [ '2018-12-15T13:24:04.31165+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #'tests - binary resolution',			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\t"eliminate rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'y\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 11:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #'tests - binary resolution',			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\t"eliminate rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'y\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ],		#time : DateAndTime [ '2018-12-15T13:24:04.315549+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testEmptyPredicate,			#protocol : #tests,			#sourceCode : 'testEmptyPredicate\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"tests for empty predicates"\r\t\r\t"Decomposition rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'P\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\texpectedResultPair :=Pair left: left right: right.\r\texpectedResultSetOfPair:=MinimalOrderedSet new. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"Conflict rule on Symbols"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'Q\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"testing will fai, so everything will be nill"\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair:=nil. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testEmptyPredicate,			#protocol : #'tests - binary resolution',			#sourceCode : 'testEmptyPredicate\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"tests for empty predicates"\r\t\r\t"Decomposition rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'P\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\texpectedResultPair :=Pair left: left right: right.\r\texpectedResultSetOfPair:=MinimalOrderedSet new. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"Conflict rule on Symbols"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'Q\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"testing will fai, so everything will be nill"\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair:=nil. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ],		#time : DateAndTime [ '2018-12-15T13:24:04.320138+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testEmptyPredicate,			#protocol : #'tests - binary resolution',			#sourceCode : 'testEmptyPredicate\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"tests for empty predicates"\r\t\r\t"Decomposition rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'P\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\texpectedResultPair :=Pair left: left right: right.\r\texpectedResultSetOfPair:=MinimalOrderedSet new. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"Conflict rule on Symbols"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'Q\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"testing will fai, so everything will be nill"\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair:=nil. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 12:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testEmptyPredicate,			#protocol : #'tests - binary resolution',			#sourceCode : 'testEmptyPredicate\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"tests for empty predicates"\r\t\r\t"Decomposition rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'P\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\texpectedResultPair :=Pair left: left right: right.\r\texpectedResultSetOfPair:=MinimalOrderedSet new. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"Conflict rule on Symbols"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'Q\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"testing will fai, so everything will be nill"\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair:=nil. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ],		#time : DateAndTime [ '2018-12-15T13:24:04.322423+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolAddition {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestUnification\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestUnification,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestUnification class\r\tinstanceVariableNames: \'\''				},				#name : #'TestUnification class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestUnification,					#isMetaSide : false				},				#parent : @8,				#content : 'Unification test. \rFor reference, the table of possible operations used is:\r\r             =         |     const      |   Linked    |     Func/Pred     \r        Const    |  Conflict     |  Swap       |    Check\r                        |  Delete        |                    |\r                        |                       |                     | \r     Linked     | Eliminate  |  Delete     |    Check\r                        |                       |                     | \rFunc/Pred  | Swap          |  Swap        |   Decompose\r                        |                       |                      |   Conflict\r                        |                       |                      | ',				#stamp : 'pm 12/14/2018 12:33'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #'tests - binary factorisation'	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ],		#time : DateAndTime [ '2018-12-15T13:24:04.32651+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherPair\r\t"comparator"\r\tself assert: ((anotherPair class)=(self class)).\r\t^(self left)=(anotherPair left) and:[(self right)=(anotherPair right)].',			#stamp : 'pm 11/11/2018 09:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherPair\r\t"comparator"\r\t^((anotherPair class)=(self class)) and:[\r\t\t(self left)=(anotherPair left) \r\t\tand:[(self right)=(anotherPair right)]].',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ],		#time : DateAndTime [ '2018-12-15T13:24:04.329788+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Clause class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"creation of a new empty clause"\r\t^self basicNew.',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ],		#time : DateAndTime [ '2018-12-15T13:24:04.332418+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ],		#time : DateAndTime [ '2018-12-15T13:24:04.338384+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testNegativeFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testNegativeFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Not new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp: (Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Not new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ],		#time : DateAndTime [ '2018-12-15T13:24:04.341482+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisationConstOnLink,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisationConstOnLink\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ],		#time : DateAndTime [ '2018-12-15T13:24:04.344109+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisationLinkOnLink,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisationLinkOnLink\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\'))))\r\t\tyourself.\r\t\t\r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T13:30:05.041186+01:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\r\tTranscript show:\'Unifiable positive const & linked predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'Unifiable negative const & linked predicate\';cr.\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\t"add multiple possible resolutions clauses next"\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\r\tTranscript show:\'Unifiable positive const & linked predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'Unifiable negative const & linked predicate\';cr.\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=\tOr new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\tc factorisationUnitTest.\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 12/15/2018 13:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T13:33:25.979254+01:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #resolutionMethod,			#sourceCode : 'factorisation: aClause\r\t"This method factorise positively AND negatively at the same time.\r\tself is an Unifier\r\taClause is the clause we want to factorise\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:[\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t"\t\t\t(sub1=sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new. We create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\t\tself applyUnifier:u onClause: newClause.\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 22:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #resolutionMethod,			#sourceCode : 'factorisation: aClause\r\t"This method factorise positively AND negatively at the same time.\r\tself is an Unifier\r\taClause is the clause we want to factorise\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:[\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t\t\t\t\tself halt.\r\t\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t"\t\t\t(sub1=sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new. We create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\t\tself applyUnifier:u onClause: newClause.\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/15/2018 13:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T13:40:30.587265+01:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t\r\t(hasFailed)\r\tifTrue:[\r\t\tunifiedPair := nil."Failed to unify thing"\r\t\t^nil."return value doesn\'t matter, we just want to breakout."\r\t\t].\r\r\tunifiedPair := initialPair veryDeepCopy.\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\t\tifTrue:["They both should be predicates, so they can use replace: by:"\r\t\t\t\t\t(unifiedPair left) replace: (each left) by: (each right).\r\t\t\t\t\t(unifiedPair right) replace: (each left) by: (each right).\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t"else it was already the same  predicate"',			#stamp : 'pm 12/14/2018 09:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t\r\t(hasFailed)\r\tifTrue:[\r\t\tunifiedPair := nil."Failed to unify thing"\r\t\t^nil."return value doesn\'t matter, we just want to breakout."\r\t\t].\r\r\tunifiedPair := initialPair veryDeepCopy.\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tself halt\r\t\tsetOfPairs do:[ :each | \r\t\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\t\tifTrue:["They both should be predicates, so they can use replace: by:"\r\t\t\t\t\t(unifiedPair left) replace: (each left) by: (each right).\r\t\t\t\t\t(unifiedPair right) replace: (each left) by: (each right).\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t"else it was already the same  predicate"',			#stamp : 'pm 12/15/2018 13:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T13:40:32.260938+01:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t\r\t(hasFailed)\r\tifTrue:[\r\t\tunifiedPair := nil."Failed to unify thing"\r\t\t^nil."return value doesn\'t matter, we just want to breakout."\r\t\t].\r\r\tunifiedPair := initialPair veryDeepCopy.\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tself halt\r\t\tsetOfPairs do:[ :each | \r\t\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\t\tifTrue:["They both should be predicates, so they can use replace: by:"\r\t\t\t\t\t(unifiedPair left) replace: (each left) by: (each right).\r\t\t\t\t\t(unifiedPair right) replace: (each left) by: (each right).\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t"else it was already the same  predicate"',			#stamp : 'pm 12/15/2018 13:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t\r\t(hasFailed)\r\tifTrue:[\r\t\tunifiedPair := nil."Failed to unify thing"\r\t\t^nil."return value doesn\'t matter, we just want to breakout."\r\t\t].\r\r\tunifiedPair := initialPair veryDeepCopy.\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tself halt.\r\t\tsetOfPairs do:[ :each | \r\t\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\t\tifTrue:["They both should be predicates, so they can use replace: by:"\r\t\t\t\t\t(unifiedPair left) replace: (each left) by: (each right).\r\t\t\t\t\t(unifiedPair right) replace: (each left) by: (each right).\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t"else it was already the same  predicate"',			#stamp : 'pm 12/15/2018 13:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T13:44:05.208915+01:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t\r\t(hasFailed)\r\tifTrue:[\r\t\tunifiedPair := nil."Failed to unify thing"\r\t\t^nil."return value doesn\'t matter, we just want to breakout."\r\t\t].\r\r\tunifiedPair := initialPair veryDeepCopy.\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tself halt.\r\t\tsetOfPairs do:[ :each | \r\t\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\t\tifTrue:["They both should be predicates, so they can use replace: by:"\r\t\t\t\t\t(unifiedPair left) replace: (each left) by: (each right).\r\t\t\t\t\t(unifiedPair right) replace: (each left) by: (each right).\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t"else it was already the same  predicate"',			#stamp : 'pm 12/15/2018 13:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t\r\t(hasFailed)\r\tifTrue:[\r\t\tunifiedPair := nil."Failed to unify thing"\r\t\t^nil."return value doesn\'t matter, we just want to breakout."\r\t\t].\r\r\tunifiedPair := initialPair veryDeepCopy.\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tself halt.\r\t\tsetOfPairs do:[ :each | \r\t\t\t"((((each left) isConst) not) and:[(each right) isConst])\r\t\t\t\tifTrue:[""They both should be predicates, so they can use replace: by:"\r\t\t\t\t\t(unifiedPair left) replace: (each left) by: (each right).\r\t\t\t\t\t(unifiedPair right) replace: (each left) by: (each right).\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t"]."\r\t"else it was already the same  predicate"',			#stamp : 'pm 12/15/2018 13:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T13:44:35.691236+01:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t\r\t(hasFailed)\r\tifTrue:[\r\t\tunifiedPair := nil."Failed to unify thing"\r\t\t^nil."return value doesn\'t matter, we just want to breakout."\r\t\t].\r\r\tunifiedPair := initialPair veryDeepCopy.\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tself halt.\r\t\tsetOfPairs do:[ :each | \r\t\t\t"((((each left) isConst) not) and:[(each right) isConst])\r\t\t\t\tifTrue:[""They both should be predicates, so they can use replace: by:"\r\t\t\t\t\t(unifiedPair left) replace: (each left) by: (each right).\r\t\t\t\t\t(unifiedPair right) replace: (each left) by: (each right).\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t"]."\r\t"else it was already the same  predicate"',			#stamp : 'pm 12/15/2018 13:44',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t\r\t(hasFailed)\r\tifTrue:[\r\t\tunifiedPair := nil."Failed to unify thing"\r\t\t^nil."return value doesn\'t matter, we just want to breakout."\r\t\t].\r\r\tunifiedPair := initialPair veryDeepCopy.\r\t(setOfPairs isNil)\r\tifFalse:[\r\r\t\tsetOfPairs do:[ :each | \r\t\t\t"((((each left) isConst) not) and:[(each right) isConst])\r\t\t\t\tifTrue:[""They both should be predicates, so they can use replace: by:"\r\t\t\t\t\t(unifiedPair left) replace: (each left) by: (each right).\r\t\t\t\t\t(unifiedPair right) replace: (each left) by: (each right).\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t"]."\r\t"else it was already the same  predicate"',			#stamp : 'pm 12/15/2018 13:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T13:44:36.961862+01:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t\r\t(hasFailed)\r\tifTrue:[\r\t\tunifiedPair := nil."Failed to unify thing"\r\t\t^nil."return value doesn\'t matter, we just want to breakout."\r\t\t].\r\r\tunifiedPair := initialPair veryDeepCopy.\r\t(setOfPairs isNil)\r\tifFalse:[\r\r\t\tsetOfPairs do:[ :each | \r\t\t\t"((((each left) isConst) not) and:[(each right) isConst])\r\t\t\t\tifTrue:[""They both should be predicates, so they can use replace: by:"\r\t\t\t\t\t(unifiedPair left) replace: (each left) by: (each right).\r\t\t\t\t\t(unifiedPair right) replace: (each left) by: (each right).\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t"]."\r\t"else it was already the same  predicate"',			#stamp : 'pm 12/15/2018 13:44',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t\r\t(hasFailed)\r\tifTrue:[\r\t\tunifiedPair := nil."Failed to unify thing"\r\t\t^nil."return value doesn\'t matter, we just want to breakout."\r\t\t].\r\r\tunifiedPair := initialPair veryDeepCopy.\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\t"((((each left) isConst) not) and:[(each right) isConst])\r\t\t\t\tifTrue:[""They both should be predicates, so they can use replace: by:"\r\t\t\t\t\t(unifiedPair left) replace: (each left) by: (each right).\r\t\t\t\t\t(unifiedPair right) replace: (each left) by: (each right).\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t"]."\r\t"else it was already the same  predicate"',			#stamp : 'pm 12/15/2018 13:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T13:48:06.206168+01:00' ],		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #resolutionMethod,			#sourceCode : 'factorisation: aClause\r\t"This method factorise positively AND negatively at the same time.\r\tself is an Unifier\r\taClause is the clause we want to factorise\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:[\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t\t\t\t\tself halt.\r\t\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t"\t\t\t(sub1=sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new. We create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\t\tself applyUnifier:u onClause: newClause.\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/15/2018 13:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #resolutionMethod,			#sourceCode : 'factorisation: aClause\r\t"This method factorise positively AND negatively at the same time.\r\tself is an Unifier\r\taClause is the clause we want to factorise\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:[\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t"\t\t\t(sub1=sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new. We create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\t\tself applyUnifier:u onClause: newClause.\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/15/2018 13:48',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T14:03:57.640675+01:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #'tests - binary resolution',			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\t"eliminate rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'y\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #'tests - binary resolution',			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\t"eliminate rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'x\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/15/2018 14:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T14:03:57.657397+01:00' ],		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #'tests - binary resolution',			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\t"eliminate rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'x\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/15/2018 14:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\t"eliminate rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'x\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/15/2018 14:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T14:04:29.672924+01:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\t"eliminate rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'x\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/15/2018 14:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\t"eliminate rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'x\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/15/2018 14:04',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T14:04:41.40598+01:00' ],		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\t"eliminate rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'x\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/15/2018 14:04',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\t"eliminate rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: right right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'x\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/15/2018 14:04',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T14:04:49.379895+01:00' ],		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\t"eliminate rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: right right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'x\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/15/2018 14:04',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\t"eliminate rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: right right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'y\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/15/2018 14:04',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T14:05:33.114377+01:00' ],		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnFunc,			#protocol : #'tests - binary resolution',			#sourceCode : 'testConstOnFunc\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aFuncTerm"\r\t\r\t"check fail"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair :=nil.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"check ok"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'a\')) right:(FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnFunc,			#protocol : #'tests - binary resolution',			#sourceCode : 'testConstOnFunc\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aFuncTerm"\r\t\r\t"check fail"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair :=nil.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"check ok"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/15/2018 14:05',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T14:05:33.136743+01:00' ],		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnFunc,			#protocol : #'tests - binary resolution',			#sourceCode : 'testConstOnFunc\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aFuncTerm"\r\t\r\t"check fail"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair :=nil.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"check ok"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/15/2018 14:05',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnFunc,			#protocol : #tests,			#sourceCode : 'testConstOnFunc\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aFuncTerm"\r\t\r\t"check fail"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair :=nil.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"check ok"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/15/2018 14:05',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T14:06:04.201491+01:00' ],		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisationLinkOnLink,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisationLinkOnLink\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\'))))\r\t\tyourself.\r\t\t\r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisationLinkOnLink,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisationLinkOnLink\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))))\r\t\tyourself.\r\t\t\r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 14:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T14:06:04.212873+01:00' ],		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisationLinkOnLink,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisationLinkOnLink\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))))\r\t\tyourself.\r\t\t\r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 14:06',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisationLinkOnLink,			#protocol : #tests,			#sourceCode : 'testPositiveFactorisationLinkOnLink\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))))\r\t\tyourself.\r\t\t\r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 14:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T14:39:11.317704+01:00' ],		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t\r\t(hasFailed)\r\tifTrue:[\r\t\tunifiedPair := nil."Failed to unify thing"\r\t\t^nil."return value doesn\'t matter, we just want to breakout."\r\t\t].\r\r\tunifiedPair := initialPair veryDeepCopy.\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\t"((((each left) isConst) not) and:[(each right) isConst])\r\t\t\t\tifTrue:[""They both should be predicates, so they can use replace: by:"\r\t\t\t\t\t(unifiedPair left) replace: (each left) by: (each right).\r\t\t\t\t\t(unifiedPair right) replace: (each left) by: (each right).\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t"]."\r\t"else it was already the same  predicate"',			#stamp : 'pm 12/15/2018 13:44',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t\r\t(hasFailed)\r\tifTrue:[\r\t\tunifiedPair := nil."Failed to unify anything"\r\t\t^nil."return value doesn\'t matter, we just want to breakout."\r\t\t].\r\r\tunifiedPair := initialPair veryDeepCopy.\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\t"((((each left) isConst) not) and:[(each right) isConst])\r\t\t\t\tifTrue:[""They both should be predicates, so they can use replace: by:"\r\t\t\t\t\t(unifiedPair left) replace: (each left) by: (each right).\r\t\t\t\t\t(unifiedPair right) replace: (each left) by: (each right).\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t"]."\r\t"else it was already the same  predicate"',			#stamp : 'pm 12/15/2018 14:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T14:46:40.791063+01:00' ],		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'y\'))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 14:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T14:46:54.364981+01:00' ],		#prior : OmReference [ '72' ],		#self : OmReference [ '73' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisationLinkOnLink,			#protocol : #tests,			#sourceCode : 'testPositiveFactorisationLinkOnLink\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'y\'))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 14:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisationLinkOnLink,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisationLinkOnLink\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'y\'))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 14:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T14:46:54.371353+01:00' ],		#prior : OmReference [ '73' ],		#self : OmReference [ '74' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisationLinkOnLink,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisationLinkOnLink\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))))\r\t\tyourself.\r\t\t\r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 14:06',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisationLinkOnLink,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisationLinkOnLink\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'y\'))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 14:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T14:47:10.244407+01:00' ],		#prior : OmReference [ '74' ],		#self : OmReference [ '75' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisationLinkOnLink,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisationLinkOnLink\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'y\'))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 14:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisationLinkOnLink,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisationLinkOnLink\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\'))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 14:47',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T14:47:23.35779+01:00' ],		#prior : OmReference [ '75' ],		#self : OmReference [ '76' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisationLinkedOnLinked,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisationLinkedOnLinked\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\'))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 14:47',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T14:47:26.408278+01:00' ],		#prior : OmReference [ '76' ],		#self : OmReference [ '77' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisationLinkOnLink,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisationLinkOnLink\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\'))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 14:47',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T14:47:31.810309+01:00' ],		#prior : OmReference [ '77' ],		#self : OmReference [ '78' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testPositiveFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testPositiveFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\'))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'y\'))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 14:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T14:48:00.235863+01:00' ],		#prior : OmReference [ '78' ],		#self : OmReference [ '79' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testNegativeFactorisationConstOnLinked,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testNegativeFactorisationConstOnLinked\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Not new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp: (Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Not new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 14:48',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T14:53:53.305748+01:00' ],		#prior : OmReference [ '79' ],		#self : OmReference [ '80' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testNegativeFactorisationLinkedOnLinked,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testNegativeFactorisationLinkedOnLinked\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))))\r\t rightProp: (Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\'))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 14:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T14:54:18.543906+01:00' ],		#prior : OmReference [ '80' ],		#self : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testNegativeFactorisationLinkedOnLinked,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testNegativeFactorisationLinkedOnLinked\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))))\r\t rightProp: (Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\'))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 14:53',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testNegativeFactorisationLinkedOnLinked,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testNegativeFactorisationLinkedOnLinked\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))))\r\t rightProp: (Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(NotPredicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\'))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 14:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T14:54:35.48405+01:00' ],		#prior : OmReference [ '81' ],		#self : OmReference [ '82' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testNegativeFactorisationConstOnLinked,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testNegativeFactorisationConstOnLinked\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Not new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp: (Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Not new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 14:48',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testNegativeFactorisationConstOnLinked,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testNegativeFactorisationConstOnLinked\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Not new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp: (Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(NotPredicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 14:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T14:57:48.535071+01:00' ],		#prior : OmReference [ '82' ],		#self : OmReference [ '83' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testNegativeFactorisation,			#protocol : #'tests - binary factorisation',			#sourceCode : 'testNegativeFactorisation\r\t| c fc r expected |\r\t"Unifiable positive const & linked predicate"\r\tc:=\tOr new: (Not new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp: (Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\r\tfc:=ClausalForm new:c.\r\tr:=Resolvante new.\r\t\t\r\texpected:=Resolvante new\r\t\tadd:(Clause new:(Not new:(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))))\r\t\tyourself.\r\t\t \r\tself assert: (r factorisation: (fc at:1)) equals:expected.\r',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:14:35.909732+01:00' ],		#prior : OmReference [ '83' ],		#self : OmReference [ '84' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'clausificationTrace debugUnification resolutionTrace skolemnTrace testNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @7,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- FullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- prettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 12/15/2018 15:14'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #debugUnification,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- FullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- PrettyPrint -> returns a string representing my  internal state.',		#newComment : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- FullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- prettyPrint -> returns a string representing my  internal state.',		#oldStamp : 'pm 10/9/2018 10:52',		#newStamp : 'pm 12/15/2018 15:14'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:14:49.221056+01:00' ],		#prior : OmReference [ '84' ],		#self : OmReference [ '85' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'clausificationTrace debugUnification resolutionTrace skolemnTrace testNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @7,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- fullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- prettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 12/15/2018 15:14'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #debugUnification,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- FullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- prettyPrint -> returns a string representing my  internal state.',		#newComment : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- fullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- prettyPrint -> returns a string representing my  internal state.',		#oldStamp : 'pm 12/15/2018 15:14',		#newStamp : 'pm 12/15/2018 15:14'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:16:42.952025+01:00' ],		#prior : OmReference [ '85' ],		#self : OmReference [ '86' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'clausificationTrace debugUnification resolutionTrace skolemnTrace testNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @7,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- fullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- prettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 12/15/2018 15:14'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #debugUnification,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'clausificationTrace debugUnification resolutionTrace skolemnTrace testNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @33			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @33,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- fullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- prettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 12/15/2018 15:14'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #debugUnification,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @33				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:17:15.918838+01:00' ],		#prior : OmReference [ '86' ],		#self : OmReference [ '87' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #setup,			#protocol : #'as yet unclassified',			#sourceCode : 'setup\r\t"used to be sure that the traces up to date."\r\tProp initEverything ',			#stamp : 'pm 12/15/2018 15:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:17:25.822044+01:00' ],		#prior : OmReference [ '87' ],		#self : OmReference [ '88' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #setup,			#protocol : #'as yet unclassified',			#sourceCode : 'setup\r\t"used to be sure that the traces up to date."\r\tProp initEverything ',			#stamp : 'pm 12/15/2018 15:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:17:31.928379+01:00' ],		#prior : OmReference [ '88' ],		#self : OmReference [ '89' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #setup,			#protocol : #'as yet unclassified',			#sourceCode : 'setup\r\t"used to be sure that the traces up to date."\r\tProp initEverything ',			#stamp : 'pm 12/15/2018 15:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #setup,			#protocol : #setup,			#sourceCode : 'setup\r\t"used to be sure that the traces up to date."\r\tProp initEverything ',			#stamp : 'pm 12/15/2018 15:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:17:40.091279+01:00' ],		#prior : OmReference [ '89' ],		#self : OmReference [ '90' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestClausification,				#isMetaSide : false			},			#name : #setup,			#protocol : #'as yet unclassified',			#sourceCode : 'setup\r\t"used to be sure that the traces up to date."\r\tProp initEverything ',			#stamp : 'pm 12/15/2018 15:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:17:40.184656+01:00' ],		#prior : OmReference [ '90' ],		#self : OmReference [ '91' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestClausification,				#isMetaSide : false			},			#name : #setup,			#protocol : #'as yet unclassified',			#sourceCode : 'setup\r\t"used to be sure that the traces up to date."\r\tProp initEverything ',			#stamp : 'pm 12/15/2018 15:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestClausification,				#isMetaSide : false			},			#name : #setup,			#protocol : #setup,			#sourceCode : 'setup\r\t"used to be sure that the traces up to date."\r\tProp initEverything ',			#stamp : 'pm 12/15/2018 15:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:17:45.622541+01:00' ],		#prior : OmReference [ '91' ],		#self : OmReference [ '92' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #setup,			#protocol : #'as yet unclassified',			#sourceCode : 'setup\r\t"used to be sure that the traces up to date."\r\tProp initEverything ',			#stamp : 'pm 12/15/2018 15:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:17:45.691588+01:00' ],		#prior : OmReference [ '92' ],		#self : OmReference [ '93' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #setup,			#protocol : #'as yet unclassified',			#sourceCode : 'setup\r\t"used to be sure that the traces up to date."\r\tProp initEverything ',			#stamp : 'pm 12/15/2018 15:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #setup,			#protocol : #setup,			#sourceCode : 'setup\r\t"used to be sure that the traces up to date."\r\tProp initEverything ',			#stamp : 'pm 12/15/2018 15:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:18:35.304111+01:00' ],		#prior : OmReference [ '93' ],		#self : OmReference [ '94' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #setup,			#protocol : #'as yet unclassified',			#sourceCode : 'setup\r\t"used to be sure that the traces up to date."\r\tProp initEverything ',			#stamp : 'pm 12/15/2018 15:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #setup,			#protocol : #setup,			#sourceCode : 'setup\r\t"used to be sure that the traces up to date."\r\tProp initEverything ',			#stamp : 'pm 12/15/2018 15:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:47:18.87571+01:00' ],		#prior : OmReference [ '94' ],		#self : OmReference [ '95' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #setup,			#protocol : #setup,			#sourceCode : 'setup\r\t"used to be sure that the traces up to date."\r\tProp initEverything ',			#stamp : 'pm 12/15/2018 15:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #setup,			#protocol : #setup,			#sourceCode : 'setup\r\t"ensure that the traces booleans / visual artifacts are up to date"\r\tProp initEverything ',			#stamp : 'pm 12/15/2018 15:47',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:47:34.444028+01:00' ],		#prior : OmReference [ '95' ],		#self : OmReference [ '96' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #setup,			#protocol : #setup,			#sourceCode : 'setup\r\t"used to be sure that the traces up to date."\r\tProp initEverything ',			#stamp : 'pm 12/15/2018 15:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #setup,			#protocol : #setup,			#sourceCode : 'setup\r\t"ensure that the traces booleans / visual artifacts are up to date"\r\tProp initEverything ',			#stamp : 'pm 12/15/2018 15:47',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:47:38.540654+01:00' ],		#prior : OmReference [ '96' ],		#self : OmReference [ '97' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #setup,			#protocol : #setup,			#sourceCode : 'setup\r\t"used to be sure that the traces up to date."\r\tProp initEverything ',			#stamp : 'pm 12/15/2018 15:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #setup,			#protocol : #setup,			#sourceCode : 'setup\r\t"ensure that the traces booleans / visual artifacts are up to date"\r\tProp initEverything ',			#stamp : 'pm 12/15/2018 15:47',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:47:42.316042+01:00' ],		#prior : OmReference [ '97' ],		#self : OmReference [ '98' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestClausification,				#isMetaSide : false			},			#name : #setup,			#protocol : #setup,			#sourceCode : 'setup\r\t"used to be sure that the traces up to date."\r\tProp initEverything ',			#stamp : 'pm 12/15/2018 15:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestClausification,				#isMetaSide : false			},			#name : #setup,			#protocol : #setup,			#sourceCode : 'setup\r\t"ensure that the traces booleans / visual artifacts are up to date"\r\tProp initEverything ',			#stamp : 'pm 12/15/2018 15:47',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:48:23.713251+01:00' ],		#prior : OmReference [ '98' ],		#self : OmReference [ '99' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Unary',				#traitCompositionSource : '{}',				#definitionSource : 'Unary subclass: #Not\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Not,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Not class\r\tinstanceVariableNames: \'patternNot patternTrue patternFalse patternOr patternAnd\''				},				#name : #'Not class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Not class',							#isMetaSide : true						},						#name : #patternNot,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Not class',							#isMetaSide : true						},						#name : #patternTrue,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Not class',							#isMetaSide : true						},						#name : #patternFalse,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Not class',							#isMetaSide : true						},						#name : #patternOr,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Not class',							#isMetaSide : true						},						#name : #patternAnd,						#parent : @12					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Not,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Not  operator\r\rMy creation is available in the Unary class',				#stamp : 'pm 11/27/2018 07:42'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Unary',				#traitCompositionSource : '{}',				#definitionSource : 'Unary subclass: #Not\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Not,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Not class\r\tinstanceVariableNames: \'\''				},				#name : #'Not class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @31			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Not,					#isMetaSide : false				},				#parent : @31,				#content : 'I represent a Not  operator\r\rMy creation is available in the Unary class',				#stamp : 'pm 11/27/2018 07:42'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:48:29.144813+01:00' ],		#prior : OmReference [ '99' ],		#self : OmReference [ '100' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Unary',				#traitCompositionSource : '{}',				#definitionSource : 'Unary subclass: #Not\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Not,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Not class\r\tinstanceVariableNames: \'\''				},				#name : #'Not class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Not,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Not  operator\r\rMy creation is available in the Unary class',				#stamp : 'pm 11/27/2018 07:42'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Unary',				#traitCompositionSource : '{}',				#definitionSource : 'Unary subclass: #Not\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Not,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Not class\r\tinstanceVariableNames: \'\''				},				#name : #'Not class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Not,					#isMetaSide : false				},				#parent : @21,				#content : 'I represent a Not  operator\r\rMy creation is available in the Unary class',				#stamp : 'pm 11/27/2018 07:42'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:48:57.588693+01:00' ],		#prior : OmReference [ '100' ],		#self : OmReference [ '101' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #Or\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Or,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Or class\r\tinstanceVariableNames: \'patternAnd patternAndSym patternTrue patternTrueSym patternFalse patternFalseSym\''				},				#name : #'Or class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Or class',							#isMetaSide : true						},						#name : #patternAnd,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Or class',							#isMetaSide : true						},						#name : #patternAndSym,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Or class',							#isMetaSide : true						},						#name : #patternTrue,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Or class',							#isMetaSide : true						},						#name : #patternTrueSym,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Or class',							#isMetaSide : true						},						#name : #patternFalse,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Or class',							#isMetaSide : true						},						#name : #patternFalseSym,						#parent : @12					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Or,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent an Or proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #Or\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Or,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Or class\r\tinstanceVariableNames: \'\''				},				#name : #'Or class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @33			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Or,					#isMetaSide : false				},				#parent : @33,				#content : 'I represent an Or proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:49:03.677423+01:00' ],		#prior : OmReference [ '101' ],		#self : OmReference [ '102' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #Or\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Or,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Or class\r\tinstanceVariableNames: \'\''				},				#name : #'Or class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Or,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent an Or proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #Or\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Or,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Or class\r\tinstanceVariableNames: \'\''				},				#name : #'Or class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Or,					#isMetaSide : false				},				#parent : @21,				#content : 'I represent an Or proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:50:40.714171+01:00' ],		#prior : OmReference [ '102' ],		#self : OmReference [ '103' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #And\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #And,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'And class\r\tinstanceVariableNames: \'patternTrue patternTrueSym patternFalse patternFalseSym\''				},				#name : #'And class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'And class',							#isMetaSide : true						},						#name : #patternTrue,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'And class',							#isMetaSide : true						},						#name : #patternTrueSym,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'And class',							#isMetaSide : true						},						#name : #patternFalse,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'And class',							#isMetaSide : true						},						#name : #patternFalseSym,						#parent : @12					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #And,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent an And proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #And\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #And,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'And class\r\tinstanceVariableNames: \'\''				},				#name : #'And class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @29			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #And,					#isMetaSide : false				},				#parent : @29,				#content : 'I represent an And proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:50:45.580402+01:00' ],		#prior : OmReference [ '103' ],		#self : OmReference [ '104' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #And\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #And,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'And class\r\tinstanceVariableNames: \'\''				},				#name : #'And class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #And,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent an And proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #And\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #And,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'And class\r\tinstanceVariableNames: \'\''				},				#name : #'And class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #And,					#isMetaSide : false				},				#parent : @21,				#content : 'I represent an And proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:52:45.360409+01:00' ],		#prior : OmReference [ '104' ],		#self : OmReference [ '105' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Or,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t"does an iteration of clausification the current proposition"\r\t\r\t"For this one, we have some different possible pattern."\r\t| t |\r\tt:=nil.\r \t((Or patternFalse) matchPatternWith: self)\r\tifTrue:[t:=left]\r\tifFalse:[\r\t\t((Or patternFalseSym) matchPatternWith: self)\r\t\tifTrue:[t:=right]\r\t\tifFalse:[\r\t\t\t((Or patternTrue) matchPatternWith: self)\r\t\t\tifTrue:[t:=right]\r\t\t\tifFalse:[\r\t\t\t\t((Or patternTrueSym) matchPatternWith: self)\r\t\t\t\tifTrue:[t:=left]\r\t\t\t\tifFalse:[\r\t\t\t\t\t((Or patternAnd) matchPatternWith: self)\r\t\t\t\t\tifTrue:[t:=And new: (Or new: ((self left) left) rightProp: (self right)) \r\t\t\t\t\t\t\t\t  rightProp: (Or new:((self left) right) rightProp: (self right))]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t((Or patternAndSym) matchPatternWith: self)\r\t\t\t\t\t\tifTrue:[t:=And new:(Or new: (self left) rightProp: ((self right) left)) \r\t\t\t\t\t\t\t\t\t  rightProp: (Or new: (self left) rightProp: ((self right) right))].\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\t\t(t isNil) ifTrue:[clausificationTrace ifTrue:[Transcript show:\'in Or\';show: self prettyPrint;cr.].\r\t\t\t\t\t\t\t\tself left:(left clausification).\r\t\t\t\t\t\t\t\tself right:(right clausification).\r\t\t\t\t\t\t\t\t^self]\r\t\t\t\t\t ifFalse:[clausificationTrace ifTrue:[Transcript show:\'in Or2\';show: t prettyPrint;cr.].\r\t\t\t\t\t\t^t "clausification" ]',			#stamp : 'pm 12/12/2018 14:14',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Or,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t"does an iteration of clausification the current proposition"\r\t\r\t"For this one, we have some different possible pattern."\r\t| t |\r\tt:=nil.\r \tpatternFalse matchPatternWith: self\r\tifTrue:[t:=left]\r\tifFalse:[\r\t\t((Or patternFalseSym) matchPatternWith: self)\r\t\tifTrue:[t:=right]\r\t\tifFalse:[\r\t\t\t((Or patternTrue) matchPatternWith: self)\r\t\t\tifTrue:[t:=right]\r\t\t\tifFalse:[\r\t\t\t\t((Or patternTrueSym) matchPatternWith: self)\r\t\t\t\tifTrue:[t:=left]\r\t\t\t\tifFalse:[\r\t\t\t\t\t((Or patternAnd) matchPatternWith: self)\r\t\t\t\t\tifTrue:[t:=And new: (Or new: ((self left) left) rightProp: (self right)) \r\t\t\t\t\t\t\t\t  rightProp: (Or new:((self left) right) rightProp: (self right))]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t((Or patternAndSym) matchPatternWith: self)\r\t\t\t\t\t\tifTrue:[t:=And new:(Or new: (self left) rightProp: ((self right) left)) \r\t\t\t\t\t\t\t\t\t  rightProp: (Or new: (self left) rightProp: ((self right) right))].\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\t\t(t isNil) ifTrue:[clausificationTrace ifTrue:[Transcript show:\'in Or\';show: self prettyPrint;cr.].\r\t\t\t\t\t\t\t\tself left:(left clausification).\r\t\t\t\t\t\t\t\tself right:(right clausification).\r\t\t\t\t\t\t\t\t^self]\r\t\t\t\t\t ifFalse:[clausificationTrace ifTrue:[Transcript show:\'in Or2\';show: t prettyPrint;cr.].\r\t\t\t\t\t\t^t "clausification" ]',			#stamp : 'pm 12/15/2018 15:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:53:11.035102+01:00' ],		#prior : OmReference [ '105' ],		#self : OmReference [ '106' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Or,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t"does an iteration of clausification the current proposition"\r\t\r\t"For this one, we have some different possible pattern."\r\t| t |\r\tt:=nil.\r \tpatternFalse matchPatternWith: self\r\tifTrue:[t:=left]\r\tifFalse:[\r\t\t((Or patternFalseSym) matchPatternWith: self)\r\t\tifTrue:[t:=right]\r\t\tifFalse:[\r\t\t\t((Or patternTrue) matchPatternWith: self)\r\t\t\tifTrue:[t:=right]\r\t\t\tifFalse:[\r\t\t\t\t((Or patternTrueSym) matchPatternWith: self)\r\t\t\t\tifTrue:[t:=left]\r\t\t\t\tifFalse:[\r\t\t\t\t\t((Or patternAnd) matchPatternWith: self)\r\t\t\t\t\tifTrue:[t:=And new: (Or new: ((self left) left) rightProp: (self right)) \r\t\t\t\t\t\t\t\t  rightProp: (Or new:((self left) right) rightProp: (self right))]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t((Or patternAndSym) matchPatternWith: self)\r\t\t\t\t\t\tifTrue:[t:=And new:(Or new: (self left) rightProp: ((self right) left)) \r\t\t\t\t\t\t\t\t\t  rightProp: (Or new: (self left) rightProp: ((self right) right))].\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\t\t(t isNil) ifTrue:[clausificationTrace ifTrue:[Transcript show:\'in Or\';show: self prettyPrint;cr.].\r\t\t\t\t\t\t\t\tself left:(left clausification).\r\t\t\t\t\t\t\t\tself right:(right clausification).\r\t\t\t\t\t\t\t\t^self]\r\t\t\t\t\t ifFalse:[clausificationTrace ifTrue:[Transcript show:\'in Or2\';show: t prettyPrint;cr.].\r\t\t\t\t\t\t^t "clausification" ]',			#stamp : 'pm 12/15/2018 15:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Or,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t"does an iteration of clausification the current proposition"\r\t\r\t"For this one, we have some different possible pattern."\r\t| t |\r\tt:=nil.\r \t(patternFalse matchPatternWith: self)\r\tifTrue:[t:=left]\r\tifFalse:[\r\t\t((Or patternFalseSym) matchPatternWith: self)\r\t\tifTrue:[t:=right]\r\t\tifFalse:[\r\t\t\t((Or patternTrue) matchPatternWith: self)\r\t\t\tifTrue:[t:=right]\r\t\t\tifFalse:[\r\t\t\t\t((Or patternTrueSym) matchPatternWith: self)\r\t\t\t\tifTrue:[t:=left]\r\t\t\t\tifFalse:[\r\t\t\t\t\t((Or patternAnd) matchPatternWith: self)\r\t\t\t\t\tifTrue:[t:=And new: (Or new: ((self left) left) rightProp: (self right)) \r\t\t\t\t\t\t\t\t  rightProp: (Or new:((self left) right) rightProp: (self right))]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t((Or patternAndSym) matchPatternWith: self)\r\t\t\t\t\t\tifTrue:[t:=And new:(Or new: (self left) rightProp: ((self right) left)) \r\t\t\t\t\t\t\t\t\t  rightProp: (Or new: (self left) rightProp: ((self right) right))].\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\t\t(t isNil) ifTrue:[clausificationTrace ifTrue:[Transcript show:\'in Or\';show: self prettyPrint;cr.].\r\t\t\t\t\t\t\t\tself left:(left clausification).\r\t\t\t\t\t\t\t\tself right:(right clausification).\r\t\t\t\t\t\t\t\t^self]\r\t\t\t\t\t ifFalse:[clausificationTrace ifTrue:[Transcript show:\'in Or2\';show: t prettyPrint;cr.].\r\t\t\t\t\t\t^t "clausification" ]',			#stamp : 'pm 12/15/2018 15:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:53:20.694359+01:00' ],		#prior : OmReference [ '106' ],		#self : OmReference [ '107' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '107' ],		#self : OmReference [ '108' ],		#time : DateAndTime [ '2018-12-15T15:53:20.703041+01:00' ],		#trigger : @3	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #Or\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'patternAnd patternAndSym patternFalse patternFalseSym patternTrue patternTrueSym\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Or,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Or class\r\tinstanceVariableNames: \'\''				},				#name : #'Or class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Or,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent an Or proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternAnd,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternAndSym,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternFalse,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternFalseSym,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternTrue,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternTrueSym,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #Or\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'PatternAndSym patternAnd patternAndSym patternFalse patternFalseSym patternTrue patternTrueSym\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Or,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Or class\r\tinstanceVariableNames: \'\''				},				#name : #'Or class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @33			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Or,					#isMetaSide : false				},				#parent : @33,				#content : 'I represent an Or proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternAndSym,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternAnd,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternAndSym,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternFalse,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternFalseSym,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternTrue,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternTrueSym,					#parent : @33				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '108' ],		#self : OmReference [ '109' ],		#time : DateAndTime [ '2018-12-15T15:53:20.709424+01:00' ],		#trigger : OmReference [ '107' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Or class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialize,			#sourceCode : 'initialize\r\t"Choosing the graphical symbol"\r\tsymb:=\'\\/\'. \r\t\r\t"patterns used for clausification.\r\tSince we\'re in a binary operator, we have represent it, to fit in one variable."\r\tpatternAnd:=Or new: (And new: (Var new: \'a\') rightProp: (Var new:(\'a\')))  rightProp: (Var new: \'a\').\r\tpatternAndSym:=Or new: (Var new: \'a\') rightProp: (And new: (Var new: \'a\') rightProp: (Var new:(\'a\'))).\r\tpatternTrue:=Or new: (Var new: \'a\') rightProp: (True_Const new).\r\tpatternTrueSym:=Or new: (True_Const new) rightProp:(Var new:\'a\').\r\tpatternFalse:=Or new: (Var new: \'a\') rightProp: (False_Const new).\r\tpatternFalseSym:=Or new: (False_Const new) rightProp:(Var new:\'a\').',			#stamp : 'pm 11/27/2018 12:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Or class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialize,			#sourceCode : 'initialize\r\t"Choosing the graphical symbol"\r\tsymb:=\'\\/\'. \r\t\r\t"patterns used for clausification.\r\tSince we\'re in a binary operator, we have represent it, to fit in one variable."\r\tpatternAnd:=Or new: (And new: (Var new: \'a\') rightProp: (Var new:(\'a\')))  rightProp: (Var new: \'a\').\r\tPatternAndSym:=Or new: (Var new: \'a\') rightProp: (And new: (Var new: \'a\') rightProp: (Var new:(\'a\'))).\r\tpatternTrue:=Or new: (Var new: \'a\') rightProp: (True_Const new).\r\tpatternTrueSym:=Or new: (True_Const new) rightProp:(Var new:\'a\').\r\tpatternFalse:=Or new: (Var new: \'a\') rightProp: (False_Const new).\r\tpatternFalseSym:=Or new: (False_Const new) rightProp:(Var new:\'a\').',			#stamp : 'pm 12/15/2018 15:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '109' ],		#self : OmReference [ '110' ],		#time : DateAndTime [ '2018-12-15T15:53:20.712445+01:00' ],		#trigger : OmReference [ '107' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Or class',				#isMetaSide : true			},			#name : #patternAndSym,			#protocol : #accessing,			#sourceCode : 'patternAndSym\t\r\t"accessor"\r\t^patternAndSym',			#stamp : 'pm 11/27/2018 18:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Or class',				#isMetaSide : true			},			#name : #patternAndSym,			#protocol : #accessing,			#sourceCode : 'patternAndSym\t\r\t"accessor"\r\t^PatternAndSym',			#stamp : 'pm 12/15/2018 15:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:53:24.993975+01:00' ],		#prior : OmReference [ '110' ],		#self : OmReference [ '111' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '111' ],		#self : OmReference [ '112' ],		#time : DateAndTime [ '2018-12-15T15:53:25.00249+01:00' ],		#trigger : @3	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #Or\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'PatternAndSym patternAnd patternFalse patternFalseSym patternTrue patternTrueSym\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Or,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Or class\r\tinstanceVariableNames: \'\''				},				#name : #'Or class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Or,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent an Or proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternAndSym,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternAnd,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternFalse,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternFalseSym,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternTrue,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternTrueSym,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #Or\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'PatternAnd PatternAndSym patternAnd patternFalse patternFalseSym patternTrue patternTrueSym\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Or,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Or class\r\tinstanceVariableNames: \'\''				},				#name : #'Or class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @33			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Or,					#isMetaSide : false				},				#parent : @33,				#content : 'I represent an Or proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternAnd,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternAndSym,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternAnd,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternFalse,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternFalseSym,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternTrue,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternTrueSym,					#parent : @33				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '112' ],		#self : OmReference [ '113' ],		#time : DateAndTime [ '2018-12-15T15:53:25.009042+01:00' ],		#trigger : OmReference [ '111' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Or class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialize,			#sourceCode : 'initialize\r\t"Choosing the graphical symbol"\r\tsymb:=\'\\/\'. \r\t\r\t"patterns used for clausification.\r\tSince we\'re in a binary operator, we have represent it, to fit in one variable."\r\tpatternAnd:=Or new: (And new: (Var new: \'a\') rightProp: (Var new:(\'a\')))  rightProp: (Var new: \'a\').\r\tPatternAndSym:=Or new: (Var new: \'a\') rightProp: (And new: (Var new: \'a\') rightProp: (Var new:(\'a\'))).\r\tpatternTrue:=Or new: (Var new: \'a\') rightProp: (True_Const new).\r\tpatternTrueSym:=Or new: (True_Const new) rightProp:(Var new:\'a\').\r\tpatternFalse:=Or new: (Var new: \'a\') rightProp: (False_Const new).\r\tpatternFalseSym:=Or new: (False_Const new) rightProp:(Var new:\'a\').',			#stamp : 'pm 12/15/2018 15:53',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Or class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialize,			#sourceCode : 'initialize\r\t"Choosing the graphical symbol"\r\tsymb:=\'\\/\'. \r\t\r\t"patterns used for clausification.\r\tSince we\'re in a binary operator, we have represent it, to fit in one variable."\r\tPatternAnd:=Or new: (And new: (Var new: \'a\') rightProp: (Var new:(\'a\')))  rightProp: (Var new: \'a\').\r\tPatternAndSym:=Or new: (Var new: \'a\') rightProp: (And new: (Var new: \'a\') rightProp: (Var new:(\'a\'))).\r\tpatternTrue:=Or new: (Var new: \'a\') rightProp: (True_Const new).\r\tpatternTrueSym:=Or new: (True_Const new) rightProp:(Var new:\'a\').\r\tpatternFalse:=Or new: (Var new: \'a\') rightProp: (False_Const new).\r\tpatternFalseSym:=Or new: (False_Const new) rightProp:(Var new:\'a\').',			#stamp : 'pm 12/15/2018 15:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '113' ],		#self : OmReference [ '114' ],		#time : DateAndTime [ '2018-12-15T15:53:25.013134+01:00' ],		#trigger : OmReference [ '111' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Or class',				#isMetaSide : true			},			#name : #patternAnd,			#protocol : #initialize,			#sourceCode : 'patternAnd\t\r\t"accessor"\r\t^patternAnd',			#stamp : 'pm 11/27/2018 18:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Or class',				#isMetaSide : true			},			#name : #patternAnd,			#protocol : #initialize,			#sourceCode : 'patternAnd\t\r\t"accessor"\r\t^PatternAnd',			#stamp : 'pm 12/15/2018 15:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:53:47.284791+01:00' ],		#prior : OmReference [ '114' ],		#self : OmReference [ '115' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #Or\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'PatternAnd PatternAndSym patternFalse patternFalseSym patternTrue patternTrueSym\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Or,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Or class\r\tinstanceVariableNames: \'\''				},				#name : #'Or class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Or,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent an Or proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternAnd,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternAndSym,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternFalse,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternFalseSym,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternTrue,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternTrueSym,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #Or\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'PatternAnd PatternAndSym patternFalse patternFalseSym patternTrue patternTrueSym\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Or,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Or class\r\tinstanceVariableNames: \'\''				},				#name : #'Or class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @33			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Or,					#isMetaSide : false				},				#parent : @33,				#content : 'I represent an Or proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternAnd,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternAndSym,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternFalse,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternFalseSym,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternTrue,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternTrueSym,					#parent : @33				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:53:51.01487+01:00' ],		#prior : OmReference [ '115' ],		#self : OmReference [ '116' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '116' ],		#self : OmReference [ '117' ],		#time : DateAndTime [ '2018-12-15T15:53:51.022419+01:00' ],		#trigger : @3	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #Or\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'PatternAnd PatternAndSym PatternFalse PatternFalseSym PatternTrue patternTrueSym\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Or,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Or class\r\tinstanceVariableNames: \'\''				},				#name : #'Or class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Or,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent an Or proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternAnd,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternAndSym,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternFalse,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternFalseSym,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternTrue,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternTrueSym,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #Or\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'PatternAnd PatternAndSym PatternFalse PatternFalseSym PatternTrue PatternTrueSym patternTrueSym\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Or,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Or class\r\tinstanceVariableNames: \'\''				},				#name : #'Or class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @33			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Or,					#isMetaSide : false				},				#parent : @33,				#content : 'I represent an Or proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternAnd,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternAndSym,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternFalse,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternFalseSym,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternTrue,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternTrueSym,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #patternTrueSym,					#parent : @33				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '117' ],		#self : OmReference [ '118' ],		#time : DateAndTime [ '2018-12-15T15:53:51.030935+01:00' ],		#trigger : OmReference [ '116' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Or class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialize,			#sourceCode : 'initialize\r\t"Choosing the graphical symbol"\r\tsymb:=\'\\/\'. \r\t\r\t"patterns used for clausification.\r\tSince we\'re in a binary operator, we have represent it, to fit in one variable."\r\tPatternAnd:=Or new: (And new: (Var new: \'a\') rightProp: (Var new:(\'a\')))  rightProp: (Var new: \'a\').\r\tPatternAndSym:=Or new: (Var new: \'a\') rightProp: (And new: (Var new: \'a\') rightProp: (Var new:(\'a\'))).\r\tpatternTrue:=Or new: (Var new: \'a\') rightProp: (True_Const new).\r\tpatternTrueSym:=Or new: (True_Const new) rightProp:(Var new:\'a\').\r\tpatternFalse:=Or new: (Var new: \'a\') rightProp: (False_Const new).\r\tpatternFalseSym:=Or new: (False_Const new) rightProp:(Var new:\'a\').',			#stamp : 'pm 12/15/2018 15:53',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Or class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialize,			#sourceCode : 'initialize\r\t"Choosing the graphical symbol"\r\tsymb:=\'\\/\'. \r\t\r\t"patterns used for clausification.\r\tSince we\'re in a binary operator, we have represent it, to fit in one variable."\r\tPatternAnd:=Or new: (And new: (Var new: \'a\') rightProp: (Var new:(\'a\')))  rightProp: (Var new: \'a\').\r\tPatternAndSym:=Or new: (Var new: \'a\') rightProp: (And new: (Var new: \'a\') rightProp: (Var new:(\'a\'))).\r\tpatternTrue:=Or new: (Var new: \'a\') rightProp: (True_Const new).\r\tPatternTrueSym:=Or new: (True_Const new) rightProp:(Var new:\'a\').\r\tpatternFalse:=Or new: (Var new: \'a\') rightProp: (False_Const new).\r\tpatternFalseSym:=Or new: (False_Const new) rightProp:(Var new:\'a\').',			#stamp : 'pm 12/15/2018 15:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '118' ],		#self : OmReference [ '119' ],		#time : DateAndTime [ '2018-12-15T15:53:51.033867+01:00' ],		#trigger : OmReference [ '116' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Or class',				#isMetaSide : true			},			#name : #patternTrueSym,			#protocol : #accessing,			#sourceCode : 'patternTrueSym\r\t"accessor"\r\t^patternTrueSym',			#stamp : 'pm 11/27/2018 18:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Or class',				#isMetaSide : true			},			#name : #patternTrueSym,			#protocol : #accessing,			#sourceCode : 'patternTrueSym\r\t"accessor"\r\t^PatternTrueSym',			#stamp : 'pm 12/15/2018 15:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:54:01.72499+01:00' ],		#prior : OmReference [ '119' ],		#self : OmReference [ '120' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:55:04.98223+01:00' ],		#prior : OmReference [ '120' ],		#self : OmReference [ '121' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #Or\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'PatternAnd PatternAndSym PatternFalse PatternFalseSym PatternTrue PatternTrueSym\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Or,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Or class\r\tinstanceVariableNames: \'\''				},				#name : #'Or class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Or,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent an Or proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternAnd,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternAndSym,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternFalse,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternFalseSym,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternTrue,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternTrueSym,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #Or\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'PatternAnd PatternAndSym PatternFalse PatternFalseSym PatternTrue PatternTrueSym\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Or,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Or class\r\tinstanceVariableNames: \'\''				},				#name : #'Or class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @33			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Or,					#isMetaSide : false				},				#parent : @33,				#content : 'I represent an Or proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternAnd,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternAndSym,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternFalse,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternFalseSym,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternTrue,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Or,						#isMetaSide : false					},					#name : #PatternTrueSym,					#parent : @33				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:57:00.153787+01:00' ],		#prior : OmReference [ '121' ],		#self : OmReference [ '122' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Or,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t"does an iteration of clausification the current proposition"\r\t\r\t"For this one, we have some different possible pattern."\r\t| t |\r\tt:=nil.\r \t(patternFalse matchPatternWith: self)\r\tifTrue:[t:=left]\r\tifFalse:[\r\t\t((Or patternFalseSym) matchPatternWith: self)\r\t\tifTrue:[t:=right]\r\t\tifFalse:[\r\t\t\t((Or patternTrue) matchPatternWith: self)\r\t\t\tifTrue:[t:=right]\r\t\t\tifFalse:[\r\t\t\t\t((Or patternTrueSym) matchPatternWith: self)\r\t\t\t\tifTrue:[t:=left]\r\t\t\t\tifFalse:[\r\t\t\t\t\t((Or patternAnd) matchPatternWith: self)\r\t\t\t\t\tifTrue:[t:=And new: (Or new: ((self left) left) rightProp: (self right)) \r\t\t\t\t\t\t\t\t  rightProp: (Or new:((self left) right) rightProp: (self right))]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t((Or patternAndSym) matchPatternWith: self)\r\t\t\t\t\t\tifTrue:[t:=And new:(Or new: (self left) rightProp: ((self right) left)) \r\t\t\t\t\t\t\t\t\t  rightProp: (Or new: (self left) rightProp: ((self right) right))].\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\t\t(t isNil) ifTrue:[clausificationTrace ifTrue:[Transcript show:\'in Or\';show: self prettyPrint;cr.].\r\t\t\t\t\t\t\t\tself left:(left clausification).\r\t\t\t\t\t\t\t\tself right:(right clausification).\r\t\t\t\t\t\t\t\t^self]\r\t\t\t\t\t ifFalse:[clausificationTrace ifTrue:[Transcript show:\'in Or2\';show: t prettyPrint;cr.].\r\t\t\t\t\t\t^t "clausification" ]',			#stamp : 'pm 12/15/2018 15:53',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Or,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t"does an iteration of clausification the current proposition"\r\t\r\t"For this one, we have some different possible pattern."\r\t| t |\r\tt:=nil.\r \t(OrPatternFalse matchPatternWith: self)\r\tifTrue:[t:=left]\r\tifFalse:[\r\t\t(OrPatternFalseSym matchPatternWith: self)\r\t\tifTrue:[t:=right]\r\t\tifFalse:[\r\t\t\t(OrPatternTrue matchPatternWith: self)\r\t\t\tifTrue:[t:=right]\r\t\t\tifFalse:[\r\t\t\t\t(OrPatternTrueSym matchPatternWith: self)\r\t\t\t\tifTrue:[t:=left]\r\t\t\t\tifFalse:[\r\t\t\t\t\t(OrPatternAnd matchPatternWith: self)\r\t\t\t\t\tifTrue:[t:=And new: (Or new: ((self left) left) rightProp: (self right)) \r\t\t\t\t\t\t\t\t  rightProp: (Or new:((self left) right) rightProp: (self right))]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t(OrPatternAndSym matchPatternWith: self)\r\t\t\t\t\t\tifTrue:[t:=And new:(Or new: (self left) rightProp: ((self right) left)) \r\t\t\t\t\t\t\t\t\t  rightProp: (Or new: (self left) rightProp: ((self right) right))].\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\t\r\t\t(t isNil)\r\t\tifTrue:[\r\t\t\tclausificationTrace ifTrue:[Transcript show:\'in Or\';show: self prettyPrint;cr.].\r\t\t\tself left:(left clausification).\r\t\t\tself right:(right clausification).\r\t\t\t^self\r\t\t\t]\r\t\t ifFalse:[\r\t\t\tclausificationTrace ifTrue:[Transcript show:\'in Or2\';show: t prettyPrint;cr.].\r\t\t\t\t^t\r\t\t\t]',			#stamp : 'pm 12/15/2018 15:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:57:56.035399+01:00' ],		#prior : OmReference [ '122' ],		#self : OmReference [ '123' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Or class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialize,			#sourceCode : 'initialize\r\t"Choosing the graphical symbol"\r\tsymb:=\'\\/\'. \r\t\r\t"patterns used for clausification.\r\tSince we\'re in a binary operator, we have represent it, to fit in one variable."\r\tPatternAnd:=Or new: (And new: (Var new: \'a\') rightProp: (Var new:(\'a\')))  rightProp: (Var new: \'a\').\r\tPatternAndSym:=Or new: (Var new: \'a\') rightProp: (And new: (Var new: \'a\') rightProp: (Var new:(\'a\'))).\r\tpatternTrue:=Or new: (Var new: \'a\') rightProp: (True_Const new).\r\tPatternTrueSym:=Or new: (True_Const new) rightProp:(Var new:\'a\').\r\tpatternFalse:=Or new: (Var new: \'a\') rightProp: (False_Const new).\r\tpatternFalseSym:=Or new: (False_Const new) rightProp:(Var new:\'a\').',			#stamp : 'pm 12/15/2018 15:53',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Or class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialize,			#sourceCode : 'initialize\r\t"Choosing the graphical symbol"\r\tsymb:=\'\\/\'. \r\t\r\t"patterns used for clausification.\r\tSince we\'re in a binary operator, we have represent it, to fit in one variable."\r\tOrPatternAnd:=Or new: (And new: (Var new: \'a\') rightProp: (Var new:(\'a\')))  rightProp: (Var new: \'a\').\r\tOrPatternAndSym:=Or new: (Var new: \'a\') rightProp: (And new: (Var new: \'a\') rightProp: (Var new:(\'a\'))).\r\tOrPatternTrue:=Or new: (Var new: \'a\') rightProp: (True_Const new).\r\tOrPatternTrueSym:=Or new: (True_Const new) rightProp:(Var new:\'a\').\r\tOrPatternFalse:=Or new: (Var new: \'a\') rightProp: (False_Const new).\r\tOrPatternFalseSym:=Or new: (False_Const new) rightProp:(Var new:\'a\').',			#stamp : 'pm 12/15/2018 15:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:58:22.056807+01:00' ],		#prior : OmReference [ '123' ],		#self : OmReference [ '124' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #And\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'patternFalse patternFalseSym patternTrue patternTrueSym\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #And,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'And class\r\tinstanceVariableNames: \'\''				},				#name : #'And class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #And,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent an And proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #patternFalse,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #patternFalseSym,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #patternTrue,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #patternTrueSym,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #And\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'patternFalse patternFalseSym patternTrue patternTrueSym\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #And,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'And class\r\tinstanceVariableNames: \'\''				},				#name : #'And class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @29			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #And,					#isMetaSide : false				},				#parent : @29,				#content : 'I represent an And proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #patternFalse,					#parent : @29				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #patternFalseSym,					#parent : @29				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #patternTrue,					#parent : @29				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #patternTrueSym,					#parent : @29				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:58:35.431016+01:00' ],		#prior : OmReference [ '124' ],		#self : OmReference [ '125' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #And\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'OrPatternFalseSym OrPatternTrue OrPatternTrueSym orPatternFalse patternFalse patternFalseSym patternTrue\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #And,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'And class\r\tinstanceVariableNames: \'\''				},				#name : #'And class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #And,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent an And proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #OrPatternFalseSym,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #OrPatternTrue,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #OrPatternTrueSym,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #orPatternFalse,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #patternFalse,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #patternFalseSym,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #patternTrue,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #And\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'OrPatternFalseSym OrPatternTrue OrPatternTrueSym orPatternFalse patternFalse patternFalseSym patternTrue\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #And,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'And class\r\tinstanceVariableNames: \'\''				},				#name : #'And class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @35			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #And,					#isMetaSide : false				},				#parent : @35,				#content : 'I represent an And proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #OrPatternFalseSym,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #OrPatternTrue,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #OrPatternTrueSym,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #orPatternFalse,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #patternFalse,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #patternFalseSym,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #patternTrue,					#parent : @35				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:58:48.316173+01:00' ],		#prior : OmReference [ '125' ],		#self : OmReference [ '126' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'And class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialize,			#sourceCode : 'initialize\r\t"Choosing the graphical symbol"\r\tsymb:=\'/\\\'.\r\t\t\r\t"patterns used for clausification.\r\tSince we\'re in a binary operator, we have represent it, to fit in one variable."\r\tpatternTrue:=And new: (Var new: \'a\') rightProp: (True_Const new).\r\tpatternTrueSym:=And new: (True_Const new) rightProp:(Var new:\'a\').\r\tpatternFalse:=And new: (Var new: \'a\') rightProp: (False_Const new).\r\tpatternFalseSym:=And new: (False_Const new) rightProp:(Var new:\'a\').',			#stamp : 'pm 12/7/2018 21:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'And class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialize,			#sourceCode : 'initialize\r\t"Choosing the graphical symbol"\r\tsymb:=\'/\\\'.\r\t\t\r\t"patterns used for clausification.\r\tSince we\'re in a binary operator, we have represent it, to fit in one variable."\r\tOrPatternTrue:=And new: (Var new: \'a\') rightProp: (True_Const new).\r\tOrPatternTrueSym:=And new: (True_Const new) rightProp:(Var new:\'a\').\r\tOrPatternFalse:=And new: (Var new: \'a\') rightProp: (False_Const new).\r\tOrPatternFalseSym:=And new: (False_Const new) rightProp:(Var new:\'a\').',			#stamp : 'pm 12/15/2018 15:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:58:55.641495+01:00' ],		#prior : OmReference [ '126' ],		#self : OmReference [ '127' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #And\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'OrPatternFalse OrPatternFalseSym OrPatternTrue OrPatternTrueSym patternFalse patternFalseSym patternTrue\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #And,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'And class\r\tinstanceVariableNames: \'\''				},				#name : #'And class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #And,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent an And proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #OrPatternFalse,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #OrPatternFalseSym,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #OrPatternTrue,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #OrPatternTrueSym,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #patternFalse,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #patternFalseSym,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #patternTrue,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #And\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'OrPatternFalse OrPatternFalseSym OrPatternTrue OrPatternTrueSym patternFalse patternFalseSym patternTrue\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #And,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'And class\r\tinstanceVariableNames: \'\''				},				#name : #'And class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @35			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #And,					#isMetaSide : false				},				#parent : @35,				#content : 'I represent an And proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #OrPatternFalse,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #OrPatternFalseSym,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #OrPatternTrue,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #OrPatternTrueSym,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #patternFalse,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #patternFalseSym,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #patternTrue,					#parent : @35				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:59:17.14639+01:00' ],		#prior : OmReference [ '127' ],		#self : OmReference [ '128' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #And\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'OrPatternFalse OrPatternFalseSym OrPatternTrue OrPatternTrueSym patternFalse patternFalseSym patternTrue\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #And,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'And class\r\tinstanceVariableNames: \'\''				},				#name : #'And class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #And,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent an And proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #OrPatternFalse,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #OrPatternFalseSym,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #OrPatternTrue,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #OrPatternTrueSym,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #patternFalse,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #patternFalseSym,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #patternTrue,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #And\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'OrPatternFalse OrPatternFalseSym OrPatternTrue OrPatternTrueSym patternFalse patternFalseSym patternTrue\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #And,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'And class\r\tinstanceVariableNames: \'\''				},				#name : #'And class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @35			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #And,					#isMetaSide : false				},				#parent : @35,				#content : 'I represent an And proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #OrPatternFalse,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #OrPatternFalseSym,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #OrPatternTrue,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #OrPatternTrueSym,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #patternFalse,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #patternFalseSym,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #And,						#isMetaSide : false					},					#name : #patternTrue,					#parent : @35				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:59:25.954909+01:00' ],		#prior : OmReference [ '128' ],		#self : OmReference [ '129' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'And class',				#isMetaSide : true			},			#name : #patternFalse,			#protocol : #accessing,			#sourceCode : 'patternFalse\t\r\t"accessor"\r\t^patternFalse',			#stamp : 'pm 11/27/2018 18:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:59:30.129158+01:00' ],		#prior : OmReference [ '129' ],		#self : OmReference [ '130' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'And class',				#isMetaSide : true			},			#name : #patternFalseSym,			#protocol : #accessing,			#sourceCode : 'patternFalseSym\t\r\t"accessor"\r\t^patternFalseSym',			#stamp : 'pm 11/27/2018 18:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:59:38.332738+01:00' ],		#prior : OmReference [ '130' ],		#self : OmReference [ '131' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'And class',				#isMetaSide : true			},			#name : #patternTrueSym,			#protocol : #accessing,			#sourceCode : 'patternTrueSym\t\r\t"accessor"\r\t^patternTrueSym',			#stamp : 'pm 11/27/2018 18:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:59:45.756951+01:00' ],		#prior : OmReference [ '131' ],		#self : OmReference [ '132' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'And class',				#isMetaSide : true			},			#name : #patternTrue,			#protocol : #accessing,			#sourceCode : 'patternTrue\t\r\t"accessor"\r\t^patternTrue',			#stamp : 'pm 11/27/2018 18:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T15:59:56.700202+01:00' ],		#prior : OmReference [ '132' ],		#self : OmReference [ '133' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'And class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialize,			#sourceCode : 'initialize\r\t"Choosing the graphical symbol"\r\tsymb:=\'/\\\'.\r\t\t\r\t"patterns used for clausification.\r\tSince we\'re in a binary operator, we have represent it, to fit in one variable."\r\tOrPatternTrue:=And new: (Var new: \'a\') rightProp: (True_Const new).\r\tOrPatternTrueSym:=And new: (True_Const new) rightProp:(Var new:\'a\').\r\tOrPatternFalse:=And new: (Var new: \'a\') rightProp: (False_Const new).\r\tOrPatternFalseSym:=And new: (False_Const new) rightProp:(Var new:\'a\').',			#stamp : 'pm 12/15/2018 15:58',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'And class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialize,			#sourceCode : 'initialize\r\t"Choosing the graphical symbol"\r\tsymb:=\'/\\\'.\r\t\t\r\t"patterns used for clausification.\r\tSince we\'re in a binary operator, we have represent it, to fit in one variable."\r\tAndPatternTrue:=And new: (Var new: \'a\') rightProp: (True_Const new).\r\tAndPatternTrueSym:=And new: (True_Const new) rightProp:(Var new:\'a\').\r\tAndPatternFalse:=And new: (Var new: \'a\') rightProp: (False_Const new).\r\tAndPatternFalseSym:=And new: (False_Const new) rightProp:(Var new:\'a\').',			#stamp : 'pm 12/15/2018 15:59',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:00:53.135338+01:00' ],		#prior : OmReference [ '133' ],		#self : OmReference [ '134' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #And,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t"does an iteration of clausification the current proposition"\r\t\r\t"For this one, we have some different possible pattern."\r\t\r\t| t |\r\tt:=nil.\r \t((And patternFalse) matchPatternWith: self)\r\tifTrue:[t:=right]\r\tifFalse:[\r\t\t((And patternFalseSym) matchPatternWith: self)\r\t\tifTrue:[t:=left]\r\t\tifFalse:[\r\t\t\t((And patternTrue) matchPatternWith: self)\r\t\t\tifTrue:[t:=left]\r\t\t\tifFalse:[\r\t\t\t\t((And patternTrueSym) matchPatternWith: self)\r\t\t\t\tifTrue:[t:=right]\r\t\t\t\tifFalse:[]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\t\t(t isNil) ifTrue:[ clausificationTrace ifTrue:[Transcript show:\'in And\';show: self prettyPrint;cr.].\r\t\t\tself left:(left clausification).\r\t\t\t\t\t\t\t\tself right:(right clausification).\r\t\t\t\t\t\t\t\t^self]\r\t\t\t\t\t ifFalse:[clausificationTrace  ifTrue:[Transcript show:\'in And2\';show: t prettyPrint;cr.].\r\t\t\t\t\t\t^t]. ',			#stamp : 'pm 12/12/2018 14:05',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #And,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t"does an iteration of clausification the current proposition"\r\t\r\t"For this one, we have some different possible pattern."\r\t\r\t| t |\r\tt:=nil.\r \t(AndPatternFalse matchPatternWith: self)\r\tifTrue:[t:=right]\r\tifFalse:[\r\t\t(AndPatternFalseSym matchPatternWith: self)\r\t\tifTrue:[t:=left]\r\t\tifFalse:[\r\t\t\t(AndPatternTrue matchPatternWith: self)\r\t\t\tifTrue:[t:=left]\r\t\t\tifFalse:[\r\t\t\t\t(AndPatternTrueSym matchPatternWith: self)\r\t\t\t\tifTrue:[t:=right]\r\t\t\t\tifFalse:[]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\t\r\t\t(t isNil)\r\t\tifTrue:[ \r\t\t\tclausificationTrace ifTrue:[Transcript show:\'in And\';show: self prettyPrint;cr.].\r\t\t\tself left:(left clausification).\r\t\t\tself right:(right clausification).\r\t\t\t^self\r\t\t\t]\r\t\tifFalse:[\r\t\t\tclausificationTrace  ifTrue:[Transcript show:\'in And2\';show: t prettyPrint;cr.].\r\t\t\t^t\r\t\t\t]. ',			#stamp : 'pm 12/15/2018 16:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:01:18.145536+01:00' ],		#prior : OmReference [ '134' ],		#self : OmReference [ '135' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Unary',				#traitCompositionSource : '{}',				#definitionSource : 'Unary subclass: #Not\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'patternAnd patternFalse patternNot patternOr patternTrue\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Not,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Not class\r\tinstanceVariableNames: \'\''				},				#name : #'Not class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Not,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Not  operator\r\rMy creation is available in the Unary class',				#stamp : 'pm 11/27/2018 07:42'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternAnd,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternFalse,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternNot,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternOr,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternTrue,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Unary',				#traitCompositionSource : '{}',				#definitionSource : 'Unary subclass: #Not\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'patternAnd patternFalse patternNot patternOr patternTrue\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Not,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Not class\r\tinstanceVariableNames: \'\''				},				#name : #'Not class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @31			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Not,					#isMetaSide : false				},				#parent : @31,				#content : 'I represent a Not  operator\r\rMy creation is available in the Unary class',				#stamp : 'pm 11/27/2018 07:42'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternAnd,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternFalse,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternNot,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternOr,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternTrue,					#parent : @31				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:01:23.341934+01:00' ],		#prior : OmReference [ '135' ],		#self : OmReference [ '136' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Unary',				#traitCompositionSource : '{}',				#definitionSource : 'Unary subclass: #Not\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'NotPatternAnd NotPatternFalse patternFalse patternNot patternOr patternTrue\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Not,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Not class\r\tinstanceVariableNames: \'\''				},				#name : #'Not class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Not,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Not  operator\r\rMy creation is available in the Unary class',				#stamp : 'pm 11/27/2018 07:42'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternAnd,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternFalse,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternFalse,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternNot,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternOr,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternTrue,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Unary',				#traitCompositionSource : '{}',				#definitionSource : 'Unary subclass: #Not\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'NotPatternAnd NotPatternFalse patternFalse patternNot patternOr patternTrue\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Not,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Not class\r\tinstanceVariableNames: \'\''				},				#name : #'Not class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @33			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Not,					#isMetaSide : false				},				#parent : @33,				#content : 'I represent a Not  operator\r\rMy creation is available in the Unary class',				#stamp : 'pm 11/27/2018 07:42'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternAnd,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternFalse,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternFalse,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternNot,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternOr,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternTrue,					#parent : @33				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:01:28.25137+01:00' ],		#prior : OmReference [ '136' ],		#self : OmReference [ '137' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Unary',				#traitCompositionSource : '{}',				#definitionSource : 'Unary subclass: #Not\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'NotPatternAnd NotPatternFalse atternNot patternFalse patternOr patternTrue\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Not,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Not class\r\tinstanceVariableNames: \'\''				},				#name : #'Not class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Not,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Not  operator\r\rMy creation is available in the Unary class',				#stamp : 'pm 11/27/2018 07:42'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternAnd,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternFalse,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #atternNot,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternFalse,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternOr,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternTrue,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Unary',				#traitCompositionSource : '{}',				#definitionSource : 'Unary subclass: #Not\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'NotPatternAnd NotPatternFalse atternNot patternFalse patternOr patternTrue\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Not,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Not class\r\tinstanceVariableNames: \'\''				},				#name : #'Not class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @33			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Not,					#isMetaSide : false				},				#parent : @33,				#content : 'I represent a Not  operator\r\rMy creation is available in the Unary class',				#stamp : 'pm 11/27/2018 07:42'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternAnd,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternFalse,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #atternNot,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternFalse,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternOr,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternTrue,					#parent : @33				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:02:12.693515+01:00' ],		#prior : OmReference [ '137' ],		#self : OmReference [ '138' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Not class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #Initialize,			#sourceCode : 'initialize\r\t"Choosing the graphical symbol"\r\tsymb:=\'~\'.\r\t\r\t"patterns used for clausification.\r\tSince we\'re in a unary operator, we choose to not represent it, and just compare those pattern with the operand"\r\tpatternNot:=Not new:(Var new: \'a\').\r\tpatternTrue:=True_Const new.\r\tpatternFalse:=False_Const new.\r\tpatternOr:=Or new:(Var new: \'a\') rightProp: (Var new: \'a\').\r\tpatternAnd:=And new:(Var new: \'a\') rightProp: (Var new: \'a\').',			#stamp : 'pm 11/27/2018 12:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Not class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #Initialize,			#sourceCode : 'initialize\r\t"Choosing the graphical symbol"\r\tsymb:=\'~\'.\r\t\r\t"patterns used for clausification.\r\tSince we\'re in a unary operator, we choose to not represent it, and just compare those pattern with the operand"\r\tNotPatternNot:=Not new:(Var new: \'a\').\r\tNotPatternTrue:=True_Const new.\r\tNotPatternFalse:=False_Const new.\r\tNotPatternOr:=Or new:(Var new: \'a\') rightProp: (Var new: \'a\').\r\tNotPatternAnd:=And new:(Var new: \'a\') rightProp: (Var new: \'a\').',			#stamp : 'pm 12/15/2018 16:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:02:17.527244+01:00' ],		#prior : OmReference [ '138' ],		#self : OmReference [ '139' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Not class',				#isMetaSide : true			},			#name : #patternAnd,			#protocol : #accessing,			#sourceCode : 'patternAnd\r\t"accessor"\r\t^patternAnd.',			#stamp : 'pm 11/27/2018 07:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:02:21.008218+01:00' ],		#prior : OmReference [ '139' ],		#self : OmReference [ '140' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Not class',				#isMetaSide : true			},			#name : #patternNot,			#protocol : #accessing,			#sourceCode : 'patternNot\r\t"accessor"\r\t^patternNot.',			#stamp : 'pm 11/27/2018 07:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:02:29.014457+01:00' ],		#prior : OmReference [ '140' ],		#self : OmReference [ '141' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Not class',				#isMetaSide : true			},			#name : #patternOr,			#protocol : #accessing,			#sourceCode : 'patternOr\r\t"accessor"\r\t^patternOr.',			#stamp : 'pm 11/27/2018 07:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:02:35.719617+01:00' ],		#prior : OmReference [ '141' ],		#self : OmReference [ '142' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Not class',				#isMetaSide : true			},			#name : #patternFalse,			#protocol : #accessing,			#sourceCode : 'patternFalse\r\t"accessor"\r\t^patternFalse.',			#stamp : 'pm 11/27/2018 07:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:02:45.081027+01:00' ],		#prior : OmReference [ '142' ],		#self : OmReference [ '143' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Not class',				#isMetaSide : true			},			#name : #patternTrue,			#protocol : #accessing,			#sourceCode : 'patternTrue\r\t"accessor"\r\t^patternTrue.',			#stamp : 'pm 11/27/2018 07:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:03:04.216916+01:00' ],		#prior : OmReference [ '143' ],		#self : OmReference [ '144' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Unary',				#traitCompositionSource : '{}',				#definitionSource : 'Unary subclass: #Not\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'NotPatternAnd NotPatternFalse NotPatternNot patternFalse patternOr patternTrue\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Not,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Not class\r\tinstanceVariableNames: \'\''				},				#name : #'Not class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Not,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Not  operator\r\rMy creation is available in the Unary class',				#stamp : 'pm 11/27/2018 07:42'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternAnd,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternFalse,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternNot,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternFalse,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternOr,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternTrue,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Unary',				#traitCompositionSource : '{}',				#definitionSource : 'Unary subclass: #Not\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'NotPatternAnd NotPatternFalse NotPatternNot patternFalse patternOr patternTrue\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Not,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Not class\r\tinstanceVariableNames: \'\''				},				#name : #'Not class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @33			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Not,					#isMetaSide : false				},				#parent : @33,				#content : 'I represent a Not  operator\r\rMy creation is available in the Unary class',				#stamp : 'pm 11/27/2018 07:42'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternAnd,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternFalse,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternNot,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternFalse,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternOr,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #patternTrue,					#parent : @33				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:04:21.420701+01:00' ],		#prior : OmReference [ '144' ],		#self : OmReference [ '145' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t"does an iteration of clausification the current proposition"\r\t\r\t"For this one, we have some different possible pattern."\r\t"/!\\ since we\'re in an unary operator, the pattern doesn\'t start at self, but at operand"\r\t| t |\r\tt:=nil.\r\t((Not patternNot) matchPatternWith: operand)\r\tifTrue:[t:=operand operand.]\r\tifFalse:[\r\t\t\t((Not patternTrue) matchPatternWith: operand)\r\t\t\tifTrue:[t:=False_Const new]\r\t\t\tifFalse:[\r\t\t\t\t((Not patternFalse) matchPatternWith: operand)\r\t\t\t\tifTrue:[t:=True_Const new]\r\t\t\t\tifFalse:[\r\t\t\t\t\t((Not patternOr) matchPatternWith: operand)\r\t\t\t\t\tifTrue:[t:=And new: (Not new:(operand left)) rightProp:(Not new:(operand right))]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t((Not patternAnd) matchPatternWith: operand)\r\t\t\t\t\t\tifTrue:[t:=Or new: (Not new:(operand left)) rightProp:(Not new:(operand right))].\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t ]\r\t\t\t].\r\t\t(t isNil) ifTrue:[clausificationTrace  ifTrue:[Transcript show:\'in Not\';show: self prettyPrint;cr.].\r\t\t\t self operand:(operand clausification).\r\t\t\t\t\t\t\t\t^self]\r\t\t\t\t\t ifFalse:[clausificationTrace ifTrue:[Transcript show:\'in Not2\';show: t prettyPrint;cr.].\r\t\t\t\t\t\t^t].',			#stamp : 'pm 12/12/2018 15:49',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t"does an iteration of clausification the current proposition"\r\t\r\t"For this one, we have some different possible pattern."\r\t"/!\\ since we\'re in an unary operator, the pattern doesn\'t start at self, but at operand"\r\t| t |\r\tt:=nil.\r\t(NotPatternNot matchPatternWith: operand)\r\tifTrue:[t:=operand operand.]\r\tifFalse:[\r\t\t\t(NotPatternTrue matchPatternWith: operand)\r\t\t\tifTrue:[t:=False_Const new]\r\t\t\tifFalse:[\r\t\t\t\t(NotPatternFalse matchPatternWith: operand)\r\t\t\t\tifTrue:[t:=True_Const new]\r\t\t\t\tifFalse:[\r\t\t\t\t\t(NotPatternOr matchPatternWith: operand)\r\t\t\t\t\tifTrue:[t:=And new: (Not new:(operand left)) rightProp:(Not new:(operand right))]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t(NotPatternAnd matchPatternWith: operand)\r\t\t\t\t\t\tifTrue:[t:=Or new: (Not new:(operand left)) rightProp:(Not new:(operand right))].\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t ]\r\t\t\t].\r\t\t(t isNil)\r\t\tifTrue:[clausificationTrace  ifTrue:[Transcript show:\'in Not\';show: self prettyPrint;cr.].\r\t\t\tself operand:(operand clausification).\r\t\t\t^self\r\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tclausificationTrace ifTrue:[Transcript show:\'in Not2\';show: t prettyPrint;cr.].\r\t\t\t\t^t\r\t\t\t\t].',			#stamp : 'pm 12/15/2018 16:04',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:04:37.080262+01:00' ],		#prior : OmReference [ '145' ],		#self : OmReference [ '146' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Unary',				#traitCompositionSource : '{}',				#definitionSource : 'Unary subclass: #Not\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'NotPatternAnd NotPatternFalse NotPatternNot NotPatternTrue\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Not,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Not class\r\tinstanceVariableNames: \'\''				},				#name : #'Not class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Not,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Not  operator\r\rMy creation is available in the Unary class',				#stamp : 'pm 11/27/2018 07:42'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternAnd,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternFalse,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternNot,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternTrue,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Unary',				#traitCompositionSource : '{}',				#definitionSource : 'Unary subclass: #Not\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'NotPatternAnd NotPatternFalse NotPatternNot NotPatternTrue\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Not,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Not class\r\tinstanceVariableNames: \'\''				},				#name : #'Not class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @29			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Not,					#isMetaSide : false				},				#parent : @29,				#content : 'I represent a Not  operator\r\rMy creation is available in the Unary class',				#stamp : 'pm 11/27/2018 07:42'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternAnd,					#parent : @29				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternFalse,					#parent : @29				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternNot,					#parent : @29				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternTrue,					#parent : @29				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:05:09.593436+01:00' ],		#prior : OmReference [ '146' ],		#self : OmReference [ '147' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Unary',				#traitCompositionSource : '{}',				#definitionSource : 'Unary subclass: #Not\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'NotPatternAnd NotPatternFalse NotPatternOr NotPatternTrue\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Not,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Not class\r\tinstanceVariableNames: \'\''				},				#name : #'Not class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Not,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Not  operator\r\rMy creation is available in the Unary class',				#stamp : 'pm 11/27/2018 07:42'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternAnd,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternFalse,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternOr,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternTrue,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Unary',				#traitCompositionSource : '{}',				#definitionSource : 'Unary subclass: #Not\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'NotPatternAnd NotPatternFalse NotPatternOr NotPatternTrue\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Not,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Not class\r\tinstanceVariableNames: \'\''				},				#name : #'Not class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @29			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Not,					#isMetaSide : false				},				#parent : @29,				#content : 'I represent a Not  operator\r\rMy creation is available in the Unary class',				#stamp : 'pm 11/27/2018 07:42'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternAnd,					#parent : @29				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternFalse,					#parent : @29				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternOr,					#parent : @29				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Not,						#isMetaSide : false					},					#name : #NotPatternTrue,					#parent : @29				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:05:38.885767+01:00' ],		#prior : OmReference [ '147' ],		#self : OmReference [ '148' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Or class',				#isMetaSide : true			},			#name : #patternAnd,			#protocol : #initialize,			#sourceCode : 'patternAnd\t\r\t"accessor"\r\t^PatternAnd',			#stamp : 'pm 12/15/2018 15:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:05:42.446163+01:00' ],		#prior : OmReference [ '148' ],		#self : OmReference [ '149' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Or class',				#isMetaSide : true			},			#name : #patternTrue,			#protocol : #accessing,			#sourceCode : 'patternTrue\t\r\t"accessor"\r\t^patternTrue',			#stamp : 'pm 11/27/2018 18:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:05:45.038472+01:00' ],		#prior : OmReference [ '149' ],		#self : OmReference [ '150' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Or class',				#isMetaSide : true			},			#name : #patternFalseSym,			#protocol : #accessing,			#sourceCode : 'patternFalseSym\t\r\t"accessor"\r\t^patternFalseSym',			#stamp : 'pm 11/27/2018 18:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:05:48.042525+01:00' ],		#prior : OmReference [ '150' ],		#self : OmReference [ '151' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Or class',				#isMetaSide : true			},			#name : #patternFalse,			#protocol : #accessing,			#sourceCode : 'patternFalse\t\r\t"accessor"\r\t^patternFalse',			#stamp : 'pm 11/27/2018 18:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:05:51.054801+01:00' ],		#prior : OmReference [ '151' ],		#self : OmReference [ '152' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Or class',				#isMetaSide : true			},			#name : #patternTrueSym,			#protocol : #accessing,			#sourceCode : 'patternTrueSym\r\t"accessor"\r\t^PatternTrueSym',			#stamp : 'pm 12/15/2018 15:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:05:55.546815+01:00' ],		#prior : OmReference [ '152' ],		#self : OmReference [ '153' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Or class',				#isMetaSide : true			},			#name : #patternAndSym,			#protocol : #accessing,			#sourceCode : 'patternAndSym\t\r\t"accessor"\r\t^PatternAndSym',			#stamp : 'pm 12/15/2018 15:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:08:01.000852+01:00' ],		#prior : OmReference [ '153' ],		#self : OmReference [ '154' ]	},	#content : EpMonticelloVersionSave {		#versionName : '_resolution_1erOrdre-pm.5',		#repositoryDescription : '/home/ariale/FORM/pharo6.1-64/shared/pharo-local/package-cache'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:08:01.107556+01:00' ],		#prior : OmReference [ '154' ],		#self : OmReference [ '155' ]	},	#content : EpMonticelloVersionSave {		#versionName : '_resolution_1erOrdre-pm.5',		#repositoryDescription : '/home/ariale/FORM/pharo6.1-64/Sources'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:15:49.175849+01:00' ],		#prior : OmReference [ '155' ],		#self : OmReference [ '156' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '156' ],		#self : OmReference [ '157' ],		#time : DateAndTime [ '2018-12-15T16:15:49.241533+01:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #accessing,			#sourceCode : 'isSameForTesting: arg1 \r\t^ self subclassResponsibility',			#stamp : 'pm 12/15/2018 16:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:16:04.93368+01:00' ],		#prior : OmReference [ '157' ],		#self : OmReference [ '158' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #accessing,			#sourceCode : 'isSameForTesting: arg1 \r\t^ self subclassResponsibility',			#stamp : 'pm 12/15/2018 16:15',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #accessing,			#sourceCode : 'isSameForTesting: anotherTerm\r\t^ self subclassResponsibility',			#stamp : 'pm 12/15/2018 16:16',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:16:08.246026+01:00' ],		#prior : OmReference [ '158' ],		#self : OmReference [ '159' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #accessing,			#sourceCode : 'isSameForTesting: anotherTerm\r\t^ self subclassResponsibility',			#stamp : 'pm 12/15/2018 16:16',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #accessing,			#sourceCode : 'isSameForTesting: aTerm\r\t^ self subclassResponsibility',			#stamp : 'pm 12/15/2018 16:16',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:16:27.586219+01:00' ],		#prior : OmReference [ '159' ],		#self : OmReference [ '160' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '160' ],		#self : OmReference [ '161' ],		#time : DateAndTime [ '2018-12-15T16:16:27.596507+01:00' ],		#trigger : @3	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'clausificationTrace resolutionTrace skolemnTrace testNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @7,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- fullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- prettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 12/15/2018 15:14'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'ClausificationTrace clausificationTrace resolutionTrace skolemnTrace testNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @31			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @31,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- fullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- prettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 12/15/2018 15:14'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #ClausificationTrace,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @31				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '161' ],		#self : OmReference [ '162' ],		#time : DateAndTime [ '2018-12-15T16:16:27.610103+01:00' ],		#trigger : OmReference [ '160' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #fullClausification,			#protocol : #clausification,			#sourceCode : 'fullClausification\r\t| t |\r\tt:=self clausification.\r\t[t isClause] whileFalse:[\t\r\t\tclausificationTrace ifTrue:[Transcript show: t prettyPrint; show: t isClause;cr.].\r\t\tt:=t clausification.].\r\t^t',			#stamp : 'pm 12/12/2018 15:56',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #fullClausification,			#protocol : #clausification,			#sourceCode : 'fullClausification\r\t| t |\r\tt:=self clausification.\r\t[t isClause] whileFalse:[\t\r\t\tClausificationTrace ifTrue:[Transcript show: t prettyPrint; show: t isClause;cr.].\r\t\tt:=t clausification.].\r\t^t',			#stamp : 'pm 12/15/2018 16:16',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '162' ],		#self : OmReference [ '163' ],		#time : DateAndTime [ '2018-12-15T16:16:27.618576+01:00' ],		#trigger : OmReference [ '160' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see the traces process"\r\r\t"Variable to activate traces or not."\r\tclausificationTrace:=false.\r\tskolemnTrace:=false.\r\tunificationTrace:=false.\r\tresolutionTrace:=false.\r\t\r\t"Used to provided context during the textual tests available in the Prop class "\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see the traces process"\r\r\t"Variable to activate traces or not."\r\tClausificationTrace:=false.\r\tskolemnTrace:=false.\r\tunificationTrace:=false.\r\tresolutionTrace:=false.\r\t\r\t"Used to provided context during the textual tests available in the Prop class "\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/15/2018 16:16',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:17:15.157961+01:00' ],		#prior : OmReference [ '163' ],		#self : OmReference [ '164' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:17:51.865642+01:00' ],		#prior : OmReference [ '164' ],		#self : OmReference [ '165' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '165' ],		#self : OmReference [ '166' ],		#time : DateAndTime [ '2018-12-15T16:17:51.875179+01:00' ],		#trigger : @3	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'ClausificationTrace resolutionTrace skolemnTrace testNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @7,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- fullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- prettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 12/15/2018 15:14'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #ClausificationTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'ClausificationTrace ResolutionTrace resolutionTrace skolemnTrace testNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @31			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @31,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- fullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- prettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 12/15/2018 15:14'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #ClausificationTrace,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #ResolutionTrace,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @31				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '166' ],		#self : OmReference [ '167' ],		#time : DateAndTime [ '2018-12-15T16:17:51.890891+01:00' ],		#trigger : OmReference [ '165' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tresolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\t\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp StartSkolemnisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tresolutionTrace ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tResolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\t\r\tResolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp StartSkolemnisation.\r\tResolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tResolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tResolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tResolutionTrace ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/15/2018 16:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '167' ],		#self : OmReference [ '168' ],		#time : DateAndTime [ '2018-12-15T16:17:51.897339+01:00' ],		#trigger : OmReference [ '165' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see the traces process"\r\r\t"Variable to activate traces or not."\r\tClausificationTrace:=false.\r\tskolemnTrace:=false.\r\tunificationTrace:=false.\r\tresolutionTrace:=false.\r\t\r\t"Used to provided context during the textual tests available in the Prop class "\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/15/2018 16:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see the traces process"\r\r\t"Variable to activate traces or not."\r\tClausificationTrace:=false.\r\tskolemnTrace:=false.\r\tunificationTrace:=false.\r\tResolutionTrace:=false.\r\t\r\t"Used to provided context during the textual tests available in the Prop class "\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/15/2018 16:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '168' ],		#self : OmReference [ '169' ],		#time : DateAndTime [ '2018-12-15T16:17:51.900542+01:00' ],		#trigger : OmReference [ '165' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #resolutionTrace,			#protocol : #'as yet unclassified',			#sourceCode : 'resolutionTrace\r\t"accessor, it\'s also used in Clausal Form during the resolution process."\r\t^resolutionTrace',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #resolutionTrace,			#protocol : #'as yet unclassified',			#sourceCode : 'resolutionTrace\r\t"accessor, it\'s also used in Clausal Form during the resolution process."\r\t^ResolutionTrace',			#stamp : 'pm 12/15/2018 16:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:17:56.673999+01:00' ],		#prior : OmReference [ '169' ],		#self : OmReference [ '170' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:18:15.611862+01:00' ],		#prior : OmReference [ '170' ],		#self : OmReference [ '171' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:18:40.335234+01:00' ],		#prior : OmReference [ '171' ],		#self : OmReference [ '172' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '172' ],		#self : OmReference [ '173' ],		#time : DateAndTime [ '2018-12-15T16:18:40.341888+01:00' ],		#trigger : @3	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'ClausificationTrace ResolutionTrace skolemnTrace testNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @7,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- fullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- prettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 12/15/2018 15:14'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #ClausificationTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #ResolutionTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'ClausificationTrace ResolutionTrace SkolemnTrace skolemnTrace testNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @31			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @31,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- fullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- prettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 12/15/2018 15:14'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #ClausificationTrace,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #ResolutionTrace,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #SkolemnTrace,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @31				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '173' ],		#self : OmReference [ '174' ],		#time : DateAndTime [ '2018-12-15T16:18:40.34804+01:00' ],		#trigger : OmReference [ '172' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see the traces process"\r\r\t"Variable to activate traces or not."\r\tClausificationTrace:=false.\r\tskolemnTrace:=false.\r\tunificationTrace:=false.\r\tResolutionTrace:=false.\r\t\r\t"Used to provided context during the textual tests available in the Prop class "\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/15/2018 16:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see the traces process"\r\r\t"Variable to activate traces or not."\r\tClausificationTrace:=false.\r\tSkolemnTrace:=false.\r\tunificationTrace:=false.\r\tResolutionTrace:=false.\r\t\r\t"Used to provided context during the textual tests available in the Prop class "\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/15/2018 16:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:18:48.105453+01:00' ],		#prior : OmReference [ '174' ],		#self : OmReference [ '175' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:18:54.490389+01:00' ],		#prior : OmReference [ '175' ],		#self : OmReference [ '176' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '176' ],		#self : OmReference [ '177' ],		#time : DateAndTime [ '2018-12-15T16:18:54.498175+01:00' ],		#trigger : @3	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'ClausificationTrace ResolutionTrace SkolemnTrace testNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @7,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- fullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- prettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 12/15/2018 15:14'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #ClausificationTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #ResolutionTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #SkolemnTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'ClausificationTrace ResolutionTrace SkolemnTrace TestNumber testNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @31			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @31,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- fullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- prettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 12/15/2018 15:14'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #ClausificationTrace,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #ResolutionTrace,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #SkolemnTrace,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #TestNumber,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @31				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '177' ],		#self : OmReference [ '178' ],		#time : DateAndTime [ '2018-12-15T16:18:54.502986+01:00' ],		#trigger : OmReference [ '176' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see the traces process"\r\r\t"Variable to activate traces or not."\r\tClausificationTrace:=false.\r\tSkolemnTrace:=false.\r\tunificationTrace:=false.\r\tResolutionTrace:=false.\r\t\r\t"Used to provided context during the textual tests available in the Prop class "\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/15/2018 16:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see the traces process"\r\r\t"Variable to activate traces or not."\r\tClausificationTrace:=false.\r\tSkolemnTrace:=false.\r\tunificationTrace:=false.\r\tResolutionTrace:=false.\r\t\r\t"Used to provided context during the textual tests available in the Prop class "\r\tTestNumber:=0.\r\t',			#stamp : 'pm 12/15/2018 16:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '178' ],		#self : OmReference [ '179' ],		#time : DateAndTime [ '2018-12-15T16:18:54.506783+01:00' ],		#trigger : OmReference [ '176' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testNumber,			#protocol : #accessing,			#sourceCode : 'testNumber\r\t"incrementor for the testnumber, to give context"\r\t^testNumber',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testNumber,			#protocol : #accessing,			#sourceCode : 'testNumber\r\t"incrementor for the testnumber, to give context"\r\t^TestNumber',			#stamp : 'pm 12/15/2018 16:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '179' ],		#self : OmReference [ '180' ],		#time : DateAndTime [ '2018-12-15T16:18:54.511078+01:00' ],		#trigger : OmReference [ '176' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testInc,			#protocol : #tests,			#sourceCode : 'testInc\r\t"incrementor for the testnumber, to give context"\r\ttestNumber:=testNumber+1.',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testInc,			#protocol : #tests,			#sourceCode : 'testInc\r\t"incrementor for the testnumber, to give context"\r\tTestNumber:=TestNumber+1.',			#stamp : 'pm 12/15/2018 16:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-15T16:19:04.95931+01:00' ],		#prior : OmReference [ '180' ],		#self : OmReference [ '181' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '181' ],		#self : OmReference [ '182' ],		#time : DateAndTime [ '2018-12-15T16:19:04.966473+01:00' ],		#trigger : @3	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'ClausificationTrace ResolutionTrace SkolemnTrace TestNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @7,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- fullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- prettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 12/15/2018 15:14'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #ClausificationTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #ResolutionTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #SkolemnTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #TestNumber,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'ClausificationTrace ResolutionTrace SkolemnTrace TestNumber UnificationTrace unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @31			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @31,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- fullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- prettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 12/15/2018 15:14'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #ClausificationTrace,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #ResolutionTrace,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #SkolemnTrace,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #TestNumber,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #UnificationTrace,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @31				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '182' ],		#self : OmReference [ '183' ],		#time : DateAndTime [ '2018-12-15T16:19:04.974167+01:00' ],		#trigger : OmReference [ '181' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see the traces process"\r\r\t"Variable to activate traces or not."\r\tClausificationTrace:=false.\r\tSkolemnTrace:=false.\r\tunificationTrace:=false.\r\tResolutionTrace:=false.\r\t\r\t"Used to provided context during the textual tests available in the Prop class "\r\tTestNumber:=0.\r\t',			#stamp : 'pm 12/15/2018 16:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see the traces process"\r\r\t"Variable to activate traces or not."\r\tClausificationTrace:=false.\r\tSkolemnTrace:=false.\r\tUnificationTrace:=false.\r\tResolutionTrace:=false.\r\t\r\t"Used to provided context during the textual tests available in the Prop class "\r\tTestNumber:=0.\r\t',			#stamp : 'pm 12/15/2018 16:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '183' ],		#self : OmReference [ '184' ],		#time : DateAndTime [ '2018-12-15T16:19:04.979108+01:00' ],		#trigger : OmReference [ '181' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #unificationTrace,			#protocol : #accessing,			#sourceCode : 'unificationTrace\r\t"accessor for the Unification process"\r\t^unificationTrace',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #unificationTrace,			#protocol : #accessing,			#sourceCode : 'unificationTrace\r\t"accessor for the Unification process"\r\t^UnificationTrace',			#stamp : 'pm 12/15/2018 16:19',			#package : #_resolution_1erOrdre		}	}}