OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T17:56:18.662192+01:00' ],		#prior : OmReference [ 'Pharo.eirsghixkgtnm0aoahhj7zocw', '3' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t(Prop debugUnification)\r\t\t\tifTrue:[Transcript show:\'conflict\';cr.].\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[(right isKindOf: LinkedTerm) or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"notPossible:=self check:aPair."\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 10/28/2018 18:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t(Prop debugUnification)\r\t\t\tifTrue:[Transcript show:\'conflict\';cr.].\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[(right isKindOf: LinkedTerm) or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 11/4/2018 17:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:10:32.590868+01:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpCategoryAddition {		#classCategoryName : '_resolution_1erOrdre-Prop',		#affectedPackageName : #_resolution_1erOrdre	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:10:40.659745+01:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #_resolution_1erOrdre,		#newCategory : #_resolution_1erOrdre-Prop,		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Prop\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'debug debugUnification testNumber unifDone resolutionTrace\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Prop class',							#isMetaSide : true						},						#name : #debug,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Prop class',							#isMetaSide : true						},						#name : #debugUnification,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Prop class',							#isMetaSide : true						},						#name : #testNumber,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Prop class',							#isMetaSide : true						},						#name : #unifDone,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Prop class',							#isMetaSide : true						},						#name : #resolutionTrace,						#parent : @12					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @7,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- FullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- PrettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 10/9/2018 10:52'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Prop,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:10:47.862985+01:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #_resolution_1erOrdre,		#newCategory : #_resolution_1erOrdre-Prop,		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Prop',				#traitCompositionSource : '{}',				#definitionSource : 'Prop subclass: #Operator\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Prop\''			},			#name : #Operator,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Operator class\r\tinstanceVariableNames: \'symb\''				},				#name : #'Operator class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Operator class',							#isMetaSide : true						},						#name : #symb,						#parent : @12					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Operator,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent an operator whith an unknown number of argument.\r\rI only factorise a method for now, but I allow possible future evolutions.',				#stamp : 'pm 10/9/2018 10:48'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Prop,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:10:53.002575+01:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #_resolution_1erOrdre,		#newCategory : #_resolution_1erOrdre-Prop,		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #Or\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Prop\''			},			#name : #Or,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Or class\r\tinstanceVariableNames: \'patternAnd patternAndSym patternTrue patternTrueSym patternFalse patternFalseSym\''				},				#name : #'Or class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Or class',							#isMetaSide : true						},						#name : #patternAnd,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Or class',							#isMetaSide : true						},						#name : #patternAndSym,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Or class',							#isMetaSide : true						},						#name : #patternTrue,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Or class',							#isMetaSide : true						},						#name : #patternTrueSym,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Or class',							#isMetaSide : true						},						#name : #patternFalse,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Or class',							#isMetaSide : true						},						#name : #patternFalseSym,						#parent : @12					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Or,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent an Or proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Prop,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:10:57.367733+01:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #_resolution_1erOrdre,		#newCategory : #_resolution_1erOrdre-Prop,		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Predicate',				#traitCompositionSource : '{}',				#definitionSource : 'Predicate subclass: #NotPredicate\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Prop\''			},			#name : #NotPredicate,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'NotPredicate class\r\tinstanceVariableNames: \'\''				},				#name : #'NotPredicate class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #NotPredicate,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a negative Predicate, only in ClausalForm',				#stamp : 'pm 10/9/2018 11:24'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Prop,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:11:09.306741+01:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #_resolution_1erOrdre-Prop,		#newCategory : #_resolution_1erOrdre,		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'debug debugUnification testNumber unifDone resolutionTrace\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Prop class',							#isMetaSide : true						},						#name : #debug,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Prop class',							#isMetaSide : true						},						#name : #debugUnification,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Prop class',							#isMetaSide : true						},						#name : #testNumber,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Prop class',							#isMetaSide : true						},						#name : #unifDone,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Prop class',							#isMetaSide : true						},						#name : #resolutionTrace,						#parent : @12					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @7,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- FullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- PrettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 10/9/2018 10:52'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:11:15.45082+01:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #_resolution_1erOrdre-Prop,		#newCategory : #_resolution_1erOrdre,		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Prop',				#traitCompositionSource : '{}',				#definitionSource : 'Prop subclass: #Operator\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Operator,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Operator class\r\tinstanceVariableNames: \'symb\''				},				#name : #'Operator class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Operator class',							#isMetaSide : true						},						#name : #symb,						#parent : @12					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Operator,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent an operator whith an unknown number of argument.\r\rI only factorise a method for now, but I allow possible future evolutions.',				#stamp : 'pm 10/9/2018 10:48'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:11:21.520287+01:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #_resolution_1erOrdre-Prop,		#newCategory : #_resolution_1erOrdre,		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #Or\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Or,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Or class\r\tinstanceVariableNames: \'patternAnd patternAndSym patternTrue patternTrueSym patternFalse patternFalseSym\''				},				#name : #'Or class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Or class',							#isMetaSide : true						},						#name : #patternAnd,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Or class',							#isMetaSide : true						},						#name : #patternAndSym,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Or class',							#isMetaSide : true						},						#name : #patternTrue,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Or class',							#isMetaSide : true						},						#name : #patternTrueSym,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Or class',							#isMetaSide : true						},						#name : #patternFalse,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Or class',							#isMetaSide : true						},						#name : #patternFalseSym,						#parent : @12					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Or,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent an Or proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:11:24.794422+01:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #_resolution_1erOrdre-Prop,		#newCategory : #_resolution_1erOrdre,		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Predicate',				#traitCompositionSource : '{}',				#definitionSource : 'Predicate subclass: #NotPredicate\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #NotPredicate,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'NotPredicate class\r\tinstanceVariableNames: \'\''				},				#name : #'NotPredicate class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #NotPredicate,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a negative Predicate, only in ClausalForm',				#stamp : 'pm 10/9/2018 11:24'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:11:36.943445+01:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpCategoryAddition {		#classCategoryName : '_resolution_1erOrdre-Propositions',		#affectedPackageName : #_resolution_1erOrdre	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:11:52.401167+01:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpCategoryAddition {		#classCategoryName : '_resolution_1erOrdre-Termes',		#affectedPackageName : #_resolution_1erOrdre	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:12:10.843174+01:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #_resolution_1erOrdre,		#newCategory : #_resolution_1erOrdre-Termes,		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'AbstractTerm',				#traitCompositionSource : '{}',				#definitionSource : 'AbstractTerm subclass: #UnaryTerm\r\tinstanceVariableNames: \'term\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Termes\''			},			#name : #UnaryTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #UnaryTerm,						#isMetaSide : false					},					#name : #term,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'UnaryTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'UnaryTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #UnaryTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'Abstract factorisation for LinkedTerm & ConstTerm\r\r',				#stamp : 'pm 10/28/2018 15:12'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Termes,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:12:20.205923+01:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #_resolution_1erOrdre,		#newCategory : #_resolution_1erOrdre-Termes,		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'UnaryTerm',				#traitCompositionSource : '{}',				#definitionSource : 'UnaryTerm subclass: #ConstTerm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Termes\''			},			#name : #ConstTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ConstTerm class\r\tinstanceVariableNames: \'factoryNum\''				},				#name : #'ConstTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'ConstTerm class',							#isMetaSide : true						},						#name : #factoryNum,						#parent : @12					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ConstTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Const term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable wasn\'t bound by anything OR if i\'m bound by an exists which isn\'t bound by a previous forall.\r\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with the character \'c\' as a start. To differenciate it from the rest visually.\r\r',				#stamp : 'pm 10/9/2018 10:44'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Termes,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:12:30.75298+01:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #_resolution_1erOrdre,		#newCategory : #_resolution_1erOrdre-Termes,		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'UnaryTerm',				#traitCompositionSource : '{}',				#definitionSource : 'UnaryTerm subclass: #LinkedTerm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Termes\''			},			#name : #LinkedTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'LinkedTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'LinkedTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #LinkedTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Linked Term, for a Predicate or a FuncTerm\r\rMost of my logic is factorised in UnaryTerm and AbstractTerm\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable is bound by a forall earlier in the proposition.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String\r\r',				#stamp : 'pm 10/28/2018 15:13'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Termes,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:12:36.294629+01:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #_resolution_1erOrdre,		#newCategory : #_resolution_1erOrdre-Termes,		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'AbstractTerm',				#traitCompositionSource : '{}',				#definitionSource : 'AbstractTerm subclass: #Term\r\tinstanceVariableNames: \'symb\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Termes\''			},			#name : #Term,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Term,						#isMetaSide : false					},					#name : #symb,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Term class\r\tinstanceVariableNames: \'\''				},				#name : #'Term class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Term,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Predicate\'s Term.\r\rMy type will be specialized in ConstTerm, FuncTerm, LinkedVar when the propostion my predicate\'s in goes through skolemnisation.\rI look a lot like a proposition, but i\'m conceptually different, hence the new object defined types.\r\rPublic API and Key Messages\r\r-prettyPrint -> print the term as a string.\r-new: aChar -> new instance, with a char as a term.\r ',				#stamp : 'pm 10/9/2018 10:36'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Termes,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:12:39.355796+01:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #_resolution_1erOrdre,		#newCategory : #_resolution_1erOrdre-Termes,		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'AbstractTerm',				#traitCompositionSource : '{}',				#definitionSource : 'AbstractTerm subclass: #FuncTerm\r\tinstanceVariableNames: \'symb terms\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Termes\''			},			#name : #FuncTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #symb,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #terms,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'FuncTerm class\r\tinstanceVariableNames: \'currentFuncNumber anonymousFuncSymb\''				},				#name : #'FuncTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'FuncTerm class',							#isMetaSide : true						},						#name : #currentFuncNumber,						#parent : @16					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'FuncTerm class',							#isMetaSide : true						},						#name : #anonymousFuncSymb,						#parent : @16					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #FuncTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Func term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable was bound by an Exists, with a forall binding the said Exists beforehand.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with a standart name \'f\' for the function, and a list of terms.\r\r',				#stamp : 'pm 10/9/2018 10:43'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Termes,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:12:42.038278+01:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #_resolution_1erOrdre,		#newCategory : #_resolution_1erOrdre-Termes,		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #AbstractTerm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Termes\''			},			#name : #AbstractTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'AbstractTerm class\r\tinstanceVariableNames: \'\''				},				#name : #'AbstractTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #AbstractTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'Abstract factorisation needed.\rDocumentation available in Term.',				#stamp : 'pm 10/22/2018 19:40'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Termes,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:14:08.38319+01:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpCategoryAddition {		#classCategoryName : '_resolution_1erOrdre-Data_structures',		#affectedPackageName : #_resolution_1erOrdre	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:14:19.426192+01:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #_resolution_1erOrdre-Propositions,		#newCategory : #_resolution_1erOrdre-Data_structures,		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'LinkedList',				#traitCompositionSource : '{}',				#definitionSource : 'LinkedList subclass: #LinkedListFix\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Data_structures\''			},			#name : #LinkedListFix,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'LinkedListFix class\r\tinstanceVariableNames: \'\''				},				#name : #'LinkedListFix class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #LinkedListFix,					#isMetaSide : false				},				#parent : @7,				#content : 'Only exists because the basic LinkedList implementation of at:put: is weird, and create a infinite loop if you add twice the same object.\r\rThat override fixes that.',				#stamp : 'pm 10/22/2018 10:04'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Data_structures,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:14:22.145624+01:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #_resolution_1erOrdre-Propositions,		#newCategory : #_resolution_1erOrdre-Data_structures,		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'LinkedListFix',				#traitCompositionSource : '{}',				#definitionSource : 'LinkedListFix subclass: #MinimalOrderedSet\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Data_structures\''			},			#name : #MinimalOrderedSet,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'MinimalOrderedSet class\r\tinstanceVariableNames: \'\''				},				#name : #'MinimalOrderedSet class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #MinimalOrderedSet,					#isMetaSide : false				},				#parent : @7,				#content : 'I\'m a ordered set, using a LinkedList. \r\rI\'m a linked list which only override the method \'add\' so i can be considered as a set.\rI also give access to a way to find an object via haveYouSeenThisObject.\r\rcf LinkedList.\r\rPublic API and Key Messages\r\r- add: anObject (add an object IF it\'s not in the set)\r- haveYouSeenThisObject: anObject (search for an element in the set\r- To create instances , cf LinkedList\r\rp:=MinimalOrderSet new.\rp add: 1 >> "p contains { 1 }"\r p add : 1 >> "p contains { 1 }"\r\rp haveYouSeenThisObject: 1 >> "true"\rp haveYouSeenThisObject: 2 >> "false"\r',				#stamp : 'pm 10/9/2018 10:08'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Data_structures,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:14:27.314588+01:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #_resolution_1erOrdre-Propositions,		#newCategory : #_resolution_1erOrdre-Data_structures,		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Pair\r\tinstanceVariableNames: \'left right\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Data_structures\''			},			#name : #Pair,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Pair,						#isMetaSide : false					},					#name : #left,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Pair,						#isMetaSide : false					},					#name : #right,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Pair class\r\tinstanceVariableNames: \'\''				},				#name : #'Pair class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Pair,					#isMetaSide : false				},				#parent : @7,				#content : 'Basic implementation of the Pair data-structure',				#stamp : '<historical>'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Data_structures,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:15:10.798383+01:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpCategoryAddition {		#classCategoryName : '_resolution_1erOrdre-Clausification',		#affectedPackageName : #_resolution_1erOrdre	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:15:18.112101+01:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #_resolution_1erOrdre-Propositions,		#newCategory : #_resolution_1erOrdre-Clausification,		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #ClausalForm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Clausification\''			},			#name : #ClausalForm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClausalForm class\r\tinstanceVariableNames: \'\''				},				#name : #'ClausalForm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClausalForm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions(Clauses).\r\rI inherit from a set, because i only want to have one of each clause object inside me.\r\rI\'m conceived to be instanciated by  the method "amIValid, of propositions"\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\rPublic API and Key Messages\r\r- resolutionMethod : I\'m using the resolutionMethod on myself\r\rI can be created empty or with a Prop object as input.\r\rClausalForm new: aFullProp. \r',				#stamp : 'pm 10/28/2018 15:21'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Clausification,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:15:21.258385+01:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #_resolution_1erOrdre-Propositions,		#newCategory : #_resolution_1erOrdre-Clausification,		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #Clause\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Clausification\''			},			#name : #Clause,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Clause class\r\tinstanceVariableNames: \'\''				},				#name : #'Clause class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Clause,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a clause, which is a set of predicate (positive or negative)  related by a variadic Or operator.\r\rBuild on top of a Set, to avoid redundancy.\r\rI should be instanciated by ClausalForm only.\r',				#stamp : 'pm 10/28/2018 15:21'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Clausification,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:15:36.646469+01:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #_resolution_1erOrdre-Propositions,		#newCategory : #_resolution_1erOrdre-Clausification,		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #Resolvante\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Clausification\''			},			#name : #Resolvante,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Resolvante class\r\tinstanceVariableNames: \'\''				},				#name : #'Resolvante class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Resolvante,					#isMetaSide : false				},				#parent : @7,				#content : 'Utility class for ClausalForm::ResolutionMethod.',				#stamp : 'pm 10/27/2018 22:04'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Clausification,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:15:41.278235+01:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpBehaviorCategoryChange {		#oldCategory : #_resolution_1erOrdre-Propositions,		#newCategory : #_resolution_1erOrdre-Clausification,		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Unifier\r\tinstanceVariableNames: \'setOfPairs hasFailed initialPair unifiedPair\'\r\tclassVariableNames: \'UnifiedTerm\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Clausification\''			},			#name : #Unifier,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #setOfPairs,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #hasFailed,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #initialPair,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #unifiedPair,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Unifier class\r\tinstanceVariableNames: \'\''				},				#name : #'Unifier class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Unifier,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent an Unifier object.\r\rMy purpose is to unify two predicate.\r\rPublic API and Key Messages\r\r-Unifier new: Predicate2:\r- UnifyThis\r\rp1:=Predicate new:(..)\rp2:=Predicate new:(...)\rUnifier new: p1 Predicate2:p2\r \rInstance Variables\r\thasFailed:\tBoolean to see if the unification failed.\r',				#stamp : 'pm 10/27/2018 22:13'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #UnifiedTerm,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Clausification,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:24:10.970144+01:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpCategoryAddition {		#classCategoryName : '_resolution_1erOrdre-SkolemnTest',		#affectedPackageName : #_resolution_1erOrdre	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T18:25:00.611598+01:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpCategoryAddition {		#classCategoryName : '_resolution_1erOrdre-General_test',		#affectedPackageName : #_resolution_1erOrdre	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T19:45:14.384666+01:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #Skolemn_test\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #Skolemn_test,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Skolemn_test class\r\tinstanceVariableNames: \'\''				},				#name : #'Skolemn_test class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Skolemn_test,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T19:45:28.456014+01:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpProtocolAddition {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #Skolemn_test\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #Skolemn_test,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Skolemn_test class\r\tinstanceVariableNames: \'\''				},				#name : #'Skolemn_test class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Skolemn_test,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #basic	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T20:08:46.702452+01:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #BasicSkolemnTest1,			#protocol : #basic,			#sourceCode : 'BasicSkolemnTest1\r\t| terms p|\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r',			#stamp : 'pm 11/4/2018 20:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-04T20:59:54.206358+01:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #BasicSkolemnTest1,			#protocol : #basic,			#sourceCode : 'BasicSkolemnTest1\r\t| terms p|\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r',			#stamp : 'pm 11/4/2018 20:08',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #BasicSkolemnTest1,			#protocol : #basic,			#sourceCode : 'BasicSkolemnTest1\r\t| terms p res expected|\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\t"expected:="\r\tself assert:[].',			#stamp : 'pm 11/4/2018 20:59',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T08:48:11.86314+01:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #BasicSkolemnTest1,			#protocol : #basic,			#sourceCode : 'BasicSkolemnTest1\r\t| terms p res expected|\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\t"expected:="\r\tself assert:[].',			#stamp : 'pm 11/4/2018 20:59',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #BasicSkolemnTest1,			#protocol : #basic,			#sourceCode : 'BasicSkolemnTest1\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new.\r\tterms2 add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new: \'f\' Variable: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\')).\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t^self assert:[res=expected].',			#stamp : 'pm 11/5/2018 08:48',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T08:50:19.588439+01:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemnTest1,			#protocol : #basic,			#sourceCode : 'testBasicSkolemnTest1\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new.\r\tterms2 add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new: \'f\' Variable: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\')).\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t^self assert:[res=expected].',			#stamp : 'pm 11/5/2018 08:50',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T08:50:29.245097+01:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemnTest1,			#protocol : #basic,			#sourceCode : 'testBasicSkolemnTest1\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new.\r\tterms2 add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new: \'f\' Variable: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\')).\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t^self assert:[res=expected].',			#stamp : 'pm 11/5/2018 08:50',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemnTest1,			#protocol : #basic,			#sourceCode : 'testBasicSkolemnTest1\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new.\r\tterms2 add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new: \'f\' Variable: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\')).\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t^self assert:res=expected.',			#stamp : 'pm 11/5/2018 08:50',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T08:50:36.726986+01:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #BasicSkolemnTest1,			#protocol : #basic,			#sourceCode : 'BasicSkolemnTest1\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new.\r\tterms2 add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new: \'f\' Variable: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\')).\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t^self assert:[res=expected].',			#stamp : 'pm 11/5/2018 08:48',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T08:51:09.93176+01:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemnTest1,			#protocol : #basic,			#sourceCode : 'testBasicSkolemnTest1\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new.\r\tterms2 add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new: \'f\' Variable: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\')).\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t^self assert:res=expected.',			#stamp : 'pm 11/5/2018 08:50',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemnTest1,			#protocol : #basic,			#sourceCode : 'testBasicSkolemnTest1\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new.\r\tterms2 add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new: \'f\' Variable: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\')).\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\tTranscript show:res;cr.\r\tTranscript show:expected;cr.\r\t^self assert:res=expected.',			#stamp : 'pm 11/5/2018 08:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T08:52:21.738635+01:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'=',			#protocol : #'as yet unclassified',			#sourceCode : '=prop2\r\t^SubclassResponsibility ',			#stamp : 'pm 11/5/2018 08:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T08:52:21.893537+01:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'=',			#protocol : #'as yet unclassified',			#sourceCode : '=prop2\r\t^SubclassResponsibility ',			#stamp : 'pm 11/5/2018 08:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=prop2\r\t^SubclassResponsibility ',			#stamp : 'pm 11/5/2018 08:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T08:53:07.359811+01:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #'=',			#protocol : #'as yet unclassified',			#sourceCode : '=prop2\r\t',			#stamp : 'pm 11/5/2018 08:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T08:53:07.439186+01:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #'=',			#protocol : #'as yet unclassified',			#sourceCode : '=prop2\r\t',			#stamp : 'pm 11/5/2018 08:53',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=prop2\r\t',			#stamp : 'pm 11/5/2018 08:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T08:53:12.935904+01:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=prop2\r\t',			#stamp : 'pm 11/5/2018 08:53',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=prop2\r\t^self=prop2\t',			#stamp : 'pm 11/5/2018 08:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T08:55:57.146302+01:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'=',			#protocol : #'as yet unclassified',			#sourceCode : '=prop2\r\t^self getSymb = prop2 getSymb and:[self left=prop2 left and:[self right=prop2 right.]].',			#stamp : 'pm 11/5/2018 08:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T08:55:57.228648+01:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'=',			#protocol : #'as yet unclassified',			#sourceCode : '=prop2\r\t^self getSymb = prop2 getSymb and:[self left=prop2 left and:[self right=prop2 right.]].',			#stamp : 'pm 11/5/2018 08:55',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=prop2\r\t^self getSymb = prop2 getSymb and:[self left=prop2 left and:[self right=prop2 right.]].',			#stamp : 'pm 11/5/2018 08:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T08:56:20.113076+01:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #'=',			#protocol : #'as yet unclassified',			#sourceCode : '=prop2\r\t^self getSymb = prop2 getSymb and:[self operand=prop2 operand].',			#stamp : 'pm 11/5/2018 08:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T08:56:20.196125+01:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #'=',			#protocol : #'as yet unclassified',			#sourceCode : '=prop2\r\t^self getSymb = prop2 getSymb and:[self operand=prop2 operand].',			#stamp : 'pm 11/5/2018 08:56',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=prop2\r\t^self getSymb = prop2 getSymb and:[self operand=prop2 operand].',			#stamp : 'pm 11/5/2018 08:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T08:58:00.575317+01:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'=',			#protocol : #'as yet unclassified',			#sourceCode : '=prop2\r\t^self getSymb = prop2 getSymb and:[self var=prop2 var and:[self operand=prop2 operand]].',			#stamp : 'pm 11/5/2018 08:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T08:58:00.717981+01:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'=',			#protocol : #'as yet unclassified',			#sourceCode : '=prop2\r\t^self getSymb = prop2 getSymb and:[self var=prop2 var and:[self operand=prop2 operand]].',			#stamp : 'pm 11/5/2018 08:58',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=prop2\r\t^self getSymb = prop2 getSymb and:[self var=prop2 var and:[self operand=prop2 operand]].',			#stamp : 'pm 11/5/2018 08:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:01:35.594236+01:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'equalForTesting:',			#protocol : #comparing,			#sourceCode : 'equalForTesting:anotherPredicate\r\t"same as =, but doesn\'t care about anonymous const/func term. for testing purposes."\r\t| res |\r\tres:=anotherPredicate isKindOf: self class."checking the input"\r\tres:=res and:[(self isSameSymb: anotherPredicate)]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTermsForTesting: anotherPredicate).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 11/5/2018 09:01',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:02:08.183697+01:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ],		#time : DateAndTime [ '2018-11-05T09:02:08.191839+01:00' ],		#trigger : @3	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameTerms:',			#protocol : #comparing,			#sourceCode : 'isSameTerms: AnotherPredicate\r\t^(self terms) = (AnotherPredicate terms).',			#stamp : 'pm 10/17/2018 12:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameTerms:',			#protocol : #comparing,			#sourceCode : 'isSameTerms: anotherPredicate\r\t^(self terms) = (anotherPredicate terms).',			#stamp : 'pm 11/5/2018 09:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:05:39.383515+01:00' ],		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameTermsForTesting: anotherPredicate\r\t\r\t1 to: (anotherPredicate size) do:[:i|\r\t\t(self at:i isSameForTesting: (anotherPredicate at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 11/5/2018 09:05',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:05:52.319227+01:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameTermsForTesting: anotherPredicate\r\t\r\t1 to: (anotherPredicate size) do:[:i|\r\t\t(self at:i isSameForTesting: (anotherPredicate at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 11/5/2018 09:05',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameTermsForTesting: anotherPredicate\r\t\r\t1 to: (anotherPredicate size) do:[:i|\r\t\t((self at:i) isSameForTesting: (anotherPredicate at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 11/5/2018 09:05',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:06:14.662018+01:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameTermsForTesting: anotherPredicate\r\t\r\t1 to: (anotherPredicate size) do:[:i|\r\t\t((self at:i) isSameForTesting: (anotherPredicate at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 11/5/2018 09:05',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameTermsForTesting: anotherPredicate\r\t\r\tself timesRepeat:[:i|\r\t\t((self at:i) isSameForTesting: (anotherPredicate at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 11/5/2018 09:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:07:38.971229+01:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #'as yet unclassified',			#sourceCode : 'isSameTermsForTesting:anotherFuncTerm\r\t\r\tself timesRepeat:[:i|\r\t\t((self at:i) isSameForTesting: (anotherFuncTerm at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 11/5/2018 09:07',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:07:39.051413+01:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #'as yet unclassified',			#sourceCode : 'isSameTermsForTesting:anotherFuncTerm\r\t\r\tself timesRepeat:[:i|\r\t\t((self at:i) isSameForTesting: (anotherFuncTerm at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 11/5/2018 09:07',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #testing,			#sourceCode : 'isSameTermsForTesting:anotherFuncTerm\r\t\r\tself timesRepeat:[:i|\r\t\t((self at:i) isSameForTesting: (anotherFuncTerm at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 11/5/2018 09:07',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:08:44.293124+01:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting: anotherFuncTerm\r\r\t"Comparaison Operator."\r\t| res |\r\tself assert:(anotherFuncTerm class=self class)."checking the input"\r\tres:=self isSameSymb: anotherFuncTerm."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherFuncTerm]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherFuncTerm).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 11/5/2018 09:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:09:00.170495+01:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherFuncTerm\r\t"Comparaison Operator."\r\t| res |\r\tself assert:(anotherFuncTerm isKindOf: FuncTerm)."checking the input"\r\tres:=self isSameSymb: anotherFuncTerm."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherFuncTerm]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherFuncTerm).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 10/28/2018 14:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherFuncTerm\r\t"Comparaison Operator."\r\t| res |\r\tself assert:(self class=anotherFuncTerm class)."checking the input"\r\tres:=self isSameSymb: anotherFuncTerm."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherFuncTerm]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherFuncTerm).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 11/5/2018 09:09',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:11:00.977527+01:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #'as yet unclassified',			#sourceCode : 'isSameForTesting: anotherTerm\r\tself assert: (self class)=(anotherTerm class).\r\t^self term = anotherTerm term.',			#stamp : 'pm 11/5/2018 09:11',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:11:01.056932+01:00' ],		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #'as yet unclassified',			#sourceCode : 'isSameForTesting: anotherTerm\r\tself assert: (self class)=(anotherTerm class).\r\t^self term = anotherTerm term.',			#stamp : 'pm 11/5/2018 09:11',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #testing,			#sourceCode : 'isSameForTesting: anotherTerm\r\tself assert: (self class)=(anotherTerm class).\r\t^self term = anotherTerm term.',			#stamp : 'pm 11/5/2018 09:11',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:11:07.495567+01:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #'as yet unclassified',			#sourceCode : 'isSameForTesting: anotherTerm\r\tself assert: (self class)=(anotherTerm class).\r\t^self term = anotherTerm term.',			#stamp : 'pm 11/5/2018 09:11',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:11:07.58685+01:00' ],		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #'as yet unclassified',			#sourceCode : 'isSameForTesting: anotherTerm\r\tself assert: (self class)=(anotherTerm class).\r\t^self term = anotherTerm term.',			#stamp : 'pm 11/5/2018 09:11',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #testing,			#sourceCode : 'isSameForTesting: anotherTerm\r\tself assert: (self class)=(anotherTerm class).\r\t^self term = anotherTerm term.',			#stamp : 'pm 11/5/2018 09:11',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:12:05.87918+01:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'AbstractTerm',				#traitCompositionSource : '{}',				#definitionSource : 'AbstractTerm subclass: #FuncTerm\r\tinstanceVariableNames: \'symb terms\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Termes\''			},			#name : #FuncTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #symb,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #terms,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'FuncTerm class\r\tinstanceVariableNames: \'currentFuncNumber anonymousFuncSymb\''				},				#name : #'FuncTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'FuncTerm class',							#isMetaSide : true						},						#name : #currentFuncNumber,						#parent : @16					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'FuncTerm class',							#isMetaSide : true						},						#name : #anonymousFuncSymb,						#parent : @16					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #FuncTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Func term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable was bound by an Exists, with a forall binding the said Exists beforehand.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with a standart name \'f\' for the function, and a list of terms.\r\r',				#stamp : 'pm 10/9/2018 10:43'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Termes,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'AbstractTerm',				#traitCompositionSource : '{}',				#definitionSource : 'AbstractTerm subclass: #FuncTerm\r\tinstanceVariableNames: \'symb terms anonymous\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Termes\''			},			#name : #FuncTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #symb,					#parent : @29				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #terms,					#parent : @29				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #FuncTerm,						#isMetaSide : false					},					#name : #anonymous,					#parent : @29				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'FuncTerm class\r\tinstanceVariableNames: \'currentFuncNumber anonymousFuncSymb\''				},				#name : #'FuncTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'FuncTerm class',							#isMetaSide : true						},						#name : #currentFuncNumber,						#parent : @40					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'FuncTerm class',							#isMetaSide : true						},						#name : #anonymousFuncSymb,						#parent : @40					}				],				#baseClass : @29			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #FuncTerm,					#isMetaSide : false				},				#parent : @29,				#content : 'I represent a Func term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable was bound by an Exists, with a forall binding the said Exists beforehand.\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with a standart name \'f\' for the function, and a list of terms.\r\r',				#stamp : 'pm 10/9/2018 10:43'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Termes,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:12:13.905708+01:00' ],		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #anonymous,			#protocol : #'as yet unclassified',			#sourceCode : 'anonymous\r\t^anonymous',			#stamp : 'pm 11/5/2018 09:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:12:13.990509+01:00' ],		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #anonymous,			#protocol : #'as yet unclassified',			#sourceCode : 'anonymous\r\t^anonymous',			#stamp : 'pm 11/5/2018 09:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #anonymous,			#protocol : #accessing,			#sourceCode : 'anonymous\r\t^anonymous',			#stamp : 'pm 11/5/2018 09:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:12:46.242332+01:00' ],		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'anonymous:',			#protocol : #accessing,			#sourceCode : 'anonymous:polarity\r\tanonymous:=polarity',			#stamp : 'pm 11/5/2018 09:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:13:29.626127+01:00' ],		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'newFunc:',			#protocol : #'instance creation',			#sourceCode : 'newFunc: variable\r\t"creation of a new anonymous funcTerm, with a variable"\r\t^self basicNew initialize: (self getNewFuncName) Variable:variable.',			#stamp : 'pm 10/28/2018 14:47',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'newFunc:',			#protocol : #'instance creation',			#sourceCode : 'newFunc: variable\r\t"creation of a new anonymous funcTerm, with a variable"\r\t^self basicNew initialize: (self getNewFuncName) Variable:variable\r\t\t\t\t\t\t;anonymous:true\r\t\t\t\t\t\t;yourself.',			#stamp : 'pm 11/5/2018 09:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:13:40.844066+01:00' ],		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'newFuncWithVars:',			#protocol : #'instance creation',			#sourceCode : 'newFuncWithVars: varList\r\t"creation of a new anonymous variadic funcTerm"\r\t^self basicNew initialize: (self getNewFuncName) Variables:varList.',			#stamp : 'pm 10/28/2018 14:47',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'newFuncWithVars:',			#protocol : #'instance creation',			#sourceCode : 'newFuncWithVars: varList\r\t"creation of a new anonymous variadic funcTerm"\r\t^self basicNew initialize: (self getNewFuncName) Variables:varList\r\t\t\t\t\t\t;anonymous:true\r\t\t\t\t\t\t;yourself.',			#stamp : 'pm 11/5/2018 09:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:13:54.692284+01:00' ],		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'new:Variables:',			#protocol : #'instance creation',			#sourceCode : 'new: symbo Variables: setOfLinkedVar\r\t"creation of a new named variadic funcTerm"\r\t^self basicNew initialize:symbo Variables: setOfLinkedVar.',			#stamp : 'pm 10/28/2018 14:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'new:Variables:',			#protocol : #'instance creation',			#sourceCode : 'new: symbo Variables: setOfLinkedVar\r\t"creation of a new named variadic funcTerm"\r\t^self basicNew initialize:symbo Variables: setOfLinkedVar\r\t\t\t\t\t\t;anonymous:false\r\t\t\t\t\t\t;yourself.',			#stamp : 'pm 11/5/2018 09:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:14:06.80526+01:00' ],		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'new:Variable:',			#protocol : #'instance creation',			#sourceCode : 'new: symbo Variable: aVar\r\t"creation of a new named funcTerm, with a term \'f(x)\'"\r\t^self basicNew initialize:symbo Variable: aVar.',			#stamp : 'pm 10/28/2018 14:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'new:Variable:',			#protocol : #'instance creation',			#sourceCode : 'new: symbo Variable: aVar\r\t"creation of a new named funcTerm, with a term \'f(x)\'"\r\t^self basicNew initialize:symbo Variable: aVar\r\t\t\t\t\t\t;anonymous:false\r\t\t\t\t\t\t;yourself..',			#stamp : 'pm 11/5/2018 09:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:14:36.730336+01:00' ],		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"creation of a new anonymous funcTerm"\r\t^(self basicNew) initialize: (self getNewFuncName).',			#stamp : 'pm 10/28/2018 14:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"creation of a new anonymous funcTerm"\r\t^(self basicNew) initialize: (self getNewFuncName)\t\r\t\t\t\t\t\t;anonymous:true\r\t\t\t\t\t\t;yourself.',			#stamp : 'pm 11/5/2018 09:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:14:47.032665+01:00' ],		#prior : OmReference [ '72' ],		#self : OmReference [ '73' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"creation of a new anonymous funcTerm"\r\t^(self basicNew) initialize: (self getNewFuncName)\t\r\t\t\t\t\t\t;anonymous:true\r\t\t\t\t\t\t;yourself.',			#stamp : 'pm 11/5/2018 09:14',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"creation of a new empty, anonymous funcTerm"\r\t^(self basicNew) initialize: (self getNewFuncName)\t\r\t\t\t\t\t\t;anonymous:true\r\t\t\t\t\t\t;yourself.',			#stamp : 'pm 11/5/2018 09:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:15:04.015202+01:00' ],		#prior : OmReference [ '73' ],		#self : OmReference [ '74' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'new:Variable:',			#protocol : #'instance creation',			#sourceCode : 'new: symbo Variable: aVar\r\t"creation of a new named funcTerm, with a term \'f(x)\'"\r\t^self basicNew initialize:symbo Variable: aVar\r\t\t\t\t\t\t;anonymous:false\r\t\t\t\t\t\t;yourself..',			#stamp : 'pm 11/5/2018 09:14',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'new:Variable:',			#protocol : #'instance creation',			#sourceCode : 'new: symbo Variable: aVar\r\t"creation of a new named funcTerm, with a term \'f(x)\'"\r\t^self basicNew initialize:symbo Variable: aVar\r\t\t\t\t\t\t;anonymous:false\r\t\t\t\t\t\t;yourself.',			#stamp : 'pm 11/5/2018 09:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:15:18.375158+01:00' ],		#prior : OmReference [ '74' ],		#self : OmReference [ '75' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: symbo\r\t"creation of a new named empty funcTerm "\r\t^self basicNew initialize:symbo.',			#stamp : 'pm 10/28/2018 14:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: symbo\r\t"creation of a new named empty funcTerm "\r\t^self basicNew initialize:symbo\r\t\t\t\t\t\t;anonymous:false\r\t\t\t\t\t\t;yourself.',			#stamp : 'pm 11/5/2018 09:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:18:33.578682+01:00' ],		#prior : OmReference [ '75' ],		#self : OmReference [ '76' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameSymb:',			#protocol : #comparing,			#sourceCode : 'isSameSymb:anotherFuncTerm\r\t"Do both funcTerm have the same symbol"\r\t^(self getSymb)=(anotherFuncTerm getSymb).',			#stamp : 'pm 10/28/2018 14:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameSymb:',			#protocol : #comparing,			#sourceCode : 'isSameSymb:anotherFuncTerm\r\t"Do both funcTerm have the same symbol"\r\t^self anonymous \r\t\t\tifTrue:[true]\r\t\t\tifFalse:[\r\t\t\t\t(self getSymb)=(anotherFuncTerm getSymb).\r\t\t\t\t].',			#stamp : 'pm 11/5/2018 09:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:19:06.186838+01:00' ],		#prior : OmReference [ '76' ],		#self : OmReference [ '77' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameSymbForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameSymbForTesting:anotherFuncTerm\r\t"Do both funcTerm have the same symbol"\r\t^self anonymous \r\t\t\tifTrue:[anotherFuncTerm anonymous]\r\t\t\tifFalse:[\r\t\t\t\t(self getSymb)=(anotherFuncTerm getSymb).\r\t\t\t\t].',			#stamp : 'pm 11/5/2018 09:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:19:23.717591+01:00' ],		#prior : OmReference [ '77' ],		#self : OmReference [ '78' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameSymb:',			#protocol : #comparing,			#sourceCode : 'isSameSymb:anotherFuncTerm\r\t"Do both funcTerm have the same symbol"\r\t^self anonymous \r\t\t\tifTrue:[true]\r\t\t\tifFalse:[\r\t\t\t\t(self getSymb)=(anotherFuncTerm getSymb).\r\t\t\t\t].',			#stamp : 'pm 11/5/2018 09:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameSymb:',			#protocol : #comparing,			#sourceCode : 'isSameSymb:anotherFuncTerm\r\t"Do both funcTerm have the same symbol"\r\t^(self getSymb)=(anotherFuncTerm getSymb).',			#stamp : 'pm 11/5/2018 09:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:19:47.426652+01:00' ],		#prior : OmReference [ '78' ],		#self : OmReference [ '79' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'UnaryTerm',				#traitCompositionSource : '{}',				#definitionSource : 'UnaryTerm subclass: #ConstTerm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Termes\''			},			#name : #ConstTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ConstTerm class\r\tinstanceVariableNames: \'factoryNum\''				},				#name : #'ConstTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'ConstTerm class',							#isMetaSide : true						},						#name : #factoryNum,						#parent : @12					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ConstTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Const term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable wasn\'t bound by anything OR if i\'m bound by an exists which isn\'t bound by a previous forall.\r\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with the character \'c\' as a start. To differenciate it from the rest visually.\r\r',				#stamp : 'pm 10/9/2018 10:44'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Termes,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'UnaryTerm',				#traitCompositionSource : '{}',				#definitionSource : 'UnaryTerm subclass: #ConstTerm\r\tinstanceVariableNames: \'anonymous\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Termes\''			},			#name : #ConstTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ConstTerm,						#isMetaSide : false					},					#name : #anonymous,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ConstTerm class\r\tinstanceVariableNames: \'factoryNum\''				},				#name : #'ConstTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'ConstTerm class',							#isMetaSide : true						},						#name : #factoryNum,						#parent : @30					}				],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ConstTerm,					#isMetaSide : false				},				#parent : @23,				#content : 'I represent a Const term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable wasn\'t bound by anything OR if i\'m bound by an exists which isn\'t bound by a previous forall.\r\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with the character \'c\' as a start. To differenciate it from the rest visually.\r\r',				#stamp : 'pm 10/9/2018 10:44'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Termes,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:19:56.644495+01:00' ],		#prior : OmReference [ '79' ],		#self : OmReference [ '80' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #anonymous,			#protocol : #'as yet unclassified',			#sourceCode : 'anonymous\r\tanonymous',			#stamp : 'pm 11/5/2018 09:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:19:56.724421+01:00' ],		#prior : OmReference [ '80' ],		#self : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #anonymous,			#protocol : #'as yet unclassified',			#sourceCode : 'anonymous\r\tanonymous',			#stamp : 'pm 11/5/2018 09:19',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #anonymous,			#protocol : #accessing,			#sourceCode : 'anonymous\r\tanonymous',			#stamp : 'pm 11/5/2018 09:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:20:04.681261+01:00' ],		#prior : OmReference [ '81' ],		#self : OmReference [ '82' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #'anonymous:',			#protocol : #accessing,			#sourceCode : 'anonymous:aBool\r\tanonymous:=aBool',			#stamp : 'pm 11/5/2018 09:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:20:08.475877+01:00' ],		#prior : OmReference [ '82' ],		#self : OmReference [ '83' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #anonymous,			#protocol : #accessing,			#sourceCode : 'anonymous\r\tanonymous',			#stamp : 'pm 11/5/2018 09:19',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #anonymous,			#protocol : #accessing,			#sourceCode : 'anonymous\r\t^anonymous',			#stamp : 'pm 11/5/2018 09:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:20:22.639445+01:00' ],		#prior : OmReference [ '83' ],		#self : OmReference [ '84' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'anonymous:',			#protocol : #accessing,			#sourceCode : 'anonymous:polarity\r\tanonymous:=polarity',			#stamp : 'pm 11/5/2018 09:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'anonymous:',			#protocol : #accessing,			#sourceCode : 'anonymous:aBool\r\tanonymous:=aBool',			#stamp : 'pm 11/5/2018 09:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:20:49.379148+01:00' ],		#prior : OmReference [ '84' ],		#self : OmReference [ '85' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #testing,			#sourceCode : 'isSameForTesting: anotherTerm\r\tself assert: (self class)=(anotherTerm class).\r\t^self term = anotherTerm term.',			#stamp : 'pm 11/5/2018 09:11',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #testing,			#sourceCode : 'isSameForTesting: anotherTerm\r\t\r\t^self term = anotherTerm term.',			#stamp : 'pm 11/5/2018 09:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:21:11.116407+01:00' ],		#prior : OmReference [ '85' ],		#self : OmReference [ '86' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #new,			#protocol : #initialization,			#sourceCode : 'new \r\t"new anonymous const term"\r\t^self basicNew initialize.',			#stamp : 'pm 10/28/2018 15:09',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #new,			#protocol : #initialization,			#sourceCode : 'new \r\t"new anonymous const term"\r\t^self basicNew initialize;\r\t\t\tanonymous:true;\r\t\t\tyourself.',			#stamp : 'pm 11/5/2018 09:21',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:21:31.348139+01:00' ],		#prior : OmReference [ '86' ],		#self : OmReference [ '87' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #initialization,			#sourceCode : 'new:Const_Value\r\t"new named const Object"\r\t^self basicNew initialize:Const_Value.',			#stamp : 'pm 10/28/2018 15:09',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #initialization,			#sourceCode : 'new:Const_Value\r\t"new named const Object"\r\t^self basicNew initialize:Const_Value;\r\t\t\tanonymous:false;\r\t\t\tyourself.',			#stamp : 'pm 11/5/2018 09:21',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:22:01.553738+01:00' ],		#prior : OmReference [ '87' ],		#self : OmReference [ '88' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'UnaryTerm',				#traitCompositionSource : '{}',				#definitionSource : 'UnaryTerm subclass: #ConstTerm\r\tinstanceVariableNames: \'anonymous\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Termes\''			},			#name : #ConstTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ConstTerm,						#isMetaSide : false					},					#name : #anonymous,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ConstTerm class\r\tinstanceVariableNames: \'factoryNum\''				},				#name : #'ConstTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'ConstTerm class',							#isMetaSide : true						},						#name : #factoryNum,						#parent : @14					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ConstTerm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a Const term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable wasn\'t bound by anything OR if i\'m bound by an exists which isn\'t bound by a previous forall.\r\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with the character \'c\' as a start. To differenciate it from the rest visually.\r\r',				#stamp : 'pm 10/9/2018 10:44'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Termes,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'UnaryTerm',				#traitCompositionSource : '{}',				#definitionSource : 'UnaryTerm subclass: #ConstTerm\r\tinstanceVariableNames: \'anonymous\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Termes\''			},			#name : #ConstTerm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ConstTerm,						#isMetaSide : false					},					#name : #anonymous,					#parent : @25				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ConstTerm class\r\tinstanceVariableNames: \'factoryVar factoryNum\''				},				#name : #'ConstTerm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'ConstTerm class',							#isMetaSide : true						},						#name : #factoryVar,						#parent : @32					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'ConstTerm class',							#isMetaSide : true						},						#name : #factoryNum,						#parent : @32					}				],				#baseClass : @25			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ConstTerm,					#isMetaSide : false				},				#parent : @25,				#content : 'I represent a Const term, for a predicate.\r\rI should only be instanciated by the skolemnisation.\rI exists if my variable wasn\'t bound by anything OR if i\'m bound by an exists which isn\'t bound by a previous forall.\r\r\rPublic API and Key Messages\r-prettyPrint >> return the term as a String, with the character \'c\' as a start. To differenciate it from the rest visually.\r\r',				#stamp : 'pm 10/9/2018 10:44'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Termes,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:22:08.149495+01:00' ],		#prior : OmReference [ '88' ],		#self : OmReference [ '89' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #nextConst,			#protocol : #initialization,			#sourceCode : 'nextConst\r\t"Used as a anonymous const term name factory"\r\t^\'c\',(self getNum).',			#stamp : 'pm 10/28/2018 15:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #nextConst,			#protocol : #initialization,			#sourceCode : 'nextConst\r\t"Used as a anonymous const term name factory"\r\t^factoryVar,(self getNum).',			#stamp : 'pm 11/5/2018 09:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:22:23.737427+01:00' ],		#prior : OmReference [ '89' ],		#self : OmReference [ '90' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"initlize of the class, which is only the number of the first anonymous const term"\r\tfactoryNum:=0.',			#stamp : 'pm 10/28/2018 15:08',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"initlize of the class, which is only the number of the first anonymous const term"\r\tfactoryVar:=\'c\'.\r\tfactoryNum:=0.',			#stamp : 'pm 11/5/2018 09:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:23:03.853148+01:00' ],		#prior : OmReference [ '90' ],		#self : OmReference [ '91' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"initlize of the class, which is only the number of the first anonymous const term"\r\tfactoryVar:=\'c\'.\r\tfactoryNum:=0.',			#stamp : 'pm 11/5/2018 09:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"initlize of the class, which is the chosen name for an anonymous const and the number of the first anonymous const term"\r\tfactoryVar:=\'c\'.\r\tfactoryNum:=0.',			#stamp : 'pm 11/5/2018 09:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:23:06.599493+01:00' ],		#prior : OmReference [ '91' ],		#self : OmReference [ '92' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"initlize of the class, which is the chosen name for an anonymous const and the number of the first anonymous const term"\r\tfactoryVar:=\'c\'.\r\tfactoryNum:=0.',			#stamp : 'pm 11/5/2018 09:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"initlize of the class, which is the chosen name for an anonymous const terms and the number of the first anonymous const term"\r\tfactoryVar:=\'c\'.\r\tfactoryNum:=0.',			#stamp : 'pm 11/5/2018 09:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:24:02.885086+01:00' ],		#prior : OmReference [ '92' ],		#self : OmReference [ '93' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemnTest1,			#protocol : #basic,			#sourceCode : 'testBasicSkolemnTest1\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new.\r\tterms2 add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new: \'f\' Variable: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\')).\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\tTranscript show:res;cr.\r\tTranscript show:expected;cr.\r\t^self assert:res=expected.',			#stamp : 'pm 11/5/2018 08:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemnTest1,			#protocol : #basic,			#sourceCode : 'testBasicSkolemnTest1\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new.\r\tterms2 add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\')).\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\tTranscript show:res;cr.\r\tTranscript show:expected;cr.\r\t^self assert:res=expected.',			#stamp : 'pm 11/5/2018 09:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:24:28.256161+01:00' ],		#prior : OmReference [ '93' ],		#self : OmReference [ '94' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #testing,			#sourceCode : 'isSameForTesting: anotherTerm\r\t\r\t^self term = anotherTerm term.',			#stamp : 'pm 11/5/2018 09:20',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #testing,			#sourceCode : 'isSameForTesting: anotherTerm\r\t\r\t^self anonymous \r\t\tifTrue:[\r\t\t\tanotherTerm anonymous\r\t\t\t]\r\t\tifFalse:[\r\t\t\tself term = anotherTerm term.\r\t\t\t].',			#stamp : 'pm 11/5/2018 09:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:24:53.207953+01:00' ],		#prior : OmReference [ '94' ],		#self : OmReference [ '95' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameTermsForTesting: anotherPredicate\r\t\r\tself timesRepeat:[:i|\r\t\t((self at:i) isSameForTesting: (anotherPredicate at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 11/5/2018 09:06',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameTermsForTesting: anotherPredicate\r\t\r\tterms timesRepeat:[:i|\r\t\t((self at:i) isSameForTesting: (anotherPredicate at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 11/5/2018 09:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:25:34.392819+01:00' ],		#prior : OmReference [ '95' ],		#self : OmReference [ '96' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting:prop2\r\t^self getSymb = prop2 getSymb and:[(self left) isSameForTesting: (prop2 left) and:[self right=prop2 right.]].',			#stamp : 'pm 11/5/2018 09:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:25:39.226746+01:00' ],		#prior : OmReference [ '96' ],		#self : OmReference [ '97' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=prop2\r\t^self getSymb = prop2 getSymb and:[self left=prop2 left and:[self right=prop2 right.]].',			#stamp : 'pm 11/5/2018 08:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:25:55.387258+01:00' ],		#prior : OmReference [ '97' ],		#self : OmReference [ '98' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting:prop2\r\t^self getSymb = prop2 getSymb and:[(self left) isSameForTesting: (prop2 left) and:[self right=prop2 right.]].',			#stamp : 'pm 11/5/2018 09:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting:prop2\r\t^self getSymb = prop2 getSymb and:[(self left) isSameForTesting: (prop2 left) and:[(self right)isSameForTesting: (prop2 right).]].',			#stamp : 'pm 11/5/2018 09:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:26:19.613045+01:00' ],		#prior : OmReference [ '98' ],		#self : OmReference [ '99' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting:prop2\r\t^self getSymb = prop2 getSymb and:[(self left) isSameForTesting: (prop2 left) and:[(self right)isSameForTesting: (prop2 right).]].',			#stamp : 'pm 11/5/2018 09:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting:prop2\r\t^(self class = prop2 class) and:[(self left) isSameForTesting: (prop2 left) and:[(self right)isSameForTesting: (prop2 right).]].',			#stamp : 'pm 11/5/2018 09:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:26:34.307917+01:00' ],		#prior : OmReference [ '99' ],		#self : OmReference [ '100' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemnTest1,			#protocol : #basic,			#sourceCode : 'testBasicSkolemnTest1\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new.\r\tterms2 add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\')).\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\tTranscript show:res;cr.\r\tTranscript show:expected;cr.\r\t^self assert:res=expected.',			#stamp : 'pm 11/5/2018 09:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemnTest1,			#protocol : #basic,			#sourceCode : 'testBasicSkolemnTest1\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new.\r\tterms2 add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\')).\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\tTranscript show:res;cr.\r\tTranscript show:expected;cr.\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 09:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:26:46.205584+01:00' ],		#prior : OmReference [ '100' ],		#self : OmReference [ '101' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting:prop2\r\t^(self class = prop2 class) and:[(self left) isSameForTesting: (prop2 left) and:[(self right)isSameForTesting: (prop2 right).]].',			#stamp : 'pm 11/5/2018 09:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting:prop2\r\t^(self class = prop2 class) and:[((self left) isSameForTesting: (prop2 left)) and:[(self right)isSameForTesting: (prop2 right).]].',			#stamp : 'pm 11/5/2018 09:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:27:00.303642+01:00' ],		#prior : OmReference [ '101' ],		#self : OmReference [ '102' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=prop2\r\t^SubclassResponsibility ',			#stamp : 'pm 11/5/2018 08:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:27:13.708286+01:00' ],		#prior : OmReference [ '102' ],		#self : OmReference [ '103' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'isSameForTesing:',			#protocol : #Skoleminsation,			#sourceCode : 'isSameForTesing:prop2\r\t^SubclassResponsibility ',			#stamp : 'pm 11/5/2018 09:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:27:18.976561+01:00' ],		#prior : OmReference [ '103' ],		#self : OmReference [ '104' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #Skoleminsation,			#sourceCode : 'isSameForTesting:prop2\r\t^SubclassResponsibility ',			#stamp : 'pm 11/5/2018 09:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:27:21.230698+01:00' ],		#prior : OmReference [ '104' ],		#self : OmReference [ '105' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'isSameForTesing:',			#protocol : #Skoleminsation,			#sourceCode : 'isSameForTesing:prop2\r\t^SubclassResponsibility ',			#stamp : 'pm 11/5/2018 09:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:27:31.541464+01:00' ],		#prior : OmReference [ '105' ],		#self : OmReference [ '106' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #Skoleminsation,			#sourceCode : 'isSameForTesting:prop2\r\t^SubclassResponsibility ',			#stamp : 'pm 11/5/2018 09:27',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting:prop2\r\t^SubclassResponsibility ',			#stamp : 'pm 11/5/2018 09:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:28:12.164594+01:00' ],		#prior : OmReference [ '106' ],		#self : OmReference [ '107' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting:prop2\r\t^self=prop2',			#stamp : 'pm 11/5/2018 09:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:28:17.659823+01:00' ],		#prior : OmReference [ '107' ],		#self : OmReference [ '108' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=prop2\r\t^self=prop2\t',			#stamp : 'pm 11/5/2018 08:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:29:06.931509+01:00' ],		#prior : OmReference [ '108' ],		#self : OmReference [ '109' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting:prop2\r\t^self class = prop2 class and:[(self operand) isSameForTesing: (prop2 operand)].',			#stamp : 'pm 11/5/2018 09:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:29:12.930323+01:00' ],		#prior : OmReference [ '109' ],		#self : OmReference [ '110' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=prop2\r\t^self getSymb = prop2 getSymb and:[self operand=prop2 operand].',			#stamp : 'pm 11/5/2018 08:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:30:53.414052+01:00' ],		#prior : OmReference [ '110' ],		#self : OmReference [ '111' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting:prop2\r\t^self class = prop2 class and:[self var=prop2 var and:[(self operand) isSameForTesting: (prop2 operand)]].',			#stamp : 'pm 11/5/2018 09:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:32:22.814562+01:00' ],		#prior : OmReference [ '111' ],		#self : OmReference [ '112' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting: anotherFuncTerm\r\r\t"Comparaison Operator."\r\t| res |\r\tself assert:(anotherFuncTerm class=self class)."checking the input"\r\tres:=self isSameSymb: anotherFuncTerm."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherFuncTerm]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherFuncTerm).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 11/5/2018 09:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting: anotherFuncTerm\r\r\t"Comparaison Operator."\r\t| res |\r\tself assert:(anotherFuncTerm class=self class)."checking the input"\r\tres:=self isSameSymb: anotherFuncTerm."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherFuncTerm]."comparing arity"\r\tres:=res and:[(self isSameTermsForTesting: anotherFuncTerm).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 11/5/2018 09:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:33:16.24686+01:00' ],		#prior : OmReference [ '112' ],		#self : OmReference [ '113' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting: anotherFuncTerm\r\r\t"Comparaison Operator."\r\t| res |\r\tself assert:(anotherFuncTerm class=self class)."checking the input"\r\tres:=self isSameSymb: anotherFuncTerm."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherFuncTerm]."comparing arity"\r\tres:=res and:[(self isSameTermsForTesting: anotherFuncTerm).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 11/5/2018 09:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting: anotherFuncTerm\r\r\t"Comparaison Operator."\r\t| res |\r\tself assert:(anotherFuncTerm class=self class)."checking the input"\r\tres:=self isSameSymbForTesting: anotherFuncTerm."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherFuncTerm]."comparing arity"\r\tres:=res and:[(self isSameTermsForTesting: anotherFuncTerm).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 11/5/2018 09:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:33:37.321854+01:00' ],		#prior : OmReference [ '113' ],		#self : OmReference [ '114' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameTerms:',			#protocol : #comparing,			#sourceCode : 'isSameTerms: anotherFuncTerm\r\t"check if every terms are in both FuncTerms."\r\t^(self terms) = (anotherFuncTerm terms).',			#stamp : 'pm 10/28/2018 14:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameTerms:',			#protocol : #comparing,			#sourceCode : 'isSameTerms: anotherFuncTerm\r\t"check if every terms are equal in both FuncTerms."\r\t^(self terms) = (anotherFuncTerm terms).',			#stamp : 'pm 11/5/2018 09:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:34:02.298448+01:00' ],		#prior : OmReference [ '114' ],		#self : OmReference [ '115' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameSymbForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameSymbForTesting:anotherFuncTerm\r\t"Do both funcTerm have the same symbol"\r\t^self anonymous \r\t\t\tifTrue:[anotherFuncTerm anonymous]\r\t\t\tifFalse:[\r\t\t\t\t(self getSymb)=(anotherFuncTerm getSymb).\r\t\t\t\t].',			#stamp : 'pm 11/5/2018 09:19',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameSymbForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameSymbForTesting:anotherFuncTerm\r\t"Do both funcTerm have the same symbol, forgeting the anonymous ones"\r\t^self anonymous \r\t\t\tifTrue:[anotherFuncTerm anonymous]\r\t\t\tifFalse:[\r\t\t\t\t(self getSymb)=(anotherFuncTerm getSymb).\r\t\t\t\t].',			#stamp : 'pm 11/5/2018 09:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:35:33.651265+01:00' ],		#prior : OmReference [ '115' ],		#self : OmReference [ '116' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemnTest1,			#protocol : #basic,			#sourceCode : 'testBasicSkolemnTest1\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new.\r\tterms2 add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\')).\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\tTranscript show:res;cr.\r\tTranscript show:expected;cr.\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 09:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicSkolemnTest1,			#protocol : #basic,			#sourceCode : 'testBasicSkolemnTest1\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new.\r\tterms2 add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\')).\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\tTranscript show:res;cr.\r\tTranscript show:expected;cr.\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 09:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:37:25.291358+01:00' ],		#prior : OmReference [ '116' ],		#self : OmReference [ '117' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting: anotherPredicate\r\t"Comparaison Operator, without carring for anonymous stuff."\r\t| res |\r\tself assert:(anotherPredicate class=self class)."checking the input"\r\tres:=self isSameSymbForTesting: anotherPredicate."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTermsForTesting: anotherPredicate).].\r\t^res.',			#stamp : 'pm 11/5/2018 09:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:37:49.667948+01:00' ],		#prior : OmReference [ '117' ],		#self : OmReference [ '118' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting: anotherPredicate\r\t"Comparaison Operator, without carring for anonymous stuff."\r\t| res |\r\tself assert:(anotherPredicate class=self class)."checking the input"\r\tres:=self isSameSymbForTesting: anotherPredicate."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTermsForTesting: anotherPredicate).].\r\t^res.',			#stamp : 'pm 11/5/2018 09:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting: anotherPredicate\r\t"Comparaison Operator, without carring for anonymous stuff."\r\t| res |\r\tself assert:(anotherPredicate class=self class)."checking the input"\r\tres:=self getSymb = anotherPredicate getSymb."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTermsForTesting: anotherPredicate).].\r\t^res.',			#stamp : 'pm 11/5/2018 09:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:37:59.553156+01:00' ],		#prior : OmReference [ '118' ],		#self : OmReference [ '119' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting: anotherPredicate\r\t"Comparaison Operator, without carring for anonymous stuff."\r\t| res |\r\tself assert:(anotherPredicate class=self class)."checking the input"\r\tres:=self getSymb = anotherPredicate getSymb."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTermsForTesting: anotherPredicate).].\r\t^res.',			#stamp : 'pm 11/5/2018 09:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameForTesting: anotherPredicate\r\t"Comparaison Operator, without carring for anonymous stuff."\r\t| res |\r\tself assert:(anotherPredicate class=self class)."checking the input"\r\tres:=self isSameSymb: anotherPredicate."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTermsForTesting: anotherPredicate).].\r\t^res.',			#stamp : 'pm 11/5/2018 09:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:38:18.82152+01:00' ],		#prior : OmReference [ '119' ],		#self : OmReference [ '120' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #SequenceableCollection,				#isMetaSide : false			},			#name : #'timesRepeat:',			#protocol : #'as yet unclassified',			#sourceCode : 'timesRepeat: aBlockClosure \r\tself shouldBeImplemented.',			#stamp : 'pm 11/5/2018 09:38',			#package : #Collections-Abstract		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:39:14.791181+01:00' ],		#prior : OmReference [ '120' ],		#self : OmReference [ '121' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameTermsForTesting: anotherPredicate\r\t\r\tterms timesRepeat:[:i|\r\t\t((self at:i) isSameForTesting: (anotherPredicate at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 11/5/2018 09:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameTermsForTesting: anotherPredicate\r\t\r\t1 to:(terms size) do:[:i|\r\t\t((self at:i) isSameForTesting: (anotherPredicate at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 11/5/2018 09:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:40:41.599128+01:00' ],		#prior : OmReference [ '121' ],		#self : OmReference [ '122' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #testing,			#sourceCode : 'isSameTermsForTesting:anotherFuncTerm\r\t\r\tself timesRepeat:[:i|\r\t\t((self at:i) isSameForTesting: (anotherFuncTerm at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 11/5/2018 09:07',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #testing,			#sourceCode : 'isSameTermsForTesting:anotherFuncTerm\r\t\r\t1 to: (terms size) do:[:i|\r\t\t(((self terms) at:i) isSameForTesting: ((anotherFuncTerm terms) at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 11/5/2018 09:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:41:52.080751+01:00' ],		#prior : OmReference [ '122' ],		#self : OmReference [ '123' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #testing,			#sourceCode : 'isSameTermsForTesting:anotherFuncTerm\r\t\r\t1 to: (terms size) do:[:i|\r\t\t(((self terms) at:i) isSameForTesting: ((anotherFuncTerm terms) at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 11/5/2018 09:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #testing,			#sourceCode : 'isSameTermsForTesting:anotherFuncTerm\r\t| selfTerms anotherFuncTerms |\r\tselfTerms:=self terms.\r\tanotherFuncTerms:=anotherFuncTerm term.\r\t1 to: (terms size) do:[:i|\r\t\t(((self terms) at:i) isSameForTesting: ((anotherFuncTerm terms) at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 11/5/2018 09:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:42:13.085005+01:00' ],		#prior : OmReference [ '123' ],		#self : OmReference [ '124' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #testing,			#sourceCode : 'isSameTermsForTesting:anotherFuncTerm\r\t| selfTerms anotherFuncTerms |\r\tselfTerms:=self terms.\r\tanotherFuncTerms:=anotherFuncTerm term.\r\t1 to: (terms size) do:[:i|\r\t\t(((self terms) at:i) isSameForTesting: ((anotherFuncTerm terms) at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 11/5/2018 09:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #testing,			#sourceCode : 'isSameTermsForTesting:anotherFuncTerm\r\t| selfTerms anotherFuncTerms |\r\tselfTerms:=self terms.\r\tanotherFuncTerms:=anotherFuncTerm term.\r\t1 to: (terms size) do:[:i|\r\t\t((selfTerms at:i) isSameForTesting: (anotherFuncTerms at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 11/5/2018 09:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:42:47.688125+01:00' ],		#prior : OmReference [ '124' ],		#self : OmReference [ '125' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'equalForTesting:',			#protocol : #comparing,			#sourceCode : 'equalForTesting:anotherPredicate\r\t"same as =, but doesn\'t care about anonymous const/func term. for testing purposes."\r\t| res |\r\tres:=anotherPredicate isKindOf: self class."checking the input"\r\tres:=res and:[(self isSameSymb: anotherPredicate)]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTermsForTesting: anotherPredicate).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 11/5/2018 09:01',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:43:42.128855+01:00' ],		#prior : OmReference [ '125' ],		#self : OmReference [ '126' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameTermsForTesting: anotherPredicate\r\t\r\t1 to:(terms size) do:[:i|\r\t\t((self at:i) isSameForTesting: (anotherPredicate at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 11/5/2018 09:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameTermsForTesting: anotherPredicate\r\t| selfTerms anotherPredicateTerms |\r\tselfTerms:=self terms.\r\tanotherPredicateTerms:=anotherPredicate term.\r\t1 to: (terms size) do:[:i|\r\t\t((selfTerms at:i) isSameForTesting: (anotherPredicateTerms at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 11/5/2018 09:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:43:58.691351+01:00' ],		#prior : OmReference [ '126' ],		#self : OmReference [ '127' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameTermsForTesting: anotherPredicate\r\t| selfTerms anotherPredicateTerms |\r\tselfTerms:=self terms.\r\tanotherPredicateTerms:=anotherPredicate term.\r\t1 to: (terms size) do:[:i|\r\t\t((selfTerms at:i) isSameForTesting: (anotherPredicateTerms at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 11/5/2018 09:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #comparing,			#sourceCode : 'isSameTermsForTesting: anotherPredicate\r\t| selfTerms anotherPredicateTerms |\r\tselfTerms:=self terms.\r\tanotherPredicateTerms:=anotherPredicate terms.\r\t1 to: (terms size) do:[:i|\r\t\t((selfTerms at:i) isSameForTesting: (anotherPredicateTerms at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 11/5/2018 09:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:44:07.490419+01:00' ],		#prior : OmReference [ '127' ],		#self : OmReference [ '128' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #testing,			#sourceCode : 'isSameTermsForTesting:anotherFuncTerm\r\t| selfTerms anotherFuncTerms |\r\tselfTerms:=self terms.\r\tanotherFuncTerms:=anotherFuncTerm term.\r\t1 to: (terms size) do:[:i|\r\t\t((selfTerms at:i) isSameForTesting: (anotherFuncTerms at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 11/5/2018 09:42',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #testing,			#sourceCode : 'isSameTermsForTesting:anotherFuncTerm\r\t| selfTerms anotherFuncTerms |\r\tselfTerms:=self terms.\r\tanotherFuncTerms:=anotherFuncTerm terms.\r\t1 to: (terms size) do:[:i|\r\t\t((selfTerms at:i) isSameForTesting: (anotherFuncTerms at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 11/5/2018 09:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:44:53.532219+01:00' ],		#prior : OmReference [ '128' ],		#self : OmReference [ '129' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #'as yet unclassified',			#sourceCode : 'isSameForTesting: anotherTerm\r\t^self=anotherTerm.',			#stamp : 'pm 11/5/2018 09:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:44:53.633886+01:00' ],		#prior : OmReference [ '129' ],		#self : OmReference [ '130' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #'as yet unclassified',			#sourceCode : 'isSameForTesting: anotherTerm\r\t^self=anotherTerm.',			#stamp : 'pm 11/5/2018 09:44',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #testing,			#sourceCode : 'isSameForTesting: anotherTerm\r\t^self=anotherTerm.',			#stamp : 'pm 11/5/2018 09:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:45:46.385922+01:00' ],		#prior : OmReference [ '130' ],		#self : OmReference [ '131' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t"comparaison operator"\r\t^(anotherTerm isKindOf: (self class)) and:[(self term)=(anotherTerm term).].\r\t\r\t\r\t',			#stamp : 'pm 10/28/2018 15:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherTerm\r\t"comparaison operator"\r\t^((anotherTerm class) = (self class)) and:[(self term)=(anotherTerm term).].\r\t\r\t\r\t',			#stamp : 'pm 11/5/2018 09:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:45:59.806495+01:00' ],		#prior : OmReference [ '131' ],		#self : OmReference [ '132' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #testing,			#sourceCode : 'isSameForTesting: anotherTerm\r\tself assert: (self class)=(anotherTerm class).\r\t^self term = anotherTerm term.',			#stamp : 'pm 11/5/2018 09:11',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #testing,			#sourceCode : 'isSameForTesting: anotherTerm\r\t^self term = anotherTerm term.',			#stamp : 'pm 11/5/2018 09:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:49:18.176233+01:00' ],		#prior : OmReference [ '132' ],		#self : OmReference [ '133' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\tsetOfLinkedVar add: (Term new:(self var)).\r\t^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 10/11/2018 08:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\t^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 11/5/2018 09:49',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-05T09:49:36.396241+01:00' ],		#prior : OmReference [ '133' ],		#self : OmReference [ '134' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\tsetOfLinkedVar add: (Term new:(self var)).\r\t^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.\r\t \r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 10/11/2018 08:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\t^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.\r\t \r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 11/5/2018 09:49',			#package : #_resolution_1erOrdre		}	}}