OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:12:04.340722+01:00' ],		#prior : OmReference [ 'Pharo.b6wta16ujaurk6pcmrcbmnn98', '24' ],		#self : OmReference [ '1' ]	},	#content : EpProtocolAddition {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #Skolemn_test\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #Skolemn_test,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Skolemn_test class\r\tinstanceVariableNames: \'\''				},				#name : #'Skolemn_test class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Skolemn_test,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #Clausification	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:15:11.774905+01:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #TestClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'TestClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: Predicate new rightProp: Predicate new.\r\tres := And new: Predicate new rightProp: Predicate new.\r\t\r\tself assert: prop = res.',			#stamp : 'pm 12/7/2018 17:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:15:15.989073+01:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #TestClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'TestClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: Predicate new rightProp: Predicate new.\r\tres := And new: Predicate new rightProp: Predicate new.\r\t\r\tself assert: prop = res.',			#stamp : 'pm 12/7/2018 17:15',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #TestClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'TestClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: Predicate new rightProp: Predicate new.\r\tres := And new: Predicate new rightProp: Predicate new.\r\t\r\t^self assert: prop = res.',			#stamp : 'pm 12/7/2018 17:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:15:23.218668+01:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: Predicate new rightProp: Predicate new.\r\tres := And new: Predicate new rightProp: Predicate new.\r\t\r\t^self assert: prop = res.',			#stamp : 'pm 12/7/2018 17:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:15:26.277186+01:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #TestClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'TestClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: Predicate new rightProp: Predicate new.\r\tres := And new: Predicate new rightProp: Predicate new.\r\t\r\t^self assert: prop = res.',			#stamp : 'pm 12/7/2018 17:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:15:52.787636+01:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: Predicate new rightProp: Predicate new.\r\tres := And new: Predicate new rightProp: Predicate new.\r\t\r\t^self assert: prop = res.',			#stamp : 'pm 12/7/2018 17:15',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: Predicate new \r\t\t\t\t\trightProp: Predicate new.\r\tres := And new: Predicate new \r\t\t\t\t\trightProp: Predicate new.\r\t\r\t^self assert: prop = prop.',			#stamp : 'pm 12/7/2018 17:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:16:15.508597+01:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: Predicate new \r\t\t\t\t\trightProp: Predicate new.\r\tres := And new: Predicate new \r\t\t\t\t\trightProp: Predicate new.\r\t\r\t^self assert: prop = prop.',			#stamp : 'pm 12/7/2018 17:15',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: Predicate new \r\t\t\t\t\trightProp: Predicate new.\r\tres := And new: Predicate new \r\t\t\t\t\trightProp: Predicate new.\r\t\r\t^self assert: prop = res.',			#stamp : 'pm 12/7/2018 17:16',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:17:17.036695+01:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: Predicate new \r\t\t\t\t\trightProp: Predicate new.\r\tres := And new: Predicate new \r\t\t\t\t\trightProp: Predicate new.\r\t\r\t^self assert: prop = res.',			#stamp : 'pm 12/7/2018 17:16',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: Predicate new \r\t\t\t\t\trightProp: Predicate new.\r\t\r\tres := And new: Predicate new \r\t\t\t\t\trightProp: Predicate new.\r\tTranscript show: prop ;cr; show:res.\r\t\r\t^self assert: prop = res.',			#stamp : 'pm 12/7/2018 17:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:17:30.596523+01:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: Predicate new \r\t\t\t\t\trightProp: Predicate new.\r\t\r\tres := And new: Predicate new \r\t\t\t\t\trightProp: Predicate new.\r\tTranscript show: prop ;cr; show:res.\r\t\r\t^self assert: prop = res.',			#stamp : 'pm 12/7/2018 17:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: Predicate new \r\t\t\t\t\trightProp: Predicate new.\r\t\r\tres := And new: Predicate new \r\t\t\t\t\trightProp: Predicate new.\r\t\t\t\t\t\r\tTranscript cr; show: prop ;cr; show:res.\r\t\r\t^self assert: prop = res.',			#stamp : 'pm 12/7/2018 17:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:18:47.34651+01:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"abstract class, not meant to be instanciated"\r\t^SubclassResponsibility \r',			#stamp : 'pm 11/28/2018 01:19',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"abstract class, not meant to be instanciated"\r\tself halt.\r\t^SubclassResponsibility \r',			#stamp : 'pm 12/7/2018 17:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:19:38.874356+01:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Constant class',				#isMetaSide : true			},			#name : #new,			#protocol : #'as yet unclassified',			#sourceCode : 'new\r\t^self basicNew.',			#stamp : 'pm 12/7/2018 17:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:19:38.953873+01:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Constant class',				#isMetaSide : true			},			#name : #new,			#protocol : #'as yet unclassified',			#sourceCode : 'new\r\t^self basicNew.',			#stamp : 'pm 12/7/2018 17:19',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Constant class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t^self basicNew.',			#stamp : 'pm 12/7/2018 17:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:21:50.817002+01:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: Predicate new \r\t\t\t\t\trightProp: Predicate new.\r\t\r\tres := And new: Predicate new \r\t\t\t\t\trightProp: Predicate new.\r\t\t\t\t\t\r\tTranscript cr; show: prop ;cr; show:res.\r\t\r\t^self assert: prop = res.',			#stamp : 'pm 12/7/2018 17:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new: Predicate new \r\t\t\t\t\trightProp: Predicate new.\r\t\t\t\t\t\r\tTranscript cr; show: prop ;cr; show:res.\r\t\r\t^self assert: prop = res.',			#stamp : 'pm 12/7/2018 17:21',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:22:03.247991+01:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new: Predicate new \r\t\t\t\t\trightProp: Predicate new.\r\t\t\t\t\t\r\tTranscript cr; show: prop ;cr; show:res.\r\t\r\t^self assert: prop = res.',			#stamp : 'pm 12/7/2018 17:21',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\t\t\t\t\r\tTranscript cr; show: prop ;cr; show:res.\r\t\r\t^self assert: prop = res.',			#stamp : 'pm 12/7/2018 17:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:22:22.930352+01:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\t\t\t\t\r\tTranscript cr; show: prop ;cr; show:res.\r\t\r\t^self assert: prop = res.',			#stamp : 'pm 12/7/2018 17:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new: (Predicate new:\'Q\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\r\tTranscript cr; show: prop ;cr; show:res.\r\t\r\t^self assert: prop = res.',			#stamp : 'pm 12/7/2018 17:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:22:32.671458+01:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new: (Predicate new:\'Q\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\r\tTranscript cr; show: prop ;cr; show:res.\r\t\r\t^self assert: prop = res.',			#stamp : 'pm 12/7/2018 17:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new: (Predicate new:\'Q\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\r\t^self assert: prop = res.',			#stamp : 'pm 12/7/2018 17:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:38:30.919368+01:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new: (Predicate new:\'Q\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\r\t^self assert: prop = res.',			#stamp : 'pm 12/7/2018 17:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new: (Predicate new:\'Q\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\r\t^self assert: prop fullClausification = res.',			#stamp : 'pm 12/7/2018 17:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:38:52.21683+01:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new: (Predicate new:\'Q\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\r\t^self assert: prop fullClausification = res.',			#stamp : 'pm 12/7/2018 17:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\t\t\t\t\r\t^self assert: prop fullClausification = res.',			#stamp : 'pm 12/7/2018 17:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:39:19.953428+01:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\t\t\t\t\r\t^self assert: prop fullClausification = res.',			#stamp : 'pm 12/7/2018 17:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tTranscript show: prop ; cr ; show: prop.\r\t\t\t\t\t\t\r\t^self assert: prop fullClausification = res.',			#stamp : 'pm 12/7/2018 17:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:39:38.842517+01:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tTranscript show: prop ; cr ; show: prop.\r\t\t\t\t\t\t\r\t^self assert: prop fullClausification = res.',			#stamp : 'pm 12/7/2018 17:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\t^self assert: prop fullClausification = res.',			#stamp : 'pm 12/7/2018 17:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:40:02.926072+01:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\t^self assert: prop fullClausification = res.',			#stamp : 'pm 12/7/2018 17:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: prop fullClausification = res.',			#stamp : 'pm 12/7/2018 17:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:53:39.860968+01:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherPredicate\r\t| res |\r\t"comparaison operator"\r\t\r\tres:=anotherPredicate isKindOf: self class."checking the input"\r\tres:=res and:[(self isSameSymb: anotherPredicate)]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherPredicate).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 11/28/2018 00:09',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherPredicate\r\t| res |\r\t"comparaison operator"\r\t\r\tres:=anotherPredicate isKindOf: self class."checking the input"\r\tres:=res and:[(self isSameSymb: anotherPredicate)]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherPredicate).]."we let the superclass LinkedList check for the correct terms"\r\tself halt.\r\t^res.',			#stamp : 'pm 12/7/2018 17:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:53:57.178433+01:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherPredicate\r\t| res |\r\t"comparaison operator"\r\t\r\tres:=anotherPredicate isKindOf: self class."checking the input"\r\tres:=res and:[(self isSameSymb: anotherPredicate)]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherPredicate).]."we let the superclass LinkedList check for the correct terms"\r\tself halt.\r\t^res.',			#stamp : 'pm 12/7/2018 17:53',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherPredicate\r\t| res |\r\t"comparaison operator"\r\t\r\tres:=anotherPredicate isKindOf: self class."checking the input"\r\tres:=res and:[(self isSameSymb: anotherPredicate)]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherPredicate).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 12/7/2018 17:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:55:32.568482+01:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #'=',			#protocol : #'as yet unclassified',			#sourceCode : '= anotherAtome',			#stamp : 'pm 12/7/2018 17:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:55:32.648147+01:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #'=',			#protocol : #'as yet unclassified',			#sourceCode : '= anotherAtome',			#stamp : 'pm 12/7/2018 17:55',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherAtome',			#stamp : 'pm 12/7/2018 17:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:55:48.903315+01:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: prop fullClausification = res.',			#stamp : 'pm 12/7/2018 17:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: prop fullClausification isTheSameForTesting: res.',			#stamp : 'pm 12/7/2018 17:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:56:04.432131+01:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: prop fullClausification isTheSameForTesting: res.',			#stamp : 'pm 12/7/2018 17:55',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: prop fullClausification isTheSame: res.',			#stamp : 'pm 12/7/2018 17:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:56:12.473708+01:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: prop fullClausification isTheSame: res.',			#stamp : 'pm 12/7/2018 17:56',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification isTheSame: res).',			#stamp : 'pm 12/7/2018 17:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:57:28.579362+01:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'=',			#protocol : #'as yet unclassified',			#sourceCode : '= anotherBinaryOperator\r\tsuper = anotherBinaryOperator',			#stamp : 'pm 12/7/2018 17:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:57:28.661966+01:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'=',			#protocol : #'as yet unclassified',			#sourceCode : '= anotherBinaryOperator\r\tsuper = anotherBinaryOperator',			#stamp : 'pm 12/7/2018 17:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherBinaryOperator\r\tsuper = anotherBinaryOperator',			#stamp : 'pm 12/7/2018 17:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T17:59:10.578054+01:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherBinaryOperator\r\tsuper = anotherBinaryOperator',			#stamp : 'pm 12/7/2018 17:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherBinaryOperator\r\t^ super = anotherBinaryOperator \r\t\tand:[self left = anotherBinaryOperator left\r\t\t\tand:[self right = anotherBinaryOperator right]\r\t\t\t]',			#stamp : 'pm 12/7/2018 17:59',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T18:00:12.345331+01:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #'=',			#protocol : #'as yet unclassified',			#sourceCode : '= anotherUnaryOperator\r\t^ super = anotherUnaryOperator \r\t\tand:[self operand = anotherUnaryOperator operand\t]',			#stamp : 'pm 12/7/2018 18:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T18:00:12.525444+01:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #'=',			#protocol : #'as yet unclassified',			#sourceCode : '= anotherUnaryOperator\r\t^ super = anotherUnaryOperator \r\t\tand:[self operand = anotherUnaryOperator operand\t]',			#stamp : 'pm 12/7/2018 18:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherUnaryOperator\r\t^ super = anotherUnaryOperator \r\t\tand:[self operand = anotherUnaryOperator operand\t]',			#stamp : 'pm 12/7/2018 18:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T18:00:50.366225+01:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherUnaryOperator\r\t^ super = anotherUnaryOperator \r\t\tand:[self operand = anotherUnaryOperator operand\t]',			#stamp : 'pm 12/7/2018 18:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherUnaryOperator\r\t^ super = anotherUnaryOperator \r\t\tand:[self operand = anotherUnaryOperator operand]',			#stamp : 'pm 12/7/2018 18:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T18:01:15.991411+01:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Operator,				#isMetaSide : false			},			#name : #'=',			#protocol : #'as yet unclassified',			#sourceCode : '= anotherOperator\r\tself getSymb = anotherOperator getSymb',			#stamp : 'pm 12/7/2018 18:01',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T18:01:16.10041+01:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Operator,				#isMetaSide : false			},			#name : #'=',			#protocol : #'as yet unclassified',			#sourceCode : '= anotherOperator\r\tself getSymb = anotherOperator getSymb',			#stamp : 'pm 12/7/2018 18:01',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Operator,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherOperator\r\tself getSymb = anotherOperator getSymb',			#stamp : 'pm 12/7/2018 18:01',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T18:01:27.506974+01:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification isTheSame: res).',			#stamp : 'pm 12/7/2018 17:56',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 18:01',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T18:13:10.782517+01:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherPredicate\r\t| res |\r\t"comparaison operator"\r\t\r\tres:=anotherPredicate isKindOf: self class."checking the input"\r\tres:=res and:[(self isSameSymb: anotherPredicate)]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherPredicate).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 12/7/2018 17:53',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherPredicate\r\t| res |\r\t"comparaison operator"\r\t\r\tres:=anotherPredicate isKindOf: self class."checking the input"\r\tres:=res and:[(self isSameSymb: anotherPredicate)]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherPredicate).]."we let the superclass LinkedList check for the correct terms"\r\tself halt.\r\t^res.',			#stamp : 'pm 12/7/2018 18:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T18:15:00.389654+01:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Operator,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherOperator\r\tself getSymb = anotherOperator getSymb',			#stamp : 'pm 12/7/2018 18:01',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Operator,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherOperator\r\tself halt.\r\tself getSymb = anotherOperator getSymb',			#stamp : 'pm 12/7/2018 18:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T18:16:50.853777+01:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Operator,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherOperator\r\tself halt.\r\tself getSymb = anotherOperator getSymb',			#stamp : 'pm 12/7/2018 18:15',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Operator,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherOperator\r\t^self getSymb = anotherOperator getSymb',			#stamp : 'pm 12/7/2018 18:16',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T18:17:07.281975+01:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherPredicate\r\t| res |\r\t"comparaison operator"\r\t\r\tres:=anotherPredicate isKindOf: self class."checking the input"\r\tres:=res and:[(self isSameSymb: anotherPredicate)]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherPredicate).]."we let the superclass LinkedList check for the correct terms"\r\tself halt.\r\t^res.',			#stamp : 'pm 12/7/2018 18:13',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherPredicate\r\t| res |\r\t"comparaison operator"\r\t\r\tres:=anotherPredicate isKindOf: self class."checking the input"\r\tres:=res and:[(self isSameSymb: anotherPredicate)]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherPredicate).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 12/7/2018 18:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T18:17:31.702384+01:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t\r\tprop := Or new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := Or new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 18:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T18:17:45.39977+01:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationImply,			#protocol : #Clausification,			#sourceCode : 'testClausificationImply\r\t| prop res |\r\t\r\tprop := Imply new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := Or new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 18:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T18:25:13.683077+01:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationImply,			#protocol : #Clausification,			#sourceCode : 'testClausificationImply\r\t| prop res |\r\t\r\tprop := Imply new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := Or new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 18:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationImply,			#protocol : #Clausification,			#sourceCode : 'testClausificationImply\r\t| prop res |\r\t\r\tprop := Imply new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := Not new:(Or new: (Predicate new:\'P\'))\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 18:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T18:25:32.832404+01:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationImply,			#protocol : #Clausification,			#sourceCode : 'testClausificationImply\r\t| prop res |\r\t\r\tprop := Imply new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := Not new:(Or new: (Predicate new:\'P\'))\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 18:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationImply,			#protocol : #Clausification,			#sourceCode : 'testClausificationImply\r\t| prop res |\r\t\r\tprop := Imply new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := Or new:(Not new: (Predicate new:\'P\'))\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 18:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T18:27:21.921789+01:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherPredicate\r\t| res |\r\t"comparaison operator"\r\t\r\tres:=anotherPredicate isKindOf: self class."checking the input"\r\tres:=res and:[(self isSameSymb: anotherPredicate)]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherPredicate).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 12/7/2018 18:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherPredicate\r\t| res |\r\t"comparaison operator"\r\t\r\tres:=anotherPredicate isKindOf: self class."checking the input"\r\tres:=res and:[self isSameSymb: anotherPredicate]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[self isSameTerms: anotherPredicate]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 12/7/2018 18:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T18:29:21.436156+01:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #Clausification,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new:(Imply new: (Predicate new:\'P\'))\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 18:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T18:29:38.707737+01:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 18:01',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 18:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T18:29:46.345294+01:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationImply,			#protocol : #Clausification,			#sourceCode : 'testClausificationImply\r\t| prop res |\r\t\r\tprop := Imply new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := Or new:(Not new: (Predicate new:\'P\'))\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 18:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationImply,			#protocol : #Clausification,			#sourceCode : 'testClausificationImply\r\t| prop res |\r\t\r\tprop := Imply new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := Or new:(Not new: (Predicate new:\'P\'))\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 18:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T18:29:53.800839+01:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t\r\tprop := Or new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := Or new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 18:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t\r\tprop := Or new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := Or new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 18:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T18:45:36.079954+01:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #Clausification,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tres := And new:(Imply new: (Predicate new:\'P\'))\r\t\t\t\t\trightProp: (Predicate new:\'P\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 18:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #Clausification,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new:(Imply new: (Predicate new:\'P\')\r\t\t\t\t\t\t\t\trightProp: (Predicate new:\'Q\'))\r\t\t\t\trightProp: (Imply new: (Predicate new:\'P\')\r\t\t\t\t\t\t\t\trightProp: (Predicate new:\'Q\')).\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 18:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T18:45:53.184924+01:00' ],		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #Clausification,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new:(Imply new: (Predicate new:\'P\')\r\t\t\t\t\t\t\t\trightProp: (Predicate new:\'Q\'))\r\t\t\t\trightProp: (Imply new: (Predicate new:\'P\')\r\t\t\t\t\t\t\t\trightProp: (Predicate new:\'Q\')).\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 18:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #Clausification,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new:(Imply new: (Predicate new:\'P\')\r\t\t\t\t\t\t\t\trightProp: (Predicate new:\'Q\'))\r\t\t\t\trightProp: (Imply new: (Predicate new:\'Q\')\r\t\t\t\t\t\t\t\trightProp: (Predicate new:\'P\')).\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 18:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T18:55:14.143355+01:00' ],		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #Clausification,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new:(Imply new: (Predicate new:\'P\')\r\t\t\t\t\t\t\t\trightProp: (Predicate new:\'Q\'))\r\t\t\t\trightProp: (Imply new: (Predicate new:\'Q\')\r\t\t\t\t\t\t\t\trightProp: (Predicate new:\'P\')).\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 18:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #Clausification,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new:(Imply new: (Predicate new:\'P\')\r\t\t\t\t\t\t\t\trightProp: (Predicate new:\'Q\'))\r\t\t\t\trightProp: (Imply new: (Predicate new:\'Q\')\r\t\t\t\t\t\t\t\trightProp: (Predicate new:\'P\')).\r\t\r\tTranscript show: prop fullClausification ; cr ; show: res.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 18:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T18:56:41.777254+01:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #Clausification,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new:(Imply new: (Predicate new:\'P\')\r\t\t\t\t\t\t\t\trightProp: (Predicate new:\'Q\'))\r\t\t\t\trightProp: (Imply new: (Predicate new:\'Q\')\r\t\t\t\t\t\t\t\trightProp: (Predicate new:\'P\')).\r\t\r\tTranscript show: prop fullClausification ; cr ; show: res.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 18:55',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #Clausification,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new:(Imply new: (Predicate new:\'P\')\r\t\t\t\t\t\t\t\trightProp: (Predicate new:\'Q\'))\r\t\t\t\trightProp: (Imply new: (Predicate new:\'Q\')\r\t\t\t\t\t\t\t\trightProp: (Predicate new:\'P\')).\r\t\r\tTranscript cr; show: prop fullClausification ; cr ; show: res.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 18:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T19:12:40.060058+01:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #Clausification,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new:(Imply new: (Predicate new:\'P\')\r\t\t\t\t\t\t\t\trightProp: (Predicate new:\'Q\'))\r\t\t\t\trightProp: (Imply new: (Predicate new:\'Q\')\r\t\t\t\t\t\t\t\trightProp: (Predicate new:\'P\')).\r\t\r\tTranscript cr; show: prop fullClausification ; cr ; show: res.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 19:06',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #Clausification,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := Or new:(And new:\r\t    \t\t      \t\t\t(Predicate new:\'P\')\r\t\t\t\t\t\t    rightProp:\r\t\t\t\t\t         (Predicate new:\'Q\'))\r\trightProp:(And new:\r          \t\t\t(Not new: (Predicate new:\'P\'))\r\t\t\t\t     rightProp:\r\t\t\t          (Not new:(Predicate new:\'Q\')))\r\r\tTranscript cr; show: prop fullClausification ; cr ; show: res.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 19:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T19:13:58.166419+01:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #Clausification,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := Or new:(And new:\r\t    \t\t      \t\t\t(Predicate new:\'P\')\r\t\t\t\t\t\t    rightProp:\r\t\t\t\t\t         (Predicate new:\'Q\'))\r\trightProp:(And new:\r          \t\t\t(Not new: (Predicate new:\'P\'))\r\t\t\t\t     rightProp:\r\t\t\t          (Not new:(Predicate new:\'Q\')))\r\r\tTranscript cr; show: prop fullClausification ; cr ; show: res.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 19:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #Clausification,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := Or new:(And new:\r\t    \t\t      \t\t\t(Predicate new:\'P\')\r\t\t\t\t\t\t    rightProp:\r\t\t\t\t\t         (Predicate new:\'Q\'))\r\t\t\t\trightProp:(And new:\r          \t\t\t(Not new: (Predicate new:\'P\'))\r\t\t\t\t     rightProp:\r\t\t\t          (Not new:(Predicate new:\'Q\'))).\r\r\tTranscript cr; show: prop fullClausification ; cr ; show: res.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 19:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T19:14:04.489644+01:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #Clausification,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := Or new:(And new:\r\t    \t\t      \t\t\t(Predicate new:\'P\')\r\t\t\t\t\t\t    rightProp:\r\t\t\t\t\t         (Predicate new:\'Q\'))\r\t\t\t\trightProp:(And new:\r          \t\t\t(Not new: (Predicate new:\'P\'))\r\t\t\t\t     rightProp:\r\t\t\t          (Not new:(Predicate new:\'Q\'))).\r\r\tTranscript cr; show: prop fullClausification ; cr ; show: res.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 19:13',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #Clausification,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := Or new:(And new:\r\t    \t\t      \t\t\t(Predicate new:\'P\')\r\t\t\t\t\t\t    rightProp:\r\t\t\t\t\t         (Predicate new:\'Q\'))\r\t\t\t\trightProp:(And new:\r          \t\t\t(Not new: (Predicate new:\'P\'))\r\t\t\t\t     rightProp:\r\t\t\t          (Not new:(Predicate new:\'Q\'))).\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 19:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T19:14:11.282753+01:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t\r\tprop := Or new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := Or new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 18:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t\r\tprop := Or new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := Or new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 19:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T19:14:16.020308+01:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationImply,			#protocol : #Clausification,			#sourceCode : 'testClausificationImply\r\t| prop res |\r\t\r\tprop := Imply new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := Or new:(Not new: (Predicate new:\'P\'))\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 18:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationImply,			#protocol : #Clausification,			#sourceCode : 'testClausificationImply\r\t| prop res |\r\t\r\tprop := Imply new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := Or new:(Not new: (Predicate new:\'P\'))\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 19:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T19:14:21.95641+01:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tTranscript show: prop fullClausification ; cr ; show: prop.\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 18:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 19:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T19:14:41.161368+01:00' ],		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAll,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAll\r\t| p res expected |\r\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'a\'))))).\r\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 18:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAll,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAll\r\t| p res expected |\r\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'a\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).',			#stamp : 'pm 12/7/2018 19:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T19:14:44.710901+01:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicOnlyPredicate,			#protocol : #basic,			#sourceCode : 'testBasicOnlyPredicate\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\');yourself.\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 19:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicOnlyPredicate,			#protocol : #basic,			#sourceCode : 'testBasicOnlyPredicate\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\');yourself.\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t\r\tself assert:(res isSameForTesting: expected).',			#stamp : 'pm 12/7/2018 19:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T19:14:47.786145+01:00' ],		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicForAll,			#protocol : #basic,			#sourceCode : 'testBasicForAll\r\t| p res expected terms |\r\r\tterms:=LinkedList new add:(Term new:\'x\');add:(Term new:\'z\');yourself.\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\r\t\r\tterms:=LinkedList new add:(LinkedTerm new:(Term new:\'x\')); add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Or new: (Predicate new: \'P\' fromList: terms)\r\t\t\t\t\trightProp: (Predicate new: \'P\' fromList: terms).\r\t\r\t\r\t^self assert:(res isSameForTesting: expected).',			#stamp : 'pm 11/5/2018 19:31',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testBasicForAll,			#protocol : #basic,			#sourceCode : 'testBasicForAll\r\t| p res expected terms |\r\r\tterms:=LinkedList new add:(Term new:\'x\');add:(Term new:\'z\');yourself.\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\r\t\r\tterms:=LinkedList new add:(LinkedTerm new:(Term new:\'x\')); add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Or new: (Predicate new: \'P\' fromList: terms)\r\t\t\t\t\trightProp: (Predicate new: \'P\' fromList: terms).\r\t\r\t\r\tself assert:(res isSameForTesting: expected).',			#stamp : 'pm 12/7/2018 19:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T19:15:32.2868+01:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAllWithSameNameForConstAndLinkedVar,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAllWithSameNameForConstAndLinkedVar\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTerms: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 11/5/2018 19:16',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testImplyAndNestedForAllWithSameNameForConstAndLinkedVar,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAllWithSameNameForConstAndLinkedVar\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTermsForTesting: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 12/7/2018 19:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T19:15:46.130754+01:00' ],		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testUnboundExistReplacedByConsts,			#protocol : #basic,			#sourceCode : 'testUnboundExistReplacedByConsts\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTerms: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 11/11/2018 09:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testUnboundExistReplacedByConsts,			#protocol : #basic,			#sourceCode : 'testUnboundExistReplacedByConsts\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTermsForTesting: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 12/7/2018 19:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T19:17:43.584157+01:00' ],		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationPredicate,			#protocol : #Clausification,			#sourceCode : 'testClausificationPredicate\r\t| prop res |\r\t\r\tprop := (Predicate new:\'P\').\r\t\r\tres := (Predicate new:\'P\')\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 19:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T19:17:46.255256+01:00' ],		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationPredicate,			#protocol : #Clausification,			#sourceCode : 'testClausificationPredicate\r\t| prop res |\r\t\r\tprop := (Predicate new:\'P\').\r\t\r\tres := (Predicate new:\'P\')\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 19:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationPredicate,			#protocol : #Clausification,			#sourceCode : 'testClausificationPredicate\r\t| prop res |\r\t\r\tprop := (Predicate new:\'P\').\r\t\r\tres := (Predicate new:\'P\').\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 19:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T19:34:56.253283+01:00' ],		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationPredicate,			#protocol : #Clausification,			#sourceCode : 'testClausificationPredicate\r\t| prop res |\r\t\r\tprop := (Predicate new:\'P\').\r\t\r\tres := (Predicate new:\'P\').\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 19:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationPredicate,			#protocol : #Clausification,			#sourceCode : 'testClausificationPredicate\r\t| prop res |\r\t"basic, should be  unafected by clausification"\r\t\r\t"for empty predicates"\r\tprop := (Predicate new:\'P\').\r\tres := (Predicate new:\'P\').\r\t\t\t\t\t\t\r\t"for unary predicates"\r\tself assert: (prop fullClausification = res).\r\t\r\tprop := (Predicate new:\'P\').\r\tres := (Predicate new:\'P\').\r\r\t"for variadic predicates"\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 19:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T19:35:04.665526+01:00' ],		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ],		#time : DateAndTime [ '2018-12-07T19:35:04.675695+01:00' ],		#trigger : @3	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t\r\tprop := Or new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := Or new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 19:14',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\tprop := Or new: (Predicate new: \'P\') rightProp: (Predicate new: \'Q\').\r\tres := Or new: (Predicate new: \'P\') rightProp: (Predicate new: \'Q\').\r\tself assert: prop fullClausification equals: res',			#stamp : 'pm 12/7/2018 19:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T19:35:28.501176+01:00' ],		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ],		#time : DateAndTime [ '2018-12-07T19:35:28.512438+01:00' ],		#trigger : @3	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationImply,			#protocol : #Clausification,			#sourceCode : 'testClausificationImply\r\t| prop res |\r\t\r\tprop := Imply new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := Or new:(Not new: (Predicate new:\'P\'))\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 19:14',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationImply,			#protocol : #Clausification,			#sourceCode : 'testClausificationImply\r\t| prop res |\r\tprop := Imply\r\t\tnew: (Predicate new: \'P\')\r\t\trightProp: (Predicate new: \'Q\').\r\tres := Or\r\t\tnew: (Not new: (Predicate new: \'P\'))\r\t\trightProp: (Predicate new: \'Q\').\r\tself assert: prop fullClausification equals: res',			#stamp : 'pm 12/7/2018 19:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T19:35:47.998816+01:00' ],		#prior : OmReference [ '72' ],		#self : OmReference [ '73' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 19:14',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 19:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T19:35:57.567826+01:00' ],		#prior : OmReference [ '73' ],		#self : OmReference [ '74' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #Clausification,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := Or new:(And new:\r\t    \t\t      \t\t\t(Predicate new:\'P\')\r\t\t\t\t\t\t    rightProp:\r\t\t\t\t\t         (Predicate new:\'Q\'))\r\t\t\t\trightProp:(And new:\r          \t\t\t(Not new: (Predicate new:\'P\'))\r\t\t\t\t     rightProp:\r\t\t\t          (Not new:(Predicate new:\'Q\'))).\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 19:14',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #Clausification,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := Or new:(And new:\r\t    \t\t      \t\t\t(Predicate new:\'P\')\r\t\t\t\t\t\t    rightProp:\r\t\t\t\t\t         (Predicate new:\'Q\'))\r\t\t\t\trightProp:(And new:\r          \t\t\t(Not new: (Predicate new:\'P\'))\r\t\t\t\t     rightProp:\r\t\t\t          (Not new:(Predicate new:\'Q\'))).\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 19:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T19:47:48.719196+01:00' ],		#prior : OmReference [ '74' ],		#self : OmReference [ '75' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationPredicate,			#protocol : #Clausification,			#sourceCode : 'testClausificationPredicate\r\t| prop res |\r\t"basic, should be  unafected by clausification"\r\t\r\t"for empty predicates"\r\tprop := (Predicate new:\'P\').\r\tres := (Predicate new:\'P\').\r\t\t\t\t\t\t\r\t"for unary predicates"\r\tself assert: (prop fullClausification = res).\r\t\r\tprop := (Predicate new:\'P\').\r\tres := (Predicate new:\'P\').\r\r\t"for variadic predicates"\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 19:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationPredicate,			#protocol : #Clausification,			#sourceCode : 'testClausificationPredicate\r\t| prop res |\r\t"basic, should be  unafected by clausification"\r\t\r\t"for empty predicates"\r\tprop := (Predicate new:\'P\').\r\tres := (Predicate new:\'P\').\r\t\t\t\t\t\t\r\t"for unary predicates"\r\tself assert: (prop fullClausification = res).\r\t\r\tprop := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\tres := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\r\t"for variadic predicates"\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 19:47',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T19:50:07.138432+01:00' ],		#prior : OmReference [ '75' ],		#self : OmReference [ '76' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationPredicate,			#protocol : #Clausification,			#sourceCode : 'testClausificationPredicate\r\t| prop res |\r\t"basic, should be  unafected by clausification"\r\t\r\t"for empty predicates"\r\tprop := (Predicate new:\'P\').\r\tres := (Predicate new:\'P\').\r\t\t\t\t\t\t\r\t"for unary predicates"\r\tself assert: (prop fullClausification = res).\r\t\r\tprop := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\tres := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\r\t"for variadic predicates"\r\tself assert: (prop fullClausification = res).',			#stamp : 'pm 12/7/2018 19:47',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationPredicate,			#protocol : #Clausification,			#sourceCode : 'testClausificationPredicate\r\t| prop res |\r\t"basic, should be  unafected by clausification"\r\t\r\t"for empty predicates"\r\tprop := (Predicate new:\'P\').\r\tres := (Predicate new:\'P\').\r\t\t\t\t\t\t\r\t"for unary predicates"\r\tself assert: (prop fullClausification = res).\r\t\r\tprop := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\tres := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\r\t"for variadic predicates"\r\tself assert: (prop fullClausification = res).\r\r\tprop := Predicate new:\'P\' fromList:\r          (LinkedList new \r               add:(Term new:\'a\');\r               add:(Term new:\'b\');\r               add:(Term new:\'c\');\r               add:(Term new:\'d\');\r               yourself).\r\tres := Predicate new:\'P\' fromList:\r          (LinkedList new \r               add:(Term new:\'a\');\r               add:(Term new:\'b\');\r               add:(Term new:\'c\');\r               add:(Term new:\'d\');\r               yourself).\r\r',			#stamp : 'pm 12/7/2018 19:50',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T19:50:40.883777+01:00' ],		#prior : OmReference [ '76' ],		#self : OmReference [ '77' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationPredicate,			#protocol : #Clausification,			#sourceCode : 'testClausificationPredicate\r\t| prop res |\r\t"basic, should be  unafected by clausification"\r\t\r\t"for empty predicates"\r\tprop := (Predicate new:\'P\').\r\tres := (Predicate new:\'P\').\r\t\t\t\t\t\t\r\t"for unary predicates"\r\tself assert: (prop fullClausification = res).\r\t\r\tprop := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\tres := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\r\t"for variadic predicates"\r\tself assert: (prop fullClausification = res).\r\r\tprop := Predicate new:\'P\' fromList:\r          (LinkedList new \r               add:(Term new:\'a\');\r               add:(Term new:\'b\');\r               add:(Term new:\'c\');\r               add:(Term new:\'d\');\r               yourself).\r\tres := Predicate new:\'P\' fromList:\r          (LinkedList new \r               add:(Term new:\'a\');\r               add:(Term new:\'b\');\r               add:(Term new:\'c\');\r               add:(Term new:\'d\');\r               yourself).\r\r',			#stamp : 'pm 12/7/2018 19:50',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationPredicate,			#protocol : #Clausification,			#sourceCode : 'testClausificationPredicate\r\t| prop res |\r\t"basic, should be  unafected by clausification"\r\t\r\t"for empty predicates"\r\tprop := (Predicate new:\'P\').\r\tres := (Predicate new:\'P\').\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).\r\t\r\t\t"for unary predicates"\r\tprop := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\tres := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\r\tself assert: (prop fullClausification = res).\r\r\t"for variadic predicates"\r\tprop := Predicate new:\'P\' fromList:\r          (LinkedList new \r               add:(Term new:\'a\');\r               add:(Term new:\'b\');\r               add:(Term new:\'c\');\r               add:(Term new:\'d\');\r               yourself).\r\tres := Predicate new:\'P\' fromList:\r          (LinkedList new \r               add:(Term new:\'a\');\r               add:(Term new:\'b\');\r               add:(Term new:\'c\');\r               add:(Term new:\'d\');\r               yourself).\r\r\t"for variadic predicates"\r\tself assert: (prop fullClausification = res).\r',			#stamp : 'pm 12/7/2018 19:50',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T19:53:10.356607+01:00' ],		#prior : OmReference [ '77' ],		#self : OmReference [ '78' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"abstract class, not meant to be instanciated"\r\tself halt.\r\t^SubclassResponsibility \r',			#stamp : 'pm 12/7/2018 17:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"abstract class, not meant to be instanciated"\r\t^SubclassResponsibility \r',			#stamp : 'pm 12/7/2018 19:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T19:58:09.618244+01:00' ],		#prior : OmReference [ '78' ],		#self : OmReference [ '79' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAtome,			#protocol : #Clausification,			#sourceCode : 'testClausificationAtome\r\t| prop res |\r\r\tprop := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\tres := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\r\tself assert: prop fullClausification equals: res.\r\t\r',			#stamp : 'pm 12/7/2018 19:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T19:58:23.188732+01:00' ],		#prior : OmReference [ '79' ],		#self : OmReference [ '80' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationPredicate,			#protocol : #Clausification,			#sourceCode : 'testClausificationPredicate\r\t| prop res |\r\t"basic, should be  unafected by clausification"\r\t\r\t"for empty predicates"\r\tprop := (Predicate new:\'P\').\r\tres := (Predicate new:\'P\').\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).\r\t\r\t\t"for unary predicates"\r\tprop := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\tres := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\r\tself assert: (prop fullClausification = res).\r\r\t"for variadic predicates"\r\tprop := Predicate new:\'P\' fromList:\r          (LinkedList new \r               add:(Term new:\'a\');\r               add:(Term new:\'b\');\r               add:(Term new:\'c\');\r               add:(Term new:\'d\');\r               yourself).\r\tres := Predicate new:\'P\' fromList:\r          (LinkedList new \r               add:(Term new:\'a\');\r               add:(Term new:\'b\');\r               add:(Term new:\'c\');\r               add:(Term new:\'d\');\r               yourself).\r\r\t"for variadic predicates"\r\tself assert: (prop fullClausification = res).\r',			#stamp : 'pm 12/7/2018 19:50',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationPredicate,			#protocol : #Clausification,			#sourceCode : 'testClausificationPredicate\r\t| prop res |\r\t"basic, should be  unafected by clausification"\r\t\r\t"for empty predicates"\r\tprop := (Predicate new:\'P\').\r\tres := (Predicate new:\'P\').\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).\r\t\r\t\t"for unary predicates"\r\tprop := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\tres := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\r\tself assert: (prop fullClausification = res).\r\r\t"for variadic predicates"\r\tprop := Predicate new:\'P\' fromList:\r          (LinkedList new \r               add:(Term new:\'a\');\r               add:(Term new:\'b\');\r               add:(Term new:\'c\');\r               add:(Term new:\'d\');\r               yourself).\r\tres := Predicate new:\'P\' fromList:\r          (LinkedList new \r               add:(Term new:\'a\');\r               add:(Term new:\'b\');\r               add:(Term new:\'c\');\r               add:(Term new:\'d\');\r               yourself).\r\r\t"for variadic predicates"\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/7/2018 19:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T19:58:51.420746+01:00' ],		#prior : OmReference [ '80' ],		#self : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationPredicate,			#protocol : #Clausification,			#sourceCode : 'testClausificationPredicate\r\t| prop res |\r\t"basic, should be  unafected by clausification"\r\t\r\t"for empty predicates"\r\tprop := (Predicate new:\'P\').\r\tres := (Predicate new:\'P\').\r\t\t\t\t\t\t\r\tself assert: (prop fullClausification = res).\r\t\r\t\t"for unary predicates"\r\tprop := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\tres := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\r\tself assert: (prop fullClausification = res).\r\r\t"for variadic predicates"\r\tprop := Predicate new:\'P\' fromList:\r          (LinkedList new \r               add:(Term new:\'a\');\r               add:(Term new:\'b\');\r               add:(Term new:\'c\');\r               add:(Term new:\'d\');\r               yourself).\r\tres := Predicate new:\'P\' fromList:\r          (LinkedList new \r               add:(Term new:\'a\');\r               add:(Term new:\'b\');\r               add:(Term new:\'c\');\r               add:(Term new:\'d\');\r               yourself).\r\r\t"for variadic predicates"\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/7/2018 19:58',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationPredicate,			#protocol : #Clausification,			#sourceCode : 'testClausificationPredicate\r\t| prop res |\r\t"basic, should be  unafected by clausification"\r\t\r\t"for empty predicates"\r\tprop := (Predicate new:\'P\').\r\tres := (Predicate new:\'P\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t\t"for unary predicates"\r\tprop := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\tres := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\r\tself assert: prop fullClausification equals: res.\r\r\t"for variadic predicates"\r\tprop := Predicate new:\'P\' fromList:\r          (LinkedList new \r               add:(Term new:\'a\');\r               add:(Term new:\'b\');\r               add:(Term new:\'c\');\r               add:(Term new:\'d\');\r               yourself).\r\tres := Predicate new:\'P\' fromList:\r          (LinkedList new \r               add:(Term new:\'a\');\r               add:(Term new:\'b\');\r               add:(Term new:\'c\');\r               add:(Term new:\'d\');\r               yourself).\r\r\t"for variadic predicates"\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/7/2018 19:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T20:02:48.241565+01:00' ],		#prior : OmReference [ '81' ],		#self : OmReference [ '82' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNot,			#protocol : #Clausification,			#sourceCode : 'testClausificationNot\r\t| prop res |\r\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/7/2018 20:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T20:03:02.550224+01:00' ],		#prior : OmReference [ '82' ],		#self : OmReference [ '83' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAtome,			#protocol : #Clausification,			#sourceCode : 'testClausificationAtome\r\t| prop res |\r\r\tprop := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\tres := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\r\tself assert: prop fullClausification equals: res.\r\t\r',			#stamp : 'pm 12/7/2018 19:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T20:06:49.23374+01:00' ],		#prior : OmReference [ '83' ],		#self : OmReference [ '84' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherAtome',			#stamp : 'pm 12/7/2018 17:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T20:07:05.522781+01:00' ],		#prior : OmReference [ '84' ],		#self : OmReference [ '85' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'=',			#protocol : #'as yet unclassified',			#sourceCode : '= anotherAtome\r\tself class = anotherAtome class.',			#stamp : 'pm 12/7/2018 20:07',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T20:07:05.698826+01:00' ],		#prior : OmReference [ '85' ],		#self : OmReference [ '86' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'=',			#protocol : #'as yet unclassified',			#sourceCode : '= anotherAtome\r\tself class = anotherAtome class.',			#stamp : 'pm 12/7/2018 20:07',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherAtome\r\tself class = anotherAtome class.',			#stamp : 'pm 12/7/2018 20:07',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T20:14:33.803645+01:00' ],		#prior : OmReference [ '86' ],		#self : OmReference [ '87' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Atome',				#traitCompositionSource : '{}',				#definitionSource : 'Atome subclass: #Constant\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Constant,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Constant class\r\tinstanceVariableNames: \'symb\''				},				#name : #'Constant class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Constant class',							#isMetaSide : true						},						#name : #symb,						#parent : @12					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Constant,					#isMetaSide : false				},				#parent : @7,				#content : 'True and False constants, to represent them in Propositions\r\r',				#stamp : 'pm 10/9/2018 11:07'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Atome',				#traitCompositionSource : '{}',				#definitionSource : 'Atome subclass: #Constant\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Constant,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Constant class\r\tinstanceVariableNames: \'\''				},				#name : #'Constant class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Constant,					#isMetaSide : false				},				#parent : @23,				#content : 'True and False constants, to represent them in Propositions\r\r',				#stamp : 'pm 10/9/2018 11:07'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T20:14:41.122861+01:00' ],		#prior : OmReference [ '87' ],		#self : OmReference [ '88' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Atome',				#traitCompositionSource : '{}',				#definitionSource : 'Atome subclass: #Constant\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Constant,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Constant class\r\tinstanceVariableNames: \'\''				},				#name : #'Constant class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Constant,					#isMetaSide : false				},				#parent : @7,				#content : 'True and False constants, to represent them in Propositions\r\r',				#stamp : 'pm 10/9/2018 11:07'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Atome',				#traitCompositionSource : '{}',				#definitionSource : 'Atome subclass: #Constant\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Constant,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Constant class\r\tinstanceVariableNames: \'\''				},				#name : #'Constant class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Constant,					#isMetaSide : false				},				#parent : @21,				#content : 'True and False constants, to represent them in Propositions\r\r',				#stamp : 'pm 10/9/2018 11:07'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T20:17:04.856024+01:00' ],		#prior : OmReference [ '88' ],		#self : OmReference [ '89' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNot,			#protocol : #Clausification,			#sourceCode : 'testClausificationNot\r\t| prop res |\r\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/7/2018 20:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNot,			#protocol : #Clausification,			#sourceCode : 'testClausificationNot\r\t| prop res |\r\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification = res.\r\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/7/2018 20:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T20:17:45.415272+01:00' ],		#prior : OmReference [ '89' ],		#self : OmReference [ '90' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherAtome\r\tself class = anotherAtome class.',			#stamp : 'pm 12/7/2018 20:07',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherAtome\r\t^self class = anotherAtome class.',			#stamp : 'pm 12/7/2018 20:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T20:17:48.869816+01:00' ],		#prior : OmReference [ '90' ],		#self : OmReference [ '91' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNot,			#protocol : #Clausification,			#sourceCode : 'testClausificationNot\r\t| prop res |\r\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification = res.\r\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/7/2018 20:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNot,			#protocol : #Clausification,			#sourceCode : 'testClausificationNot\r\t| prop res |\r\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification equals res.\r\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/7/2018 20:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T20:17:50.160632+01:00' ],		#prior : OmReference [ '91' ],		#self : OmReference [ '92' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNot,			#protocol : #Clausification,			#sourceCode : 'testClausificationNot\r\t| prop res |\r\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification equals res.\r\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/7/2018 20:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNot,			#protocol : #Clausification,			#sourceCode : 'testClausificationNot\r\t| prop res |\r\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/7/2018 20:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T20:43:18.593939+01:00' ],		#prior : OmReference [ '92' ],		#self : OmReference [ '93' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #Clausification,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := Or new:(And new:\r\t    \t\t      \t\t\t(Predicate new:\'P\')\r\t\t\t\t\t\t    rightProp:\r\t\t\t\t\t         (Predicate new:\'Q\'))\r\t\t\t\trightProp:(And new:\r          \t\t\t(Not new: (Predicate new:\'P\'))\r\t\t\t\t     rightProp:\r\t\t\t          (Not new:(Predicate new:\'Q\'))).\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 19:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #Clausification,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t"basic test for equal\'s clausification"\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := Or new:(And new:\r\t    \t\t      \t\t\t(Predicate new:\'P\')\r\t\t\t\t\t\t    rightProp:\r\t\t\t\t\t         (Predicate new:\'Q\'))\r\t\t\t\trightProp:(And new:\r          \t\t\t(Not new: (Predicate new:\'P\'))\r\t\t\t\t     rightProp:\r\t\t\t          (Not new:(Predicate new:\'Q\'))).\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 20:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T20:43:45.340121+01:00' ],		#prior : OmReference [ '93' ],		#self : OmReference [ '94' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationImply,			#protocol : #Clausification,			#sourceCode : 'testClausificationImply\r\t| prop res |\r\tprop := Imply\r\t\tnew: (Predicate new: \'P\')\r\t\trightProp: (Predicate new: \'Q\').\r\tres := Or\r\t\tnew: (Not new: (Predicate new: \'P\'))\r\t\trightProp: (Predicate new: \'Q\').\r\tself assert: prop fullClausification equals: res',			#stamp : 'pm 12/7/2018 19:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationImply,			#protocol : #Clausification,			#sourceCode : 'testClausificationImply\r\t| prop res |\r\t\r\t"basic test for imply"\r\tprop := Imply\r\t\tnew: (Predicate new: \'P\')\r\t\trightProp: (Predicate new: \'Q\').\r\tres := Or\r\t\tnew: (Not new: (Predicate new: \'P\'))\r\t\trightProp: (Predicate new: \'Q\').\r\tself assert: prop fullClausification equals: res',			#stamp : 'pm 12/7/2018 20:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T20:43:50.242394+01:00' ],		#prior : OmReference [ '94' ],		#self : OmReference [ '95' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationImply,			#protocol : #Clausification,			#sourceCode : 'testClausificationImply\r\t| prop res |\r\t\r\t"basic test for imply"\r\tprop := Imply\r\t\tnew: (Predicate new: \'P\')\r\t\trightProp: (Predicate new: \'Q\').\r\tres := Or\r\t\tnew: (Not new: (Predicate new: \'P\'))\r\t\trightProp: (Predicate new: \'Q\').\r\tself assert: prop fullClausification equals: res',			#stamp : 'pm 12/7/2018 20:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationImply,			#protocol : #Clausification,			#sourceCode : 'testClausificationImply\r\t| prop res |\r\t\r\t"basic test for imply\'s clausification"\r\tprop := Imply\r\t\tnew: (Predicate new: \'P\')\r\t\trightProp: (Predicate new: \'Q\').\r\tres := Or\r\t\tnew: (Not new: (Predicate new: \'P\'))\r\t\trightProp: (Predicate new: \'Q\').\r\tself assert: prop fullClausification equals: res',			#stamp : 'pm 12/7/2018 20:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T20:45:06.850156+01:00' ],		#prior : OmReference [ '95' ],		#self : OmReference [ '96' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNot,			#protocol : #Clausification,			#sourceCode : 'testClausificationNot\r\t| prop res |\r\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/7/2018 20:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNot,			#protocol : #Clausification,			#sourceCode : 'testClausificationNot\r\t| prop res |\r\r\t"Complete test for the Not clausifications"\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/7/2018 20:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T20:45:28.276138+01:00' ],		#prior : OmReference [ '96' ],		#self : OmReference [ '97' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\tprop := Or new: (Predicate new: \'P\') rightProp: (Predicate new: \'Q\').\r\tres := Or new: (Predicate new: \'P\') rightProp: (Predicate new: \'Q\').\r\tself assert: prop fullClausification equals: res',			#stamp : 'pm 12/7/2018 19:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t\r\tprop := Or new: (Predicate new: \'P\') \r\t\t\t\t rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\') rightProp: (Predicate new: \'Q\').\r\t\r\tself assert: prop fullClausification equals: res',			#stamp : 'pm 12/7/2018 20:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T20:45:34.684191+01:00' ],		#prior : OmReference [ '97' ],		#self : OmReference [ '98' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t\r\tprop := Or new: (Predicate new: \'P\') \r\t\t\t\t rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\') rightProp: (Predicate new: \'Q\').\r\t\r\tself assert: prop fullClausification equals: res',			#stamp : 'pm 12/7/2018 20:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\') rightProp: (Predicate new: \'Q\').\r\t\r\tself assert: prop fullClausification equals: res',			#stamp : 'pm 12/7/2018 20:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T20:45:45.634902+01:00' ],		#prior : OmReference [ '98' ],		#self : OmReference [ '99' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\') rightProp: (Predicate new: \'Q\').\r\t\r\tself assert: prop fullClausification equals: res',			#stamp : 'pm 12/7/2018 20:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\r\tself assert: prop fullClausification equals: res',			#stamp : 'pm 12/7/2018 20:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T20:47:49.160063+01:00' ],		#prior : OmReference [ '99' ],		#self : OmReference [ '100' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\r\tself assert: prop fullClausification equals: res',			#stamp : 'pm 12/7/2018 20:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\r\tself assert: prop fullClausification equals: res',			#stamp : 'pm 12/7/2018 20:47',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T20:50:24.901244+01:00' ],		#prior : OmReference [ '100' ],		#self : OmReference [ '101' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\r\tself assert: prop fullClausification equals: res',			#stamp : 'pm 12/7/2018 20:47',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res',			#stamp : 'pm 12/7/2018 20:50',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T20:54:35.135634+01:00' ],		#prior : OmReference [ '101' ],		#self : OmReference [ '102' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res',			#stamp : 'pm 12/7/2018 20:50',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\tprop := Not new:\r     (And new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= Or new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\t\r\tprop:=Not new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= And new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/7/2018 20:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T20:55:18.890481+01:00' ],		#prior : OmReference [ '102' ],		#self : OmReference [ '103' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\tprop := Not new:\r     (And new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= Or new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\t\r\tprop:=Not new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= And new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/7/2018 20:54',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\tprop := Not new:\r     (And new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= Or new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\t\r',			#stamp : 'pm 12/7/2018 20:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T20:55:35.789547+01:00' ],		#prior : OmReference [ '103' ],		#self : OmReference [ '104' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNot,			#protocol : #Clausification,			#sourceCode : 'testClausificationNot\r\t| prop res |\r\r\t"Complete test for the Not clausifications"\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/7/2018 20:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNot,			#protocol : #Clausification,			#sourceCode : 'testClausificationNot\r\t| prop res |\r\r\t"Complete test for the Not clausifications"\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r\t\r\tprop:=Not new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= And new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r',			#stamp : 'pm 12/7/2018 20:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T20:56:35.078246+01:00' ],		#prior : OmReference [ '104' ],		#self : OmReference [ '105' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNot,			#protocol : #Clausification,			#sourceCode : 'testClausificationNot\r\t| prop res |\r\r\t"Complete test for the Not clausifications"\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r\t\r\tprop:=Not new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= And new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r',			#stamp : 'pm 12/7/2018 20:55',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNot,			#protocol : #Clausification,			#sourceCode : 'testClausificationNot\r\t| prop res |\r\r\t"Complete test for the Not clausifications"\r\t\r\t"Polarity inversion"\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"Polarity inversion #2"\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"cancel Not"\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r\t\r\t"Not on an Or"\r\tprop:=Not new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= And new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r',			#stamp : 'pm 12/7/2018 20:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T20:56:47.881612+01:00' ],		#prior : OmReference [ '105' ],		#self : OmReference [ '106' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\tprop := Not new:\r     (And new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= Or new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\t\r',			#stamp : 'pm 12/7/2018 20:55',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r',			#stamp : 'pm 12/7/2018 20:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T20:57:08.251884+01:00' ],		#prior : OmReference [ '106' ],		#self : OmReference [ '107' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNot,			#protocol : #Clausification,			#sourceCode : 'testClausificationNot\r\t| prop res |\r\r\t"Complete test for the Not clausifications"\r\t\r\t"Polarity inversion"\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"Polarity inversion #2"\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"cancel Not"\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r\t\r\t"Not on an Or"\r\tprop:=Not new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= And new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r',			#stamp : 'pm 12/7/2018 20:56',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNot,			#protocol : #Clausification,			#sourceCode : 'testClausificationNot\r\t| prop res |\r\r\t"Complete test for the Not clausifications"\r\t\r\t"Polarity inversion"\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"Polarity inversion #2"\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"cancel Not"\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r\t\r\t"Not on an Or"\r\tprop:=Not new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= And new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r\t"Not on an And"\r\tprop := Not new:\r     (And new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= Or new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\t\r\r',			#stamp : 'pm 12/7/2018 20:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T21:04:30.973048+01:00' ],		#prior : OmReference [ '107' ],		#self : OmReference [ '108' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r',			#stamp : 'pm 12/7/2018 20:56',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 21:04',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T21:06:15.74858+01:00' ],		#prior : OmReference [ '108' ],		#self : OmReference [ '109' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 21:04',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of an or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 21:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T21:09:05.510312+01:00' ],		#prior : OmReference [ '109' ],		#self : OmReference [ '110' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of an or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 21:06',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of an or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"P() /\\ T -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 21:09',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T21:10:07.722332+01:00' ],		#prior : OmReference [ '110' ],		#self : OmReference [ '111' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #And,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t| t |\r\tt:=nil.\r \t((And patternFalse) matchPatternWith: self)\r\tifTrue:[t:=right]\r\tifFalse:[\r\t\t((And patternFalseSym) matchPatternWith: self)\r\t\tifTrue:[t:=left]\r\t\tifFalse:[\r\t\t\t((And patternTrue) matchPatternWith: self)\r\t\t\tifTrue:[t:=left]\r\t\t\tifFalse:[\r\t\t\t\t((And patternTrueSym) matchPatternWith: self)\r\t\t\t\tifTrue:[t:=right]\r\t\t\t\tifFalse:["\r\t\t\t\t\t((And patternOr) matchPatternWith: self)\r\t\t\t\t\tifTrue:[t:=Or new: (And new: ((self left) left) rightProp: (self right)) \r\t\t\t\t\t\t\t\t  rightProp: (And new:((self left) right) rightProp: (self right))]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t((And patternOrSym) matchPatternWith: self)\r\t\t\t\t\t\tifTrue:[t:=Or new:(And new: (self left) rightProp: ((self right) left)) \r\t\t\t\t\t\t\t\t\t  rightProp: (And new: (self left) rightProp: ((self right) right))].\r\t\t\t\t\t\t]\r\t\t\t\t\t"]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\t\t(t isNil) ifTrue:[ (Prop debug) ifTrue:[Transcript show:\'in And\';show: self prettyPrint;cr.].\r\t\t\tself left:(left clausification).\r\t\t\t\t\t\t\t\tself right:(right clausification).\r\t\t\t\t\t\t\t\t^self]\r\t\t\t\t\t ifFalse:[(Prop debug) ifTrue:[Transcript show:\'in And2\';show: t prettyPrint;cr.].\r\t\t\t\t\t\t^t "clausification"]. ',			#stamp : 'pm 10/1/2018 11:09',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #And,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t| t |\r\tt:=nil.\r \t((And patternFalse) matchPatternWith: self)\r\tifTrue:[t:=right]\r\tifFalse:[\r\t\t((And patternFalseSym) matchPatternWith: self)\r\t\tifTrue:[t:=left]\r\t\tifFalse:[\r\t\t\t((And patternTrue) matchPatternWith: self)\r\t\t\tifTrue:[t:=left]\r\t\t\tifFalse:[\r\t\t\t\t((And patternTrueSym) matchPatternWith: self)\r\t\t\t\tifTrue:[t:=right]\r\t\t\t\tifFalse:[]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\t\t(t isNil) ifTrue:[ (Prop debug) ifTrue:[Transcript show:\'in And\';show: self prettyPrint;cr.].\r\t\t\tself left:(left clausification).\r\t\t\t\t\t\t\t\tself right:(right clausification).\r\t\t\t\t\t\t\t\t^self]\r\t\t\t\t\t ifFalse:[(Prop debug) ifTrue:[Transcript show:\'in And2\';show: t prettyPrint;cr.].\r\t\t\t\t\t\t^t "clausification"]. ',			#stamp : 'pm 12/7/2018 21:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T21:11:05.529541+01:00' ],		#prior : OmReference [ '111' ],		#self : OmReference [ '112' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'And class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialize,			#sourceCode : 'initialize\r\t"Choosing the graphical symbol"\r\tsymb:=\'/\\\'.\r\t\t\r\t"patterns used for clausification.\r\tSince we\'re in a binary operator, we have represent it, to fit in one variable."\r\tpatternOr:=And new: (Or new: (Var new: \'a\') rightProp: (Var new:(\'a\')))  rightProp: (Var new: \'a\').\r\tpatternOrSym:=And new: (Var new: \'a\') rightProp: (Or new: (Var new: \'a\') rightProp: (Var new:(\'a\'))).\r\tpatternTrue:=And new: (Var new: \'a\') rightProp: (True_Const new).\r\tpatternTrueSym:=And new: (True_Const new) rightProp:(Var new:\'a\').\r\tpatternFalse:=And new: (Var new: \'a\') rightProp: (False_Const new).\r\tpatternFalseSym:=And new: (False_Const new) rightProp:(Var new:\'a\').',			#stamp : 'pm 11/27/2018 12:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'And class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialize,			#sourceCode : 'initialize\r\t"Choosing the graphical symbol"\r\tsymb:=\'/\\\'.\r\t\t\r\t"patterns used for clausification.\r\tSince we\'re in a binary operator, we have represent it, to fit in one variable."\r"\tpatternOr:=And new: (Or new: (Var new: \'a\') rightProp: (Var new:(\'a\')))  rightProp: (Var new: \'a\').\r\tpatternOrSym:=And new: (Var new: \'a\') rightProp: (Or new: (Var new: \'a\') rightProp: (Var new:(\'a\')))."\r\tpatternTrue:=And new: (Var new: \'a\') rightProp: (True_Const new).\r\tpatternTrueSym:=And new: (True_Const new) rightProp:(Var new:\'a\').\r\tpatternFalse:=And new: (Var new: \'a\') rightProp: (False_Const new).\r\tpatternFalseSym:=And new: (False_Const new) rightProp:(Var new:\'a\').',			#stamp : 'pm 12/7/2018 21:11',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T21:11:54.290545+01:00' ],		#prior : OmReference [ '112' ],		#self : OmReference [ '113' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'And class',				#isMetaSide : true			},			#name : #patternOr,			#protocol : #accessing,			#sourceCode : 'patternOr\t\r\t"accessor"\r\t^patternOr',			#stamp : 'pm 11/27/2018 18:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T21:11:57.849712+01:00' ],		#prior : OmReference [ '113' ],		#self : OmReference [ '114' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'And class',				#isMetaSide : true			},			#name : #patternOrSym,			#protocol : #accessing,			#sourceCode : 'patternOrSym\t\r\t"accessor"\r\t^patternOrSym',			#stamp : 'pm 11/27/2018 18:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T21:12:03.319572+01:00' ],		#prior : OmReference [ '114' ],		#self : OmReference [ '115' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'And class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialize,			#sourceCode : 'initialize\r\t"Choosing the graphical symbol"\r\tsymb:=\'/\\\'.\r\t\t\r\t"patterns used for clausification.\r\tSince we\'re in a binary operator, we have represent it, to fit in one variable."\r"\tpatternOr:=And new: (Or new: (Var new: \'a\') rightProp: (Var new:(\'a\')))  rightProp: (Var new: \'a\').\r\tpatternOrSym:=And new: (Var new: \'a\') rightProp: (Or new: (Var new: \'a\') rightProp: (Var new:(\'a\')))."\r\tpatternTrue:=And new: (Var new: \'a\') rightProp: (True_Const new).\r\tpatternTrueSym:=And new: (True_Const new) rightProp:(Var new:\'a\').\r\tpatternFalse:=And new: (Var new: \'a\') rightProp: (False_Const new).\r\tpatternFalseSym:=And new: (False_Const new) rightProp:(Var new:\'a\').',			#stamp : 'pm 12/7/2018 21:11',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'And class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialize,			#sourceCode : 'initialize\r\t"Choosing the graphical symbol"\r\tsymb:=\'/\\\'.\r\t\t\r\t"patterns used for clausification.\r\tSince we\'re in a binary operator, we have represent it, to fit in one variable."\r\r\tpatternTrue:=And new: (Var new: \'a\') rightProp: (True_Const new).\r\tpatternTrueSym:=And new: (True_Const new) rightProp:(Var new:\'a\').\r\tpatternFalse:=And new: (Var new: \'a\') rightProp: (False_Const new).\r\tpatternFalseSym:=And new: (False_Const new) rightProp:(Var new:\'a\').',			#stamp : 'pm 12/7/2018 21:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T21:12:04.577126+01:00' ],		#prior : OmReference [ '115' ],		#self : OmReference [ '116' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'And class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialize,			#sourceCode : 'initialize\r\t"Choosing the graphical symbol"\r\tsymb:=\'/\\\'.\r\t\t\r\t"patterns used for clausification.\r\tSince we\'re in a binary operator, we have represent it, to fit in one variable."\r\r\tpatternTrue:=And new: (Var new: \'a\') rightProp: (True_Const new).\r\tpatternTrueSym:=And new: (True_Const new) rightProp:(Var new:\'a\').\r\tpatternFalse:=And new: (Var new: \'a\') rightProp: (False_Const new).\r\tpatternFalseSym:=And new: (False_Const new) rightProp:(Var new:\'a\').',			#stamp : 'pm 12/7/2018 21:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'And class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialize,			#sourceCode : 'initialize\r\t"Choosing the graphical symbol"\r\tsymb:=\'/\\\'.\r\t\t\r\t"patterns used for clausification.\r\tSince we\'re in a binary operator, we have represent it, to fit in one variable."\r\tpatternTrue:=And new: (Var new: \'a\') rightProp: (True_Const new).\r\tpatternTrueSym:=And new: (True_Const new) rightProp:(Var new:\'a\').\r\tpatternFalse:=And new: (Var new: \'a\') rightProp: (False_Const new).\r\tpatternFalseSym:=And new: (False_Const new) rightProp:(Var new:\'a\').',			#stamp : 'pm 12/7/2018 21:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T21:12:31.872201+01:00' ],		#prior : OmReference [ '116' ],		#self : OmReference [ '117' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of an or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"P() /\\ T -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 21:09',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of an or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"P() /\\ T -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ F -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 21:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T21:14:17.845283+01:00' ],		#prior : OmReference [ '117' ],		#self : OmReference [ '118' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of an or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"P() /\\ T -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ F -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 21:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of an or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t\r',			#stamp : 'pm 12/7/2018 21:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T21:14:21.363522+01:00' ],		#prior : OmReference [ '118' ],		#self : OmReference [ '119' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 19:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ T -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ F -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/7/2018 21:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T21:14:35.718013+01:00' ],		#prior : OmReference [ '119' ],		#self : OmReference [ '120' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ T -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ F -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/7/2018 21:14',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\t""\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ T -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ F -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/7/2018 21:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T21:14:51.556488+01:00' ],		#prior : OmReference [ '120' ],		#self : OmReference [ '121' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of an or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t\r',			#stamp : 'pm 12/7/2018 21:14',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of a clausified or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t\r',			#stamp : 'pm 12/7/2018 21:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T21:15:05.198594+01:00' ],		#prior : OmReference [ '121' ],		#self : OmReference [ '122' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\t""\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ T -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ F -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/7/2018 21:14',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\t"stability of a clausified and"\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ T -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ F -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/7/2018 21:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T21:18:02.488811+01:00' ],		#prior : OmReference [ '122' ],		#self : OmReference [ '123' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\t"stability of a clausified and"\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ T -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ F -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/7/2018 21:15',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\t"stability of a clausified and"\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ T -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ F -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\r\t"P() /\\ T -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F /\\ P() -> F"\t\r\tprop := And new: (False_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 21:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T21:18:12.058348+01:00' ],		#prior : OmReference [ '123' ],		#self : OmReference [ '124' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\t"stability of a clausified and"\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ T -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ F -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\r\t"P() /\\ T -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F /\\ P() -> F"\t\r\tprop := And new: (False_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 21:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\t"stability of a clausified and"\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ T -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ F -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\r\t"P() /\\ T -> T"\t\r\tprop := And new: (True_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F /\\ P() -> F"\t\r\tprop := And new: (False_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 21:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T21:18:25.679499+01:00' ],		#prior : OmReference [ '124' ],		#self : OmReference [ '125' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\t"stability of a clausified and"\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ T -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ F -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\r\t"P() /\\ T -> T"\t\r\tprop := And new: (True_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F /\\ P() -> F"\t\r\tprop := And new: (False_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 21:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\t"stability of a clausified and"\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ T -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ F -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T /\\ P() -> P()"\t\r\tprop := And new: (True_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F /\\ P() -> F"\t\r\tprop := And new: (False_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 21:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T21:18:39.855214+01:00' ],		#prior : OmReference [ '125' ],		#self : OmReference [ '126' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\t"stability of a clausified and"\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ T -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ F -> T"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T /\\ P() -> P()"\t\r\tprop := And new: (True_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F /\\ P() -> F"\t\r\tprop := And new: (False_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 21:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\t"stability of a clausified and"\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ T -> P()"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ F -> F"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T /\\ P() -> P()"\t\r\tprop := And new: (True_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F /\\ P() -> F"\t\r\tprop := And new: (False_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 21:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T21:20:21.228179+01:00' ],		#prior : OmReference [ '126' ],		#self : OmReference [ '127' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of a clausified or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t\r',			#stamp : 'pm 12/7/2018 21:14',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of a clausified or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T \\/ P()-> T"\r\tprop := Or new: (True_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r',			#stamp : 'pm 12/7/2018 21:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T21:20:49.970839+01:00' ],		#prior : OmReference [ '127' ],		#self : OmReference [ '128' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of a clausified or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T \\/ P()-> T"\r\tprop := Or new: (True_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r',			#stamp : 'pm 12/7/2018 21:20',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of a clausified or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T \\/ P()-> T"\r\tprop := Or new: (True_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F \\/ P() -> P()"\t\t\r\tprop := Or new: (False_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r',			#stamp : 'pm 12/7/2018 21:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T21:30:07.787351+01:00' ],		#prior : OmReference [ '128' ],		#self : OmReference [ '129' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of a clausified or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T \\/ P()-> T"\r\tprop := Or new: (True_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F \\/ P() -> P()"\t\t\r\tprop := Or new: (False_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r',			#stamp : 'pm 12/7/2018 21:20',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of a clausified or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T \\/ P()-> T"\r\tprop := Or new: (True_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F \\/ P() -> P()"\t\t\r\tprop := Or new: (False_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\tprop:=Or new:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     )\r\trightProp:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r\tprop :=Or new:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r',			#stamp : 'pm 12/7/2018 21:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T21:33:36.149327+01:00' ],		#prior : OmReference [ '129' ],		#self : OmReference [ '130' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of a clausified or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T \\/ P()-> T"\r\tprop := Or new: (True_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F \\/ P() -> P()"\t\t\r\tprop := Or new: (False_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\tprop:=Or new:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     )\r\trightProp:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r\tprop :=Or new:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r',			#stamp : 'pm 12/7/2018 21:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of a clausified or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T \\/ P()-> T"\r\tprop := Or new: (True_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F \\/ P() -> P()"\t\t\r\tprop := Or new: (False_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"Or\'s distributivity"\r\tprop:=Or new:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     )\r\trightProp:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r\t"And the symetric. No need to overide res, it\'s the same"\r\tprop :=Or new:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r',			#stamp : 'pm 12/7/2018 21:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T21:35:17.190332+01:00' ],		#prior : OmReference [ '130' ],		#self : OmReference [ '131' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of a clausified or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T \\/ P()-> T"\r\tprop := Or new: (True_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F \\/ P() -> P()"\t\t\r\tprop := Or new: (False_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"Or\'s distributivity"\r\tprop:=Or new:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     )\r\trightProp:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r\t"And the symetric. No need to overide res, it\'s the same"\r\tprop :=Or new:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r',			#stamp : 'pm 12/7/2018 21:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of a clausified or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T \\/ P()-> T"\r\tprop := Or new: (True_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F \\/ P() -> P()"\t\t\r\tprop := Or new: (False_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"Or\'s distributivity"\r\tprop:=Or new:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     )\r\trightProp:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r\t"And the symetric. No need to overide res, it\'s the same"\r\tprop :=Or new:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     ).\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\rrightProp:\r     (Or new:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r',			#stamp : 'pm 12/7/2018 21:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T21:35:29.304068+01:00' ],		#prior : OmReference [ '131' ],		#self : OmReference [ '132' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of a clausified or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T \\/ P()-> T"\r\tprop := Or new: (True_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F \\/ P() -> P()"\t\t\r\tprop := Or new: (False_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"Or\'s distributivity"\r\tprop:=Or new:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     )\r\trightProp:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r\t"And the symetric. No need to overide res, it\'s the same"\r\tprop :=Or new:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     ).\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\rrightProp:\r     (Or new:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r',			#stamp : 'pm 12/7/2018 21:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of a clausified or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T \\/ P()-> T"\r\tprop := Or new: (True_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F \\/ P() -> P()"\t\t\r\tprop := Or new: (False_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"Or\'s distributivity"\r\tprop:=Or new:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     )\r\trightProp:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r\t"And the symetric. "\r\tprop :=Or new:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     ).\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Or new:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r',			#stamp : 'pm 12/7/2018 21:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T21:52:57.915624+01:00' ],		#prior : OmReference [ '132' ],		#self : OmReference [ '133' ]	},	#content : EpProtocolAddition {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #Skolemn_test\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #Skolemn_test,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Skolemn_test class\r\tinstanceVariableNames: \'\''				},				#name : #'Skolemn_test class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Skolemn_test,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #isClause	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T22:03:36.651742+01:00' ],		#prior : OmReference [ '133' ],		#self : OmReference [ '134' ]	},	#content : EpMonticelloVersionSave {		#versionName : '_resolution_1erOrdre-pm.1',		#repositoryDescription : '/home/ariale/FORM/pharo6.1-64/shared/pharo-local/package-cache'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-07T22:03:36.83472+01:00' ],		#prior : OmReference [ '134' ],		#self : OmReference [ '135' ]	},	#content : EpMonticelloVersionSave {		#versionName : '_resolution_1erOrdre-pm.1',		#repositoryDescription : '/home/ariale/FORM/pharo6.1-64/Sources'	}}