OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T13:08:26.713929+02:00' ],		#prior : OmReference [ 'Pharo.8g10siifxzc4w749fawtxpx37', '33' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'without:or:',			#protocol : #adding,			#sourceCode : 'without:index1 or:index2\r\t|i resClause|\r\tresClause:=Clause new.\r\ti:=1.\r\t\r\t[i<=self size]\r\twhileTrue:[\r\t\t(i~=index1 or:[i~=index2])\r\t\tifTrue:[\r\t\t\tTranscript show: (self at: i);show:\' \'.\r\t\t\tresClause add:(self at:i).\r\t\t\t].\r\t\ti:=i+1.\r\t\t].\r\t^resClause ',			#stamp : 'pm 10/26/2018 07:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'without:or:',			#protocol : #adding,			#sourceCode : 'without:index1 or:index2\r\t|i resClause|\r\tresClause:=Clause new.\r\ti:=1.\r\t\r\tTranscript show: self size;cr.\r\t[i<=self size]\r\twhileTrue:[\r\t\t(i~=index1 and:[i~=index2])\r\t\tifTrue:[\r\t\t\tTranscript show: (self at: i);show:\' \'.\r\t\t\tresClause add:(self at:i).\r\t\t\t].\r\t\ti:=i+1.\r\t\t].\r\tTranscript cr.\r\t^resClause ',			#stamp : 'pm 10/26/2018 13:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T13:08:40.611909+02:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r"\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\tTranscript show:newClause;cr.\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 07:36',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r"\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tTranscript show:newClause;cr.\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 13:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T13:08:48.703541+02:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'without:or:',			#protocol : #adding,			#sourceCode : 'without:index1 or:index2\r\t|i resClause|\r\tresClause:=Clause new.\r\ti:=1.\r\t\r\tTranscript show: self size;cr.\r\t[i<=self size]\r\twhileTrue:[\r\t\t(i~=index1 and:[i~=index2])\r\t\tifTrue:[\r\t\t\tTranscript show: (self at: i);show:\' \'.\r\t\t\tresClause add:(self at:i).\r\t\t\t].\r\t\ti:=i+1.\r\t\t].\r\tTranscript cr.\r\t^resClause ',			#stamp : 'pm 10/26/2018 13:08',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'without:or:',			#protocol : #adding,			#sourceCode : 'without:index1 or:index2\r\t|i resClause|\r\tresClause:=Clause new.\r\ti:=1.\r\t\r\t[i<=self size]\r\twhileTrue:[\r\t\t(i~=index1 and:[i~=index2])\r\t\tifTrue:[\r\t\t\tresClause add:(self at:i).\r\t\t\t].\r\t\ti:=i+1.\r\t\t].\r\t^resClause ',			#stamp : 'pm 10/26/2018 13:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T13:10:56.395731+02:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r"\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tTranscript show:newClause;cr.\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 13:08',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r"\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 13:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T13:16:25.428525+02:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tc factorisationUnitTest.\r\r\t\r"\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r."\r\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 07:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\tTranscript show:\'same predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))).\r\tc factorisationUnitTest.\r\r\r\tTranscript show:\'same predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\t\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 13:16',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T13:17:12.257603+02:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\tTranscript show:\'same predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))).\r\tc factorisationUnitTest.\r\r\r\tTranscript show:\'same predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\t\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 13:16',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\tTranscript show:\'same const predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same const predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\'))).\r\tc factorisationUnitTest.\r\r\r\tTranscript show:\'same predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\t\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 13:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T13:19:40.336928+02:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\tTranscript show:\'same const predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same const predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\'))).\r\tc factorisationUnitTest.\r\r\r\tTranscript show:\'same predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\t\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 13:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\tTranscript show:\'same const predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same linked predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tc factorisationUnitTest.\r\t\r\tTranscript show:\'Unnifiable const & linked predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tc factorisationUnitTest.\r\r\r\tTranscript show:\'same predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\t\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 13:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T13:20:01.806577+02:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #factorisationUnitTest,			#protocol : #testing,			#sourceCode : 'factorisationUnitTest\r\t|r fc|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tfc:=ClausalForm new:self.\r\tTranscript show: \'Trying to factorise \';show: fc ;cr.\r\tr:=Resolvante new.\r\t\r\tr factorisation: (fc at:1).\r\tTranscript show:r;cr.',			#stamp : 'pm 10/26/2018 07:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #factorisationUnitTest,			#protocol : #testing,			#sourceCode : 'factorisationUnitTest\r\t|r fc|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tfc:=ClausalForm new:self.\r\tTranscript show: \'Trying to factorise \';show: fc ;cr.\r\tr:=Resolvante new.\r\t\r\tr factorisation: (fc at:1).\r\tTranscript show:r;cr;cr;cr.',			#stamp : 'pm 10/26/2018 13:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T13:23:03.278676+02:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\tTranscript show:\'same const predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same linked predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tc factorisationUnitTest.\r\t\r\tTranscript show:\'Unnifiable const & linked predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tc factorisationUnitTest.\r\r\r\tTranscript show:\'same predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\t\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 13:19',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\r\tTranscript show:\'Unnifiable const & linked predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tc factorisationUnitTest.\r\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\t\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 13:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T13:29:37.491899+02:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\r\tTranscript show:\'Unnifiable const & linked predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tc factorisationUnitTest.\r\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\t\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 13:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\r\tTranscript show:\'Unifiable positive const & linked predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'Unifiable negative const & linked predicate\';cr.\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\r\t\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 13:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T13:51:34.756588+02:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isOppositePolarity:',			#protocol : #comparing,			#sourceCode : 'isOppositePolarity: anotherPredicate\r\t^((anotherPredicate isPredicate) and:[(anotherPredicate isKindOf: self class) not])."checking the input"',			#stamp : 'pm 10/26/2018 13:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T14:20:25.342831+02:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSamePolarity:',			#protocol : #comparing,			#sourceCode : 'isSamePolarity: anotherPredicate\r\t^((anotherPredicate isPredicate) and:[anotherPredicate isKindOf: self class])."checking the input"',			#stamp : 'pm 10/26/2018 14:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T14:21:57.855104+02:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r"\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 13:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t(sub1=sub2)\r\t\t\t\tifTrue:[\r\t\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 14:21',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T14:23:25.108109+02:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSamePolarity:',			#protocol : #comparing,			#sourceCode : 'isSamePolarity: anotherPredicate\r\t^((anotherPredicate isPredicate) and:[anotherPredicate isKindOf: self class])."checking the input"',			#stamp : 'pm 10/26/2018 14:20',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSamePolarity:',			#protocol : #comparing,			#sourceCode : 'isSamePolarity: anotherPredicate\r\t^((anotherPredicate isPredicate) and:[anotherPredicate isNotPredicate])."checking the input"',			#stamp : 'pm 10/26/2018 14:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T14:24:19.94806+02:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #NotPredicate,				#isMetaSide : false			},			#name : #'isSamePolarity:',			#protocol : #'as yet unclassified',			#sourceCode : 'isSamePolarity: anotherPredicate\r\t^((anotherPredicate isPredicate) and:[anotherPredicate isNotPredicate])."checking the input"',			#stamp : 'pm 10/26/2018 14:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T14:24:20.107639+02:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #NotPredicate,				#isMetaSide : false			},			#name : #'isSamePolarity:',			#protocol : #'as yet unclassified',			#sourceCode : 'isSamePolarity: anotherPredicate\r\t^((anotherPredicate isPredicate) and:[anotherPredicate isNotPredicate])."checking the input"',			#stamp : 'pm 10/26/2018 14:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #NotPredicate,				#isMetaSide : false			},			#name : #'isSamePolarity:',			#protocol : #testing,			#sourceCode : 'isSamePolarity: anotherPredicate\r\t^((anotherPredicate isPredicate) and:[anotherPredicate isNotPredicate])."checking the input"',			#stamp : 'pm 10/26/2018 14:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T14:24:31.69355+02:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #NotPredicate,				#isMetaSide : false			},			#name : #'isSamePolarity:',			#protocol : #testing,			#sourceCode : 'isSamePolarity: anotherPredicate\r\t^((anotherPredicate isPredicate) and:[anotherPredicate isNotPredicate])."checking the input"',			#stamp : 'pm 10/26/2018 14:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #NotPredicate,				#isMetaSide : false			},			#name : #'isSamePolarity:',			#protocol : #testing,			#sourceCode : 'isSamePolarity: anotherPredicate\r\t^((anotherPredicate isNotPredicate) and:[anotherPredicate isPredicate])."checking the input"',			#stamp : 'pm 10/26/2018 14:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T14:24:58.703654+02:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #NotPredicate,				#isMetaSide : false			},			#name : #'isSamePolarity:',			#protocol : #testing,			#sourceCode : 'isSamePolarity: anotherPredicate\r\t^((anotherPredicate isNotPredicate) and:[anotherPredicate isPredicate])."checking the input"',			#stamp : 'pm 10/26/2018 14:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #NotPredicate,				#isMetaSide : false			},			#name : #'isSamePolarity:',			#protocol : #testing,			#sourceCode : 'isSamePolarity: anotherPredicate\r\t^((self isNotPredicate) and:[(anotherPredicate isPredicate) not])."checking the input"',			#stamp : 'pm 10/26/2018 14:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T14:25:18.071043+02:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSamePredicate:',			#protocol : #testing,			#sourceCode : 'isSamePredicate: predicate\r\t"deprecated."\r\t^(self getSymb)=(predicate getSymb)',			#stamp : 'pm 10/17/2018 12:31',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T14:25:54.953309+02:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSamePolarity:',			#protocol : #comparing,			#sourceCode : 'isSamePolarity: anotherPredicate\r\t^((anotherPredicate isPredicate) and:[anotherPredicate isNotPredicate])."checking the input"',			#stamp : 'pm 10/26/2018 14:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSamePolarity:',			#protocol : #comparing,			#sourceCode : 'isSamePolarity: anotherPredicate\r\t^((self isPredicate) and:[anotherPredicate isNotPredicate])."checking the input"',			#stamp : 'pm 10/26/2018 14:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T14:44:43.559909+02:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #NotPredicate,				#isMetaSide : false			},			#name : #'isSamePolarity:',			#protocol : #testing,			#sourceCode : 'isSamePolarity: anotherPredicate\r\t^((self isNotPredicate) and:[(anotherPredicate isPredicate) not])."checking the input"',			#stamp : 'pm 10/26/2018 14:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T15:05:27.614587+02:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isOppositePolarity:',			#protocol : #comparing,			#sourceCode : 'isOppositePolarity: anotherPredicate\r\t^((anotherPredicate isPredicate) and:[(anotherPredicate isKindOf: self class) not])."checking the input"',			#stamp : 'pm 10/26/2018 13:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isOppositePolarity:',			#protocol : #comparing,			#sourceCode : 'isOppositePolarity: anotherPredicate\r\t^((anotherPredicate isPredicate) and:[(anotherPredicate class = self class) not])."checking the input"',			#stamp : 'pm 10/26/2018 15:05',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T15:14:56.012531+02:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSamePolarity:',			#protocol : #comparing,			#sourceCode : 'isSamePolarity: anotherPredicate\r\t^((self isPredicate) and:[anotherPredicate isNotPredicate])."checking the input"',			#stamp : 'pm 10/26/2018 14:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSamePolarity:',			#protocol : #comparing,			#sourceCode : 'isSamePolarity: anotherPredicate\r\t^((anotherPredicate isPredicate) and:[self class = anotherPredicate])."checking the input"',			#stamp : 'pm 10/26/2018 15:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T15:49:27.175256+02:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSamePolarity:',			#protocol : #comparing,			#sourceCode : 'isSamePolarity: anotherPredicate\r\t^((anotherPredicate isPredicate) and:[self class = anotherPredicate])."checking the input"',			#stamp : 'pm 10/26/2018 15:14',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isSamePolarity:',			#protocol : #comparing,			#sourceCode : 'isSamePolarity: anotherPredicate\r\t^((anotherPredicate isPredicate) and:[self class = anotherPredicate class])."checking the input"',			#stamp : 'pm 10/26/2018 15:49',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T16:36:15.37917+02:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\r\tTranscript show:\'Unifiable positive const & linked predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'Unifiable negative const & linked predicate\';cr.\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\r\t\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 13:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\r\tTranscript show:\'Unifiable positive const & linked predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'Unifiable negative const & linked predicate\';cr.\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 16:36',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T16:37:24.895782+02:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\r\tTranscript show:\'Unifiable positive const & linked predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'Unifiable negative const & linked predicate\';cr.\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 16:36',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\r\tTranscript show:\'Unifiable positive const & linked predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'Unifiable negative const & linked predicate\';cr.\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\t"add multiple possible resolutions clauses"\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 16:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T16:37:29.312006+02:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\r\tTranscript show:\'Unifiable positive const & linked predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'Unifiable negative const & linked predicate\';cr.\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\t"add multiple possible resolutions clauses"\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 16:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\r\tTranscript show:\'Unifiable positive const & linked predicate\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'Unifiable negative const & linked predicate\';cr.\r\tc:=Or new:(Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp:(Not new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\tTranscript show:\'same predicate, different polarity\';cr.\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Not new:(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')))).\r\tc factorisationUnitTest.\r\r\t"add multiple possible resolutions clauses next"\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 16:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T16:38:43.317129+02:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ],		#time : DateAndTime [ '2018-10-26T16:38:43.330257+02:00' ],		#trigger : @3	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isOppositePolarity:',			#protocol : #comparing,			#sourceCode : 'isOppositePolarity: anotherPredicate\r\t^((anotherPredicate isPredicate) and:[(anotherPredicate class = self class) not])."checking the input"',			#stamp : 'pm 10/26/2018 15:05',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isOppositePolarity:',			#protocol : #comparing,			#sourceCode : 'isOppositePolarity: anotherPredicate\r\t^ anotherPredicate isPredicate\r\t\tand: [ anotherPredicate class ~= self class ]\t"checking the input"',			#stamp : 'pm 10/26/2018 16:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T16:38:53.638179+02:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isOppositePolarity:',			#protocol : #comparing,			#sourceCode : 'isOppositePolarity: anotherPredicate\r\t^ anotherPredicate isPredicate\r\t\tand: [ anotherPredicate class ~= self class ]\t"checking the input"',			#stamp : 'pm 10/26/2018 16:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'isOppositePolarity:',			#protocol : #comparing,			#sourceCode : 'isOppositePolarity: anotherPredicate\r\t^ anotherPredicate isPredicate\tand: [ anotherPredicate class ~= self class ]',			#stamp : 'pm 10/26/2018 16:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T16:52:06.786638+02:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'without:nor:',			#protocol : #adding,			#sourceCode : 'without:index1 nor:index2\r\t|i resClause|\r\tresClause:=Clause new.\r\ti:=1.\r\t\r\t[i<=self size]\r\twhileTrue:[\r\t\t(i~=index1 and:[i~=index2])\r\t\tifTrue:[\r\t\t\tresClause add:(self at:i).\r\t\t\t].\r\t\ti:=i+1.\r\t\t].\r\t^resClause ',			#stamp : 'pm 10/26/2018 16:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T16:52:10.861383+02:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'without:or:',			#protocol : #adding,			#sourceCode : 'without:index1 or:index2\r\t|i resClause|\r\tresClause:=Clause new.\r\ti:=1.\r\t\r\t[i<=self size]\r\twhileTrue:[\r\t\t(i~=index1 and:[i~=index2])\r\t\tifTrue:[\r\t\t\tresClause add:(self at:i).\r\t\t\t].\r\t\ti:=i+1.\r\t\t].\r\t^resClause ',			#stamp : 'pm 10/26/2018 13:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T16:52:14.572283+02:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #methodeDeResolution,			#sourceCode : 'resolvante: clause1 with: clause2\r\t^self error:\'todo\'.',			#stamp : 'pm 10/25/2018 20:56',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #methodeDeResolution,			#sourceCode : 'resolvante: aClause1 with: aClause2\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause1 size). ]\r\twhileTrue:[\r\t\ta1:=aClause1 at:i.\r\t\t\r\t\tj:=1.\r\t\t[ j<=(aClause2 size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause2 at:j.\r\r\t\t\t(a1 isOppositePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t(sub1=sub2)\r\t\t\t\tifTrue:[\r\t\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\t\tnewClause addFromList: (aClause1 without:i).\r\t\t\t\t\tnewClause addFromList: (aClause2 without:j).\r\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 16:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T16:52:18.878765+02:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t(sub1=sub2)\r\t\t\t\tifTrue:[\r\t\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 14:21',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t(sub1=sub2)\r\t\t\t\tifTrue:[\r\t\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\t\tnewClause addFromList: (aClause without:i nor:j).\r\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 16:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T16:52:32.000104+02:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'without:',			#protocol : #adding,			#sourceCode : 'without:index1\r\t|i resClause|\r\tresClause:=Clause new.\r\ti:=1.\r\t\r\t[i<=self size]\r\twhileTrue:[\r\t\t(i~=index1)\r\t\tifTrue:[\r\t\t\tresClause add:(self at:i).\r\t\t\t].\r\t\ti:=i+1.\r\t\t].\r\t^resClause ',			#stamp : 'pm 10/26/2018 16:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T16:52:35.489524+02:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'without:',			#protocol : #adding,			#sourceCode : 'without:index1\r\t|i resClause|\r\tresClause:=Clause new.\r\ti:=1.\r\t\r\t[i<=self size]\r\twhileTrue:[\r\t\t(i~=index1)\r\t\tifTrue:[\r\t\t\tresClause add:(self at:i).\r\t\t\t].\r\t\ti:=i+1.\r\t\t].\r\t^resClause ',			#stamp : 'pm 10/26/2018 16:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'without:',			#protocol : #adding,			#sourceCode : 'without:index\r\t|i resClause|\r\tresClause:=Clause new.\r\ti:=1.\r\t\r\t[i<=self size]\r\twhileTrue:[\r\t\t(i~=index)\r\t\tifTrue:[\r\t\t\tresClause add:(self at:i).\r\t\t\t].\r\t\ti:=i+1.\r\t\t].\r\t^resClause ',			#stamp : 'pm 10/26/2018 16:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T17:00:17.771468+02:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #methodeDeResolution,			#sourceCode : 'resolvante: aClause1 with: aClause2\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause1 size). ]\r\twhileTrue:[\r\t\ta1:=aClause1 at:i.\r\t\t\r\t\tj:=1.\r\t\t[ j<=(aClause2 size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause2 at:j.\r\r\t\t\t(a1 isOppositePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t(sub1=sub2)\r\t\t\t\tifTrue:[\r\t\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\t\tnewClause addFromList: (aClause1 without:i).\r\t\t\t\t\tnewClause addFromList: (aClause2 without:j).\r\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 16:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #methodeDeResolution,			#sourceCode : 'resolvante: aClause1 with: aClause2\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\t\r\t[ i<=(aClause1 size). ]\r\twhileTrue:[\r\t\ta1:=aClause1 at:i.\r\t\t\r\t\tj:=1.\r\t\t[ j<=(aClause2 size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause2 at:j.\r\r\t\t\t(a1 isOppositePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t(sub1=sub2)\r\t\t\t\tifTrue:[\r\t\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\t\tnewClause addFromList: (aClause1 without:i).\r\t\t\t\t\tnewClause addFromList: (aClause2 without:j).\r\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 17:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T17:16:20.677703+02:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'factorisationUnitTest:',			#protocol : #testing,			#sourceCode : 'factorisationUnitTest: anotherClause\r\t|r fc1 fc2|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tfc1:=ClausalForm new:self.\r\tfc2:=ClausalForm new:anotherClause.\r\tTranscript show: \'Trying to resolve \';show: fc1 ; show:\' with \';show: fc2; cr.\r\tr:=Resolvante new.\r\t\r\tr resolvante: (fc1 at:1) with: (fc2 at:1).\r\tTranscript show:r;cr;cr;cr.',			#stamp : 'pm 10/26/2018 17:16',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T17:42:04.613113+02:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'factorisationUnitTest:',			#protocol : #testing,			#sourceCode : 'factorisationUnitTest: anotherClause\r\t|r fc1 fc2|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tfc1:=ClausalForm new:self.\r\tfc2:=ClausalForm new:anotherClause.\r\tTranscript show: \'Trying to resolve \';show: fc1 ; show:\' with \';show: fc2; cr.\r\tr:=Resolvante new.\r\t\r\tr resolvante: (fc1 at:1) with: (fc2 at:1).\r\tTranscript show:r;cr;cr;cr.',			#stamp : 'pm 10/26/2018 17:16',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'factorisationUnitTest:',			#protocol : #testing,			#sourceCode : 'factorisationUnitTest: anotherClause\r\t"We expect self and anotherClause to be clauses, or at minimal a clausal form."\r\t|r fc1 fc2|\r\tself assert: [ self isClause ].\r\tanotherClause assert:[ self isClause ].\r\t\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tfc1:=ClausalForm new:self.\r\tfc2:=ClausalForm new:anotherClause.\r\tTranscript show: \'Trying to resolve \';show: fc1 ; show:\' with \';show: fc2; cr.\r\tr:=Resolvante new.\r\t\r\tr resolvante: (fc1 at:1) with: (fc2 at:1).\r\tTranscript show:r;cr;cr;cr.',			#stamp : 'pm 10/26/2018 17:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T17:54:14.520449+02:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #resolvanteUnitTest,			#protocol : #testing,			#sourceCode : 'resolvanteUnitTest\r\t|r fc|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tfc:=ClausalForm new:self.\r\tr:=Resolvante new.\r\tr factorisation: (fc at:1).\r\tTranscript show:r;cr.\r\t^self error:\'todo\'.',			#stamp : 'pm 10/26/2018 07:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #resolvanteUnitTest,			#protocol : #testing,			#sourceCode : 'resolvanteUnitTest\r\t|r fc|\r\tProp testInc.\r\tself assert:[self isClause.].\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tfc:=ClausalForm new:self.\r\tr:=Resolvante new.\r\tr factorisation: (fc at:1).\r\tTranscript show:r;cr.\r\t^self error:\'todo\'.',			#stamp : 'pm 10/26/2018 17:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T17:55:13.850055+02:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #resolvanteUnitTest,			#protocol : #testing,			#sourceCode : 'resolvanteUnitTest\r\t|r fc|\r\tProp testInc.\r\tself assert:[self isClause.].\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tfc:=ClausalForm new:self.\r\tr:=Resolvante new.\r\tr factorisation: (fc at:1).\r\tTranscript show:r;cr.\r\t^self error:\'todo\'.',			#stamp : 'pm 10/26/2018 17:54',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #resolvanteUnitTest,			#protocol : #testing,			#sourceCode : 'resolvanteUnitTest\r\t|r fc|\r\tProp testInc.\r\tself assert:[self isClause.].\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tfc:=ClausalForm new:self.\r\tr:=Resolvante new.\r\tr factorisation: (fc at:1).\r\tTranscript show:r;cr.',			#stamp : 'pm 10/26/2018 17:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T17:56:01.899857+02:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #ResolvanteUnitTest,			#protocol : #testing,			#sourceCode : 'ResolvanteUnitTest\r\t|r|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \'; show: self;cr.\r\tr:=Resolvante new.\r\tr factorisation:self.\r\t\r\tTranscript show:r;cr.',			#stamp : 'pm 10/26/2018 07:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T17:56:07.103697+02:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #factorisationUnitTest,			#protocol : #testing,			#sourceCode : 'factorisationUnitTest\r\t|r fc|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tfc:=ClausalForm new:self.\r\tTranscript show: \'Trying to factorise \';show: fc ;cr.\r\tr:=Resolvante new.\r\t\r\tr factorisation: (fc at:1).\r\tTranscript show:r;cr;cr;cr.',			#stamp : 'pm 10/26/2018 13:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T18:15:28.345304+02:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingResolvante,			#protocol : #testing,			#sourceCode : 'testingResolvante\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|l r|\r\t\r\tTranscript show: \'Testing resolvante related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\r\tTranscript show:\'Unifiable positive const & linked predicate\';cr.\r\tl:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\t\r\t\r\tl factorisationUnitTest r.\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 18:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T18:35:13.858071+02:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #factorisationUnitTest,			#protocol : #testing,			#sourceCode : 'factorisationUnitTest\r\t|r fc|\r\tProp testInc.\r\tself assert:[self isClause.].\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tfc:=ClausalForm new:self.\r\tr:=Resolvante new.\r\tr factorisation: (fc at:1).\r\tTranscript show:r;cr.',			#stamp : 'pm 10/26/2018 18:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T18:35:29.977422+02:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'resolvanteUnitTest:',			#protocol : #testing,			#sourceCode : 'resolvanteUnitTest: anotherClause\r\t"We expect self and anotherClause to be clauses, or at minimal a clausal form."\r\t|r fc1 fc2|\r\tself assert: [ self isClause ].\r\tanotherClause assert:[ self isClause ].\r\t\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tfc1:=ClausalForm new:self.\r\tfc2:=ClausalForm new:anotherClause.\r\tTranscript show: \'Trying to resolve \';show: fc1 ; show:\' with \';show: fc2; cr.\r\tr:=Resolvante new.\r\t\r\tr resolvante: (fc1 at:1) with: (fc2 at:1).\r\tTranscript show:r;cr;cr;cr.',			#stamp : 'pm 10/26/2018 18:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T18:38:01.461206+02:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'factorisationUnitTest:',			#protocol : #testing,			#sourceCode : 'factorisationUnitTest: anotherClause\r\t"We expect self and anotherClause to be clauses, or at minimal a clausal form."\r\t|r fc1 fc2|\r\tself assert: [ self isClause ].\r\tanotherClause assert:[ self isClause ].\r\t\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tfc1:=ClausalForm new:self.\r\tfc2:=ClausalForm new:anotherClause.\r\tTranscript show: \'Trying to resolve \';show: fc1 ; show:\' with \';show: fc2; cr.\r\tr:=Resolvante new.\r\t\r\tr resolvante: (fc1 at:1) with: (fc2 at:1).\r\tTranscript show:r;cr;cr;cr.',			#stamp : 'pm 10/26/2018 17:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T18:38:06.889846+02:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #resolvanteUnitTest,			#protocol : #testing,			#sourceCode : 'resolvanteUnitTest\r\t|r fc|\r\tProp testInc.\r\tself assert:[self isClause.].\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tfc:=ClausalForm new:self.\r\tr:=Resolvante new.\r\tr factorisation: (fc at:1).\r\tTranscript show:r;cr.',			#stamp : 'pm 10/26/2018 17:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T18:38:36.336601+02:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #factorisationUnitTest,			#protocol : #testing,			#sourceCode : 'factorisationUnitTest\r\t|r fc|\r\tProp testInc.\r\tself assert:[self isClause.].\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tfc:=ClausalForm new:self.\r\tr:=Resolvante new.\r\tr factorisation: (fc at:1).\r\tTranscript show:r;cr.',			#stamp : 'pm 10/26/2018 18:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #factorisationUnitTest,			#protocol : #testing,			#sourceCode : 'factorisationUnitTest\r\t|r fc|\r\tProp testInc.\r\tself assert:[self isClause.].\r\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\t\r\tfc:=ClausalForm new:self.\r\tr:=Resolvante new.\r\tr factorisation: (fc at:1).\r\t\r\t\r\tTranscript show:r;cr;cr;cr.',			#stamp : 'pm 10/26/2018 18:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T18:45:08.733066+02:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingResolvante,			#protocol : #testing,			#sourceCode : 'testingResolvante\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|l r|\r\t\r\tTranscript show: \'Testing resolvante related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\r\tTranscript show:\'Unifiable positive const & linked predicate\';cr.\r\tl:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\t\r\t\r\tl factorisationUnitTest r.\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 18:15',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingResolvante,			#protocol : #testing,			#sourceCode : 'testingResolvante\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|l r|\r\t\r\tTranscript show: \'Testing resolvante related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\r\tTranscript show:\'Unifiable positive const & linked predicate\';cr.\r\tl:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tr:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\t\r\tl resolvanteUnitTest r.\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 18:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T19:22:38.457271+02:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testEverything,			#protocol : #testing,			#sourceCode : 'testEverything\r\tTranscript clear.\r\tProp initEverything.\r\t"Prop testingProp."\r\t"Prop testingMatch."\r\t"Prop testingClausification."\r\r\r"\tProp testingSkolemn.\r\tProp testingUnification."\r\tProp testingFactorisation.',			#stamp : 'pm 10/26/2018 07:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testEverything,			#protocol : #testing,			#sourceCode : 'testEverything\r\tTranscript clear.\r\tProp initEverything.\r\t"Prop testingProp."\r\t"Prop testingMatch."\r\t"Prop testingClausification."\r\tProp testingFactorisation.\r\tProp testingResolvante.\r\r"\tProp testingSkolemn.\r\tProp testingUnification."\r',			#stamp : 'pm 10/26/2018 19:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T19:23:06.32055+02:00' ],		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingResolvante,			#protocol : #testing,			#sourceCode : 'testingResolvante\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|l r|\r\t\r\tTranscript show: \'Testing resolvante related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\r\tTranscript show:\'Unifiable positive const & linked predicate\';cr.\r\tl:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tr:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\t\r\tl resolvanteUnitTest r.\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 18:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingResolvante,			#protocol : #testing,			#sourceCode : 'testingResolvante\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|l r|\r\t\r\tTranscript show: \'Testing resolvante related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\r\tTranscript show:\'Unifiable positive const & linked predicate\';cr.\r\tl:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tr:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\t\r\tl resolvanteUnitTest:r.\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 19:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T20:43:35.708247+02:00' ],		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingResolvante,			#protocol : #testing,			#sourceCode : 'testingResolvante\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|l r|\r\t\r\tTranscript show: \'Testing resolvante related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\r\tTranscript show:\'Unifiable positive const & linked predicate\';cr.\r\tl:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tr:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\t\r\tl resolvanteUnitTest:r.\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 19:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingResolvante,			#protocol : #testing,			#sourceCode : 'testingResolvante\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|l r|\r\t\r\tTranscript show: \'Testing resolvante related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\r\tTranscript show:\'Unifiable positive const & linked predicate\';cr.\r\tl:=Or new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))\r\t rightProp: (Predicate new: \'Q\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tr:=Or new: (Predicate new: \'P\' variable: (Not new: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp: (Predicate new: \'Q\' variable: (Not new: (ConstTerm new:(Term new:\'a\')))).\t\r\tl resolvanteUnitTest:r.\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 20:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T20:47:25.612791+02:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingResolvante,			#protocol : #testing,			#sourceCode : 'testingResolvante\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|l r|\r\t\r\tTranscript show: \'Testing resolvante related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\r\tTranscript show:\'Unifiable positive const & linked predicate\';cr.\r\tl:=Or new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))\r\t rightProp: (Predicate new: \'Q\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tr:=Or new: (Predicate new: \'P\' variable: (Not new: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp: (Predicate new: \'Q\' variable: (Not new: (ConstTerm new:(Term new:\'a\')))).\t\r\tl resolvanteUnitTest:r.\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 20:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingResolvante,			#protocol : #testing,			#sourceCode : 'testingResolvante\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|l r|\r\t\r\tTranscript show: \'Testing resolvante related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\r\tTranscript show:\'Class exemple.\';cr.\r\tl:=Or new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))\r\t rightProp: (Predicate new: \'Q\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tr:=Or new: (Predicate new: \'P\' variable: (Not new: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp: (Predicate new: \'Q\' variable: (Not new: (ConstTerm new:(Term new:\'a\')))).\t\r\tl resolvanteUnitTest:r.\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 20:47',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T20:50:19.514734+02:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingResolvante,			#protocol : #testing,			#sourceCode : 'testingResolvante\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|l r|\r\t\r\tTranscript show: \'Testing resolvante related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\r\tTranscript show:\'Class exemple.\';cr.\r\tl:=Or new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))\r\t rightProp: (Predicate new: \'Q\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tr:=Or new: (Predicate new: \'P\' variable: (Not new: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp: (Predicate new: \'Q\' variable: (Not new: (ConstTerm new:(Term new:\'a\')))).\t\r\tl resolvanteUnitTest:r.\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 20:47',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingResolvante,			#protocol : #testing,			#sourceCode : 'testingResolvante\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|l r|\r\t\r\tTranscript show: \'Testing resolvante related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\r\tTranscript show:\'Class exemple.\';cr.\r\tl:=Or new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))\r\t rightProp: (Predicate new: \'Q\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tr:=Or new: (Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp: (Not new: (Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')))).\t\r\tl resolvanteUnitTest:r.\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 20:50',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T21:00:17.09097+02:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr.\r\t"r:=Resolvante new.\r\tr factorisation: (t at:1).\r\tTranscript show:\'Factorisation\' ;show:r;cr;cr;cr."\r\t^t',			#stamp : 'pm 10/25/2018 20:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr.\r\tt:=t resolutionMethod.\r\r\tTranscript show:\'Factorisation\' ;show:t;cr;cr;cr.\r\t^t ',			#stamp : 'pm 10/26/2018 21:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T21:01:35.57843+02:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testEverything,			#protocol : #testing,			#sourceCode : 'testEverything\r\tTranscript clear.\r\tProp initEverything.\r\t"Prop testingProp."\r\t"Prop testingMatch."\r\t"Prop testingClausification."\r\tProp testingFactorisation.\r\tProp testingResolvante.\r\r"\tProp testingSkolemn.\r\tProp testingUnification."\r',			#stamp : 'pm 10/26/2018 19:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testEverything,			#protocol : #testing,			#sourceCode : 'testEverything\r\tTranscript clear.\r\tProp initEverything.\r\t"Prop testingProp."\r\t"Prop testingMatch."\r\t"Prop testingClausification."\r\tProp testingFactorisation.\r\tProp testingResolvante.\r\r\tProp testingSkolemn.\r"\tProp testingUnification."\r',			#stamp : 'pm 10/26/2018 21:01',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T21:08:29.4134+02:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c t |\r\tsat:=MinimalOrderedSet new.\r\t(self isEmpty)\r\twhileFalse: [ \r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:c.])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tt:= Resolvante new.\r\t\t\t\t\tt resolvante: c1 with: c.\r\t\t\t\t\tself addAll:t.\r\t\t\t\t\t].\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/25/2018 19:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse: [ \r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:c.])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addAll:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/26/2018 21:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T21:15:10.8869+02:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #isEmptyClause,			#protocol : #testing,			#sourceCode : 'isEmptyClause\r\t^self empty.',			#stamp : 'pm 10/25/2018 18:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #isEmptyClause,			#protocol : #testing,			#sourceCode : 'isEmptyClause\r\t^self isEmpty.',			#stamp : 'pm 10/26/2018 21:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T21:18:52.545905+02:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'addFromList:',			#protocol : #adding,			#sourceCode : 'addFromList: aLinkedList\r\taLinkedList do:[:each|\r\t\tself add: each.\r\t\t].',			#stamp : 'pm 10/25/2018 11:07',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T21:18:58.358658+02:00' ],		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addFromList:',			#protocol : #'as yet unclassified',			#sourceCode : 'addFromList: aLinkedList\r\taLinkedList do:[:each|\r\t\tself add: each.\r\t\t].',			#stamp : 'pm 10/26/2018 21:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T21:19:04.768355+02:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse: [ \r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:c.])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addAll:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/26/2018 21:08',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse: [ \r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:c.])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/26/2018 21:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T21:19:05.038041+02:00' ],		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addFromList:',			#protocol : #'as yet unclassified',			#sourceCode : 'addFromList: aLinkedList\r\taLinkedList do:[:each|\r\t\tself add: each.\r\t\t].',			#stamp : 'pm 10/26/2018 21:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addFromList:',			#protocol : #adding,			#sourceCode : 'addFromList: aLinkedList\r\taLinkedList do:[:each|\r\t\tself add: each.\r\t\t].',			#stamp : 'pm 10/26/2018 21:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T21:19:28.495656+02:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addFromList:',			#protocol : #adding,			#sourceCode : 'addFromList: aLinkedList\r\taLinkedList do:[:each|\r\t\tself add: each.\r\t\t].',			#stamp : 'pm 10/26/2018 21:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T21:19:37.087628+02:00' ],		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'addFromList:',			#protocol : #'as yet unclassified',			#sourceCode : 'addFromList: aLinkedList\r\taLinkedList do:[:each|\r\t\tself add: each.\r\t\t].',			#stamp : 'pm 10/26/2018 21:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T21:19:37.239139+02:00' ],		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'addFromList:',			#protocol : #'as yet unclassified',			#sourceCode : 'addFromList: aLinkedList\r\taLinkedList do:[:each|\r\t\tself add: each.\r\t\t].',			#stamp : 'pm 10/26/2018 21:19',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'addFromList:',			#protocol : #adding,			#sourceCode : 'addFromList: aLinkedList\r\taLinkedList do:[:each|\r\t\tself add: each.\r\t\t].',			#stamp : 'pm 10/26/2018 21:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T21:19:58.618224+02:00' ],		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse: [ \r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:c.])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/26/2018 21:19',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse: [ \r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:c.])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/26/2018 21:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T21:20:16.545001+02:00' ],		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'addFromList:',			#protocol : #adding,			#sourceCode : 'addFromList: aLinkedList\r\taLinkedList do:[:each|\r\t\tself add: each.\r\t\t].',			#stamp : 'pm 10/26/2018 21:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T21:20:22.093851+02:00' ],		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addFromList:',			#protocol : #'as yet unclassified',			#sourceCode : 'addFromList: aLinkedList\r\taLinkedList do:[:each|\r\t\tself add: each.\r\t\t].',			#stamp : 'pm 10/26/2018 21:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T21:20:22.385274+02:00' ],		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addFromList:',			#protocol : #'as yet unclassified',			#sourceCode : 'addFromList: aLinkedList\r\taLinkedList do:[:each|\r\t\tself add: each.\r\t\t].',			#stamp : 'pm 10/26/2018 21:20',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addFromList:',			#protocol : #adding,			#sourceCode : 'addFromList: aLinkedList\r\taLinkedList do:[:each|\r\t\tself add: each.\r\t\t].',			#stamp : 'pm 10/26/2018 21:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T21:28:05.408562+02:00' ],		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t(sub1=sub2)\r\t\t\t\tifTrue:[\r\t\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\t\tnewClause addFromList: (aClause without:i nor:j).\r\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 16:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t(sub1=sub2)\r\t\t\t\tifTrue:[\r\t\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\t\tnewClause add: (aClause without:i nor:j).\r\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 21:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T21:38:56.407391+02:00' ],		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t(sub1=sub2)\r\t\t\t\tifTrue:[\r\t\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\t\tnewClause add: (aClause without:i nor:j).\r\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 21:28',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t(sub1=sub2)\r\t\t\t\tifTrue:[\r\t\t\t\t\t"newClause:=Clause new.we create a new clause with everything but the Atomes used"\r\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 21:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T21:39:31.548667+02:00' ],		#prior : OmReference [ '72' ],		#self : OmReference [ '73' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t(sub1=sub2)\r\t\t\t\tifTrue:[\r\t\t\t\t\t"newClause:=Clause new.we create a new clause with everything but the Atomes used"\r\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 21:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t(sub1=sub2)\r\t\t\t\tifTrue:[\r\t\t\t\t\t"newClause:=Clause new. We create a new clause with everything but the Atomes used"\r\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 21:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T21:40:33.914214+02:00' ],		#prior : OmReference [ '73' ],		#self : OmReference [ '74' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #methodeDeResolution,			#sourceCode : 'resolvante: aClause1 with: aClause2\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\t\r\t[ i<=(aClause1 size). ]\r\twhileTrue:[\r\t\ta1:=aClause1 at:i.\r\t\t\r\t\tj:=1.\r\t\t[ j<=(aClause2 size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause2 at:j.\r\r\t\t\t(a1 isOppositePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t(sub1=sub2)\r\t\t\t\tifTrue:[\r\t\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\t\tnewClause addFromList: (aClause1 without:i).\r\t\t\t\t\tnewClause addFromList: (aClause2 without:j).\r\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 17:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #methodeDeResolution,			#sourceCode : 'resolvante: aClause1 with: aClause2\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\t\r\t[ i<=(aClause1 size). ]\r\twhileTrue:[\r\t\ta1:=aClause1 at:i.\r\t\t\r\t\tj:=1.\r\t\t[ j<=(aClause2 size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause2 at:j.\r\r\t\t\t(a1 isOppositePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t(sub1=sub2)\r\t\t\t\tifTrue:[\r\t\t\t\t\t"newClause:=Clause new.we create a new clause with everything but the Atomes used"\r\t\t\t\t\tnewClause:=(aClause1 without:i).\r\t\t\t\t\tnewClause addFromList: (aClause2 without:j).\r\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 21:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T21:46:11.298394+02:00' ],		#prior : OmReference [ '74' ],		#self : OmReference [ '75' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'addFromList:',			#protocol : #'as yet unclassified',			#sourceCode : 'addFromList: aLinkedList\r\taLinkedList do:[:each|\r\t\tself add: each.\r\t\t].',			#stamp : 'pm 10/26/2018 21:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T21:46:11.458283+02:00' ],		#prior : OmReference [ '75' ],		#self : OmReference [ '76' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'addFromList:',			#protocol : #'as yet unclassified',			#sourceCode : 'addFromList: aLinkedList\r\taLinkedList do:[:each|\r\t\tself add: each.\r\t\t].',			#stamp : 'pm 10/26/2018 21:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'addFromList:',			#protocol : #adding,			#sourceCode : 'addFromList: aLinkedList\r\taLinkedList do:[:each|\r\t\tself add: each.\r\t\t].',			#stamp : 'pm 10/26/2018 21:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T21:47:42.682635+02:00' ],		#prior : OmReference [ '76' ],		#self : OmReference [ '77' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse: [ \r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:c.])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/26/2018 21:19',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse: [ \r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:[c].])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/26/2018 21:47',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T22:11:57.528099+02:00' ],		#prior : OmReference [ '77' ],		#self : OmReference [ '78' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse: [ \r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:[c].])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/26/2018 21:47',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse: [ \r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/26/2018 22:11',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T22:12:27.57213+02:00' ],		#prior : OmReference [ '78' ],		#self : OmReference [ '79' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr.\r\tt:=t resolutionMethod.\r\r\tTranscript show:\'Factorisation\' ;show:t;cr;cr;cr.\r\t^t ',			#stamp : 'pm 10/26/2018 21:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr.\r\tt:=t resolutionMethod.\r\r\tTranscript show:\'Resolution method\' ;show:t;cr;cr;cr.\r\t^t ',			#stamp : 'pm 10/26/2018 22:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T22:12:38.052328+02:00' ],		#prior : OmReference [ '79' ],		#self : OmReference [ '80' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr.\r\tt:=t resolutionMethod.\r\r\tTranscript show:\'Resolution method\' ;show:t;cr;cr;cr.\r\t^t ',			#stamp : 'pm 10/26/2018 22:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr.\r\tt:=t resolutionMethod.\r\r\tTranscript show:\'Resolution method:\' ;show:t;cr;cr;cr.\r\t^t ',			#stamp : 'pm 10/26/2018 22:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T22:17:20.24204+02:00' ],		#prior : OmReference [ '80' ],		#self : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse: [ \r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/26/2018 22:11',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[ \r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/26/2018 22:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T22:25:19.387996+02:00' ],		#prior : OmReference [ '81' ],		#self : OmReference [ '82' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[ \r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/26/2018 22:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tTranscript show:self;cr.\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/26/2018 22:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T22:26:39.212058+02:00' ],		#prior : OmReference [ '82' ],		#self : OmReference [ '83' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\t[ modified ]\r\twhileTrue:[\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\t"TEMPORARY"\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t\r\t\t]. ',			#stamp : 'pm 10/21/2018 13:14',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\t[ modified ]\r\twhileTrue:[\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\t"Transcript show: \'Unification impossible\'; cr."\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t\r\t\t]. ',			#stamp : 'pm 10/26/2018 22:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T22:27:20.518689+02:00' ],		#prior : OmReference [ '83' ],		#self : OmReference [ '84' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:self;cr.\r\t(hasFailed)\r\tifTrue:[\r\t\tunifiedPair := nil."Failed to unify thing"\r\t\t].\r\r\tunifiedPair := initialPair veryDeepCopy.\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\t\tifTrue:["They both should be predicates, so they can use replace: by:"\r\t\t\t\t\t(unifiedPair left) replace: (each left) by: (each right).\r\t\t\t\t\t(unifiedPair right) replace: (each left) by: (each right).\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t"else it was already the same  predicate"',			#stamp : 'pm 10/25/2018 07:56',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t"Transcript show:self;cr."\r\t(hasFailed)\r\tifTrue:[\r\t\tunifiedPair := nil."Failed to unify thing"\r\t\t].\r\r\tunifiedPair := initialPair veryDeepCopy.\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\t\tifTrue:["They both should be predicates, so they can use replace: by:"\r\t\t\t\t\t(unifiedPair left) replace: (each left) by: (each right).\r\t\t\t\t\t(unifiedPair right) replace: (each left) by: (each right).\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t"else it was already the same  predicate"',			#stamp : 'pm 10/26/2018 22:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T22:27:41.067474+02:00' ],		#prior : OmReference [ '84' ],		#self : OmReference [ '85' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t"Transcript show:self;cr."\r\t(hasFailed)\r\tifTrue:[\r\t\tunifiedPair := nil."Failed to unify thing"\r\t\t].\r\r\tunifiedPair := initialPair veryDeepCopy.\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\t\tifTrue:["They both should be predicates, so they can use replace: by:"\r\t\t\t\t\t(unifiedPair left) replace: (each left) by: (each right).\r\t\t\t\t\t(unifiedPair right) replace: (each left) by: (each right).\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t"else it was already the same  predicate"',			#stamp : 'pm 10/26/2018 22:27',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t\r\t(hasFailed)\r\tifTrue:[\r\t\tunifiedPair := nil."Failed to unify thing"\r\t\t].\r\r\tunifiedPair := initialPair veryDeepCopy.\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\t\tifTrue:["They both should be predicates, so they can use replace: by:"\r\t\t\t\t\t(unifiedPair left) replace: (each left) by: (each right).\r\t\t\t\t\t(unifiedPair right) replace: (each left) by: (each right).\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t"else it was already the same  predicate"',			#stamp : 'pm 10/26/2018 22:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T22:29:51.121727+02:00' ],		#prior : OmReference [ '85' ],		#self : OmReference [ '86' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tTranscript show:self;cr.\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/26/2018 22:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tc:=self removeFirst.\r\t\tTranscript show:self;show:c;cr.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/26/2018 22:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T22:31:48.20316+02:00' ],		#prior : OmReference [ '86' ],		#self : OmReference [ '87' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2 |\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\r\tTranscript show: \'basic one #1\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'basic one #2\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'z\').\t\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\r\tTranscript show: \'with imply and nested forall.\'.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\'.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\'.\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' .\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r\tp SkolemnisationTest.\r\t\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest .\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/25/2018 17:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2 |\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\r\tTranscript show: \'basic one #1\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'basic one #2\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'z\').\t\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\r\tTranscript show: \'with imply and nested forall.\'.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\'.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\'.\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' .\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r\tp SkolemnisationTest.\r\t\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest .\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest.\r\t\r\tTranscript show:\'Class exemple.\';cr.\r\tp:=And new:(Or new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))\r\t rightProp: (Predicate new: \'Q\' variable: (LinkedTerm new:(Term new:\'x\'))))\r\trightProp:(Or new: (Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp: (Not new: (Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\'))))).\t\r\tp SkolemnisationTest.\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/26/2018 22:31',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T22:32:21.112203+02:00' ],		#prior : OmReference [ '87' ],		#self : OmReference [ '88' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialize,			#sourceCode : 'initialize:aTerm\r\t(aTerm isKindOf: Term)\r\tifFalse:[^Error new: (self class),\'Takes only Terms as parameters. This is a\', (aTerm class). ]\r\tifTrue:[term:=aTerm].',			#stamp : 'pm 10/11/2018 09:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialize,			#sourceCode : 'initialize:aTerm\r\t(aTerm isKindOf: Term)\r\tifFalse:[^self error:\'Takes only Terms as parameters. This is a\', (aTerm class). ]\r\tifTrue:[term:=aTerm].',			#stamp : 'pm 10/26/2018 22:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T22:35:51.785987+02:00' ],		#prior : OmReference [ '88' ],		#self : OmReference [ '89' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2 |\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\r\tTranscript show: \'basic one #1\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'basic one #2\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'z\').\t\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\r\tTranscript show: \'with imply and nested forall.\'.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\'.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\'.\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' .\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r\tp SkolemnisationTest.\r\t\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest .\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest.\r\t\r\tTranscript show:\'Class exemple.\';cr.\r\tp:=And new:(Or new: (Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')))\r\t rightProp: (Predicate new: \'Q\' variable: (LinkedTerm new:(Term new:\'x\'))))\r\trightProp:(Or new: (Not new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))))\r\t rightProp: (Not new: (Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\'))))).\t\r\tp SkolemnisationTest.\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/26/2018 22:31',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2 |\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\r\tTranscript show: \'basic one #1\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'basic one #2\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'z\').\t\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\r\tTranscript show: \'with imply and nested forall.\'.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\'.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\'.\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' .\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r\tp SkolemnisationTest.\r\t\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest .\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest.\r\t\r\tTranscript show:\'Class exemple.\';cr.\r\tp:=And new:(Or new: (Predicate new: \'P\' variable: (Term new:\'x\'))\r\t rightProp: (Predicate new: \'Q\' variable: (Term new:\'x\')))\r\trightProp:(Or new: (Not new: (Predicate new: \'P\' variable: (Term new:\'a\')))\r\t rightProp: (Not new: (Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/26/2018 22:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T22:37:03.62389+02:00' ],		#prior : OmReference [ '89' ],		#self : OmReference [ '90' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tc:=self removeFirst.\r\t\tTranscript show:self;show:c;cr.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/26/2018 22:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tTranscript show:self;cr.\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/26/2018 22:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T22:43:43.863181+02:00' ],		#prior : OmReference [ '90' ],		#self : OmReference [ '91' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2 |\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\r\tTranscript show: \'basic one #1\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'basic one #2\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'z\').\t\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\r\tTranscript show: \'with imply and nested forall.\'.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\'.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\'.\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' .\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r\tp SkolemnisationTest.\r\t\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest .\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest.\r\t\r\tTranscript show:\'Class exemple.\';cr.\r\tp:=And new:(Or new: (Predicate new: \'P\' variable: (Term new:\'x\'))\r\t rightProp: (Predicate new: \'Q\' variable: (Term new:\'x\')))\r\trightProp:(Or new: (Not new: (Predicate new: \'P\' variable: (Term new:\'a\')))\r\t rightProp: (Not new: (Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/26/2018 22:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2 |\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\r\tTranscript show: \'basic one #1\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'basic one #2\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'z\').\t\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\r\tTranscript show: \'with imply and nested forall.\'.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\'.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\'.\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' .\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r\tp SkolemnisationTest.\r\t\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest .\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest.\r\t\r\tTranscript show:\'Class exemple.\';cr.\r\tp:=Imply new: (And new: (Predicate new: \'P\' variable:(Term new: \'a\'))\r\t\t\t\t\t\t\trightProp: (Predicate new:\'Q\' variable:(Term new:\'b\')))\r\t rightProp: (Predicate new: \'P\' variable:(Term new: \'a\')).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/26/2018 22:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T22:44:36.217571+02:00' ],		#prior : OmReference [ '91' ],		#self : OmReference [ '92' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tTranscript show:self;cr.\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/26/2018 22:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tTranscript show:self;cr.\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[\t\tTranscript show:\'pouet\';cr.\r\t\t\t^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/26/2018 22:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T22:45:10.4371+02:00' ],		#prior : OmReference [ '92' ],		#self : OmReference [ '93' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tTranscript show:self;cr.\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[\t\tTranscript show:\'pouet\';cr.\r\t\t\t^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/26/2018 22:44',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tTranscript show:sat;cr.\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/26/2018 22:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T22:45:41.458591+02:00' ],		#prior : OmReference [ '93' ],		#self : OmReference [ '94' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tTranscript show:sat;cr.\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/26/2018 22:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tTranscript show:self;cr.\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/26/2018 22:45',			#package : #_resolution_1erOrdre		}	}}