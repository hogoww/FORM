OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:16:21.622282+02:00' ],		#prior : OmReference [ 'Pharo.9gfh9xku4v6ao28jodnwvgwp5', '72' ],		#self : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))).\r\tc FactorisationUnitTest.\r\r\t\r"\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r."\r\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 07:16',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:17:11.479628+02:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #ResolvanteUnitTest,			#protocol : #testing,			#sourceCode : 'ResolvanteUnitTest\r\t|r newPair|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tr:=Resolvante new.\r\tr factorisation: self.\r\t\r\tTranscript show:(r unifiedPair);cr.',			#stamp : 'pm 10/25/2018 18:31',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #ResolvanteUnitTest,			#protocol : #testing,			#sourceCode : 'ResolvanteUnitTest\r\t|r|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tr:=Resolvante new.\r\tr factorisation:self.\r\t\r\tTranscript show:r;cr.',			#stamp : 'pm 10/26/2018 07:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:17:53.026889+02:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testEverything,			#protocol : #testing,			#sourceCode : 'testEverything\r\tTranscript clear.\r\tProp initEverything.\r\t"Prop testingProp."\r\t"Prop testingMatch."\r\t"Prop testingClausification."\r\tProp testingSkolemn.\r\tProp testingUnification.',			#stamp : 'pm 10/22/2018 10:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testEverything,			#protocol : #testing,			#sourceCode : 'testEverything\r\tTranscript clear.\r\tProp initEverything.\r\t"Prop testingProp."\r\t"Prop testingMatch."\r\t"Prop testingClausification."\r\r\r"\tProp testingSkolemn.\r\tProp testingUnification."\r\tProp testingFactorisation.',			#stamp : 'pm 10/26/2018 07:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:18:38.873672+02:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))).\r\tc FactorisationUnitTest.\r\r\t\r"\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r."\r\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 07:16',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))).\r\t(ClausalForm new:c) FactorisationUnitTest.\r\r\t\r"\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r."\r\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 07:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:19:01.256066+02:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))).\r\t(ClausalForm new:c) FactorisationUnitTest.\r\r\t\r"\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r."\r\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 07:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))).\r\tc FactorisationUnitTest.\r\r\t\r"\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r."\r\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 07:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:20:29.940387+02:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #resolvanteUnitTest,			#protocol : #testing,			#sourceCode : 'resolvanteUnitTest\r\t|r|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tr:=Resolvante new.\r\tr factorisation: self.\r\tTranscript show:r;cr.',			#stamp : 'pm 10/25/2018 21:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #resolvanteUnitTest,			#protocol : #testing,			#sourceCode : 'resolvanteUnitTest\r\t|r fc|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tfc:=ClausalForm new:self.\r\tr:=Resolvante new.\r\tr factorisation: fc.\r\tTranscript show:r;cr.',			#stamp : 'pm 10/26/2018 07:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:21:51.295696+02:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #resolvanteUnitTest,			#protocol : #testing,			#sourceCode : 'resolvanteUnitTest\r\t|r fc|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tfc:=ClausalForm new:self.\r\tr:=Resolvante new.\r\tr factorisation: fc.\r\tTranscript show:r;cr.',			#stamp : 'pm 10/26/2018 07:20',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #resolvanteUnitTest,			#protocol : #testing,			#sourceCode : 'resolvanteUnitTest\r\t|r fc|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tfc:=ClausalForm new:self.\r\tr:=Resolvante new.\r\tr factorisation: (fc at:1).\r\tTranscript show:r;cr.',			#stamp : 'pm 10/26/2018 07:21',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:23:21.074937+02:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #resolvanteUnitTest,			#protocol : #testing,			#sourceCode : 'resolvanteUnitTest\r\t|r fc|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tfc:=ClausalForm new:self.\r\tr:=Resolvante new.\r\tr factorisation: (fc at:1).\r\tTranscript show:r;cr.',			#stamp : 'pm 10/26/2018 07:21',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #resolvanteUnitTest,			#protocol : #testing,			#sourceCode : 'resolvanteUnitTest\r\t|r fc|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tfc:=ClausalForm new:self.\r\tr:=Resolvante new.\r\tr factorisation: (fc at:1).\r\tTranscript show:r;cr.\r\t^self error:\'todo\'.',			#stamp : 'pm 10/26/2018 07:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:23:38.865002+02:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #FactorisationUnitTest,			#protocol : #testing,			#sourceCode : 'FactorisationUnitTest\r\t|r|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\r\tr:=Resolvante new.\r\tr factorisation: self.\r\r\tTranscript show: r;cr.',			#stamp : 'pm 10/25/2018 17:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #FactorisationUnitTest,			#protocol : #testing,			#sourceCode : 'FactorisationUnitTest\r\t|r fc|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tfc:=ClausalForm new:self.\r\tr:=Resolvante new.\r\tr factorisation: (fc at:1).\r\tTranscript show:r;cr.',			#stamp : 'pm 10/26/2018 07:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:24:58.143571+02:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'without:or:',			#protocol : #'as yet unclassified',			#sourceCode : 'without:index1 or:index2\r\t|i resClause|\r\tresClause:=Clause new.\r\ti:=1.\r\t\r\t[i<=self size]\r\twhileTrue:[\r\t\t(i~=index1 or:[i~=index2])\r\t\tifTrue:[\r\t\t\tresClause add:(self at:i).\r\t\t\ti:=i+1.\r\t\t\t].\r\t\t].\r\t^resClause ',			#stamp : 'pm 10/25/2018 20:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'without:or:',			#protocol : #adding,			#sourceCode : 'without:index1 or:index2\r\t|i resClause|\r\tresClause:=Clause new.\r\ti:=1.\r\t\r\t[i<=self size]\r\twhileTrue:[\r\t\t(i~=index1 or:[i~=index2])\r\t\tifTrue:[\r\t\t\tresClause add:(self at:i).\r\t\t\ti:=i+1.\r\t\t\t].\r\t\t].\r\t^resClause ',			#stamp : 'pm 10/25/2018 20:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:25:04.825592+02:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 20:56',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tTranscript show:sub1;cr.\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 07:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:25:46.039018+02:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tTranscript show:sub1;cr.\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 07:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 07:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:26:12.717511+02:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 07:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\tTranscript show:(aClause size).\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 07:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:26:17.20985+02:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\tTranscript show:(aClause size).\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 07:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\tTranscript show:(aClause size);cr.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 07:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:26:41.528967+02:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\tTranscript show:(aClause size);cr.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 07:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\tTranscript show:aClause;cr.\r\t\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 07:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:27:06.907689+02:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\tTranscript show:aClause;cr.\r\t\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 07:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r"\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 07:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:27:09.274909+02:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r"\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 07:27',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r"\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 07:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:27:25.642698+02:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r"\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 07:27',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r"\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 07:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:28:39.012072+02:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #factorisationUnitTest,			#protocol : #testing,			#sourceCode : 'factorisationUnitTest\r\t|r fc|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tfc:=ClausalForm new:self.\r\tr:=Resolvante new.\r\tr factorisation: (fc at:1).\r\tTranscript show:r;cr.',			#stamp : 'pm 10/26/2018 07:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:28:43.070922+02:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #FactorisationUnitTest,			#protocol : #testing,			#sourceCode : 'FactorisationUnitTest\r\t|r fc|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tfc:=ClausalForm new:self.\r\tr:=Resolvante new.\r\tr factorisation: (fc at:1).\r\tTranscript show:r;cr.',			#stamp : 'pm 10/26/2018 07:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:28:58.473243+02:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))).\r\tc FactorisationUnitTest.\r\r\t\r"\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r."\r\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 07:19',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))).\r\tc factorisationUnitTest.\r\r\t\r"\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r."\r\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 07:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:29:19.084565+02:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #ResolvanteUnitTest,			#protocol : #testing,			#sourceCode : 'ResolvanteUnitTest\r\t|r|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tr:=Resolvante new.\r\tr factorisation:self.\r\t\r\tTranscript show:r;cr.',			#stamp : 'pm 10/26/2018 07:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #ResolvanteUnitTest,			#protocol : #testing,			#sourceCode : 'ResolvanteUnitTest\r\t|r|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \'; show: self;cr.\r\tr:=Resolvante new.\r\tr factorisation:self.\r\t\r\tTranscript show:r;cr.',			#stamp : 'pm 10/26/2018 07:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:29:41.920951+02:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #factorisationUnitTest,			#protocol : #testing,			#sourceCode : 'factorisationUnitTest\r\t|r fc|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tfc:=ClausalForm new:self.\r\tr:=Resolvante new.\r\tr factorisation: (fc at:1).\r\tTranscript show:r;cr.',			#stamp : 'pm 10/26/2018 07:28',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #factorisationUnitTest,			#protocol : #testing,			#sourceCode : 'factorisationUnitTest\r\t|r fc|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tfc:=ClausalForm new:self.\r\tTranscript show: \'Trying to factorise \';show: fc;cr.\r\tr:=Resolvante new.\r\t\r\tr factorisation: (fc at:1).\r\tTranscript show:r;cr.',			#stamp : 'pm 10/26/2018 07:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:29:43.803223+02:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #factorisationUnitTest,			#protocol : #testing,			#sourceCode : 'factorisationUnitTest\r\t|r fc|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tfc:=ClausalForm new:self.\r\tTranscript show: \'Trying to factorise \';show: fc;cr.\r\tr:=Resolvante new.\r\t\r\tr factorisation: (fc at:1).\r\tTranscript show:r;cr.',			#stamp : 'pm 10/26/2018 07:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #factorisationUnitTest,			#protocol : #testing,			#sourceCode : 'factorisationUnitTest\r\t|r fc|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tfc:=ClausalForm new:self.\r\tTranscript show: \'Trying to factorise \';show: fc ;cr.\r\tr:=Resolvante new.\r\t\r\tr factorisation: (fc at:1).\r\tTranscript show:r;cr.',			#stamp : 'pm 10/26/2018 07:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:30:13.399953+02:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\'))).\r\tc factorisationUnitTest.\r\r\t\r"\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r."\r\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 07:28',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\'))).\r\tc factorisationUnitTest.\r\r\t\r"\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r."\r\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 07:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:30:32.65377+02:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\'))).\r\tc factorisationUnitTest.\r\r\t\r"\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r."\r\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 07:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\'))).\r\tc factorisationUnitTest.\r\r\t\r"\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r."\r\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 07:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:30:44.294909+02:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\'))).\r\tc factorisationUnitTest.\r\r\t\r"\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r."\r\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 07:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingFactorisation,			#protocol : #testing,			#sourceCode : 'testingFactorisation\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|c|\r\t\r\tTranscript show: \'Testing factorisation related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\r\tc:=Or new: (Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')))\r\t rightProp: \t(Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\'))).\r\tc factorisationUnitTest.\r\r\t\r"\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r."\r\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/26/2018 07:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:33:45.714202+02:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r"\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 07:27',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 07:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:35:08.303079+02:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'without:or:',			#protocol : #adding,			#sourceCode : 'without:index1 or:index2\r\t|i resClause|\r\tresClause:=Clause new.\r\ti:=1.\r\t\r\t[i<=self size]\r\twhileTrue:[\r\t\t(i~=index1 or:[i~=index2])\r\t\tifTrue:[\r\t\t\tresClause add:(self at:i).\r\t\t\ti:=i+1.\r\t\t\t].\r\t\t].\r\t^resClause ',			#stamp : 'pm 10/25/2018 20:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'without:or:',			#protocol : #adding,			#sourceCode : 'without:index1 or:index2\r\t|i resClause|\r\tresClause:=Clause new.\r\ti:=1.\r\t\r\t[i<=self size]\r\twhileTrue:[\r\t\t(i~=index1 or:[i~=index2])\r\t\tifTrue:[\r\t\t\tresClause add:(self at:i).\r\t\t\t].\r\t\t\t\t\ti:=i+1.\r\t\t].\r\t^resClause ',			#stamp : 'pm 10/26/2018 07:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:35:11.05285+02:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'without:or:',			#protocol : #adding,			#sourceCode : 'without:index1 or:index2\r\t|i resClause|\r\tresClause:=Clause new.\r\ti:=1.\r\t\r\t[i<=self size]\r\twhileTrue:[\r\t\t(i~=index1 or:[i~=index2])\r\t\tifTrue:[\r\t\t\tresClause add:(self at:i).\r\t\t\t].\r\t\t\t\t\ti:=i+1.\r\t\t].\r\t^resClause ',			#stamp : 'pm 10/26/2018 07:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'without:or:',			#protocol : #adding,			#sourceCode : 'without:index1 or:index2\r\t|i resClause|\r\tresClause:=Clause new.\r\ti:=1.\r\t\r\t[i<=self size]\r\twhileTrue:[\r\t\t(i~=index1 or:[i~=index2])\r\t\tifTrue:[\r\t\t\tresClause add:(self at:i).\r\t\t\t].\r\t\ti:=i+1.\r\t\t].\r\t^resClause ',			#stamp : 'pm 10/26/2018 07:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:36:24.620568+02:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 07:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r"\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\tTranscript show:newClause;cr.\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 07:36',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:36:53.629191+02:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'without:or:',			#protocol : #adding,			#sourceCode : 'without:index1 or:index2\r\t|i resClause|\r\tresClause:=Clause new.\r\ti:=1.\r\t\r\t[i<=self size]\r\twhileTrue:[\r\t\t(i~=index1 or:[i~=index2])\r\t\tifTrue:[\r\t\t\tresClause add:(self at:i).\r\t\t\t].\r\t\ti:=i+1.\r\t\t].\r\t^resClause ',			#stamp : 'pm 10/26/2018 07:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'without:or:',			#protocol : #adding,			#sourceCode : 'without:index1 or:index2\r\t|i resClause|\r\tresClause:=Clause new.\r\ti:=1.\r\t\r\t[i<=self size]\r\twhileTrue:[\r\t\t(i~=index1 or:[i~=index2])\r\t\tifTrue:[\r\t\t\tTranscript show: (self at: i).\r\t\t\tresClause add:(self at:i).\r\t\t\t].\r\t\ti:=i+1.\r\t\t].\r\t^resClause ',			#stamp : 'pm 10/26/2018 07:36',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-26T07:37:00.921094+02:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'without:or:',			#protocol : #adding,			#sourceCode : 'without:index1 or:index2\r\t|i resClause|\r\tresClause:=Clause new.\r\ti:=1.\r\t\r\t[i<=self size]\r\twhileTrue:[\r\t\t(i~=index1 or:[i~=index2])\r\t\tifTrue:[\r\t\t\tTranscript show: (self at: i).\r\t\t\tresClause add:(self at:i).\r\t\t\t].\r\t\ti:=i+1.\r\t\t].\r\t^resClause ',			#stamp : 'pm 10/26/2018 07:36',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'without:or:',			#protocol : #adding,			#sourceCode : 'without:index1 or:index2\r\t|i resClause|\r\tresClause:=Clause new.\r\ti:=1.\r\t\r\t[i<=self size]\r\twhileTrue:[\r\t\t(i~=index1 or:[i~=index2])\r\t\tifTrue:[\r\t\t\tTranscript show: (self at: i);show:\' \'.\r\t\t\tresClause add:(self at:i).\r\t\t\t].\r\t\ti:=i+1.\r\t\t].\r\t^resClause ',			#stamp : 'pm 10/26/2018 07:37',			#package : #_resolution_1erOrdre		}	}}