OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T17:34:38.392009+01:00' ],		#prior : OmReference [ 'Pharo.5ewk2t0wuay0jgv4ngq8kez1r', '154' ],		#self : OmReference [ '1' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestClausification\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestClausification,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestClausification class\r\tinstanceVariableNames: \'\''				},				#name : #'TestClausification class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestClausification,					#isMetaSide : false				},				#parent : @7,				#content : 'Automatiic Clausification tests\r\rWhat\'s in the predicates isn\'t relevant, since they aren\'t touched through this process.\rThat mean that even though we\'re after the skolemnisation, and there should only be specific terms in there (const/linked/func), they don\'t matter. \r\rWe therefore are able to use the propGeneration tool to create new tests at will.',				#stamp : 'pm 12/13/2018 17:34'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'Automatiic Clausification tests',		#newComment : 'Automatiic Clausification tests\r\rWhat\'s in the predicates isn\'t relevant, since they aren\'t touched through this process.\rThat mean that even though we\'re after the skolemnisation, and there should only be specific terms in there (const/linked/func), they don\'t matter. \r\rWe therefore are able to use the propGeneration tool to create new tests at will.',		#oldStamp : 'pm 12/12/2018 13:58',		#newStamp : 'pm 12/13/2018 17:34'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T17:41:54.874152+01:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestSkolemnisation\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestSkolemnisation,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestSkolemnisation class\r\tinstanceVariableNames: \'\''				},				#name : #'TestSkolemnisation class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestSkolemnisation,					#isMetaSide : false				},				#parent : @7,				#content : 'Automatic Skolemnisation tests\r\rFirst step of the Resolution Method process. We therefor have to use only Terms in predicates. Those terms will be specialized through this process.',				#stamp : 'pm 12/13/2018 17:41'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'Automatic Skolemnisation tests',		#newComment : 'Automatic Skolemnisation tests\r\rFirst step of the Resolution Method process. We therefor have to use only Terms in predicates. Those terms will be specialized through this process.',		#oldStamp : 'pm 12/12/2018 13:58',		#newStamp : 'pm 12/13/2018 17:41'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T17:43:34.903038+01:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestSkolemnisation\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestSkolemnisation,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestSkolemnisation class\r\tinstanceVariableNames: \'\''				},				#name : #'TestSkolemnisation class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestSkolemnisation,					#isMetaSide : false				},				#parent : @7,				#content : 'Automatic Skolemnisation tests\r\rFirst step of the Resolution Method process.\r-> We therefor have to use only Terms in predicates. \r(Those terms will be specialized through this process.)',				#stamp : 'pm 12/13/2018 17:43'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'Automatic Skolemnisation tests\r\rFirst step of the Resolution Method process. We therefor have to use only Terms in predicates. Those terms will be specialized through this process.',		#newComment : 'Automatic Skolemnisation tests\r\rFirst step of the Resolution Method process.\r-> We therefor have to use only Terms in predicates. \r(Those terms will be specialized through this process.)',		#oldStamp : 'pm 12/13/2018 17:41',		#newStamp : 'pm 12/13/2018 17:43'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T17:48:50.06962+01:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestSkolemnisation\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestSkolemnisation,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestSkolemnisation class\r\tinstanceVariableNames: \'\''				},				#name : #'TestSkolemnisation class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestSkolemnisation,					#isMetaSide : false				},				#parent : @7,				#content : 'Automatic Skolemnisation tests\r\rFirst step of the Resolution Method process.\r-> We therefor have to use only Terms in predicates. \rThose terms are being specialized through this process\r\rThis imply that  we can generate the inputs from the propGeneration tool, but NOT the expected results.',				#stamp : 'pm 12/13/2018 17:48'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'Automatic Skolemnisation tests\r\rFirst step of the Resolution Method process.\r-> We therefor have to use only Terms in predicates. \r(Those terms will be specialized through this process.)',		#newComment : 'Automatic Skolemnisation tests\r\rFirst step of the Resolution Method process.\r-> We therefor have to use only Terms in predicates. \rThose terms are being specialized through this process\r\rThis imply that  we can generate the inputs from the propGeneration tool, but NOT the expected results.',		#oldStamp : 'pm 12/13/2018 17:43',		#newStamp : 'pm 12/13/2018 17:48'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T17:58:58.010137+01:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestUnification\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestUnification,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestUnification class\r\tinstanceVariableNames: \'\''				},				#name : #'TestUnification class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestUnification,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T18:25:15.915464+01:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #debug,			#protocol : #testing,			#sourceCode : 'debug\r\t^debug',			#stamp : 'pm 10/1/2018 10:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T18:25:27.552573+01:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #debugUnification,			#protocol : #accessing,			#sourceCode : 'debugUnification\r\t^debugUnification',			#stamp : 'pm 10/18/2018 18:16',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T18:25:36.65169+01:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #resolutionTrace,			#protocol : #accessing,			#sourceCode : 'resolutionTrace\r\t^resolutionTrace\r',			#stamp : 'pm 10/27/2018 08:05',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T18:27:09.052573+01:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #isConst,			#protocol : #testing,			#sourceCode : 'isConst\r \t"is const if every terms of his is const"\r\tterms do:[:each | (each isConst)ifFalse:[^false]].\r\t^true',			#stamp : 'pm 10/28/2018 14:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #isConst,			#protocol : #testing,			#sourceCode : 'isConst\r \t"is const if every terms of his is const"\r\t^ terms allSatisfy: [ :each | each isConst ]',			#stamp : 'pm 12/13/2018 18:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T18:27:38.665281+01:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #isConst,			#protocol : #testing,			#sourceCode : 'isConst\r\t"check if every term in the list of terms is const"\r\tterms do:[:each | (each isConst)ifFalse:[^false]].\r\t^true',			#stamp : 'pm 11/28/2018 00:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #isConst,			#protocol : #testing,			#sourceCode : 'isConst\r\t"check if every term in the list of terms is const"\r\t^ terms allSatisfy: [ :each | each isConst ]',			#stamp : 'pm 12/13/2018 18:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T18:28:17.017061+01:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MinimalOrderedSet,				#isMetaSide : false			},			#name : #'haveYouSeenThisObject:',			#protocol : #search,			#sourceCode : 'haveYouSeenThisObject: anObject \r\t"search for the object"\r\tself do: [ :each | \r\t\t(each=anObject) \r\t\tifTrue:["Transcript cr;show:each prettyPrint;cr".\r\t\t\t^true.]\r\t\t].\r\t^false.',			#stamp : 'pm 10/11/2018 13:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MinimalOrderedSet,				#isMetaSide : false			},			#name : #'haveYouSeenThisObject:',			#protocol : #search,			#sourceCode : 'haveYouSeenThisObject: anObject \r\t"search for the object"\r\t^ self anySatisfy: [ :each | each = anObject ]',			#stamp : 'pm 12/13/2018 18:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T18:29:02.776869+01:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t"application of the resolution method on self. Course algorithm"\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tTranscript show:self;cr.\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r\t   ((c isTautology) or:[sat contains:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 12/12/2018 16:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t"application of the resolution method on self. Course algorithm"\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tTranscript show:self;cr.\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r\t   ((c isTautology) or:[sat anySatisfy:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 12/13/2018 18:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T18:29:26.733955+01:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #False_Const,				#isMetaSide : false			},			#name : #'matchPatternWith:',			#protocol : #matching,			#sourceCode : 'matchPatternWith: prop\r\t"see Prop comment for usage."\r\t^prop isKindOf: False_Const',			#stamp : 'pm 9/30/2018 09:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #False_Const,				#isMetaSide : false			},			#name : #'matchPatternWith:',			#protocol : #matching,			#sourceCode : 'matchPatternWith: prop\r\t"see Prop comment for usage."\r\t^prop isFalse_Const',			#stamp : 'pm 12/13/2018 18:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T18:29:32.803687+01:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #True_Const,				#isMetaSide : false			},			#name : #'matchPatternWith:',			#protocol : #matching,			#sourceCode : 'matchPatternWith: prop\r\t"see Prop comment for usage."\r\t^prop isKindOf: True_Const',			#stamp : 'pm 9/30/2018 09:48',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #True_Const,				#isMetaSide : false			},			#name : #'matchPatternWith:',			#protocol : #matching,			#sourceCode : 'matchPatternWith: prop\r\t"see Prop comment for usage."\r\t^prop isTrue_Const',			#stamp : 'pm 12/13/2018 18:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T18:29:43.678011+01:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #isClause,			#protocol : #clausification,			#sourceCode : 'isClause\r\t"tester"\r\t" (! a) is a clause, but (! (a \\/ b)) isn\'t"\r\t" (! (! a)) has to be flush during the clausification process too."\r\t^(operand isKindOf: Atome)',			#stamp : 'pm 11/27/2018 07:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #isClause,			#protocol : #clausification,			#sourceCode : 'isClause\r\t"tester"\r\t" (! a) is a clause, but (! (a \\/ b)) isn\'t"\r\t" (! (! a)) has to be flush during the clausification process too."\r\t^(operand isAtome)',			#stamp : 'pm 12/13/2018 18:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T18:30:05.462802+01:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t"toString"\r\t^((left isKindOf: Atome) ifTrue:[\' \'] ifFalse:[\' (\']) ,\r\t\tleft prettyPrint,\r\t\t((left isKindOf: Atome) ifTrue:[\' \'] ifFalse:[\') \']) ,\r\r\t\tself getSymb,\r\r\t\t((right isKindOf: Atome) ifTrue:[\' \'] ifFalse:[\' (\']) ,\r\t\tright prettyPrint,\r\t\t((right isKindOf: Atome) ifTrue:[\' \'] ifFalse:[\') \']).\r',			#stamp : 'pm 11/26/2018 21:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t"toString"\r\t^((left isAtome) ifTrue:[\' \'] ifFalse:[\' (\']) ,\r\t\tleft prettyPrint,\r\t\t((left isAtome) ifTrue:[\' \'] ifFalse:[\') \']) ,\r\r\t\tself getSymb,\r\r\t\t((right isAtome) ifTrue:[\' \'] ifFalse:[\' (\']) ,\r\t\tright prettyPrint,\r\t\t((right isAtome) ifTrue:[\' \'] ifFalse:[\') \']).\r',			#stamp : 'pm 12/13/2018 18:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T18:33:28.444429+01:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #And\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #And,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'And class\r\tinstanceVariableNames: \'patternOr patternOrSym patternTrue patternTrueSym patternFalse patternFalseSym\''				},				#name : #'And class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'And class',							#isMetaSide : true						},						#name : #patternOr,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'And class',							#isMetaSide : true						},						#name : #patternOrSym,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'And class',							#isMetaSide : true						},						#name : #patternTrue,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'And class',							#isMetaSide : true						},						#name : #patternTrueSym,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'And class',							#isMetaSide : true						},						#name : #patternFalse,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'And class',							#isMetaSide : true						},						#name : #patternFalseSym,						#parent : @12					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #And,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent an And proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Binary',				#traitCompositionSource : '{}',				#definitionSource : 'Binary subclass: #And\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #And,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'And class\r\tinstanceVariableNames: \'patternTrue patternTrueSym patternFalse patternFalseSym\''				},				#name : #'And class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'And class',							#isMetaSide : true						},						#name : #patternTrue,						#parent : @38					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'And class',							#isMetaSide : true						},						#name : #patternTrueSym,						#parent : @38					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'And class',							#isMetaSide : true						},						#name : #patternFalse,						#parent : @38					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'And class',							#isMetaSide : true						},						#name : #patternFalseSym,						#parent : @38					}				],				#baseClass : @33			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #And,					#isMetaSide : false				},				#parent : @33,				#content : 'I represent an And proposition',				#stamp : 'pm 10/9/2018 11:29'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T18:34:12.37175+01:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Clause class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: OrProp\r\t"creation of a new clause of a OrProp"\r\t^self basicNew initialize:OrProp.',			#stamp : 'pm 11/11/2018 09:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Clause class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: orProp\r\t"creation of a new clause of a OrProp"\r\t^self basicNew initialize:orProp.',			#stamp : 'pm 12/13/2018 18:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T18:41:16.968488+01:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'PackageManifest',				#traitCompositionSource : '{}',				#definitionSource : 'PackageManifest subclass: #ManifestresolutionerOrdre\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ManifestresolutionerOrdre,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ManifestresolutionerOrdre class\r\tinstanceVariableNames: \'\''				},				#name : #'ManifestresolutionerOrdre class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ManifestresolutionerOrdre,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T18:41:16.97636+01:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'PackageManifest',				#traitCompositionSource : '{}',				#definitionSource : 'PackageManifest subclass: #ManifestresolutionerOrdre\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ManifestresolutionerOrdre,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ManifestresolutionerOrdre class\r\tinstanceVariableNames: \'\''				},				#name : #'ManifestresolutionerOrdre class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ManifestresolutionerOrdre,					#isMetaSide : false				},				#parent : @7,				#content : 'I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser',				#stamp : '<historical>'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser',		#newStamp : '<historical>'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T18:41:30.643159+01:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpGenericRefactoring {		#storeString : '(RBRemoveClassRefactoring classNames: #(#ManifestresolutionerOrdre ))'	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ],		#time : DateAndTime [ '2018-12-13T18:41:30.728163+01:00' ],		#trigger : @3	},	#content : EpClassRemoval {		#classRemoved : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'PackageManifest',				#traitCompositionSource : '{}',				#definitionSource : 'PackageManifest subclass: #ManifestresolutionerOrdre\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: #_resolution_1erOrdre'			},			#name : #ManifestresolutionerOrdre,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ManifestresolutionerOrdre class\r\tinstanceVariableNames: \'\''				},				#name : #'AnObsoleteManifestresolutionerOrdre class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #AnObsoleteManifestresolutionerOrdre,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T19:00:09.231858+01:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t(Prop debugUnification)\r\t\t\tifTrue:[Transcript show:\'conflict\';cr.].\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[(right isKindOf: LinkedTerm) or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 11/4/2018 17:56',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t(Prop debugUnification)\r\t\t\tifTrue:[Transcript show:\'conflict\';cr.].\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t(((left isKindOf: LinkedTerm) or:[left isKindOf: ConstTerm]) and:[(right isKindOf: LinkedTerm) or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/13/2018 19:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T19:08:22.825461+01:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testingUnification,			#protocol : #'as yet unclassified',			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl unificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t\r\t"should replace x by y at the end of the unification"\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:( LinkedTerm new:(Term new:\'x\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 12/13/2018 19:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T19:08:22.890887+01:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testingUnification,			#protocol : #'as yet unclassified',			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl unificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t\r\t"should replace x by y at the end of the unification"\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:( LinkedTerm new:(Term new:\'x\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 12/13/2018 19:08',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl unificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t\r\t"should replace x by y at the end of the unification"\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:( LinkedTerm new:(Term new:\'x\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 12/13/2018 19:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T19:10:25.961088+01:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #debugUnification,			#protocol : #'as yet unclassified',			#sourceCode : 'debugUnification\r\t^debugUnification',			#stamp : 'pm 12/13/2018 19:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T19:14:50.389013+01:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tclausificationTrace:=false.\r\tskolemnTrace:=false.\r\tdebugUnification:=false.\r\tresolutionTrace:=true.\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/12/2018 17:01',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tclausificationTrace:=false.\r\tskolemnTrace:=false.\r\tdebugUnification:=true.\r\tresolutionTrace:=false.\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/13/2018 19:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T20:41:05.441079+01:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t(Prop debugUnification)\r\t\t\tifTrue:[Transcript show:\'conflict\';cr.].\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t(((left isKindOf: LinkedTerm) or:[left isKindOf: ConstTerm]) and:[(right isKindOf: LinkedTerm) or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/13/2018 19:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.]"delete"\r\t\tifFalse:[\t\t\t(Prop debugUnification)\r\t\t\tifTrue:[Transcript show:\'conflict\';cr.].\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].]\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t(Prop debugUnification)\r\t\t\tifTrue:[Transcript show:\'conflict\';cr.].\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t(((left isKindOf: LinkedTerm) or:[left isKindOf: ConstTerm]) and:[(right isKindOf: LinkedTerm) or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/13/2018 20:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T20:43:56.97704+01:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.]"delete"\r\t\tifFalse:[\t\t\t(Prop debugUnification)\r\t\t\tifTrue:[Transcript show:\'conflict\';cr.].\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].]\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t(Prop debugUnification)\r\t\t\tifTrue:[Transcript show:\'conflict\';cr.].\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t(((left isKindOf: LinkedTerm) or:[left isKindOf: ConstTerm]) and:[(right isKindOf: LinkedTerm) or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/13/2018 20:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.]"delete"\r\t\tifFalse:[\t\t\t(Prop debugUnification)\r\t\t\tifTrue:[Transcript show:\'conflict\';cr.].\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].]\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t(Prop debugUnification)\r\t\t\tifTrue:[Transcript show:\'conflict\';cr.].\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t(((left isKindOf: LinkedTerm) or:[left isKindOf: ConstTerm]) and:[(right isKindOf: LinkedTerm) or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/13/2018 20:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T20:50:01.622787+01:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'conflict:',			#protocol : #unification,			#sourceCode : 'conflict: aPair\r\t(Prop debugUnification) \r\tifTrue:[Transcript show:\'[Unification] conflict between : \'; show:aPair ; cr.].\r',			#stamp : 'pm 12/13/2018 20:50',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T20:52:31.068282+01:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.]"delete"\r\t\tifFalse:[\t\t\t(Prop debugUnification)\r\t\t\tifTrue:[Transcript show:\'conflict\';cr.].\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].]\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t(Prop debugUnification)\r\t\t\tifTrue:[Transcript show:\'conflict\';cr.].\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t(((left isKindOf: LinkedTerm) or:[left isKindOf: ConstTerm]) and:[(right isKindOf: LinkedTerm) or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/13/2018 20:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.]"delete"\r\t\tifFalse:[\t\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].]\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t(((left isKindOf: LinkedTerm) or:[left isKindOf: ConstTerm]) and:[(right isKindOf: LinkedTerm) or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/13/2018 20:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T20:54:39.845537+01:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'swap:',			#protocol : #unification,			#sourceCode : 'swap: aPair\r\t|left right|\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'swap\';cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tsetOfPairs remove:aPair.\r\tself add: (Pair left: right right: left).\r\t',			#stamp : 'pm 10/18/2018 18:20',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'swap:',			#protocol : #unification,			#sourceCode : 'swap: aPair\r\t|left right|\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'swaping : \'; show:aPair ;cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tsetOfPairs remove:aPair.\r\tself add: (Pair left: right right: left).\r\t',			#stamp : 'pm 12/13/2018 20:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T20:56:23.964892+01:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right i|\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'decompose\';cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\ti:=1.\r\tsetOfPairs remove: aPair.\r\t[i<=(left arity)]"arity is the same, as we tested in the caller."\r\twhileTrue:[\r\t\tself add: (Pair left: (left at: i) right: (right at: i)).\r\t\ti:=i+1.\r\t\t].\t',			#stamp : 'pm 10/18/2018 18:19',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right i|\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'decompose \'; show:aPair;cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\ti:=1.\r\tsetOfPairs remove: aPair.\r\t[i<=(left arity)]"arity is the same, as we tested in the caller."\r\twhileTrue:[\r\t\tself add: (Pair left: (left at: i) right: (right at: i)).\r\t\ti:=i+1.\r\t\t].\t',			#stamp : 'pm 12/13/2018 20:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T20:56:24.742797+01:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right i|\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'decompose \'; show:aPair;cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\ti:=1.\r\tsetOfPairs remove: aPair.\r\t[i<=(left arity)]"arity is the same, as we tested in the caller."\r\twhileTrue:[\r\t\tself add: (Pair left: (left at: i) right: (right at: i)).\r\t\ti:=i+1.\r\t\t].\t',			#stamp : 'pm 12/13/2018 20:56',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right i|\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'decompose \'; show:aPair ;cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\ti:=1.\r\tsetOfPairs remove: aPair.\r\t[i<=(left arity)]"arity is the same, as we tested in the caller."\r\twhileTrue:[\r\t\tself add: (Pair left: (left at: i) right: (right at: i)).\r\t\ti:=i+1.\r\t\t].\t',			#stamp : 'pm 12/13/2018 20:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T20:57:53.92717+01:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'delete:',			#protocol : #unification,			#sourceCode : 'delete:aPair\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'delete\';cr.].\r\tsetOfPairs remove:aPair.',			#stamp : 'pm 10/18/2018 18:27',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'delete:',			#protocol : #unification,			#sourceCode : 'delete:aPair\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'delete\'; show:aPair ;cr.].\r\tsetOfPairs remove:aPair.',			#stamp : 'pm 12/13/2018 20:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T20:58:06.522338+01:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right previousSet newSet |\r\t\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'eliminate with \';show: aPair;cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\t\r\tpreviousSet:=setOfPairs veryDeepCopy."we need to work on a copy, to avoid having another iteration"\r\tpreviousSet remove:aPair.\r\t\r\tpreviousSet do:[:each |\r\t\t"tempVar:=each veryDeepCopy.""since we modify the underlying data, we work on a copy"\r\t\tnewSet add: (self replacementPair:each replaced:left by:right).\r\t\t].\r\t(previousSet = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r ',			#stamp : 'pm 10/20/2018 17:21',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right previousSet newSet |\r\t\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'eliminate with \'; show:aPair ;cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\t\r\tpreviousSet:=setOfPairs veryDeepCopy."we need to work on a copy, to avoid having another iteration"\r\tpreviousSet remove:aPair.\r\t\r\tpreviousSet do:[:each |\r\t\t"tempVar:=each veryDeepCopy.""since we modify the underlying data, we work on a copy"\r\t\tnewSet add: (self replacementPair:each replaced:left by:right).\r\t\t].\r\t(previousSet = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r ',			#stamp : 'pm 12/13/2018 20:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T20:59:33.817406+01:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl unificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t\r\t"should replace x by y at the end of the unification"\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:( LinkedTerm new:(Term new:\'x\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/22/2018 10:05',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tProp initialize.\r\tTranscript clear.\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl unificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t\r\t"should replace x by y at the end of the unification"\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:( LinkedTerm new:(Term new:\'x\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 12/13/2018 20:59',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T21:04:30.183243+01:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.]"delete"\r\t\tifFalse:[\t\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].]\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t(((left isKindOf: LinkedTerm) or:[left isKindOf: ConstTerm]) and:[(right isKindOf: LinkedTerm) or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/13/2018 20:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.]"delete"\r\t\tifFalse:[\t\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].]\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t(((left isKindOf: LinkedTerm) or:[left isKindOf: ConstTerm]) and:[(right isKindOf: LinkedTerm) or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\tTranscript show:modified;cr.\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/13/2018 21:04',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T21:04:49.223747+01:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.]"delete"\r\t\tifFalse:[\t\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].]\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t(((left isKindOf: LinkedTerm) or:[left isKindOf: ConstTerm]) and:[(right isKindOf: LinkedTerm) or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\tTranscript show:modified;cr.\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/13/2018 21:04',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.]"delete"\r\t\tifFalse:[\t\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].]\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t(((left isKindOf: LinkedTerm) or:[left isKindOf: ConstTerm]) and:[(right isKindOf: LinkedTerm) or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\tTranscript show:notPossible;cr.\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/13/2018 21:04',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T21:08:01.411719+01:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\t[ modified ]\r\twhileTrue:[\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\t"Transcript show: \'Unification impossible\'; cr."\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t\r\t\t]. ',			#stamp : 'pm 10/26/2018 22:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\t[ modified ]\r\twhileTrue:[\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right"=not possible"\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t\r\t\t]. ',			#stamp : 'pm 12/13/2018 21:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T21:10:38.032049+01:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\t[ modified ]\r\twhileTrue:[\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right"=not possible"\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t\r\t\t]. ',			#stamp : 'pm 12/13/2018 21:08',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\t[ modified ]\r\twhileTrue:[\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right"=not possible"\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\thasFailed:=true.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t\r\t\t]. ',			#stamp : 'pm 12/13/2018 21:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T21:13:32.188178+01:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\t[ modified ]\r\twhileTrue:[\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right"=not possible"\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\thasFailed:=true.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t\r\t\t]. ',			#stamp : 'pm 12/13/2018 21:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\t[ modified ]\r\twhileTrue:[\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right"=not possible"\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\t"Transcript show: \'Unification impossible\'; cr."\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\thasFailed:=true.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t\r\t\t]. ',			#stamp : 'pm 12/13/2018 21:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T21:14:15.842381+01:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.]"delete"\r\t\tifFalse:[\t\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].]\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t(((left isKindOf: LinkedTerm) or:[left isKindOf: ConstTerm]) and:[(right isKindOf: LinkedTerm) or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\tTranscript show:notPossible;cr.\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/13/2018 21:04',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.]"delete"\r\t\tifFalse:[\t\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].]\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t(((left isKindOf: LinkedTerm) or:[left isKindOf: ConstTerm]) and:[(right isKindOf: LinkedTerm) or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/13/2018 21:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-13T21:18:26.973222+01:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.]"delete"\r\t\tifFalse:[\t\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].]\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t(((left isKindOf: LinkedTerm) or:[left isKindOf: ConstTerm]) and:[(right isKindOf: LinkedTerm) or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/13/2018 21:14',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.]"delete"\r\t\tifFalse:[\t\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].]\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[(right isKindOf: LinkedTerm) or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/13/2018 21:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T08:48:28.825337+01:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #'as yet unclassified',			#sourceCode : 'testConstOnConst\r\t| l r |\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\t',			#stamp : 'pm 12/14/2018 08:48',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T08:48:28.885647+01:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #'as yet unclassified',			#sourceCode : 'testConstOnConst\r\t| l r |\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\t',			#stamp : 'pm 12/14/2018 08:48',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| l r |\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\t',			#stamp : 'pm 12/14/2018 08:48',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T09:10:46.32697+01:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| l r |\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\t',			#stamp : 'pm 12/14/2018 08:48',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| l r u res |\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tu:=Unifier new: l Predicate2:r.\r\t\r\tself deny:u hasFailed.\r\tself assert: u unifiedPair equals:nil.\r\t',			#stamp : 'pm 12/14/2018 09:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T09:14:56.301673+01:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| l r u res |\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tu:=Unifier new: l Predicate2:r.\r\t\r\tself deny:u hasFailed.\r\tself assert: u unifiedPair equals:nil.\r\t',			#stamp : 'pm 12/14/2018 09:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| l r u |\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tu:=Unifier new: l Predicate2:r.\r\t\r\tself assert:u hasFailed.\r\tself assert: u unifiedPair equals:nil.\r\t',			#stamp : 'pm 12/14/2018 09:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T09:17:42.598159+01:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| l r u |\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tu:=Unifier new: l Predicate2:r.\r\t\r\tself assert:u hasFailed.\r\tself assert: u unifiedPair equals:nil.\r\t',			#stamp : 'pm 12/14/2018 09:14',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| l r u |\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tu:=Unifier new: l Predicate2:r.\r\t\r\tself assert:u hasFailed.\r\t\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tu:=Unifier new: l Predicate2:r.\r\t\r\tself deny:u hasFailed.\r\tself assert: u unifiedPair equals: (Pair left:l right:r).\r\t',			#stamp : 'pm 12/14/2018 09:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T09:19:51.941806+01:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| l r u |\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tu:=Unifier new: l Predicate2:r.\r\t\r\tself assert:u hasFailed.\r\t\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tu:=Unifier new: l Predicate2:r.\r\t\r\tself deny:u hasFailed.\r\tself assert: u unifiedPair equals: (Pair left:l right:r).\r\t',			#stamp : 'pm 12/14/2018 09:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| l r u |\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tu:=Unifier new: l Predicate2:r.\r\t\r\tself assert:u hasFailed.\r\tself assert:u unifiedPair equals:nil.\r\t\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tu:=Unifier new: l Predicate2:r.\r\t\r\tself deny:u hasFailed.\r\tself assert: u unifiedPair equals: (Pair left:l right:r).\r\t',			#stamp : 'pm 12/14/2018 09:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T09:22:19.161959+01:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #False_Const,				#isMetaSide : false			},			#name : #'matchPatternWith:',			#protocol : #matching,			#sourceCode : 'matchPatternWith: prop\r\t"see Prop comment for usage."\r\t^prop isFalse_Const',			#stamp : 'pm 12/13/2018 18:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #False_Const,				#isMetaSide : false			},			#name : #'matchPatternWith:',			#protocol : #matching,			#sourceCode : 'matchPatternWith: prop\r\t"see Prop comment for usage."\r\t^prop isFalseConst',			#stamp : 'pm 12/14/2018 09:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T09:22:31.983944+01:00' ],		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #True_Const,				#isMetaSide : false			},			#name : #'matchPatternWith:',			#protocol : #matching,			#sourceCode : 'matchPatternWith: prop\r\t"see Prop comment for usage."\r\t^prop isTrue_Const',			#stamp : 'pm 12/13/2018 18:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #True_Const,				#isMetaSide : false			},			#name : #'matchPatternWith:',			#protocol : #matching,			#sourceCode : 'matchPatternWith: prop\r\t"see Prop comment for usage."\r\t^prop isTrueConst',			#stamp : 'pm 12/14/2018 09:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T09:46:06.696041+01:00' ],		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\t[ modified ]\r\twhileTrue:[\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right"=not possible"\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\t"Transcript show: \'Unification impossible\'; cr."\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\thasFailed:=true.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t\r\t\t]. ',			#stamp : 'pm 12/13/2018 21:13',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\t[ modified ]\r\twhileTrue:[\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification ifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right"=not possible"\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\t"Transcript show: \'Unification impossible\'; cr."\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\thasFailed:=true.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t\r\t\t]. ',			#stamp : 'pm 12/14/2018 09:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T09:46:48.690377+01:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'initialize:Predicate2:',			#protocol : #initialization,			#sourceCode : 'initialize: p1 Predicate2: p2\r\t"initialized with two predicates, that we\'ll try to unify."\r\t\r\t"init two different pair to be sure that we have the initial\r\tone to unify at the end."\r\tinitialPair:=(Pair left: (p1 veryDeepCopy) right: (p2 veryDeepCopy)).\r\tsetOfPairs:=MinimalOrderedSet new.\r\tsetOfPairs add:(Pair left: p1 right: p2).\r\thasFailed:=false.\r\t\r\tUnifiedTerm:=Pair left:nil right:nil."not sure if needed"\r\t\r\t"And we try to unify it instantly"\r\tself unifyThis.\r',			#stamp : 'pm 11/11/2018 09:44',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'initialize:Predicate2:',			#protocol : #initialization,			#sourceCode : 'initialize: p1 Predicate2: p2\r\t"initialized with two predicates, that we\'ll try to unify."\r\t\r\t"init two different pair to be sure that we have the initial\r\tone to unify at the end."\r\tinitialPair:=(Pair left: (p1 veryDeepCopy) right: (p2 veryDeepCopy)).\r\tsetOfPairs:=MinimalOrderedSet new.\r\tsetOfPairs add:(Pair left: p1 right: p2).\r\thasFailed:=false.\r\t\r\t"UnifiedTerm:=Pair left:nil right:nil.""not sure if needed"\r\t\r\t"And we try to unify it instantly"\r\tself unifyThis.\r',			#stamp : 'pm 12/14/2018 09:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T09:49:32.326837+01:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'initialize:Predicate2:',			#protocol : #initialization,			#sourceCode : 'initialize: p1 Predicate2: p2\r\t"initialized with two predicates, that we\'ll try to unify."\r\t\r\t"init two different pair to be sure that we have the initial\r\tone to unify at the end."\r\tinitialPair:=(Pair left: (p1 veryDeepCopy) right: (p2 veryDeepCopy)).\r\tsetOfPairs:=MinimalOrderedSet new.\r\tsetOfPairs add:(Pair left: p1 right: p2).\r\thasFailed:=false.\r\t\r\t"UnifiedTerm:=Pair left:nil right:nil.""not sure if needed"\r\t\r\t"And we try to unify it instantly"\r\tself unifyThis.\r',			#stamp : 'pm 12/14/2018 09:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'initialize:Predicate2:',			#protocol : #initialization,			#sourceCode : 'initialize: p1 Predicate2: p2\r\t"initialized with two predicates, that we\'ll try to unify."\r\t\r\t"init two different pair to be sure that we have the initial\r\tone to unify at the end."\r\tinitialPair:=(Pair left: (p1 veryDeepCopy) right: (p2 veryDeepCopy)).\r\tsetOfPairs:=MinimalOrderedSet new.\r\tsetOfPairs add:(Pair left: p1 right: p2).\r\thasFailed:=false.\r\t\r\tunifiedPair:=Pair left:nil right:nil."not sure if needed"\r\t\r\t"And we try to unify it instantly"\r\tself unifyThis.\r',			#stamp : 'pm 12/14/2018 09:49',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T09:52:49.608601+01:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t\r\t(hasFailed)\r\tifTrue:[\r\t\tunifiedPair := nil."Failed to unify thing"\r\t\t].\r\r\tunifiedPair := initialPair veryDeepCopy.\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\t\tifTrue:["They both should be predicates, so they can use replace: by:"\r\t\t\t\t\t(unifiedPair left) replace: (each left) by: (each right).\r\t\t\t\t\t(unifiedPair right) replace: (each left) by: (each right).\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t"else it was already the same  predicate"',			#stamp : 'pm 10/26/2018 22:27',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t\r\t(hasFailed)\r\tifTrue:[\r\t\tunifiedPair := nil."Failed to unify thing"\r\t\t^nil."return value doesn\'t matter, we just want to breakout."\r\t\t].\r\r\tunifiedPair := initialPair veryDeepCopy.\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\t\tifTrue:["They both should be predicates, so they can use replace: by:"\r\t\t\t\t\t(unifiedPair left) replace: (each left) by: (each right).\r\t\t\t\t\t(unifiedPair right) replace: (each left) by: (each right).\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t"else it was already the same  predicate"',			#stamp : 'pm 12/14/2018 09:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T10:10:26.949743+01:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| l r u |\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tu:=Unifier new: l Predicate2:r.\r\t\r\tself assert:u hasFailed.\r\tself assert:u unifiedPair equals:nil.\r\t\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tu:=Unifier new: l Predicate2:r.\r\t\r\tself deny:u hasFailed.\r\tself assert: u unifiedPair equals: (Pair left:l right:r).\r\t',			#stamp : 'pm 12/14/2018 09:19',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| l r u |\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tu:=Unifier new: l Predicate2:r.\r\t\r\tself assert:u hasFailed.\r\tself assert:u unifiedPair equals:nil.\r\tself assert:u setOfPairs equals: nil.\r\t\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tu:=Unifier new: l Predicate2:r.\r\t\r\tself deny:u hasFailed.\r\tself assert: u unifiedPair equals: (Pair left:l right:r).\r\t',			#stamp : 'pm 12/14/2018 10:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T10:31:37.980721+01:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestUnification\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestUnification,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestUnification class\r\tinstanceVariableNames: \'\''				},				#name : #'TestUnification class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestUnification,					#isMetaSide : false				},				#parent : @7,				#content : 'Unification test. \rFor reference, the table of possible operations used is:\r\r    =         |     const      |   Linked    |     Func      \rConst   |  Conflict     |  Swap       |    Check\r               |  Delete        |                    |\r               |                       |                     | \rLinked | Eliminate  |  Delete     |    Check\r               |                       |                     | \rFunc     | Swap          |  Swap        |   Decompose\r               |                       |                      |   Conflict\r               |                       |                      | ',				#stamp : 'pm 12/14/2018 10:31'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'Unification test. \rFor reference, the table of possible operations used is:\r\r    =         |     const      |   Linked    |     Func      \rConst   |  Conflict     |  Swap       |    Check\r               |  Delete        |                    |\r               |                       |                     | \rLinked | Eliminate  |  Delete     |    Check\r               |                       |                     | \rFunc     | Swap          |  Swap        |   Decompose\r               |                       |                      |   Conflict\r               |                       |                      | ',		#newStamp : 'pm 12/14/2018 10:31'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:02:03.540313+01:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnLinked,			#protocol : #tests,			#sourceCode : 'testConstOnLinked\r\t| l r u expectedResultPair|\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tu:=Unifier new: l Predicate2:r.\r\t\r\texpectedResultPair:=Pair left: l right: l. \r\t\t\r\tself deny:u hasFailed.\r\tself assert:u unifiedPair equals:expectedResultPair.\r\tself assert:u setOfPairs equals: nil.\r\t\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tu:=Unifier new: l Predicate2:r.\r\t\r\tself deny:u hasFailed.\r\tself assert: u unifiedPair equals: (Pair left:l right:r).\r\t',			#stamp : 'pm 12/14/2018 11:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:02:48.262946+01:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnLinked,			#protocol : #tests,			#sourceCode : 'testConstOnLinked\r\t| l r u expectedResultPair|\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tu:=Unifier new: l Predicate2:r.\r\t\r\texpectedResultPair:=Pair left: l right: l. \r\t\t\r\tself deny:u hasFailed.\r\tself assert:u unifiedPair equals:expectedResultPair.\r\tself assert:u setOfPairs equals: nil.\r\t\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tu:=Unifier new: l Predicate2:r.\r\t\r\tself deny:u hasFailed.\r\tself assert: u unifiedPair equals: (Pair left:l right:r).\r\t',			#stamp : 'pm 12/14/2018 11:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnLinked,			#protocol : #tests,			#sourceCode : 'testConstOnLinked\r\t| l r u expectedResultPair expectedResultSetOfPair|\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tu:=Unifier new: l Predicate2:r.\r\t\r\texpectedResultPair:=Pair left: l right: l. \r\t\t\r\tself deny:u hasFailed.\r\tself assert:u unifiedPair equals:expectedResultPair.\r\tself assert:u setOfPairs equals: nil.\r\t\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tu:=Unifier new: l Predicate2:r.\r\t\r\tself deny:u hasFailed.\r\tself assert: u unifiedPair equals: (Pair left:l right:r).\r\t',			#stamp : 'pm 12/14/2018 11:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:08:17.939772+01:00' ],		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnLinked,			#protocol : #tests,			#sourceCode : 'testConstOnLinked\r\t| l r u expectedResultPair expectedResultSetOfPair|\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tu:=Unifier new: l Predicate2:r.\r\t\r\texpectedResultPair:=Pair left: l right: l. \r\t\t\r\tself deny:u hasFailed.\r\tself assert:u unifiedPair equals:expectedResultPair.\r\tself assert:u setOfPairs equals: nil.\r\t\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tu:=Unifier new: l Predicate2:r.\r\t\r\tself deny:u hasFailed.\r\tself assert: u unifiedPair equals: (Pair left:l right:r).\r\t',			#stamp : 'pm 12/14/2018 11:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnLinked,			#protocol : #tests,			#sourceCode : 'testConstOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair|\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new;\r\t\tadd: (Pair left: (Term new:\'a\') right:(Term new:\'x\'));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:09:01.34165+01:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnLinked,			#protocol : #tests,			#sourceCode : 'testConstOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair|\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new;\r\t\tadd: (Pair left: (Term new:\'a\') right:(Term new:\'x\'));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:08',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnLinked,			#protocol : #tests,			#sourceCode : 'testConstOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair|\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (Term new:\'a\') right:(Term new:\'x\'));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:09',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:09:46.447479+01:00' ],		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnLinked,			#protocol : #tests,			#sourceCode : 'testConstOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair|\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (Term new:\'a\') right:(Term new:\'x\'));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:09',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnLinked,			#protocol : #tests,			#sourceCode : 'testConstOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair|\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'a\')) right:(LinkedTerm new:(Term new:\'x\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:09',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:10:15.861481+01:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnLinked,			#protocol : #tests,			#sourceCode : 'testConstOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair|\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'a\')) right:(LinkedTerm new:(Term new:\'x\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:09',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnLinked,			#protocol : #tests,			#sourceCode : 'testConstOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair|\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:12:18.465264+01:00' ],		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| l r u |\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tu:=Unifier new: l Predicate2:r.\r\t\r\tself assert:u hasFailed.\r\tself assert:u unifiedPair equals:nil.\r\tself assert:u setOfPairs equals: nil.\r\t\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tu:=Unifier new: l Predicate2:r.\r\t\r\tself deny:u hasFailed.\r\tself assert: u unifiedPair equals: (Pair left:l right:r).\r\t',			#stamp : 'pm 12/14/2018 10:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| left right unifier |\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals: (Pair left:left right:right).\r\t',			#stamp : 'pm 12/14/2018 11:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:12:28.106694+01:00' ],		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| left right unifier |\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals: (Pair left:left right:right).\r\t',			#stamp : 'pm 12/14/2018 11:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| left right unifier |\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals: (Pair left:left right:right).\r\tself assert:unifier setOfPairs equals: nil.\r\t',			#stamp : 'pm 12/14/2018 11:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:12:40.596827+01:00' ],		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| left right unifier |\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals: (Pair left:left right:right).\r\tself assert:unifier setOfPairs equals: nil.\r\t',			#stamp : 'pm 12/14/2018 11:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| left right unifier expectedResultSetOfPair |\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals: (Pair left:left right:right).\r\tself assert:unifier setOfPairs equals: nil.\r\t',			#stamp : 'pm 12/14/2018 11:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:12:53.990253+01:00' ],		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| left right unifier expectedResultSetOfPair |\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals: (Pair left:left right:right).\r\tself assert:unifier setOfPairs equals: nil.\r\t',			#stamp : 'pm 12/14/2018 11:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals: (Pair left:left right:right).\r\tself assert:unifier setOfPairs equals: nil.\r\t',			#stamp : 'pm 12/14/2018 11:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:17:13.479596+01:00' ],		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals: (Pair left:left right:right).\r\tself assert:unifier setOfPairs equals: nil.\r\t',			#stamp : 'pm 12/14/2018 11:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\texpectedResultPair:=(Pair left:left right:right).\r\texpectedResultSetOfPair:=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair .\r\t',			#stamp : 'pm 12/14/2018 11:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:25:53.477159+01:00' ],		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\texpectedResultPair:=(Pair left:left right:right).\r\texpectedResultSetOfPair:=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair .\r\t',			#stamp : 'pm 12/14/2018 11:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both test for aConstTerm = anotherConstTerm"\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"The resulting pair is the same as the input, since the unification was unnecessary"\r\texpectedResultPair:=(Pair left:left right:right).\r\t"The resulting setOfPair should be empty since there\'s nothing to unify"\r\texpectedResultSetOfPair:=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:33:53.599627+01:00' ],		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnLinked,			#protocol : #tests,			#sourceCode : 'testConstOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair|\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnLinked,			#protocol : #tests,			#sourceCode : 'testConstOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair|\r\t"Only test for aConstTerm=aLinkedTerm"\r\r\t"since they can\'t be equal. As proven by this assertion. (obviously)"\r\tself deny:(ConstTerm new: ( Term new: \'a\'))=(LinkedTerm new: ( Term new: \'a\'))."S"\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:34:26.587576+01:00' ],		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnLinked,			#protocol : #tests,			#sourceCode : 'testConstOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair|\r\t"Only test for aConstTerm=aLinkedTerm"\r\r\t"since they can\'t be equal. As proven by this assertion. (obviously)"\r\tself deny:(ConstTerm new: ( Term new: \'a\'))=(LinkedTerm new: ( Term new: \'a\'))."S"\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnLinked,			#protocol : #tests,			#sourceCode : 'testConstOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aLinkedTerm"\r\r\t"since they can\'t be equal. As proven by this assertion. (obviously)"\r\tself deny:(ConstTerm new: ( Term new: \'a\'))=(LinkedTerm new: ( Term new: \'a\'))."S"\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:37:07.331689+01:00' ],		#prior : OmReference [ '72' ],		#self : OmReference [ '73' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #'as yet unclassified',			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:37:07.394911+01:00' ],		#prior : OmReference [ '73' ],		#self : OmReference [ '74' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #'as yet unclassified',			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:37:27.624864+01:00' ],		#prior : OmReference [ '74' ],		#self : OmReference [ '75' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:39:22.017854+01:00' ],		#prior : OmReference [ '75' ],		#self : OmReference [ '76' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: right right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:39:44.026513+01:00' ],		#prior : OmReference [ '76' ],		#self : OmReference [ '77' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: right right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'y\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:40:08.565756+01:00' ],		#prior : OmReference [ '77' ],		#self : OmReference [ '78' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'y\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'y\')) right:(LinkedTerm new:(Term new:\'x\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:42:12.089053+01:00' ],		#prior : OmReference [ '78' ],		#self : OmReference [ '79' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'y\')) right:(LinkedTerm new:(Term new:\'x\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'y\')) right:(LinkedTerm new:(Term new:\'x\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:42:18.201356+01:00' ],		#prior : OmReference [ '79' ],		#self : OmReference [ '80' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'y\')) right:(LinkedTerm new:(Term new:\'x\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:42',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'x\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:54:00.284393+01:00' ],		#prior : OmReference [ '80' ],		#self : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'x\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:42',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'y\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:54:26.646826+01:00' ],		#prior : OmReference [ '81' ],		#self : OmReference [ '82' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'y\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:54',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'y\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'x\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 11:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:55:17.490826+01:00' ],		#prior : OmReference [ '82' ],		#self : OmReference [ '83' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both test for aConstTerm = anotherConstTerm"\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"The resulting pair is the same as the input, since the unification was unnecessary"\r\texpectedResultPair:=(Pair left:left right:right).\r\t"The resulting setOfPair should be empty since there\'s nothing to unify"\r\texpectedResultSetOfPair:=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both test for aConstTerm = anotherConstTerm"\r\t\r\t"conflict rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"The resulting pair is the same as the input, since the unification was unnecessary"\r\texpectedResultPair:=(Pair left:left right:right).\r\t"The resulting setOfPair should be empty since there\'s nothing to unify"\r\texpectedResultSetOfPair:=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:57:21.165997+01:00' ],		#prior : OmReference [ '83' ],		#self : OmReference [ '84' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'y\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'x\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 11:54',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\t"eliminate"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'y\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 11:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:57:45.815039+01:00' ],		#prior : OmReference [ '84' ],		#self : OmReference [ '85' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both test for aConstTerm = anotherConstTerm"\r\t\r\t"conflict rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"The resulting pair is the same as the input, since the unification was unnecessary"\r\texpectedResultPair:=(Pair left:left right:right).\r\t"The resulting setOfPair should be empty since there\'s nothing to unify"\r\texpectedResultSetOfPair:=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:55',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both test for aConstTerm = anotherConstTerm"\r\t\r\t"conflict rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"The resulting pair is the same as the input, since the unification was unnecessary"\r\texpectedResultPair:=(Pair left:left right:right).\r\t"the delete let us an empty set"\r\texpectedResultSetOfPair:=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 11:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T11:57:57.771549+01:00' ],		#prior : OmReference [ '85' ],		#self : OmReference [ '86' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\t"eliminate"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'y\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 11:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testLinkedOnLinked,			#protocol : #tests,			#sourceCode : 'testLinkedOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\t"eliminate rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'y\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 11:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:06:41.098383+01:00' ],		#prior : OmReference [ '86' ],		#self : OmReference [ '87' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testEmptyPredicate,			#protocol : #tests,			#sourceCode : 'testEmptyPredicate\r\t| left right unifier |\r\t"tests for empty predicates"\r\t\r\t"Decomposition rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'P\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"this first test should just fail, with everything being nil"\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\t"Conflict rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'Q\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t',			#stamp : 'pm 12/14/2018 12:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:08:13.374492+01:00' ],		#prior : OmReference [ '87' ],		#self : OmReference [ '88' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testEmptyPredicate,			#protocol : #tests,			#sourceCode : 'testEmptyPredicate\r\t| left right unifier |\r\t"tests for empty predicates"\r\t\r\t"Decomposition rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'P\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"this first test should just fail, with everything being nil"\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\t"Conflict rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'Q\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t',			#stamp : 'pm 12/14/2018 12:06',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testEmptyPredicate,			#protocol : #tests,			#sourceCode : 'testEmptyPredicate\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"tests for empty predicates"\r\t\r\t"Decomposition rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'P\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\texpectedResultPair :=nil.\r\texpectedResultSetOfPair:=MinimalOrderedSet new. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"Conflict rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'Q\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t',			#stamp : 'pm 12/14/2018 12:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:20:51.117716+01:00' ],		#prior : OmReference [ '88' ],		#self : OmReference [ '89' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testEmptyPredicate,			#protocol : #tests,			#sourceCode : 'testEmptyPredicate\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"tests for empty predicates"\r\t\r\t"Decomposition rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'P\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\texpectedResultPair :=nil.\r\texpectedResultSetOfPair:=MinimalOrderedSet new. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"Conflict rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'Q\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t',			#stamp : 'pm 12/14/2018 12:08',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testEmptyPredicate,			#protocol : #tests,			#sourceCode : 'testEmptyPredicate\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"tests for empty predicates"\r\t\r\t"Decomposition rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'P\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\texpectedResultPair :=nil.\r\texpectedResultSetOfPair:=MinimalOrderedSet new. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"Conflict rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'Q\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 12:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:21:18.444154+01:00' ],		#prior : OmReference [ '89' ],		#self : OmReference [ '90' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testEmptyPredicate,			#protocol : #tests,			#sourceCode : 'testEmptyPredicate\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"tests for empty predicates"\r\t\r\t"Decomposition rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'P\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\texpectedResultPair :=nil.\r\texpectedResultSetOfPair:=MinimalOrderedSet new. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"Conflict rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'Q\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 12:20',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testEmptyPredicate,			#protocol : #tests,			#sourceCode : 'testEmptyPredicate\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"tests for empty predicates"\r\t\r\t"Decomposition rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'P\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\texpectedResultPair :=nil.\r\texpectedResultSetOfPair:=MinimalOrderedSet new. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"Conflict rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'Q\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair:=MinimalOrderedSet new. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 12:21',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:21:48.843589+01:00' ],		#prior : OmReference [ '90' ],		#self : OmReference [ '91' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testEmptyPredicate,			#protocol : #tests,			#sourceCode : 'testEmptyPredicate\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"tests for empty predicates"\r\t\r\t"Decomposition rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'P\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\texpectedResultPair :=nil.\r\texpectedResultSetOfPair:=MinimalOrderedSet new. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"Conflict rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'Q\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair:=MinimalOrderedSet new. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 12:21',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testEmptyPredicate,			#protocol : #tests,			#sourceCode : 'testEmptyPredicate\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"tests for empty predicates"\r\t\r\t"Decomposition rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'P\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\texpectedResultPair :=Pair left: left right: right.\r\texpectedResultSetOfPair:=MinimalOrderedSet new. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"Conflict rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'Q\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair:=MinimalOrderedSet new. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 12:21',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:22:08.260954+01:00' ],		#prior : OmReference [ '91' ],		#self : OmReference [ '92' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testEmptyPredicate,			#protocol : #tests,			#sourceCode : 'testEmptyPredicate\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"tests for empty predicates"\r\t\r\t"Decomposition rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'P\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\texpectedResultPair :=Pair left: left right: right.\r\texpectedResultSetOfPair:=MinimalOrderedSet new. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"Conflict rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'Q\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair:=MinimalOrderedSet new. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 12:21',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testEmptyPredicate,			#protocol : #tests,			#sourceCode : 'testEmptyPredicate\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"tests for empty predicates"\r\t\r\t"Decomposition rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'P\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\texpectedResultPair :=Pair left: left right: right.\r\texpectedResultSetOfPair:=MinimalOrderedSet new. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"Conflict rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'Q\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair:=nil. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 12:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:25:29.836118+01:00' ],		#prior : OmReference [ '92' ],		#self : OmReference [ '93' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testEmptyPredicate,			#protocol : #tests,			#sourceCode : 'testEmptyPredicate\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"tests for empty predicates"\r\t\r\t"Decomposition rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'P\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\texpectedResultPair :=Pair left: left right: right.\r\texpectedResultSetOfPair:=MinimalOrderedSet new. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"Conflict rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'Q\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair:=nil. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 12:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testEmptyPredicate,			#protocol : #tests,			#sourceCode : 'testEmptyPredicate\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"tests for empty predicates"\r\t\r\t"Decomposition rule"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'P\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\texpectedResultPair :=Pair left: left right: right.\r\texpectedResultSetOfPair:=MinimalOrderedSet new. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"Conflict rule on Symbols"\r\tleft:=Predicate new: \'P\'.\r\tright:=Predicate new: \'Q\'.\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"testing will fai, so everything will be nill"\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair:=nil. \r\t\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals: expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 12:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:33:28.105137+01:00' ],		#prior : OmReference [ '93' ],		#self : OmReference [ '94' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestUnification\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestUnification,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestUnification class\r\tinstanceVariableNames: \'\''				},				#name : #'TestUnification class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestUnification,					#isMetaSide : false				},				#parent : @7,				#content : 'Unification test. \rFor reference, the table of possible operations used is:\r\r             =         |     const      |   Linked    |     Func/Pred     \r        Const    |  Conflict     |  Swap       |    Check\r                        |  Delete        |                    |\r                        |                       |                     | \rLinked | Eliminate  |  Delete     |    Check\r                        |                       |                     | \rFunc/Pred  | Swap          |  Swap        |   Decompose\r                        |                       |                      |   Conflict\r                        |                       |                      | ',				#stamp : 'pm 12/14/2018 12:33'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'Unification test. \rFor reference, the table of possible operations used is:\r\r    =         |     const      |   Linked    |     Func      \rConst   |  Conflict     |  Swap       |    Check\r               |  Delete        |                    |\r               |                       |                     | \rLinked | Eliminate  |  Delete     |    Check\r               |                       |                     | \rFunc     | Swap          |  Swap        |   Decompose\r               |                       |                      |   Conflict\r               |                       |                      | ',		#newComment : 'Unification test. \rFor reference, the table of possible operations used is:\r\r             =         |     const      |   Linked    |     Func/Pred     \r        Const    |  Conflict     |  Swap       |    Check\r                        |  Delete        |                    |\r                        |                       |                     | \rLinked | Eliminate  |  Delete     |    Check\r                        |                       |                     | \rFunc/Pred  | Swap          |  Swap        |   Decompose\r                        |                       |                      |   Conflict\r                        |                       |                      | ',		#oldStamp : 'pm 12/14/2018 10:31',		#newStamp : 'pm 12/14/2018 12:33'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:33:56.662405+01:00' ],		#prior : OmReference [ '94' ],		#self : OmReference [ '95' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestUnification\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestUnification,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestUnification class\r\tinstanceVariableNames: \'\''				},				#name : #'TestUnification class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestUnification,					#isMetaSide : false				},				#parent : @7,				#content : 'Unification test. \rFor reference, the table of possible operations used is:\r\r             =         |     const      |   Linked    |     Func/Pred     \r        Const    |  Conflict     |  Swap       |    Check\r                        |  Delete        |                    |\r                        |                       |                     | \r     Linked     | Eliminate  |  Delete     |    Check\r                        |                       |                     | \rFunc/Pred  | Swap          |  Swap        |   Decompose\r                        |                       |                      |   Conflict\r                        |                       |                      | ',				#stamp : 'pm 12/14/2018 12:33'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'Unification test. \rFor reference, the table of possible operations used is:\r\r             =         |     const      |   Linked    |     Func/Pred     \r        Const    |  Conflict     |  Swap       |    Check\r                        |  Delete        |                    |\r                        |                       |                     | \rLinked | Eliminate  |  Delete     |    Check\r                        |                       |                     | \rFunc/Pred  | Swap          |  Swap        |   Decompose\r                        |                       |                      |   Conflict\r                        |                       |                      | ',		#newComment : 'Unification test. \rFor reference, the table of possible operations used is:\r\r             =         |     const      |   Linked    |     Func/Pred     \r        Const    |  Conflict     |  Swap       |    Check\r                        |  Delete        |                    |\r                        |                       |                     | \r     Linked     | Eliminate  |  Delete     |    Check\r                        |                       |                     | \rFunc/Pred  | Swap          |  Swap        |   Decompose\r                        |                       |                      |   Conflict\r                        |                       |                      | ',		#oldStamp : 'pm 12/14/2018 12:33',		#newStamp : 'pm 12/14/2018 12:33'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:38:09.515312+01:00' ],		#prior : OmReference [ '95' ],		#self : OmReference [ '96' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isAbstractTerm,			#protocol : #'as yet unclassified',			#sourceCode : 'isAbstractTerm\r\t^true',			#stamp : 'pm 12/14/2018 12:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:38:09.569604+01:00' ],		#prior : OmReference [ '96' ],		#self : OmReference [ '97' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isAbstractTerm,			#protocol : #'as yet unclassified',			#sourceCode : 'isAbstractTerm\r\t^true',			#stamp : 'pm 12/14/2018 12:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isAbstractTerm,			#protocol : #testing,			#sourceCode : 'isAbstractTerm\r\t^true',			#stamp : 'pm 12/14/2018 12:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:38:22.494533+01:00' ],		#prior : OmReference [ '97' ],		#self : OmReference [ '98' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isFuncTerm,			#protocol : #testing,			#sourceCode : 'isFuncTerm\r\t^false',			#stamp : 'pm 12/14/2018 12:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:38:41.655034+01:00' ],		#prior : OmReference [ '98' ],		#self : OmReference [ '99' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isTerm,			#protocol : #testing,			#sourceCode : 'isTerm\r\t^false',			#stamp : 'pm 12/14/2018 12:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:38:55.788975+01:00' ],		#prior : OmReference [ '99' ],		#self : OmReference [ '100' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #UnaryTerm,			#protocol : #testing,			#sourceCode : 'UnaryTerm\r\t^false',			#stamp : 'pm 12/14/2018 12:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:38:58.996371+01:00' ],		#prior : OmReference [ '100' ],		#self : OmReference [ '101' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isUnaryTerm,			#protocol : #testing,			#sourceCode : 'isUnaryTerm\r\t^false',			#stamp : 'pm 12/14/2018 12:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:39:02.350237+01:00' ],		#prior : OmReference [ '101' ],		#self : OmReference [ '102' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #UnaryTerm,			#protocol : #testing,			#sourceCode : 'UnaryTerm\r\t^false',			#stamp : 'pm 12/14/2018 12:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:39:18.88987+01:00' ],		#prior : OmReference [ '102' ],		#self : OmReference [ '103' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isConstTerm,			#protocol : #testing,			#sourceCode : 'isConstTerm\r\t^false',			#stamp : 'pm 12/14/2018 12:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:39:25.302152+01:00' ],		#prior : OmReference [ '103' ],		#self : OmReference [ '104' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isLinkedTerm,			#protocol : #testing,			#sourceCode : 'isLinkedTerm\r\t^false',			#stamp : 'pm 12/14/2018 12:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:40:15.623905+01:00' ],		#prior : OmReference [ '104' ],		#self : OmReference [ '105' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #isFuncTerm,			#protocol : #testing,			#sourceCode : 'isFuncTerm\r\t^true',			#stamp : 'pm 12/14/2018 12:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:40:27.725374+01:00' ],		#prior : OmReference [ '105' ],		#self : OmReference [ '106' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #isTerm,			#protocol : #'as yet unclassified',			#sourceCode : 'isTerm\r\t^true',			#stamp : 'pm 12/14/2018 12:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:40:27.774711+01:00' ],		#prior : OmReference [ '106' ],		#self : OmReference [ '107' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #isTerm,			#protocol : #'as yet unclassified',			#sourceCode : 'isTerm\r\t^true',			#stamp : 'pm 12/14/2018 12:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #isTerm,			#protocol : #testing,			#sourceCode : 'isTerm\r\t^true',			#stamp : 'pm 12/14/2018 12:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:40:38.45289+01:00' ],		#prior : OmReference [ '107' ],		#self : OmReference [ '108' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #isUnaryTerm,			#protocol : #'as yet unclassified',			#sourceCode : 'isUnaryTerm\r\t^true',			#stamp : 'pm 12/14/2018 12:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:40:38.507559+01:00' ],		#prior : OmReference [ '108' ],		#self : OmReference [ '109' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #isUnaryTerm,			#protocol : #'as yet unclassified',			#sourceCode : 'isUnaryTerm\r\t^true',			#stamp : 'pm 12/14/2018 12:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #isUnaryTerm,			#protocol : #testing,			#sourceCode : 'isUnaryTerm\r\t^true',			#stamp : 'pm 12/14/2018 12:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:40:50.972968+01:00' ],		#prior : OmReference [ '109' ],		#self : OmReference [ '110' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #isConstTerm,			#protocol : #'as yet unclassified',			#sourceCode : 'isConstTerm\r\t^true',			#stamp : 'pm 12/14/2018 12:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:40:51.027126+01:00' ],		#prior : OmReference [ '110' ],		#self : OmReference [ '111' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #isConstTerm,			#protocol : #'as yet unclassified',			#sourceCode : 'isConstTerm\r\t^true',			#stamp : 'pm 12/14/2018 12:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #isConstTerm,			#protocol : #testing,			#sourceCode : 'isConstTerm\r\t^true',			#stamp : 'pm 12/14/2018 12:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:41:02.441523+01:00' ],		#prior : OmReference [ '111' ],		#self : OmReference [ '112' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LinkedTerm,				#isMetaSide : false			},			#name : #isLinkedTerm,			#protocol : #'as yet unclassified',			#sourceCode : 'isLinkedTerm\r\t^true',			#stamp : 'pm 12/14/2018 12:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:41:02.486348+01:00' ],		#prior : OmReference [ '112' ],		#self : OmReference [ '113' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LinkedTerm,				#isMetaSide : false			},			#name : #isLinkedTerm,			#protocol : #'as yet unclassified',			#sourceCode : 'isLinkedTerm\r\t^true',			#stamp : 'pm 12/14/2018 12:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LinkedTerm,				#isMetaSide : false			},			#name : #isLinkedTerm,			#protocol : #testing,			#sourceCode : 'isLinkedTerm\r\t^true',			#stamp : 'pm 12/14/2018 12:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:48:02.66437+01:00' ],		#prior : OmReference [ '113' ],		#self : OmReference [ '114' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.]"delete"\r\t\tifFalse:[\t\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].]\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[(right isKindOf: LinkedTerm) or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/13/2018 21:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.]"delete"\r\t\tifFalse:[\t\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].]\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(((left isConst) and:[right isLinkedTerm.])\r\t\t\tor:[left isFuncTerm])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[(right isKindOf: LinkedTerm) or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 12:48',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:49:39.866748+01:00' ],		#prior : OmReference [ '114' ],		#self : OmReference [ '115' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.]"delete"\r\t\tifFalse:[\t\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].]\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(((left isConst) and:[right isLinkedTerm.])\r\t\t\tor:[left isFuncTerm])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[(right isKindOf: LinkedTerm) or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 12:48',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t\r\t((left isConstTerm) and:[right isConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.]"delete"\r\t\tifFalse:[\t\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].]\r\tifFalse:[\r\t\t(((left isFuncTerm) and:[right isFuncTerm])\r\t\tor:[(left isPredicate) and:[right isPredicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(((left isConst) and:[right isLinkedTerm.])\r\t\t\tor:[left isFuncTerm])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[(right isKindOf: LinkedTerm) or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 12:49',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:51:52.817168+01:00' ],		#prior : OmReference [ '115' ],		#self : OmReference [ '116' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t\r\t((left isConstTerm) and:[right isConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.]"delete"\r\t\tifFalse:[\t\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].]\r\tifFalse:[\r\t\t(((left isFuncTerm) and:[right isFuncTerm])\r\t\tor:[(left isPredicate) and:[right isPredicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(((left isConst) and:[right isLinkedTerm.])\r\t\t\tor:[left isFuncTerm])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[(right isKindOf: LinkedTerm) or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 12:49',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t\r\t((left isConstTerm) and:[right isConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.]"delete"\r\t\tifFalse:[\t\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].]\r\tifFalse:[\r\t\t(((left isFuncTerm) and:[right isFuncTerm])\r\t\tor:[(left isPredicate) and:[right isPredicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(((left isConst) and:[right isLinkedTerm.])\r\t\t\tor:[left isFuncTerm])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isLinkedTerm) \r\t\t\t\tand:[(right isLinkedTerm) or:[right isConst]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isLinkedTerm) and:[right isFuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 12:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:52:45.317596+01:00' ],		#prior : OmReference [ '116' ],		#self : OmReference [ '117' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isPredicate,			#protocol : #'as yet unclassified',			#sourceCode : 'isPredicate\r\t"that tester is necessary because of the similitudes between FuncTerm and Predicate"\r\t^false.',			#stamp : 'pm 12/14/2018 12:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T12:52:45.365564+01:00' ],		#prior : OmReference [ '117' ],		#self : OmReference [ '118' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isPredicate,			#protocol : #'as yet unclassified',			#sourceCode : 'isPredicate\r\t"that tester is necessary because of the similitudes between FuncTerm and Predicate"\r\t^false.',			#stamp : 'pm 12/14/2018 12:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isPredicate,			#protocol : #testing,			#sourceCode : 'isPredicate\r\t"that tester is necessary because of the similitudes between FuncTerm and Predicate"\r\t^false.',			#stamp : 'pm 12/14/2018 12:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T13:17:37.917043+01:00' ],		#prior : OmReference [ '118' ],		#self : OmReference [ '119' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isPredicateOrFunc,			#protocol : #'as yet unclassified',			#sourceCode : 'isPredicateOrFunc\r\t^false',			#stamp : 'pm 12/14/2018 13:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T13:17:37.983116+01:00' ],		#prior : OmReference [ '119' ],		#self : OmReference [ '120' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isPredicateOrFunc,			#protocol : #'as yet unclassified',			#sourceCode : 'isPredicateOrFunc\r\t^false',			#stamp : 'pm 12/14/2018 13:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isPredicateOrFunc,			#protocol : #testing,			#sourceCode : 'isPredicateOrFunc\r\t^false',			#stamp : 'pm 12/14/2018 13:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T13:18:11.049956+01:00' ],		#prior : OmReference [ '120' ],		#self : OmReference [ '121' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #isPredicateOrFunc,			#protocol : #'as yet unclassified',			#sourceCode : 'isPredicateOrFunc\r\t^true',			#stamp : 'pm 12/14/2018 13:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T13:18:11.11635+01:00' ],		#prior : OmReference [ '121' ],		#self : OmReference [ '122' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #isPredicateOrFunc,			#protocol : #'as yet unclassified',			#sourceCode : 'isPredicateOrFunc\r\t^true',			#stamp : 'pm 12/14/2018 13:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #isPredicateOrFunc,			#protocol : #testing,			#sourceCode : 'isPredicateOrFunc\r\t^true',			#stamp : 'pm 12/14/2018 13:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T13:19:34.328798+01:00' ],		#prior : OmReference [ '122' ],		#self : OmReference [ '123' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #isPredicateOrFunc,			#protocol : #testing,			#sourceCode : 'isPredicateOrFunc\r\t^true',			#stamp : 'pm 12/14/2018 13:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #isPredicateOrFunc,			#protocol : #testing,			#sourceCode : 'isPredicateOrFunc\r\t"Class tester"\r\t"Necessary because we don\'t distinguish them in the unification process"\r\t^true',			#stamp : 'pm 12/14/2018 13:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T13:20:15.149079+01:00' ],		#prior : OmReference [ '123' ],		#self : OmReference [ '124' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isPredicateOrFunc,			#protocol : #testing,			#sourceCode : 'isPredicateOrFunc\r\t^false',			#stamp : 'pm 12/14/2018 13:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isPredicateOrFunc,			#protocol : #testing,			#sourceCode : 'isPredicateOrFunc\t\r\t"Class tester"\r\t"Necessary because we don\'t distinguish them in the unification process"\r\t^false',			#stamp : 'pm 12/14/2018 13:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T13:20:27.334152+01:00' ],		#prior : OmReference [ '124' ],		#self : OmReference [ '125' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isPredicateOrFunc,			#protocol : #'as yet unclassified',			#sourceCode : 'isPredicateOrFunc\t\r\t"Class tester"\r\t"Necessary because we don\'t distinguish them in the unification process"\r\t^false',			#stamp : 'pm 12/14/2018 13:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T13:20:27.411248+01:00' ],		#prior : OmReference [ '125' ],		#self : OmReference [ '126' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isPredicateOrFunc,			#protocol : #'as yet unclassified',			#sourceCode : 'isPredicateOrFunc\t\r\t"Class tester"\r\t"Necessary because we don\'t distinguish them in the unification process"\r\t^false',			#stamp : 'pm 12/14/2018 13:20',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isPredicateOrFunc,			#protocol : #testing,			#sourceCode : 'isPredicateOrFunc\t\r\t"Class tester"\r\t"Necessary because we don\'t distinguish them in the unification process"\r\t^false',			#stamp : 'pm 12/14/2018 13:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T13:20:58.796742+01:00' ],		#prior : OmReference [ '126' ],		#self : OmReference [ '127' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #isPredicateOrFunc,			#protocol : #'as yet unclassified',			#sourceCode : 'isPredicateOrFunc\t\r\t"Class tester"\r\t"Necessary because we don\'t distinguish them in the unification process"\r\t^true',			#stamp : 'pm 12/14/2018 13:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T13:20:58.849521+01:00' ],		#prior : OmReference [ '127' ],		#self : OmReference [ '128' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #isPredicateOrFunc,			#protocol : #'as yet unclassified',			#sourceCode : 'isPredicateOrFunc\t\r\t"Class tester"\r\t"Necessary because we don\'t distinguish them in the unification process"\r\t^true',			#stamp : 'pm 12/14/2018 13:20',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #isPredicateOrFunc,			#protocol : #testing,			#sourceCode : 'isPredicateOrFunc\t\r\t"Class tester"\r\t"Necessary because we don\'t distinguish them in the unification process"\r\t^true',			#stamp : 'pm 12/14/2018 13:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T13:21:08.914915+01:00' ],		#prior : OmReference [ '128' ],		#self : OmReference [ '129' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #isPredicateOrFuncTerm,			#protocol : #testing,			#sourceCode : 'isPredicateOrFuncTerm\r\t"Class tester"\r\t"Necessary because we don\'t distinguish them in the unification process"\r\t^true',			#stamp : 'pm 12/14/2018 13:21',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T13:22:40.29196+01:00' ],		#prior : OmReference [ '129' ],		#self : OmReference [ '130' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isPredicateOrFuncTerm,			#protocol : #testing,			#sourceCode : 'isPredicateOrFuncTerm\r\t"Class tester"\r\t"Necessary because we don\'t distinguish them in the unification process"\r\t^false',			#stamp : 'pm 12/14/2018 13:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T13:22:43.97556+01:00' ],		#prior : OmReference [ '130' ],		#self : OmReference [ '131' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isPredicateOrFunc,			#protocol : #testing,			#sourceCode : 'isPredicateOrFunc\t\r\t"Class tester"\r\t"Necessary because we don\'t distinguish them in the unification process"\r\t^false',			#stamp : 'pm 12/14/2018 13:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T13:22:51.710351+01:00' ],		#prior : OmReference [ '131' ],		#self : OmReference [ '132' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #isPredicateOrFunc,			#protocol : #testing,			#sourceCode : 'isPredicateOrFunc\t\r\t"Class tester"\r\t"Necessary because we don\'t distinguish them in the unification process"\r\t^true',			#stamp : 'pm 12/14/2018 13:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T13:22:59.912763+01:00' ],		#prior : OmReference [ '132' ],		#self : OmReference [ '133' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isPredicateOrFuncTerm,			#protocol : #testing,			#sourceCode : 'isPredicateOrFuncTerm\r\t"Class tester"\r\t"Necessary because we don\'t distinguish them in the unification process"\r\t^false',			#stamp : 'pm 12/14/2018 13:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T13:23:03.362234+01:00' ],		#prior : OmReference [ '133' ],		#self : OmReference [ '134' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isPredicateOrFunc,			#protocol : #testing,			#sourceCode : 'isPredicateOrFunc\t\r\t"Class tester"\r\t"Necessary because we don\'t distinguish them in the unification process"\r\t^false',			#stamp : 'pm 12/14/2018 13:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T13:23:09.826279+01:00' ],		#prior : OmReference [ '134' ],		#self : OmReference [ '135' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #isPredicateOrFuncTerm,			#protocol : #testing,			#sourceCode : 'isPredicateOrFuncTerm\r\t"Class tester"\r\t"Necessary because we don\'t distinguish them in the unification process"\r\t^true',			#stamp : 'pm 12/14/2018 13:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T13:24:07.990598+01:00' ],		#prior : OmReference [ '135' ],		#self : OmReference [ '136' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #isPredicateOrFunc,			#protocol : #testing,			#sourceCode : 'isPredicateOrFunc\r\t"Class tester"\r\t"Necessary because we don\'t distinguish them in the unification process"\r\t^true',			#stamp : 'pm 12/14/2018 13:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T13:43:32.371704+01:00' ],		#prior : OmReference [ '136' ],		#self : OmReference [ '137' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperationsRefactor:',			#protocol : #unification,			#sourceCode : 'tryOperationsRefactor: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFunc)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tself swap:aPair.\r\t\t\t]\r\t\t]\r\tifFalse:[].\r\r\r\t\r\t((left isConstTerm) and:[right isConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.]"delete"\r\t\tifFalse:[\t\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].]\r\tifFalse:[\r\t\t(((left isFuncTerm) and:[right isFuncTerm])\r\t\tor:[(left isPredicate) and:[right isPredicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(((left isConst) and:[right isLinkedTerm.])\r\t\t\tor:[left isFuncTerm])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isLinkedTerm) \r\t\t\t\tand:[(right isLinkedTerm) or:[right isConst]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isLinkedTerm) and:[right isFuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 13:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T14:42:25.277732+01:00' ],		#prior : OmReference [ '137' ],		#self : OmReference [ '138' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperationsRefactor:',			#protocol : #unification,			#sourceCode : 'tryOperationsRefactor: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFunc)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tself swap:aPair.\r\t\t\t]\r\t\t]\r\tifFalse:[].\r\r\r\t\r\t((left isConstTerm) and:[right isConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.]"delete"\r\t\tifFalse:[\t\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].]\r\tifFalse:[\r\t\t(((left isFuncTerm) and:[right isFuncTerm])\r\t\tor:[(left isPredicate) and:[right isPredicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(((left isConst) and:[right isLinkedTerm.])\r\t\t\tor:[left isFuncTerm])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isLinkedTerm) \r\t\t\t\tand:[(right isLinkedTerm) or:[right isConst]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isLinkedTerm) and:[right isFuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 13:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperationsRefactor:',			#protocol : #unification,			#sourceCode : 'tryOperationsRefactor: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFunc)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tself swap:aPair.\r\t\t\tmodified:=true.\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tself eliminate:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\t\tleft=right\r\t\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\t\tmodified:=true\r\t\t\t\t\t\t\t]\r\t\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\r\t\r\t((left isConstTerm) and:[right isConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.]"delete"\r\t\tifFalse:[\t\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].]\r\tifFalse:[\r\t\t(((left isFuncTerm) and:[right isFuncTerm])\r\t\tor:[(left isPredicate) and:[right isPredicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(((left isConst) and:[right isLinkedTerm.])\r\t\t\tor:[left isFuncTerm])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isLinkedTerm) \r\t\t\t\tand:[(right isLinkedTerm) or:[right isConst]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isLinkedTerm) and:[right isFuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 14:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T14:42:57.520671+01:00' ],		#prior : OmReference [ '138' ],		#self : OmReference [ '139' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperationsRefactor:',			#protocol : #unification,			#sourceCode : 'tryOperationsRefactor: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFunc)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tself swap:aPair.\r\t\t\tmodified:=true.\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tself eliminate:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\t\tleft=right\r\t\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\t\tmodified:=true\r\t\t\t\t\t\t\t]\r\t\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\r\t\r\t((left isConstTerm) and:[right isConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.]"delete"\r\t\tifFalse:[\t\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].]\r\tifFalse:[\r\t\t(((left isFuncTerm) and:[right isFuncTerm])\r\t\tor:[(left isPredicate) and:[right isPredicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(((left isConst) and:[right isLinkedTerm.])\r\t\t\tor:[left isFuncTerm])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isLinkedTerm) \r\t\t\t\tand:[(right isLinkedTerm) or:[right isConst]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isLinkedTerm) and:[right isFuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 14:42',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperationsRefactor:',			#protocol : #unification,			#sourceCode : 'tryOperationsRefactor: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFunc)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tself swap:aPair.\r\t\t\tmodified:=true.\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tself eliminate:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\tleft=right\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\tmodified:=true\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 14:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T14:43:06.880992+01:00' ],		#prior : OmReference [ '139' ],		#self : OmReference [ '140' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperationsOld:',			#protocol : #unification,			#sourceCode : 'tryOperationsOld: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t\r\t((left isConstTerm) and:[right isConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.]"delete"\r\t\tifFalse:[\t\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].]\r\tifFalse:[\r\t\t(((left isFuncTerm) and:[right isFuncTerm])\r\t\tor:[(left isPredicate) and:[right isPredicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(((left isConst) and:[right isLinkedTerm.])\r\t\t\tor:[left isFuncTerm])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isLinkedTerm) \r\t\t\t\tand:[(right isLinkedTerm) or:[right isConst]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isLinkedTerm) and:[right isFuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 14:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T14:43:12.122767+01:00' ],		#prior : OmReference [ '140' ],		#self : OmReference [ '141' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t\r\t((left isConstTerm) and:[right isConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.]"delete"\r\t\tifFalse:[\t\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].]\r\tifFalse:[\r\t\t(((left isFuncTerm) and:[right isFuncTerm])\r\t\tor:[(left isPredicate) and:[right isPredicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(((left isConst) and:[right isLinkedTerm.])\r\t\t\tor:[left isFuncTerm])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isLinkedTerm) \r\t\t\t\tand:[(right isLinkedTerm) or:[right isConst]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isLinkedTerm) and:[right isFuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 12:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFunc)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tself swap:aPair.\r\t\t\tmodified:=true.\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tself eliminate:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\tleft=right\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\tmodified:=true\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 14:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T14:43:15.414446+01:00' ],		#prior : OmReference [ '141' ],		#self : OmReference [ '142' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperationsRefactor:',			#protocol : #unification,			#sourceCode : 'tryOperationsRefactor: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFunc)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tself swap:aPair.\r\t\t\tmodified:=true.\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tself eliminate:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\tleft=right\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\tmodified:=true\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 14:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T14:44:02.958165+01:00' ],		#prior : OmReference [ '142' ],		#self : OmReference [ '143' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFunc)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tself swap:aPair.\r\t\t\tmodified:=true.\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tself eliminate:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\tleft=right\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\tmodified:=true\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 14:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFunc)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:["Decompose is possible"\r\t\t\t\tself decompose:aPair. \r\t\t\t\tmodified:=true.\r\t\t\t\t]\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tself swap:aPair.\r\t\t\tmodified:=true.\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tself eliminate:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\tleft=right\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\tmodified:=true\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 14:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T14:44:22.297648+01:00' ],		#prior : OmReference [ '143' ],		#self : OmReference [ '144' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFunc)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:["Decompose is possible"\r\t\t\t\tself decompose:aPair. \r\t\t\t\tmodified:=true.\r\t\t\t\t]\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tself swap:aPair.\r\t\t\tmodified:=true.\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tself eliminate:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\tleft=right\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\tmodified:=true\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 14:44',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFuncTerm)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:["Decompose is possible"\r\t\t\t\tself decompose:aPair. \r\t\t\t\tmodified:=true.\r\t\t\t\t]\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tself swap:aPair.\r\t\t\tmodified:=true.\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tself eliminate:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\tleft=right\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\tmodified:=true\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 14:44',			#package : #_resolution_1erOrdre		}	}}