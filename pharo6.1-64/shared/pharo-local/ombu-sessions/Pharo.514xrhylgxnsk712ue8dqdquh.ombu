OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T20:13:51.165432+02:00' ],		#prior : OmReference [ 'Pharo.1q0p6h4juxv5mzqk7tltsld7p', '103' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'add:',			#protocol : #initialization,			#sourceCode : 'add: clause\r\t(clause isKindOf: Clause)\r\tifTrue: [ self clauses add: clause ]\r\tifFalse:[Transcript show: \'Tried to add a non clause object to a clausaleForm\'].',			#stamp : 'pm 10/3/2018 13:01',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'add:',			#protocol : #initialization,			#sourceCode : 'add: clause\r\t(clause isKindOf: Clause)\r\tifTrue: [ self clauses add: clause ]\r\tifFalse:[Error new: \'Tried to add a non clause object to a clausaleForm\'].',			#stamp : 'pm 10/9/2018 13:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T20:13:51.189639+02:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #initialization,			#sourceCode : 'addAll: clausifiedProp\r\t\t(clausifiedProp  isKindOf: Or) | (clausifiedProp isKindOf: Atome) "If i\'m in a or, there\'s only or(s) under him."\r\t\tifTrue:[self clauses add: (Clause new:clausifiedProp)]\r\t\tifFalse:[\r\t\t\t(clausifiedProp isKindOf: And)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (clausifiedProp left).\r\t\t\t\tself addAll: (clausifiedProp right).\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\tTranscript show: \'Tried to add a non clause object to a clausaleForm\'  ].\r\t\t].',			#stamp : 'pm 10/2/2018 21:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #initialization,			#sourceCode : 'addAll: clausifiedProp\r\t((clausifiedProp  isKindOf: Or) | (clausifiedProp isKindOf: Atome))\r\t "If i\'m in a or, there\'s only or(s) under him."\r\tifTrue:[self clauses add: (Clause new:clausifiedProp)]\r\tifFalse:[\r\t\t(clausifiedProp isKindOf: Not)\r\t\tifTrue:[\r\t\t\t((clausifiedProp operand) isKindOf:Atome)\r\t\t\tifTrue:[^self clauses add:(Clause new:clausifiedProp).]\r\t\t\tifFalse:[^Error new:\'a not isn\'\'t englobing an atome\'.].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(clausifiedProp isKindOf: And)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (clausifiedProp left).\r\t\t\t\tself addAll: (clausifiedProp right).\r\t\t\t\t]\r\t\tifFalse:[\r\t\tError new: \'Tried to add a non clause object to a clausaleForm\'.].\r\t].\r\t].',			#stamp : 'pm 10/9/2018 13:59',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T20:13:51.203287+02:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #initialization,			#sourceCode : 'prettyPrint\r\t|t|\r\tt:=\'{\'.\r\t\tclauses do: [  :each | t:=t,(each prettyPrint),\',\'. ].\r\tt:=t,\'}\'.\r\t^t.',			#stamp : 'pm 10/3/2018 15:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #initialization,			#sourceCode : 'prettyPrint\r\t|t|\r\tt:=\'{\'.\r\t\tclauses do: [  :each | t:=t,(each prettyPrint). ] separatedBy: [t:=t,\',\'].\r\tt:=t,\'}\'.\r\t^t.',			#stamp : 'pm 10/9/2018 17:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T20:13:51.232784+02:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'add:',			#protocol : #accessing,			#sourceCode : 'add: var\r\t(var isKindOf: Atome)\r\t\tifTrue:[\r\t\t\t(self atomes) add:var.\r\t\t\t^self."able chaining operation"\r\t\t\t]\r\t\tifFalse:[\r\t\t\t\tTranscript show: \'wrong type\'.\r\t\t\t\t"should add an error."\r\t\t\t].',			#stamp : 'pm 10/3/2018 13:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'add:',			#protocol : #accessing,			#sourceCode : 'add: var\r\t(var isKindOf: Atome)\r\t\tifTrue:[\r\t\t\t(self atomes) add:var.\r\t\t\t^self."able chaining operation"\r\t\t\t]\r\t\tifFalse:[\r\t\t\t\tError new: \'wrong type in clause\'.\r\t\t\t].',			#stamp : 'pm 10/9/2018 13:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T20:13:51.253784+02:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #accessing,			#sourceCode : 'addAll: orProp\r\t(orProp isKindOf: Atome)\r\tifTrue:[self add:orProp.]\r\tifFalse:[\r\t\t((orProp) isKindOf: Not)\r\t\tifTrue:["we\'re in a not"\r\t\t\t(orProp operand isKindOf:Atome)\r\t\t\t\tifTrue:["we\'re in an atom"\r\t\t\t\t\t((orProp operand) isKindOf: Predicate)\r\t\t\t\t\tifTrue:[self add:(NotPredicate new: (orProp operand) getSymb fromList: (orProp operand) terms).]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t((orProp operand) isKindOf: Var)\r\t\t\t\t\t\tifTrue:[self add:(NotVar new:((orProp operand) getSymb)).]\r\t\t\t\t\t\tifFalse: [ Error new: \'shouldn\'\'t be any True or false here\' ]].\r\t\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tError new:\'Error, shouldn\'\'t be any more not ( binaryOp )\'\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((orProp) isKindOf: Or)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (orProp left).\r\t\t\t\tself addAll: (orProp right).\r\t\t\t\t]\r\t\t\tifFalse:["switch to Error new:"\r\t\t\t\tTranscript show:\'Error, shouldn\'\'t be any other kind of prop here.\'.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/9/2018 12:19',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #accessing,			#sourceCode : 'addAll: orProp\r\t(orProp isKindOf: Atome)\r\tifTrue:[self add:orProp.]\r\tifFalse:[\r\t\t((orProp) isKindOf: Not)\r\t\tifTrue:["we\'re in a not"\r\t\t\t(orProp operand isKindOf:Atome)\r\t\t\t\tifTrue:["we\'re in an atom"\r\t\t\t\t\t((orProp operand) isKindOf: Predicate)\r\t\t\t\t\tifTrue:[self add:(NotPredicate new: (orProp operand) getSymb fromList: (orProp operand) terms).]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t((orProp operand) isKindOf: Var)\r\t\t\t\t\t\tifTrue:[self add:(NotVar new:((orProp operand) getSymb)).]\r\t\t\t\t\t\tifFalse: [ Error new: \'shouldn\'\'t be any True or false here\' ]].\r\t\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tError new:\'Error, shouldn\'\'t be any more not ( binaryOp )\'\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((orProp) isKindOf: Or)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (orProp left).\r\t\t\t\tself addAll: (orProp right).\r\t\t\t\t]\r\t\t\tifFalse:["switch to Error new:"\r\t\t\t\tError new:\'Error, shouldn\'\'t be any other kind of prop here.\'.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/9/2018 13:36',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T20:13:51.266322+02:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t|t|\r\tt:=\'{\'.\r\t\tatomes do: [  :each | t:=t,(each prettyPrint),\',\'. ].\r\tt:=t,\'}\'.\r\t^t.',			#stamp : 'pm 10/3/2018 13:08',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t|t|\r\tt:=\'{\'.\r\t\tatomes do:[  :each | t:=t,(each prettyPrint). ] separatedBy:[t:=t,\',\'].\r\tt:=t,\'}\'.\r\t^t.',			#stamp : 'pm 10/9/2018 17:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T20:13:51.311759+02:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #clausificationUnitTest,			#protocol : #testing,			#sourceCode : 'clausificationUnitTest\r\t|t|\r\tTranscript show: self prettyPrint; show: \'  \' ;show: self isClause; cr.\r\tt:=self fullClausification.\r\tTranscript show: t prettyPrint; show: \'  \' ;show: t isClause; cr;cr.\r\t^t',			#stamp : 'pm 10/9/2018 12:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #clausificationUnitTest,			#protocol : #testing,			#sourceCode : 'clausificationUnitTest\r\t|t|\r\tTranscript show: self prettyPrint; show: \'  \' ;show: self isClause; cr.\r\tt:=self fullClausification.\r\tTranscript show: t prettyPrint; show: \'  \' ;show: t isClause; cr;cr.\r\t^t.',			#stamp : 'pm 10/9/2018 13:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T20:13:51.351156+02:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #HerbranSkolemDocu,			#protocol : #Skoleminsation,			#sourceCode : 'HerbranSkolemDocu\r\t^Error new:\'documentation of Skolemnisation\'.\r\t"return that prop skolemnised"',			#stamp : 'pm 10/6/2018 18:09',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T20:13:51.400711+02:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms |\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\r\tTranscript cr;show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\r\tTranscript cr; show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\r\tTranscript cr; show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t(p SkolemnisationTest) clausificationUnitTest.\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/9/2018 12:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms |\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\r\r\tTranscript cr;show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\t\t\r\tTranscript cr; show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint;show:\'pouet\'.\r\t\t\r\tTranscript cr; show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint.\r\t\t\r\t\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/9/2018 13:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T20:13:51.467277+02:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #isSkolem,			#protocol : #testing,			#sourceCode : 'isSkolem\r\t^true.',			#stamp : 'pm 10/5/2018 23:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T20:13:51.748385+02:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t|t|\r\tt:=(self getSymb),\'(\'.\r"\tTranscript show:terms ;cr."\r\tterms do:[:each| t:=t,each prettyPrint,\',\'. ].\r\tt:=t,\')\'.\r\t^t.',			#stamp : 'pm 10/8/2018 21:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t|t|\r\tt:=(self getSymb),\'(\'.\r"\tTranscript show:terms ;cr."\r\tterms do:[:each| t:=t,each prettyPrint. ] separatedBy:[t:=t,\',\'].\r\tt:=t,\')\'.\r\t^t.',			#stamp : 'pm 10/9/2018 17:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T20:13:51.757303+02:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #isClause,			#protocol : #testing,			#sourceCode : 'isClause\r\t^true.',			#stamp : 'pm 10/5/2018 17:11',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T20:13:51.823301+02:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #NotPredicate,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint \r\t^(Not symb),(super prettyPrint)',			#stamp : 'pm 10/9/2018 17:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T20:13:51.942274+02:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t|t|\r\tt:=(self getSymb),\'(\'.\r\tterms do: [:each| t:=t,each,\',\'. ].\r\tt:=t,\')\'.\r\t^t.\r\t',			#stamp : 'pm 10/8/2018 17:16',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t|t|\r\tt:=(self getSymb),\'(\'.\r\tterms do: [:each| t:=t,each. ] separatedBy:[t:=t,\',\'].\r\tt:=t,\')\'.\r\t^t.\r\t',			#stamp : 'pm 10/9/2018 17:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T20:21:47.870099+02:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms |\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\r\r\tTranscript cr;show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\t\t\r\tTranscript cr; show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint;show:\'pouet\'.\r\t\t\r\tTranscript cr; show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint.\r\t\t\r\t\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/9/2018 13:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\r\r\tTranscript cr;show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\t\t\r\tTranscript cr; show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint.\r\t\t\r\tTranscript cr; show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint.\r\t\r\t\r\tTranscript cr; show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint.\r\t\r\tTranscript cr; show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\t\t\r\t\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/10/2018 20:21',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T20:22:11.627684+02:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\r\r\tTranscript cr;show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\t\t\r\tTranscript cr; show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint.\r\t\t\r\tTranscript cr; show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint.\r\t\r\t\r\tTranscript cr; show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint.\r\t\r\tTranscript cr; show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\t\t\r\t\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/10/2018 20:21',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\r\r\tTranscript cr;show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\t\t\r\tTranscript cr; show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint.\r\t\t\r\tTranscript cr; show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint.\r\t\r\t\r\tTranscript cr; show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint.\r\t\r\tTranscript cr; show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\t  p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r     Transcript show:p prettyPrint.\t\r\t\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/10/2018 20:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T20:59:01.984521+02:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\r\r\tTranscript cr;show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\t\t\r\tTranscript cr; show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint.\r\t\t\r\tTranscript cr; show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint.\r\t\r\t\r\tTranscript cr; show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint.\r\t\r\tTranscript cr; show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\t  p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r     Transcript show:p prettyPrint.\t\r\t\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/10/2018 20:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\r\r\tTranscript cr;show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\t\t\r\tTranscript cr; show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint.\r\t\t\r\tTranscript cr; show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint.\r\t\r\t\r\tTranscript cr; show: \'Teacher\'\'s stress test#1\' ; cr.\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint.\r\t\r\tTranscript cr; show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\t  p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r     Transcript show:p prettyPrint;cr.\t\r\t\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/10/2018 20:59',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T21:00:25.913841+02:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\r\r\tTranscript cr;show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\t\t\r\tTranscript cr; show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint.\r\t\t\r\tTranscript cr; show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint.\r\t\r\t\r\tTranscript cr; show: \'Teacher\'\'s stress test#1\' ; cr.\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint.\r\t\r\tTranscript cr; show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\t  p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r     Transcript show:p prettyPrint;cr.\t\r\t\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/10/2018 20:59',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\r\r\tTranscript cr;show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint ;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint;cr;cr.\r\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' ; cr.\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint;cr;cr.\r\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\t  p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r     Transcript show:p prettyPrint;cr.\t\r\t\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/10/2018 21:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T21:01:28.81064+02:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\r\r\tTranscript cr;show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint ;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint;cr;cr.\r\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' ; cr.\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint;cr;cr.\r\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\t  p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r     Transcript show:p prettyPrint;cr.\t\r\t\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/10/2018 21:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint ;cr;cr.\r\r\r\tTranscript show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint ;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint;cr;cr.\r\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' ; cr.\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint;cr;cr.\r\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\t  p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r     Transcript show:p prettyPrint;cr.\t\r\t\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/10/2018 21:01',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T21:24:45.448927+02:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint ;cr;cr.\r\r\r\tTranscript show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint ;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint;cr;cr.\r\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' ; cr.\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint;cr;cr.\r\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\t  p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r     Transcript show:p prettyPrint;cr.\t\r\t\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/10/2018 21:01',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint ;cr;cr.\r\r\r\tTranscript show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint ;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint;cr;cr.\r\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' ; cr.\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint;cr;cr.\r\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\t  p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r     Transcript show:p prettyPrint;cr.\t\r\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'\t ; cr.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variables: (Term new:\'z\')).\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r   Transcript show:p prettyPrint;cr.\t\r\t\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/10/2018 21:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T21:25:19.230176+02:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #PrettyPrint,			#protocol : #accessing,			#sourceCode : 'PrettyPrint\r\t|r|\r\tr:=\t(self getSymb),\'(\'.\r\tterms do:[:each|r:=r,each,\',\'.].\r\tr:=r,\')\'.\r\t^r.\r\t',			#stamp : 'pm 10/6/2018 19:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T21:35:41.233372+02:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint ;cr;cr.\r\r\r\tTranscript show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint ;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint;cr;cr.\r\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' ; cr.\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint;cr;cr.\r\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\t  p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r     Transcript show:p prettyPrint;cr.\t\r\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'\t ; cr.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variables: (Term new:\'z\')).\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r   Transcript show:p prettyPrint;cr.\t\r\t\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/10/2018 21:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint ;cr;cr.\r\r\r\tTranscript show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint ;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint;cr;cr.\r\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' ; cr.\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint;cr;cr.\r\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\t  p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r     Transcript show:p prettyPrint;cr.\t\r\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'\t ; cr.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r   Transcript show:p prettyPrint;cr.\t\r\t\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/10/2018 21:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T21:39:24.949079+02:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'new:Variable:',			#protocol : #'instance creation',			#sourceCode : 'new: symbo Variable: aVar\r\t^self basicNew initialize:symbo Variables: aVar.',			#stamp : 'pm 10/10/2018 21:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T21:39:28.243469+02:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'new:Variable:',			#protocol : #'instance creation',			#sourceCode : 'new: symbo Variable: aVar\r\t^self basicNew initialize:symbo Variables: aVar.',			#stamp : 'pm 10/10/2018 21:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'FuncTerm class',				#isMetaSide : true			},			#name : #'new:Variable:',			#protocol : #'instance creation',			#sourceCode : 'new: symbo Variable: aVar\r\t^self basicNew initialize:symbo Variable: aVar.',			#stamp : 'pm 10/10/2018 21:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T21:39:55.452591+02:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'initialize:Variable:',			#protocol : #initialization,			#sourceCode : 'initialize: symbo Variable: aTerm\r\tsuper initialize:symbo.\r\tterms:=LinkedList new.\r\tterms add: aTerm.',			#stamp : 'pm 10/10/2018 21:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T21:58:36.428331+02:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t|t|\r\tt:=(self getSymb),\'(\'.\r\tterms do: [:each| t:=t,each. ] separatedBy:[t:=t,\',\'].\r\tt:=t,\')\'.\r\t^t.\r\t',			#stamp : 'pm 10/9/2018 17:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t|t|\r\tt:=(self getSymb),\'(\'.\r\tterms do: [:each| t:=t,each prettyPrint. ] separatedBy:[t:=t,\',\'].\r\tt:=t,\')\'.\r\t^t.\r\t',			#stamp : 'pm 10/10/2018 21:58',			#package : #_resolution_1erOrdre		}	}}