OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T19:52:01.116391+01:00' ],		#prior : OmReference [ 'Pharo.4alm5slhxj9do56bo51krdzic', '69' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t"application of the resolution method on self. Course algorithm"\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tProp resolutionTrace ifTrue:[ Transcript show:self;cr].\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[Transcript show:\'POUET\'.^true.]."Insatisfiable"\r\t   ((c isTautology) or:[sat anySatisfy:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 12/14/2018 19:42',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t"application of the resolution method on self. Course algorithm"\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tProp resolutionTrace ifTrue:[ Transcript show:self;cr].\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[Transcript show:\'POUET\'.^false.]."Insatisfiable"\r\t   ((c isTautology) or:[sat anySatisfy:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 12/14/2018 19:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T19:52:10.390246+01:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t"application of the resolution method on self. Course algorithm"\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tProp resolutionTrace ifTrue:[ Transcript show:self;cr].\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[Transcript show:\'POUET\'.^false.]."Insatisfiable"\r\t   ((c isTautology) or:[sat anySatisfy:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 12/14/2018 19:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t"application of the resolution method on self. Course algorithm"\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tProp resolutionTrace ifTrue:[ Transcript show:self;cr].\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[Transcript show:\'POUET\'.^true.]."Insatisfiable"\r\t   ((c isTautology) or:[sat anySatisfy:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 12/14/2018 19:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T19:54:22.578009+01:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t"application of the resolution method on self. Course algorithm"\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tProp resolutionTrace ifTrue:[ Transcript show:self;cr].\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[Transcript show:\'POUET\'.^true.]."Insatisfiable"\r\t   ((c isTautology) or:[sat anySatisfy:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 12/14/2018 19:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t"application of the resolution method on self. Course algorithm"\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tProp resolutionTrace ifTrue:[ Transcript show:self;cr].\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[Transcript show:\'POUET\'.^true.]."Insatisfiable"\r\t   ((c isTautology) or:[sat anySatisfy:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\tTranscript show:\'TRUC\'.\r\t^false."satisfiable"',			#stamp : 'pm 12/14/2018 19:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T19:59:57.385966+01:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tclausificationTrace:=false.\r\tskolemnTrace:=false.\r\tdebugUnification:=true.\r\tresolutionTrace:=true.\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/14/2018 19:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tclausificationTrace:=false.\r\tskolemnTrace:=false.\r\tdebugUnification:=false.\r\tresolutionTrace:=true.\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/14/2018 19:59',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T20:02:09.607182+01:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t"application of the resolution method on self. Course algorithm"\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tProp resolutionTrace ifTrue:[ Transcript show:self;cr].\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[Transcript show:\'POUET\'.^true.]."Insatisfiable"\r\t   ((c isTautology) or:[sat anySatisfy:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\tTranscript show:\'TRUC\'.\r\t^false."satisfiable"',			#stamp : 'pm 12/14/2018 19:54',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t"application of the resolution method on self. Course algorithm"\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tProp resolutionTrace ifTrue:[ Transcript show:self;cr].\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r\t   ((c isTautology) or:[sat anySatisfy:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 12/14/2018 20:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T20:03:13.359567+01:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t"application of the resolution method on self. Course algorithm"\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tProp resolutionTrace ifTrue:[ Transcript show:self;cr].\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r\t   ((c isTautology) or:[sat anySatisfy:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 12/14/2018 20:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t"application of the resolution method on self. Course algorithm"\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tProp resolutionTrace ifTrue:[Transcript show:self;cr].\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r\t   ((c isTautology) or:[sat anySatisfy:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 12/14/2018 20:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T20:03:34.214139+01:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\t[ modified ]\r\twhileTrue:[\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification ifTrue: [ Transcript cr;cr;show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right"=not possible"\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\t"Transcript show: \'Unification impossible\'; cr."\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\thasFailed:=true.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t\r\t\t]. ',			#stamp : 'pm 12/14/2018 19:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\t[ modified ]\r\twhileTrue:[\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification ifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right"=not possible"\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\t"Transcript show: \'Unification impossible\'; cr."\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\thasFailed:=true.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t\r\t\t]. ',			#stamp : 'pm 12/14/2018 20:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T20:11:55.244925+01:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'ApplyUnifier:onClause:',			#protocol : #resolutionMethod,			#sourceCode : 'ApplyUnifier: u onClause:aClause',			#stamp : 'pm 12/14/2018 18:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'ApplyUnifier:onClause:',			#protocol : #resolutionMethod,			#sourceCode : 'ApplyUnifier: u onClause:aClause\r',			#stamp : 'pm 12/14/2018 20:11',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T20:12:08.369607+01:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'ApplyUnifier:onPredicate:',			#protocol : #resolutionMethod,			#sourceCode : 'ApplyUnifier: u onPredicate:aPredicate\r',			#stamp : 'pm 12/14/2018 20:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T20:15:00.99941+01:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'applyUnifier:onPredicate:',			#protocol : #resolutionMethod,			#sourceCode : 'applyUnifier: u onPredicate:aPredicate\r',			#stamp : 'pm 12/14/2018 20:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T20:15:05.263676+01:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'applyUnifier:onClause:',			#protocol : #resolutionMethod,			#sourceCode : 'applyUnifier: u onClause:aClause\r',			#stamp : 'pm 12/14/2018 20:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T20:15:08.971942+01:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'ApplyUnifier:onPredicate:',			#protocol : #resolutionMethod,			#sourceCode : 'ApplyUnifier: u onPredicate:aPredicate\r',			#stamp : 'pm 12/14/2018 20:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T20:15:11.399943+01:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'ApplyUnifier:onClause:',			#protocol : #resolutionMethod,			#sourceCode : 'ApplyUnifier: u onClause:aClause\r',			#stamp : 'pm 12/14/2018 20:11',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T20:17:25.830468+01:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #TestResolution\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestResolution,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestResolution class\r\tinstanceVariableNames: \'\''				},				#name : #'TestResolution class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestResolution,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T20:19:07.380229+01:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionLimitCase,			#protocol : #'as yet unclassified',			#sourceCode : 'testResolutionLimitCase\r\t| prop |\r\tprop:=And new:\r\t  (Or new:\r\t   (Predicate new:\'P\' fromList:\r\t     (LinkedList new \r\t      add:(LinkedTerm new:(Term new:\'x\'));\r\t      yourself)\r\t   )\r\t  rightProp:\r\t   (Predicate new:\'Q\' fromList:\r\t     (LinkedList new \r\t      add:(LinkedTerm new:(Term new:\'x\'));\r\t      yourself)\r\t   )\r\t  )\r\t rightProp:\r\t  (And new:\r\t   (Not new:(Predicate new:\'P\' fromList:\r\t     (LinkedList new \r\t      add:(ConstTerm new:(Term new:\'a\'));\r      yourself))\r\t   )\r\t\t  rightProp:\r\t   (Not new:(Predicate new:\'Q\' fromList:\r\t     (LinkedList new \r\t      add:(ConstTerm new:(Term new:\'b\'));\r\t      yourself))\r\t   )\r\t  ).\r\t\r\tself deny:(ClausalForm new:prop) resolutionMethod..',			#stamp : 'pm 12/14/2018 20:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T20:19:07.581608+01:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionLimitCase,			#protocol : #'as yet unclassified',			#sourceCode : 'testResolutionLimitCase\r\t| prop |\r\tprop:=And new:\r\t  (Or new:\r\t   (Predicate new:\'P\' fromList:\r\t     (LinkedList new \r\t      add:(LinkedTerm new:(Term new:\'x\'));\r\t      yourself)\r\t   )\r\t  rightProp:\r\t   (Predicate new:\'Q\' fromList:\r\t     (LinkedList new \r\t      add:(LinkedTerm new:(Term new:\'x\'));\r\t      yourself)\r\t   )\r\t  )\r\t rightProp:\r\t  (And new:\r\t   (Not new:(Predicate new:\'P\' fromList:\r\t     (LinkedList new \r\t      add:(ConstTerm new:(Term new:\'a\'));\r      yourself))\r\t   )\r\t\t  rightProp:\r\t   (Not new:(Predicate new:\'Q\' fromList:\r\t     (LinkedList new \r\t      add:(ConstTerm new:(Term new:\'b\'));\r\t      yourself))\r\t   )\r\t  ).\r\t\r\tself deny:(ClausalForm new:prop) resolutionMethod..',			#stamp : 'pm 12/14/2018 20:19',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionLimitCase,			#protocol : #tests,			#sourceCode : 'testResolutionLimitCase\r\t| prop |\r\tprop:=And new:\r\t  (Or new:\r\t   (Predicate new:\'P\' fromList:\r\t     (LinkedList new \r\t      add:(LinkedTerm new:(Term new:\'x\'));\r\t      yourself)\r\t   )\r\t  rightProp:\r\t   (Predicate new:\'Q\' fromList:\r\t     (LinkedList new \r\t      add:(LinkedTerm new:(Term new:\'x\'));\r\t      yourself)\r\t   )\r\t  )\r\t rightProp:\r\t  (And new:\r\t   (Not new:(Predicate new:\'P\' fromList:\r\t     (LinkedList new \r\t      add:(ConstTerm new:(Term new:\'a\'));\r      yourself))\r\t   )\r\t\t  rightProp:\r\t   (Not new:(Predicate new:\'Q\' fromList:\r\t     (LinkedList new \r\t      add:(ConstTerm new:(Term new:\'b\'));\r\t      yourself))\r\t   )\r\t  ).\r\t\r\tself deny:(ClausalForm new:prop) resolutionMethod..',			#stamp : 'pm 12/14/2018 20:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T20:19:22.382682+01:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionLimitCase,			#protocol : #tests,			#sourceCode : 'testResolutionLimitCase\r\t| prop |\r\tprop:=And new:\r\t  (Or new:\r\t   (Predicate new:\'P\' fromList:\r\t     (LinkedList new \r\t      add:(LinkedTerm new:(Term new:\'x\'));\r\t      yourself)\r\t   )\r\t  rightProp:\r\t   (Predicate new:\'Q\' fromList:\r\t     (LinkedList new \r\t      add:(LinkedTerm new:(Term new:\'x\'));\r\t      yourself)\r\t   )\r\t  )\r\t rightProp:\r\t  (And new:\r\t   (Not new:(Predicate new:\'P\' fromList:\r\t     (LinkedList new \r\t      add:(ConstTerm new:(Term new:\'a\'));\r      yourself))\r\t   )\r\t\t  rightProp:\r\t   (Not new:(Predicate new:\'Q\' fromList:\r\t     (LinkedList new \r\t      add:(ConstTerm new:(Term new:\'b\'));\r\t      yourself))\r\t   )\r\t  ).\r\t\r\tself deny:(ClausalForm new:prop) resolutionMethod..',			#stamp : 'pm 12/14/2018 20:19',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestResolution,				#isMetaSide : false			},			#name : #testResolutionLimitCase,			#protocol : #tests,			#sourceCode : 'testResolutionLimitCase\r\t| prop |\r\tprop:=And new:\r\t  (Or new:\r\t   (Predicate new:\'P\' fromList:\r\t     (LinkedList new \r\t      add:(LinkedTerm new:(Term new:\'x\'));\r\t      yourself)\r\t   )\r\t  rightProp:\r\t   (Predicate new:\'Q\' fromList:\r\t     (LinkedList new \r\t      add:(LinkedTerm new:(Term new:\'x\'));\r\t      yourself)\r\t   )\r\t  )\r\t rightProp:\r\t  (And new:\r\t   (Not new:(Predicate new:\'P\' fromList:\r\t     (LinkedList new \r\t      add:(ConstTerm new:(Term new:\'a\'));\r      yourself))\r\t   )\r\t\t  rightProp:\r\t   (Not new:(Predicate new:\'Q\' fromList:\r\t     (LinkedList new \r\t      add:(ConstTerm new:(Term new:\'b\'));\r\t      yourself))\r\t   )\r\t  ).\r\t\r\t^self deny:(ClausalForm new:prop) resolutionMethod.',			#stamp : 'pm 12/14/2018 20:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T20:19:32.762591+01:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #TestResolution\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestResolution,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestResolution class\r\tinstanceVariableNames: \'\''				},				#name : #'TestResolution class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestResolution,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #TestResolution\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestResolution,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestResolution class\r\tinstanceVariableNames: \'\''				},				#name : #'TestResolution class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestResolution,					#isMetaSide : false				},				#parent : @21,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T20:19:33.072939+01:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #TestResolution\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestResolution,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestResolution class\r\tinstanceVariableNames: \'\''				},				#name : #'TestResolution class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestResolution,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestResolution\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestResolution,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestResolution class\r\tinstanceVariableNames: \'\''				},				#name : #'TestResolution class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @21			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestResolution,					#isMetaSide : false				},				#parent : @21,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T20:25:16.442021+01:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tclausificationTrace:=false.\r\tskolemnTrace:=false.\r\tdebugUnification:=false.\r\tresolutionTrace:=true.\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/14/2018 19:59',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tclausificationTrace:=false.\r\tskolemnTrace:=false.\r\tdebugUnification:=false.\r\tresolutionTrace:=false.\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/14/2018 20:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T20:50:39.39042+01:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'applyUnifier:onClause:',			#protocol : #resolutionMethod,			#sourceCode : 'applyUnifier: u onClause:aClause\r',			#stamp : 'pm 12/14/2018 20:15',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'applyUnifier:onClause:',			#protocol : #resolutionMethod,			#sourceCode : 'applyUnifier: u onClause:aClause\r\t|res|\r\tres:=Clause new.\r\tself do:[:each| res add: (self applyUnifier: u onPredicate: each)].\r\t^res.',			#stamp : 'pm 12/14/2018 20:50',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T20:52:05.566163+01:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'applyUnifier:onPredicate:',			#protocol : #resolutionMethod,			#sourceCode : 'applyUnifier: u onPredicate:aPredicate\r',			#stamp : 'pm 12/14/2018 20:15',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'applyUnifier:onPredicate:',			#protocol : #resolutionMethod,			#sourceCode : 'applyUnifier: u onPredicate:aPredicate\r\tself halt.',			#stamp : 'pm 12/14/2018 20:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T20:53:08.187396+01:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #resolutionMethod,			#sourceCode : 'resolvante: aClause1 with: aClause2\r\t"This method gets all the resolvantes between aClause1 and aClause2, modulo a subtitution of two terms.\r\tself is an Unifier\r\taClause1 and aClause2 are the clauses we want to get the resolvant off.\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\t\r\t[ i<=(aClause1 size). ]\r\twhileTrue:[\r\t\ta1:=aClause1 at:i.\r\t\t\r\t\tj:=1.\r\t\t[ j<=(aClause2 size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause2 at:j.\r\r\t\t\t(a1 isOppositePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:["if the unified pair isNil, then the unification failed"\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t\t(sub1 isOpposite: sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new.we create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause1 without:i).\r\t\t\t\t\t\tnewClause addFromList: (aClause2 without:j).\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 18:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #resolutionMethod,			#sourceCode : 'resolvante: aClause1 with: aClause2\r\t"This method gets all the resolvantes between aClause1 and aClause2, modulo a subtitution of two terms.\r\tself is an Unifier\r\taClause1 and aClause2 are the clauses we want to get the resolvant off.\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\t\r\t[ i<=(aClause1 size). ]\r\twhileTrue:[\r\t\ta1:=aClause1 at:i.\r\t\t\r\t\tj:=1.\r\t\t[ j<=(aClause2 size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause2 at:j.\r\r\t\t\t(a1 isOppositePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:["if the unified pair isNil, then the unification failed"\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t\t(sub1 isOpposite: sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new.we create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause1 without:i).\r\t\t\t\t\t\tnewClause addFromList: (aClause2 without:j).\r\t\t\t\t\t\tself applyUnifier: u onClause: newClause.\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 20:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T21:24:37.078024+01:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [\r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].\r\t^self',			#stamp : 'pm 11/28/2018 00:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t((terms at:i) isFuncTerm)\r\t\tifTrue: [\r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].\r\t^self',			#stamp : 'pm 12/14/2018 21:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T21:25:06.377832+01:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t"replace every occurence of the term \'x\' with the term \'t\'"\r\t| i |\r\ti:=1.\r\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue:[ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].\r\t^self',			#stamp : 'pm 10/28/2018 14:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t"replace every occurence of the term \'x\' with the term \'t\'"\r\t| i |\r\ti:=1.\r\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t((terms at:i) isFuncTerm)\r\t\tifTrue:[ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].\r\t^self',			#stamp : 'pm 12/14/2018 21:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T21:31:52.211966+01:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'applyUnifier:onPredicate:',			#protocol : #resolutionMethod,			#sourceCode : 'applyUnifier: u onPredicate:aPredicate\r\tself halt.',			#stamp : 'pm 12/14/2018 20:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'applyUnifier:onPredicate:',			#protocol : #resolutionMethod,			#sourceCode : 'applyUnifier: u onPredicate:aPredicate\r\tu setOfPairs do:[:each | aPredicate replace: each left by: each right]',			#stamp : 'pm 12/14/2018 21:31',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T21:40:40.816369+01:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'applyUnifier:onPredicate:',			#protocol : #resolutionMethod,			#sourceCode : 'applyUnifier: u onPredicate:aPredicate\r\tu setOfPairs do:[:each | aPredicate replace: each left by: each right]',			#stamp : 'pm 12/14/2018 21:31',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'applyUnifier:onPredicate:',			#protocol : #resolutionMethod,			#sourceCode : 'applyUnifier: u onPredicate:aPredicate\r\t|res|\r\tres:=aPredicate deepCopy.\r\tu setOfPairs do:[:each | aPredicate replace: each left by: each right].\r\t^res',			#stamp : 'pm 12/14/2018 21:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T21:55:44.02081+01:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'applyUnifier:onClause:',			#protocol : #resolutionMethod,			#sourceCode : 'applyUnifier: u onClause:aClause\r\t|res|\r\tres:=Clause new.\r\tself do:[:each| res add: (self applyUnifier: u onPredicate: each)].\r\t^res.',			#stamp : 'pm 12/14/2018 20:50',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'applyUnifier:onClause:',			#protocol : #resolutionMethod,			#sourceCode : 'applyUnifier: u onClause:aClause\r\t|res|\r\tres:=self setOfPairs.\r\tres:=Clause new.\r\tself do:[:each| res add: (self applyUnifier: u onPredicate: each)].\r\t^res.',			#stamp : 'pm 12/14/2018 21:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T21:58:26.270558+01:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Clause class',				#isMetaSide : true			},			#name : #new,			#protocol : #'as yet unclassified',			#sourceCode : 'new',			#stamp : 'pm 12/14/2018 21:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T21:58:26.41438+01:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Clause class',				#isMetaSide : true			},			#name : #new,			#protocol : #'as yet unclassified',			#sourceCode : 'new',			#stamp : 'pm 12/14/2018 21:58',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Clause class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new',			#stamp : 'pm 12/14/2018 21:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T22:04:10.090962+01:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Clause class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new',			#stamp : 'pm 12/14/2018 21:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T22:08:16.457945+01:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'applyUnifier:onClause:',			#protocol : #resolutionMethod,			#sourceCode : 'applyUnifier: u onClause:aClause\r\t|res|\r\tres:=self setOfPairs.\r\tres:=Clause new.\r\tself do:[:each| res add: (self applyUnifier: u onPredicate: each)].\r\t^res.',			#stamp : 'pm 12/14/2018 21:55',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'applyUnifier:onClause:',			#protocol : #resolutionMethod,			#sourceCode : 'applyUnifier: u onClause:aClause\r\t|res|\r\taClause do:[:each| (self applyUnifier: u onPredicate: each)].\r\t',			#stamp : 'pm 12/14/2018 22:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T22:08:30.692762+01:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'applyUnifier:onClause:',			#protocol : #resolutionMethod,			#sourceCode : 'applyUnifier: u onClause:aClause\r\t|res|\r\taClause do:[:each| (self applyUnifier: u onPredicate: each)].\r\t',			#stamp : 'pm 12/14/2018 22:08',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'applyUnifier:onClause:',			#protocol : #resolutionMethod,			#sourceCode : 'applyUnifier: u onClause:aClause\r\taClause do:[:each| (self applyUnifier: u onPredicate: each)].\r\t^aClause',			#stamp : 'pm 12/14/2018 22:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T22:08:49.788522+01:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'applyUnifier:onPredicate:',			#protocol : #resolutionMethod,			#sourceCode : 'applyUnifier: u onPredicate:aPredicate\r\t|res|\r\tres:=aPredicate deepCopy.\r\tu setOfPairs do:[:each | aPredicate replace: each left by: each right].\r\t^res',			#stamp : 'pm 12/14/2018 21:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'applyUnifier:onPredicate:',			#protocol : #resolutionMethod,			#sourceCode : 'applyUnifier: u onPredicate:aPredicate\r\t|res|\r\tu setOfPairs do:[:each | aPredicate replace: each left by: each right].\r',			#stamp : 'pm 12/14/2018 22:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T22:08:52.229421+01:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'applyUnifier:onPredicate:',			#protocol : #resolutionMethod,			#sourceCode : 'applyUnifier: u onPredicate:aPredicate\r\t|res|\r\tu setOfPairs do:[:each | aPredicate replace: each left by: each right].\r',			#stamp : 'pm 12/14/2018 22:08',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'applyUnifier:onPredicate:',			#protocol : #resolutionMethod,			#sourceCode : 'applyUnifier: u onPredicate:aPredicate\r\tu setOfPairs do:[:each | aPredicate replace: each left by: each right].\r',			#stamp : 'pm 12/14/2018 22:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T22:10:47.237081+01:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #resolutionMethod,			#sourceCode : 'factorisation: aClause\r\t"This method factorise positively AND negatively at the same time.\r\tself is an Unifier\r\taClause is the clause we want to factorise\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:[\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t"\t\t\t(sub1=sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new. We create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 18:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #resolutionMethod,			#sourceCode : 'factorisation: aClause\r\t"This method factorise positively AND negatively at the same time.\r\tself is an Unifier\r\taClause is the clause we want to factorise\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:[\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t"\t\t\t(sub1=sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new. We create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\t\tself applyUnifier:u onClause: newClause.\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 22:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T22:13:02.759816+01:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMonticelloVersionSave {		#versionName : '_resolution_1erOrdre-pm.4',		#repositoryDescription : '/home/ariale/FORM/pharo6.1-64/shared/pharo-local/package-cache'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T22:13:02.957766+01:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMonticelloVersionSave {		#versionName : '_resolution_1erOrdre-pm.4',		#repositoryDescription : '/home/ariale/FORM/pharo6.1-64/Sources'	}}