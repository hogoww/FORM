OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-09T14:13:26.289891+01:00' ],		#prior : OmReference [ 'Pharo.ac9s11zm13g6gti4sljzm9b97', '135' ],		#self : OmReference [ '1' ]	},	#content : EpCompositeRefactoring {		#childrenRefactorings : [ ]	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ],		#time : DateAndTime [ '2018-12-09T14:13:26.926644+01:00' ],		#trigger : @3	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialize,			#sourceCode : 'initialize: OrProp\r\t"initialization using an OrProp. Should only contain predicates/const"\r\tself addAll:OrProp.',			#stamp : 'pm 11/11/2018 09:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialize,			#sourceCode : 'initialize: orProp\r\t"initialization using an OrProp. Should only contain predicates/const"\r\tself addAll:orProp.',			#stamp : 'pm 12/9/2018 14:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-09T14:13:30.552789+01:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialize,			#sourceCode : 'initialize: orProp\r\t"initialization using an OrProp. Should only contain predicates/const"\r\tself addAll:orProp.',			#stamp : 'pm 12/9/2018 14:13',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialize,			#sourceCode : 'initialize: orProp\r\t"initialization using an orProp. Should only contain predicates/const"\r\tself addAll:orProp.',			#stamp : 'pm 12/9/2018 14:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-11T20:53:57.118577+01:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #isClause,			#protocol : #clausification,			#sourceCode : 'isClause\r\t"tester"\r\t^true',			#stamp : 'pm 11/28/2018 00:56',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #isClause,			#protocol : #clausification,			#sourceCode : 'isClause\r\t"An atome is a clause, whatever it is."\r\t^true',			#stamp : 'pm 12/11/2018 20:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-11T21:37:34.397065+01:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Operator,				#isMetaSide : false			},			#name : #ConstitureOfOr,			#protocol : #'as yet unclassified',			#sourceCode : 'ConstitureOfOr\r\t"Used to check if there\'s only Or\'s in this prop tree"\r\t^self isClause',			#stamp : 'pm 12/11/2018 21:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-11T21:38:59.968235+01:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Operator,				#isMetaSide : false			},			#name : #ConstitureOfOr,			#protocol : #'as yet unclassified',			#sourceCode : 'ConstitureOfOr\r\t"Used to check if there\'s only Or\'s in this prop tree"\r\t^self isClause',			#stamp : 'pm 12/11/2018 21:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Operator,				#isMetaSide : false			},			#name : #ConstitureOfOr,			#protocol : #'as yet unclassified',			#sourceCode : 'ConstitureOfOr\r\t"Used to check if there\'s only Or\'s in this prop tree, during the clausification process"\r\r\t"This is basically the same as isClause, except for the And class."\r\t^self isClause',			#stamp : 'pm 12/11/2018 21:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-11T21:39:57.018573+01:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #And,				#isMetaSide : false			},			#name : #ConstitureOfOr,			#protocol : #'as yet unclassified',			#sourceCode : 'ConstitureOfOr\r\t"Used to check if there\'s only Or\'s in this prop tree, during the clausification process"\r\r\t"Since we\'re in an And, we\'re not in a or, so, false !"\r\t^false',			#stamp : 'pm 12/11/2018 21:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-11T21:40:32.412073+01:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #And,				#isMetaSide : false			},			#name : #isClause,			#protocol : #clausification,			#sourceCode : 'isClause\r\t^(left isClause & right isClause)',			#stamp : 'pm 9/29/2018 08:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #And,				#isMetaSide : false			},			#name : #isClause,			#protocol : #clausification,			#sourceCode : 'isClause\r\t^left ConstituteOfOr \r\tand:[right isClause]',			#stamp : 'pm 12/11/2018 21:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-11T21:40:49.41764+01:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #And,				#isMetaSide : false			},			#name : #ConstituteOfOr,			#protocol : #'as yet unclassified',			#sourceCode : 'ConstituteOfOr\r\t"Used to check if there\'s only Or\'s in this prop tree, during the clausification process"\r\r\t"Since we\'re in an And, we\'re not in a or, so, false !"\r\t^false',			#stamp : 'pm 12/11/2018 21:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-11T21:40:53.270824+01:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #And,				#isMetaSide : false			},			#name : #ConstitureOfOr,			#protocol : #'as yet unclassified',			#sourceCode : 'ConstitureOfOr\r\t"Used to check if there\'s only Or\'s in this prop tree, during the clausification process"\r\r\t"Since we\'re in an And, we\'re not in a or, so, false !"\r\t^false',			#stamp : 'pm 12/11/2018 21:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-11T21:41:04.017623+01:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Operator,				#isMetaSide : false			},			#name : #ConstituteOfOr,			#protocol : #'as yet unclassified',			#sourceCode : 'ConstituteOfOr\r\t"Used to check if there\'s only Or\'s in this prop tree, during the clausification process"\r\r\t"This is basically the same as isClause, except for the And class."\r\t^self isClause',			#stamp : 'pm 12/11/2018 21:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-11T21:41:08.160992+01:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Operator,				#isMetaSide : false			},			#name : #ConstitureOfOr,			#protocol : #'as yet unclassified',			#sourceCode : 'ConstitureOfOr\r\t"Used to check if there\'s only Or\'s in this prop tree, during the clausification process"\r\r\t"This is basically the same as isClause, except for the And class."\r\t^self isClause',			#stamp : 'pm 12/11/2018 21:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-11T21:43:50.539641+01:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #And,				#isMetaSide : false			},			#name : #isClause,			#protocol : #clausification,			#sourceCode : 'isClause\r\t^left ConstituteOfOr \r\tand:[right isClause]',			#stamp : 'pm 12/11/2018 21:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #And,				#isMetaSide : false			},			#name : #isClause,			#protocol : #clausification,			#sourceCode : 'isClause\r\t"a And is a clause only if the rest is constitute of Ors !"\r\t^left ConstituteOfOr \r\tand:[right Constitute]',			#stamp : 'pm 12/11/2018 21:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-11T21:44:55.575646+01:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #And,				#isMetaSide : false			},			#name : #isClause,			#protocol : #clausification,			#sourceCode : 'isClause\r\t"a And is a clause only if the rest is constitute of Ors !"\r\t^left ConstituteOfOr \r\tand:[right Constitute]',			#stamp : 'pm 12/11/2018 21:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #And,				#isMetaSide : false			},			#name : #isClause,			#protocol : #clausification,			#sourceCode : 'isClause\r\t"a And is a clause only if the rest is constitute of Ors !"\r\t^left ConstituteOfOr \r\tand:[right ConstituteOfOr]',			#stamp : 'pm 12/11/2018 21:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-11T21:58:28.913031+01:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #And,				#isMetaSide : false			},			#name : #isClause,			#protocol : #clausification,			#sourceCode : 'isClause\r\t"a And is a clause only if the rest is constitute of Ors !"\r\t^left ConstituteOfOr \r\tand:[right ConstituteOfOr]',			#stamp : 'pm 12/11/2018 21:44',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #And,				#isMetaSide : false			},			#name : #isClause,			#protocol : #clausification,			#sourceCode : 'isClause\r\t"a And is a clause only if the rest is constitute of Ors !"\r\t^((left isAnd ifTrue:[left isClause]ifFalse:[left ConstituteOfOr])\r\t\tand:[(right isAnd ifTrue:[right isClause]ifFalse:[right ConstituteOfOr])])',			#stamp : 'pm 12/11/2018 21:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-11T21:59:02.144867+01:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #ConstituteOfOr,			#protocol : #'as yet unclassified',			#sourceCode : 'ConstituteOfOr\r\t^true',			#stamp : 'pm 12/11/2018 21:59',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-11T22:00:37.981675+01:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #ConstituteOfOr,			#protocol : #'as yet unclassified',			#sourceCode : 'ConstituteOfOr\r\t^true',			#stamp : 'pm 12/11/2018 21:59',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #ConstituteOfOr,			#protocol : #'as yet unclassified',			#sourceCode : 'ConstituteOfOr\r\t"Used to check if there\'s only Or\'s in this prop tree, during the clausification process"\r\r\t"In an atome, it\'s always true. They aren\'t considered during the clausification process"\r\t^true',			#stamp : 'pm 12/11/2018 22:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:03:46.637148+01:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testDoubleNot,			#protocol : #isClause,			#sourceCode : 'testDoubleNot\r\t| input |\r\tinput:=Not new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself fail: input isClause.\r\r',			#stamp : 'pm 12/12/2018 09:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:05:06.419317+01:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testDoubleNot,			#protocol : #isClause,			#sourceCode : 'testDoubleNot\r\t| input |\r\tinput:=Not new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself fail: input isClause.\r\r',			#stamp : 'pm 12/12/2018 09:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testDoubleNot,			#protocol : #isClause,			#sourceCode : 'testDoubleNot\r\t| input |\r\tinput:=Not new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tinput isClause fail.\r\r',			#stamp : 'pm 12/12/2018 09:05',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:06:25.00028+01:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testDoubleNot,			#protocol : #isClause,			#sourceCode : 'testDoubleNot\r\t| input |\r\tinput:=Not new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tinput isClause fail.\r\r',			#stamp : 'pm 12/12/2018 09:05',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testDoubleNot,			#protocol : #isClause,			#sourceCode : 'testDoubleNot\r\t| input |\r\tinput:=Not new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself deny: input isClause.\r\r',			#stamp : 'pm 12/12/2018 09:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:07:32.112293+01:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testDoubleNotWithOnlyAtomes,			#protocol : #isClause,			#sourceCode : 'testDoubleNotWithOnlyAtomes\r\t| input |\r\tinput:=Not new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself deny: input isClause.\r\r',			#stamp : 'pm 12/12/2018 09:07',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:07:34.563911+01:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testDoubleNot,			#protocol : #isClause,			#sourceCode : 'testDoubleNot\r\t| input |\r\tinput:=Not new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself deny: input isClause.\r\r',			#stamp : 'pm 12/12/2018 09:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:07:49.419481+01:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testSimpleNotWithOnlyAtomes,			#protocol : #isClause,			#sourceCode : 'testSimpleNotWithOnlyAtomes\r\t| input |\r\tinput:=Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          ).\r\r\tself deny: input isClause.\r\r',			#stamp : 'pm 12/12/2018 09:07',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:10:06.45436+01:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testSimpleNotWithOnlyAtomes,			#protocol : #isClause,			#sourceCode : 'testSimpleNotWithOnlyAtomes\r\t| input |\r\tinput:=Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          ).\r\r\tself deny: input isClause.\r\r',			#stamp : 'pm 12/12/2018 09:07',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testSimpleNotWithOnlyAtomes,			#protocol : #isClause,			#sourceCode : 'testSimpleNotWithOnlyAtomes\r\t| input |\r\tinput:=Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          ).\r\r\tself assert: input isClause.\r\r',			#stamp : 'pm 12/12/2018 09:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:11:20.711337+01:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpProtocolAddition {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #Skolemn_test\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #Skolemn_test,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Skolemn_test class\r\tinstanceVariableNames: \'\''				},				#name : #'Skolemn_test class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Skolemn_test,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #clausification-And	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:11:31.265+01:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\t"stability of a clausified and"\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ T -> P()"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ F -> F"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T /\\ P() -> P()"\t\r\tprop := And new: (True_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F /\\ P() -> F"\t\r\tprop := And new: (False_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 21:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #clausification-general,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\t"stability of a clausified and"\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ T -> P()"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ F -> F"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T /\\ P() -> P()"\t\r\tprop := And new: (True_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F /\\ P() -> F"\t\r\tprop := And new: (False_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 21:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:11:31.267704+01:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationPredicate,			#protocol : #Clausification,			#sourceCode : 'testClausificationPredicate\r\t| prop res |\r\t"basic, should be  unafected by clausification"\r\t\r\t"for empty predicates"\r\tprop := (Predicate new:\'P\').\r\tres := (Predicate new:\'P\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t\t"for unary predicates"\r\tprop := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\tres := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\r\tself assert: prop fullClausification equals: res.\r\r\t"for variadic predicates"\r\tprop := Predicate new:\'P\' fromList:\r          (LinkedList new \r               add:(Term new:\'a\');\r               add:(Term new:\'b\');\r               add:(Term new:\'c\');\r               add:(Term new:\'d\');\r               yourself).\r\tres := Predicate new:\'P\' fromList:\r          (LinkedList new \r               add:(Term new:\'a\');\r               add:(Term new:\'b\');\r               add:(Term new:\'c\');\r               add:(Term new:\'d\');\r               yourself).\r\r\t"for variadic predicates"\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/7/2018 19:58',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationPredicate,			#protocol : #clausification-general,			#sourceCode : 'testClausificationPredicate\r\t| prop res |\r\t"basic, should be  unafected by clausification"\r\t\r\t"for empty predicates"\r\tprop := (Predicate new:\'P\').\r\tres := (Predicate new:\'P\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t\t"for unary predicates"\r\tprop := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\tres := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\r\tself assert: prop fullClausification equals: res.\r\r\t"for variadic predicates"\r\tprop := Predicate new:\'P\' fromList:\r          (LinkedList new \r               add:(Term new:\'a\');\r               add:(Term new:\'b\');\r               add:(Term new:\'c\');\r               add:(Term new:\'d\');\r               yourself).\r\tres := Predicate new:\'P\' fromList:\r          (LinkedList new \r               add:(Term new:\'a\');\r               add:(Term new:\'b\');\r               add:(Term new:\'c\');\r               add:(Term new:\'d\');\r               yourself).\r\r\t"for variadic predicates"\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/7/2018 19:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:11:31.270979+01:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #Clausification,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t"basic test for equal\'s clausification"\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := Or new:(And new:\r\t    \t\t      \t\t\t(Predicate new:\'P\')\r\t\t\t\t\t\t    rightProp:\r\t\t\t\t\t         (Predicate new:\'Q\'))\r\t\t\t\trightProp:(And new:\r          \t\t\t(Not new: (Predicate new:\'P\'))\r\t\t\t\t     rightProp:\r\t\t\t          (Not new:(Predicate new:\'Q\'))).\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 20:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #clausification-general,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t"basic test for equal\'s clausification"\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := Or new:(And new:\r\t    \t\t      \t\t\t(Predicate new:\'P\')\r\t\t\t\t\t\t    rightProp:\r\t\t\t\t\t         (Predicate new:\'Q\'))\r\t\t\t\trightProp:(And new:\r          \t\t\t(Not new: (Predicate new:\'P\'))\r\t\t\t\t     rightProp:\r\t\t\t          (Not new:(Predicate new:\'Q\'))).\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 20:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:11:31.273184+01:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationImply,			#protocol : #Clausification,			#sourceCode : 'testClausificationImply\r\t| prop res |\r\t\r\t"basic test for imply\'s clausification"\r\tprop := Imply\r\t\tnew: (Predicate new: \'P\')\r\t\trightProp: (Predicate new: \'Q\').\r\tres := Or\r\t\tnew: (Not new: (Predicate new: \'P\'))\r\t\trightProp: (Predicate new: \'Q\').\r\tself assert: prop fullClausification equals: res',			#stamp : 'pm 12/7/2018 20:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationImply,			#protocol : #clausification-general,			#sourceCode : 'testClausificationImply\r\t| prop res |\r\t\r\t"basic test for imply\'s clausification"\r\tprop := Imply\r\t\tnew: (Predicate new: \'P\')\r\t\trightProp: (Predicate new: \'Q\').\r\tres := Or\r\t\tnew: (Not new: (Predicate new: \'P\'))\r\t\trightProp: (Predicate new: \'Q\').\r\tself assert: prop fullClausification equals: res',			#stamp : 'pm 12/7/2018 20:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:11:31.275267+01:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of a clausified or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T \\/ P()-> T"\r\tprop := Or new: (True_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F \\/ P() -> P()"\t\t\r\tprop := Or new: (False_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"Or\'s distributivity"\r\tprop:=Or new:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     )\r\trightProp:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r\t"And the symetric. "\r\tprop :=Or new:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     ).\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Or new:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r',			#stamp : 'pm 12/7/2018 21:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #clausification-general,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of a clausified or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T \\/ P()-> T"\r\tprop := Or new: (True_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F \\/ P() -> P()"\t\t\r\tprop := Or new: (False_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"Or\'s distributivity"\r\tprop:=Or new:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     )\r\trightProp:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r\t"And the symetric. "\r\tprop :=Or new:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     ).\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Or new:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r',			#stamp : 'pm 12/7/2018 21:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:11:31.277241+01:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNot,			#protocol : #Clausification,			#sourceCode : 'testClausificationNot\r\t| prop res |\r\r\t"Complete test for the Not clausifications"\r\t\r\t"Polarity inversion"\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"Polarity inversion #2"\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"cancel Not"\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r\t\r\t"Not on an Or"\r\tprop:=Not new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= And new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r\t"Not on an And"\r\tprop := Not new:\r     (And new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= Or new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\t\r\r',			#stamp : 'pm 12/7/2018 20:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNot,			#protocol : #clausification-general,			#sourceCode : 'testClausificationNot\r\t| prop res |\r\r\t"Complete test for the Not clausifications"\r\t\r\t"Polarity inversion"\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"Polarity inversion #2"\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"cancel Not"\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r\t\r\t"Not on an Or"\r\tprop:=Not new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= And new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r\t"Not on an And"\r\tprop := Not new:\r     (And new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= Or new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\t\r\r',			#stamp : 'pm 12/7/2018 20:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:11:41.590018+01:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpProtocolAddition {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #Skolemn_test\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #Skolemn_test,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Skolemn_test class\r\tinstanceVariableNames: \'\''				},				#name : #'Skolemn_test class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Skolemn_test,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #clausification-Not	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:11:51.642184+01:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpProtocolAddition {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #Skolemn_test\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #Skolemn_test,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Skolemn_test class\r\tinstanceVariableNames: \'\''				},				#name : #'Skolemn_test class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Skolemn_test,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #clausification-Or	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:12:00.449705+01:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #clausification-general,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\t"stability of a clausified and"\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ T -> P()"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ F -> F"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T /\\ P() -> P()"\t\r\tprop := And new: (True_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F /\\ P() -> F"\t\r\tprop := And new: (False_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 21:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #clausification-And,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\t"stability of a clausified and"\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ T -> P()"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ F -> F"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T /\\ P() -> P()"\t\r\tprop := And new: (True_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F /\\ P() -> F"\t\r\tprop := And new: (False_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 21:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:12:08.705182+01:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNot,			#protocol : #clausification-general,			#sourceCode : 'testClausificationNot\r\t| prop res |\r\r\t"Complete test for the Not clausifications"\r\t\r\t"Polarity inversion"\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"Polarity inversion #2"\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"cancel Not"\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r\t\r\t"Not on an Or"\r\tprop:=Not new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= And new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r\t"Not on an And"\r\tprop := Not new:\r     (And new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= Or new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\t\r\r',			#stamp : 'pm 12/7/2018 20:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNot,			#protocol : #clausification-Not,			#sourceCode : 'testClausificationNot\r\t| prop res |\r\r\t"Complete test for the Not clausifications"\r\t\r\t"Polarity inversion"\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"Polarity inversion #2"\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"cancel Not"\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r\t\r\t"Not on an Or"\r\tprop:=Not new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= And new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r\t"Not on an And"\r\tprop := Not new:\r     (And new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= Or new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\t\r\r',			#stamp : 'pm 12/7/2018 20:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:12:11.470135+01:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #clausification-general,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of a clausified or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T \\/ P()-> T"\r\tprop := Or new: (True_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F \\/ P() -> P()"\t\t\r\tprop := Or new: (False_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"Or\'s distributivity"\r\tprop:=Or new:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     )\r\trightProp:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r\t"And the symetric. "\r\tprop :=Or new:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     ).\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Or new:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r',			#stamp : 'pm 12/7/2018 21:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #clausification-Or,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of a clausified or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T \\/ P()-> T"\r\tprop := Or new: (True_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F \\/ P() -> P()"\t\t\r\tprop := Or new: (False_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"Or\'s distributivity"\r\tprop:=Or new:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     )\r\trightProp:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r\t"And the symetric. "\r\tprop :=Or new:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     ).\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Or new:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r',			#stamp : 'pm 12/7/2018 21:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:13:13.053907+01:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNot,			#protocol : #clausification-Not,			#sourceCode : 'testClausificationNot\r\t| prop res |\r\r\t"Complete test for the Not clausifications"\r\t\r\t"Polarity inversion"\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"Polarity inversion #2"\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"cancel Not"\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r\t\r\t"Not on an Or"\r\tprop:=Not new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= And new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r\t"Not on an And"\r\tprop := Not new:\r     (And new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= Or new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\t\r\r',			#stamp : 'pm 12/7/2018 20:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNot,			#protocol : #clausification-Not,			#sourceCode : 'testClausificationNot\r\t| prop res |\r\r\t"Complete test for the Not clausifications"\r\t\r\t"Polarity inversion"\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"Polarity inversion #2"\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"cancel Not"\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r\t\r\t"Not on an Or"\r\tprop:=Not new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= And new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r\t\r\r',			#stamp : 'pm 12/12/2018 09:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:13:54.494412+01:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNotDistributedOnAnd,			#protocol : #clausification-Not,			#sourceCode : 'testClausificationNotDistributedOnAnd\r\r\t"Not on an And"\r\t| prop res |\r\tprop := Not new:\r     (And new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= Or new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/12/2018 09:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:13:57.575668+01:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNotDistributedOnAnd,			#protocol : #clausification-Not,			#sourceCode : 'testClausificationNotDistributedOnAnd\r\r\t"Not on an And"\r\t| prop res |\r\tprop := Not new:\r     (And new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= Or new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/12/2018 09:13',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNotDistributedOnAnd,			#protocol : #clausification-Not,			#sourceCode : 'testClausificationNotDistributedOnAnd\r\t"Not on an And"\r\t| prop res |\r\tprop := Not new:\r     (And new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= Or new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/12/2018 09:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:14:28.000015+01:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNot,			#protocol : #clausification-Not,			#sourceCode : 'testClausificationNot\r\t| prop res |\r\r\t"Complete test for the Not clausifications"\r\t\r\t"Polarity inversion"\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"Polarity inversion #2"\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"cancel Not"\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r\t\r\t"Not on an Or"\r\tprop:=Not new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= And new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r\t\r\r',			#stamp : 'pm 12/12/2018 09:13',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNot,			#protocol : #clausification-Not,			#sourceCode : 'testClausificationNot\r\t| prop res |\r\r\t"Complete test for the Not clausifications"\r\t\r\t"Polarity inversion"\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"Polarity inversion #2"\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"cancel Not"\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r\t\r\r\t\r\r',			#stamp : 'pm 12/12/2018 09:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:15:25.439339+01:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNotDistributedOnOr,			#protocol : #clausification-Not,			#sourceCode : 'testClausificationNotDistributedOnOr\r\t| prop res |\r\t"Not on an Or"\r\tprop:=Not new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= And new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/12/2018 09:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:15:46.663127+01:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNotOnAtomes,			#protocol : #clausification-Not,			#sourceCode : 'testClausificationNotOnAtomes\r\t| prop res |\r\r\t"Complete test for the Not clausifications"\r\t\r\t"Polarity inversion"\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"Polarity inversion #2"\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"cancel Not"\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r\t\r\r\t\r\r',			#stamp : 'pm 12/12/2018 09:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:15:54.019946+01:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNot,			#protocol : #clausification-Not,			#sourceCode : 'testClausificationNot\r\t| prop res |\r\r\t"Complete test for the Not clausifications"\r\t\r\t"Polarity inversion"\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"Polarity inversion #2"\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"cancel Not"\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r\t\r\r\t\r\r',			#stamp : 'pm 12/12/2018 09:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:16:43.085284+01:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #clausification-Or,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of a clausified or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T \\/ P()-> T"\r\tprop := Or new: (True_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F \\/ P() -> P()"\t\t\r\tprop := Or new: (False_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"Or\'s distributivity"\r\tprop:=Or new:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     )\r\trightProp:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r\t"And the symetric. "\r\tprop :=Or new:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     ).\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Or new:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r',			#stamp : 'pm 12/7/2018 21:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #clausification-Or,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of a clausified or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T \\/ P()-> T"\r\tprop := Or new: (True_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F \\/ P() -> P()"\t\t\r\tprop := Or new: (False_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\r\t"And the symetric. "\r\tprop :=Or new:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     ).\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Or new:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r',			#stamp : 'pm 12/12/2018 09:16',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:18:11.373746+01:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOrDistributivity,			#protocol : #clausification-Or,			#sourceCode : 'testClausificationOrDistributivity\r\t| prop res |\r\t"Or\'s distributivity"\r\tprop:=Or new:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     )\r\trightProp:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/12/2018 09:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:18:54.810223+01:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #clausification-Or,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of a clausified or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T \\/ P()-> T"\r\tprop := Or new: (True_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F \\/ P() -> P()"\t\t\r\tprop := Or new: (False_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\r\t"And the symetric. "\r\tprop :=Or new:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     ).\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Or new:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r',			#stamp : 'pm 12/12/2018 09:16',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #clausification-Or,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of a clausified or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T \\/ P()-> T"\r\tprop := Or new: (True_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F \\/ P() -> P()"\t\t\r\tprop := Or new: (False_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r',			#stamp : 'pm 12/12/2018 09:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:19:07.467925+01:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOrDistributivitySymetric,			#protocol : #clausification-Or,			#sourceCode : 'testClausificationOrDistributivitySymetric\r\t| prop res |\r\r\t"And the symetric. "\r\tprop :=Or new:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     ).\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Or new:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r',			#stamp : 'pm 12/12/2018 09:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:20:33.817995+01:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOrOnAtomes,			#protocol : #clausification-Or,			#sourceCode : 'testClausificationOrOnAtomes\r\t| prop res |\r\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T \\/ P()-> T"\r\tprop := Or new: (True_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F \\/ P() -> P()"\t\t\r\tprop := Or new: (False_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r',			#stamp : 'pm 12/12/2018 09:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:21:55.821274+01:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOrStability,			#protocol : #clausification-Or,			#sourceCode : 'testClausificationOrStability\r\t| prop res |\r\t\r\t"stability of a clausified or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t',			#stamp : 'pm 12/12/2018 09:21',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:23:35.689898+01:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #clausification-Or,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of a clausified or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T \\/ P()-> T"\r\tprop := Or new: (True_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F \\/ P() -> P()"\t\t\r\tprop := Or new: (False_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r',			#stamp : 'pm 12/12/2018 09:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:26:20.802676+01:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #clausification-And,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\t"stability of a clausified and"\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ T -> P()"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ F -> F"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T /\\ P() -> P()"\t\r\tprop := And new: (True_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F /\\ P() -> F"\t\r\tprop := And new: (False_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 21:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #clausification-And,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\t"P() /\\ T -> P()"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ F -> F"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T /\\ P() -> P()"\t\r\tprop := And new: (True_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F /\\ P() -> F"\t\r\tprop := And new: (False_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/12/2018 09:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:26:40.955244+01:00' ],		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAndStability,			#protocol : #clausification-And,			#sourceCode : 'testClausificationAndStability\r\t| prop res |\r\t\r\t"stability of a clausified and"\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/12/2018 09:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:27:04.151994+01:00' ],		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAndOnAtomes,			#protocol : #clausification-And,			#sourceCode : 'testClausificationAndOnAtomes\r\t| prop res |\r\t\r\t"P() /\\ T -> P()"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ F -> F"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T /\\ P() -> P()"\t\r\tprop := And new: (True_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F /\\ P() -> F"\t\r\tprop := And new: (False_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/12/2018 09:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:27:06.83247+01:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #clausification-And,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\t"P() /\\ T -> P()"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ F -> F"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T /\\ P() -> P()"\t\r\tprop := And new: (True_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F /\\ P() -> F"\t\r\tprop := And new: (False_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/12/2018 09:26',			#package : #_resolution_1erOrdre		}	}}