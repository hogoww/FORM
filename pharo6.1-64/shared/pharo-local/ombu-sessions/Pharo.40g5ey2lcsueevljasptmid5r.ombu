OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T08:46:11.833846+02:00' ],		#prior : OmReference [ 'Pharo.2hyb8zlq6ii3fduxlrzs6mkvk', '46' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperation:',			#protocol : #unification,			#sourceCode : 'tryOperation: aPair\r\t| modified left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[setOfPairs remove:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t(left isSameSymb: right)\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t\t"FAIRE UN THROW ERROR & CATCH"\r\t\t\t]\r\t\t\t\r\t\t\t"STOPPED HERE"\r\t\t\t\r\t\t\tleft arity.\r\t\t\t.modified:=true.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t].\r\t\t].\r\t\r\t\r\t^modified.',			#stamp : 'pm 10/17/2018 12:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperation:',			#protocol : #unification,			#sourceCode : 'tryOperation: aPair\r\t| modified left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[setOfPairs remove:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t(left isSameSymb: right)\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t\t"FAIRE UN THROW ERROR & CATCH"\r\t\t\t].\r\t\t\t(left arity=right arity)\r\t\t\tifFalse:[\r\t\t\t\t"FAIRE UN THROW ERROR & CATCH"\r\t\t\t\t]."conflict"\r\t\t\tmodified:=true.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isKindOf: FuncTerm )and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[right isConst])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifFalse:[].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^modified.',			#stamp : 'pm 10/18/2018 08:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T08:46:48.272024+02:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperation:',			#protocol : #unification,			#sourceCode : 'tryOperation: aPair\r\t| modified left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[setOfPairs remove:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t(left isSameSymb: right)\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t\t"FAIRE UN THROW ERROR & CATCH"\r\t\t\t].\r\t\t\t(left arity=right arity)\r\t\t\tifFalse:[\r\t\t\t\t"FAIRE UN THROW ERROR & CATCH"\r\t\t\t\t]."conflict"\r\t\t\tmodified:=true.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isKindOf: FuncTerm )and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[right isConst])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\t\r\t\t\t\t\t]\r\t\t\t\tifFalse:[].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^modified.',			#stamp : 'pm 10/18/2018 08:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperation:',			#protocol : #unification,			#sourceCode : 'tryOperation: aPair\r\t| modified left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[setOfPairs remove:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t(left isSameSymb: right)\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t\t"FAIRE UN THROW ERROR & CATCH"\r\t\t\t].\r\t\t\t(left arity=right arity)\r\t\t\tifFalse:[\r\t\t\t\t"FAIRE UN THROW ERROR & CATCH"\r\t\t\t\t]."conflict"\r\t\t\tmodified:=true.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isKindOf: FuncTerm )and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[right isConst])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\t\tself eliminate:aPair.\r\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^modified.',			#stamp : 'pm 10/18/2018 08:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T09:03:19.619957+02:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperation:',			#protocol : #unification,			#sourceCode : 'tryOperation: aPair\r\t| modified left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[setOfPairs remove:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t(left isSameSymb: right)\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t\t"FAIRE UN THROW ERROR & CATCH"\r\t\t\t].\r\t\t\t(left arity=right arity)\r\t\t\tifFalse:[\r\t\t\t\t"FAIRE UN THROW ERROR & CATCH"\r\t\t\t\t]."conflict"\r\t\t\tmodified:=true.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isKindOf: FuncTerm )and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[right isConst])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\t\tself eliminate:aPair.\r\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^modified.',			#stamp : 'pm 10/18/2018 08:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperation:',			#protocol : #unification,			#sourceCode : 'tryOperation: aPair\r\t| modified left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[setOfPairs remove:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t(left isSameSymb: right)\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t\t"FAIRE UN THROW ERROR & CATCH"\r\t\t\t].\r\t\t\t(left arity=right arity)\r\t\t\tifFalse:[\r\t\t\t\t"FAIRE UN THROW ERROR & CATCH"\r\t\t\t\t]."conflict"\r\t\t\tmodified:=true.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isKindOf: FuncTerm )and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[right isConst])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tself eliminate:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check"\r\t\t\t\t\t(((left isConst) not) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself check: aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^modified.',			#stamp : 'pm 10/18/2018 09:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T09:04:00.460467+02:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'swap:',			#protocol : #'as yet unclassified',			#sourceCode : 'swap: aPair\r\t|left right|\r\t',			#stamp : 'pm 10/18/2018 09:04',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T09:05:52.318858+02:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'swap:',			#protocol : #'as yet unclassified',			#sourceCode : 'swap: aPair\r\t|left right|\r\t',			#stamp : 'pm 10/18/2018 09:04',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'swap:',			#protocol : #'as yet unclassified',			#sourceCode : 'swap: aPair\r\t|left right|\r\tleft:=aPair left.\r\tright:=aPair right.\r\t(self setOfPairs) remove:aPair.\r\tself add: Pair left: right right: left.\r\t',			#stamp : 'pm 10/18/2018 09:05',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T09:06:34.874715+02:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t^self error show:\'todo FuncTerm->decompose:aPair\'.',			#stamp : 'pm 10/17/2018 12:20',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right |\r',			#stamp : 'pm 10/18/2018 09:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T09:06:36.578705+02:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right |\r',			#stamp : 'pm 10/18/2018 09:06',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right|\r',			#stamp : 'pm 10/18/2018 09:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T09:06:44.015388+02:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'swap:',			#protocol : #'as yet unclassified',			#sourceCode : 'swap: aPair\r\t|left right|\r\tleft:=aPair left.\r\tright:=aPair right.\r\t(self setOfPairs) remove:aPair.\r\tself add: Pair left: right right: left.\r\t',			#stamp : 'pm 10/18/2018 09:05',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'swap:',			#protocol : #unification,			#sourceCode : 'swap: aPair\r\t|left right|\r\tleft:=aPair left.\r\tright:=aPair right.\r\t(self setOfPairs) remove:aPair.\r\tself add: Pair left: right right: left.\r\t',			#stamp : 'pm 10/18/2018 09:05',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T09:13:32.417797+02:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right|\r',			#stamp : 'pm 10/18/2018 09:06',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right|\r\tleft:=aPair left.\r\tright:=aPair right.\r\t\r\t\r\t',			#stamp : 'pm 10/18/2018 09:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T09:14:23.25264+02:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperation:',			#protocol : #unification,			#sourceCode : 'tryOperation: aPair\r\t| modified left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[setOfPairs remove:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t(left isSameSymb: right)\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t\t"FAIRE UN THROW ERROR & CATCH"\r\t\t\t].\r\t\t\t(left arity=right arity)\r\t\t\tifFalse:[\r\t\t\t\t"FAIRE UN THROW ERROR & CATCH"\r\t\t\t\t]."conflict"\r\t\t\tmodified:=true.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isKindOf: FuncTerm )and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[right isConst])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tself eliminate:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check"\r\t\t\t\t\t(((left isConst) not) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself check: aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^modified.',			#stamp : 'pm 10/18/2018 09:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperation:',			#protocol : #unification,			#sourceCode : 'tryOperation: aPair\r\t| modified left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[setOfPairs remove:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t\t"FAIRE UN THROW ERROR & CATCH"\r\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isKindOf: FuncTerm )and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[right isConst])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tself eliminate:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check"\r\t\t\t\t\t(((left isConst) not) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself check: aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^modified.',			#stamp : 'pm 10/18/2018 09:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T09:22:37.097946+02:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'at:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: index \r\t^ (self terms) at:index.',			#stamp : 'pm 10/18/2018 09:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T09:22:37.179477+02:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'at:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: index \r\t^ (self terms) at:index.',			#stamp : 'pm 10/18/2018 09:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'at: index \r\t^ (self terms) at:index.',			#stamp : 'pm 10/18/2018 09:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T09:23:54.623235+02:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'at:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: index \r\t^ (self terms) at:index.',			#stamp : 'pm 10/18/2018 09:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T09:23:54.704834+02:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'at:',			#protocol : #'as yet unclassified',			#sourceCode : 'at: index \r\t^ (self terms) at:index.',			#stamp : 'pm 10/18/2018 09:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'at: index \r\t^ (self terms) at:index.',			#stamp : 'pm 10/18/2018 09:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T09:25:21.181235+02:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right|\r\tleft:=aPair left.\r\tright:=aPair right.\r\t\r\t\r\t',			#stamp : 'pm 10/18/2018 09:13',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right i|\r\tleft:=aPair left.\r\tright:=aPair right.\r\ti:=0.\r\t(i<(left arity))"arity is the same, as we tested in the caller."\r\twhileTrue:[\r\t\tself add: (Pair left: (left at: i) right: (right at: i)).\r\t\ti:=i+1.\r\t\t].\r\t',			#stamp : 'pm 10/18/2018 09:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T10:04:24.883209+02:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right i|\r\tleft:=aPair left.\r\tright:=aPair right.\r\tsetOfPairs remove:aPair."we remove the pair first, iterate on everything, then add it again"\r\t\r\r\tsetOfPairs do:[:each| ].',			#stamp : 'pm 10/18/2018 10:04',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T10:30:46.661236+02:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'replace:x by:t\r',			#stamp : 'pm 10/18/2018 10:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T10:30:46.760549+02:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'replace:x by:t\r',			#stamp : 'pm 10/18/2018 10:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r',			#stamp : 'pm 10/18/2018 10:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T10:30:50.316222+02:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right i|\r\tleft:=aPair left.\r\tright:=aPair right.\r\tsetOfPairs remove:aPair."we remove the pair first, iterate on everything, then add it again"\r\t\r\r\tsetOfPairs do:[:each| ].',			#stamp : 'pm 10/18/2018 10:04',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right newSet|\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\tsetOfPairs do:[:each| each replace: left by:right].\r\r',			#stamp : 'pm 10/18/2018 10:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T10:32:46.169931+02:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right newSet|\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\tsetOfPairs do:[:each| each replace: left by:right].\r\r',			#stamp : 'pm 10/18/2018 10:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right newSet|\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\tsetOfPairs remove:aPair. "We don\'t want to replace x=t by t=t. So we\'ll just add it back at the end"\r\tsetOfPairs do:[:each| newSet add:(each replace: left by:right).].\r\tnewSet add:aPair.\r\tsetOfPairs:=newSet.\r\t\r',			#stamp : 'pm 10/18/2018 10:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T10:36:07.826502+02:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right newSet|\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\tsetOfPairs remove:aPair. "We don\'t want to replace x=t by t=t. So we\'ll just add it back at the end"\r\tsetOfPairs do:[:each| newSet add:(each replace: left by:right).].\r\tnewSet add:aPair.\r\tsetOfPairs:=newSet.\r\t\r',			#stamp : 'pm 10/18/2018 10:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t"Shouldn\'t we get a isModified?"\r\t|left right newSet|\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\tsetOfPairs remove:aPair. "We don\'t want to replace x=t by t=t. So we\'ll just add it back at the end"\r\tsetOfPairs do:[:each| newSet add:(each replace: left by:right).].\r\t(setOfPairs = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r',			#stamp : 'pm 10/18/2018 10:36',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T10:36:18.852175+02:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t"Shouldn\'t we get a isModified?"\r\t|left right newSet|\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\tsetOfPairs remove:aPair. "We don\'t want to replace x=t by t=t. So we\'ll just add it back at the end"\r\tsetOfPairs do:[:each| newSet add:(each replace: left by:right).].\r\t(setOfPairs = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r',			#stamp : 'pm 10/18/2018 10:36',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right newSet|\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\tsetOfPairs remove:aPair. "We don\'t want to replace x=t by t=t. So we\'ll just add it back at the end"\r\tsetOfPairs do:[:each| newSet add:(each replace: left by:right).].\r\t(setOfPairs = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r',			#stamp : 'pm 10/18/2018 10:36',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T10:37:33.571596+02:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperation:',			#protocol : #unification,			#sourceCode : 'tryOperation: aPair\r\t| modified left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[setOfPairs remove:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t\t"FAIRE UN THROW ERROR & CATCH"\r\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isKindOf: FuncTerm )and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[right isConst])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tself eliminate:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check"\r\t\t\t\t\t(((left isConst) not) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself check: aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^modified.',			#stamp : 'pm 10/18/2018 09:14',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperation:',			#protocol : #unification,			#sourceCode : 'tryOperation: aPair\r\t| modified left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[setOfPairs remove:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t\t"FAIRE UN THROW ERROR & CATCH"\r\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isKindOf: FuncTerm )and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[right isConst])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check"\r\t\t\t\t\t(((left isConst) not) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself check: aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^modified.',			#stamp : 'pm 10/18/2018 10:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T10:42:48.186611+02:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r',			#stamp : 'pm 10/18/2018 10:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| res | \r\tterms do:[:each| res addTerm:(each replace)].',			#stamp : 'pm 10/18/2018 10:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T10:57:34.037051+02:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| res | \r\tterms do:[:each| res addTerm:(each replace)].',			#stamp : 'pm 10/18/2018 10:42',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| res | \r\tres:=FuncTerm new: (self getSymb).\r\tterms do:[:each| res addTerm:(each replace)].',			#stamp : 'pm 10/18/2018 10:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T10:58:29.540445+02:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'addTerm:',			#protocol : #adding,			#sourceCode : 'addTerm: aTerm\r\tterms add:aTerm.',			#stamp : 'pm 10/18/2018 10:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T11:05:57.807201+02:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| res | \r\tres:=FuncTerm new: (self getSymb).\r\tterms do:[:each| res addTerm:(each replace)].',			#stamp : 'pm 10/18/2018 10:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| res | \r\tres:=FuncTerm new: (self getSymb).\r\tterms do:[:each| res addTerm:(each replace:x by:t)].',			#stamp : 'pm 10/18/2018 11:05',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T14:09:01.561668+02:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| res | \r\tres:=FuncTerm new: (self getSymb).\r\tterms do:[:each| res addTerm:(each replace:x by:t)].',			#stamp : 'pm 10/18/2018 11:05',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| res | \r\tterms do:[:each| each replace:x by:t].',			#stamp : 'pm 10/18/2018 14:09',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T14:09:15.192554+02:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| res | \r\tterms do:[:each| each replace:x by:t].',			#stamp : 'pm 10/18/2018 14:09',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\tterms do:[:each| each replace:x by:t].',			#stamp : 'pm 10/18/2018 14:09',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T14:09:25.219459+02:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'replace:x by:t\r\tterms do:[:each| each replace:x by:t].',			#stamp : 'pm 10/18/2018 14:09',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T14:09:25.393624+02:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'replace:x by:t\r\tterms do:[:each| each replace:x by:t].',			#stamp : 'pm 10/18/2018 14:09',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\tterms do:[:each| each replace:x by:t].',			#stamp : 'pm 10/18/2018 14:09',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T14:25:38.218153+02:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'replace:x by:t\r\t',			#stamp : 'pm 10/18/2018 14:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T14:25:38.312692+02:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #'as yet unclassified',			#sourceCode : 'replace:x by:t\r\t',			#stamp : 'pm 10/18/2018 14:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t',			#stamp : 'pm 10/18/2018 14:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T14:26:44.159556+02:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t',			#stamp : 'pm 10/18/2018 14:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t(term = x)\r\tifTrue:[term:=x.]\r\t',			#stamp : 'pm 10/18/2018 14:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T14:36:37.899413+02:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperation:',			#protocol : #unification,			#sourceCode : 'tryOperation: aPair\r\t| modified left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[setOfPairs remove:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t\t"FAIRE UN THROW ERROR & CATCH"\r\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isKindOf: FuncTerm )and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[right isConst])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check"\r\t\t\t\t\t(((left isConst) not) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself check: aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^modified.',			#stamp : 'pm 10/18/2018 10:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperation:',			#protocol : #unification,			#sourceCode : 'tryOperation: aPair\r\t| modified left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[setOfPairs remove:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t\t"FAIRE UN THROW ERROR & CATCH"\r\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isKindOf: FuncTerm )and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[right isConst])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check"\r\t\t\t\t\t(((left isConst) not) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself check: aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^modified.',			#stamp : 'pm 10/18/2018 14:36',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T14:40:22.831455+02:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #UnifyMe,			#protocol : #unification,			#sourceCode : 'UnifyMe\r\t|modified|\r\tmodified:=true.\r\tmodified whileTrue:[\t\t\r\t\tsetOfPairs do:[:each |\r\t\t\t\tmodified:=self TryOperations: each.\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/17/2018 11:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #UnifyMe,			#protocol : #unification,			#sourceCode : 'UnifyMe\r\t|modified|\r\tmodified:=true.\r\tmodified whileTrue:[\t\t\r\t\tsetOfPairs do:[:each |\r\t\t\t\tmodified:=self tryOperation: each.\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/18/2018 14:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T14:40:28.131938+02:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[setOfPairs remove:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t\t"FAIRE UN THROW ERROR & CATCH"\r\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isKindOf: FuncTerm )and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[right isConst])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check"\r\t\t\t\t\t(((left isConst) not) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself check: aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^modified.',			#stamp : 'pm 10/18/2018 14:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T14:40:33.518841+02:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperation:',			#protocol : #unification,			#sourceCode : 'tryOperation: aPair\r\t| modified left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[setOfPairs remove:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t\t"FAIRE UN THROW ERROR & CATCH"\r\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isKindOf: FuncTerm )and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[right isConst])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check"\r\t\t\t\t\t(((left isConst) not) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself check: aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^modified.',			#stamp : 'pm 10/18/2018 14:36',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-18T14:40:37.95535+02:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #UnifyMe,			#protocol : #unification,			#sourceCode : 'UnifyMe\r\t|modified|\r\tmodified:=true.\r\tmodified whileTrue:[\t\t\r\t\tsetOfPairs do:[:each |\r\t\t\t\tmodified:=self tryOperation: each.\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/18/2018 14:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #UnifyMe,			#protocol : #unification,			#sourceCode : 'UnifyMe\r\t|modified|\r\tmodified:=true.\r\tmodified whileTrue:[\t\t\r\t\tsetOfPairs do:[:each |\r\t\t\t\tmodified:=self tryOperations: each.\r\t\t\t]\r\t\t]\r\t',			#stamp : 'pm 10/18/2018 14:40',			#package : #_resolution_1erOrdre		}	}}