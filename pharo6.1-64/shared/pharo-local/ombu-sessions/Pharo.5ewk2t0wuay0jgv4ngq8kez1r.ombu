OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:32:37.418697+01:00' ],		#prior : OmReference [ 'Pharo.5v4ywramp4agtvgsa2i269ui8', '16' ],		#self : OmReference [ '1' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '5ewk2sz0aj0si5xvb3hmiph3u', '1' ],			OmReference [ '5ewk2sz0aj0si5xvb3hmiph3u', '2' ],			OmReference [ '5ewk2sz0aj0si5xvb3hmiph3u', '3' ],			OmReference [ '5ewk2sz0aj0si5xvb3hmiph3u', '4' ],			OmReference [ '5ewk2sz0aj0si5xvb3hmiph3u', '5' ],			OmReference [ '5ewk2sz0aj0si5xvb3hmiph3u', '6' ],			OmReference [ '5ewk2sz0aj0si5xvb3hmiph3u', '7' ],			OmReference [ '5ewk2sz0aj0si5xvb3hmiph3u', '8' ],			OmReference [ '5ewk2sz0aj0si5xvb3hmiph3u', '9' ],			OmReference [ '5ewk2sz0aj0si5xvb3hmiph3u', '10' ],			OmReference [ '5ewk2sz0aj0si5xvb3hmiph3u', '11' ],			OmReference [ '5ewk2sz0aj0si5xvb3hmiph3u', '12' ],			OmReference [ '5ewk2sz0aj0si5xvb3hmiph3u', '13' ],			OmReference [ '5ewk2sz0aj0si5xvb3hmiph3u', '14' ],			OmReference [ '5ewk2sz0aj0si5xvb3hmiph3u', '15' ],			OmReference [ '5ewk2sz0aj0si5xvb3hmiph3u', '16' ],			OmReference [ '5ewk2sz0aj0si5xvb3hmiph3u', '17' ],			OmReference [ '5ewk2sz0aj0si5xvb3hmiph3u', '18' ],			OmReference [ '5ewk2sz0aj0si5xvb3hmiph3u', '19' ],			OmReference [ '5ewk2sz0aj0si5xvb3hmiph3u', '20' ],			OmReference [ '5ewk2sz0aj0si5xvb3hmiph3u', '21' ]		]	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ],		#time : DateAndTime [ '2018-12-12T09:32:37.448859+01:00' ],		#trigger : @3	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #ConstituteOfOr,			#protocol : #'as yet unclassified',			#sourceCode : 'ConstituteOfOr\r\t^true',			#stamp : 'pm 12/11/2018 21:59',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #ConstituteOfOr,			#protocol : #'as yet unclassified',			#sourceCode : 'ConstituteOfOr\r\t"Used to check if there\'s only Or\'s in this prop tree, during the clausification process"\r\r\t"In an atome, it\'s always true. They aren\'t considered during the clausification process"\r\t^true',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ],		#time : DateAndTime [ '2018-12-12T09:32:37.461068+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testDoubleNotWithOnlyAtomes,			#protocol : #isClause,			#sourceCode : 'testDoubleNotWithOnlyAtomes\r\t| input |\r\tinput:=Not new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself deny: input isClause.\r\r',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ],		#time : DateAndTime [ '2018-12-12T09:32:37.464567+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testSimpleNotWithOnlyAtomes,			#protocol : #isClause,			#sourceCode : 'testSimpleNotWithOnlyAtomes\r\t| input |\r\tinput:=Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          ).\r\r\tself assert: input isClause.\r\r',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ],		#time : DateAndTime [ '2018-12-12T09:32:37.465766+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolAddition {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #Skolemn_test\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #Skolemn_test,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Skolemn_test class\r\tinstanceVariableNames: \'\''				},				#name : #'Skolemn_test class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Skolemn_test,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #clausification-And	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ],		#time : DateAndTime [ '2018-12-12T09:32:37.628967+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationPredicate,			#protocol : #Clausification,			#sourceCode : 'testClausificationPredicate\r\t| prop res |\r\t"basic, should be  unafected by clausification"\r\t\r\t"for empty predicates"\r\tprop := (Predicate new:\'P\').\r\tres := (Predicate new:\'P\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t\t"for unary predicates"\r\tprop := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\tres := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\r\tself assert: prop fullClausification equals: res.\r\r\t"for variadic predicates"\r\tprop := Predicate new:\'P\' fromList:\r          (LinkedList new \r               add:(Term new:\'a\');\r               add:(Term new:\'b\');\r               add:(Term new:\'c\');\r               add:(Term new:\'d\');\r               yourself).\r\tres := Predicate new:\'P\' fromList:\r          (LinkedList new \r               add:(Term new:\'a\');\r               add:(Term new:\'b\');\r               add:(Term new:\'c\');\r               add:(Term new:\'d\');\r               yourself).\r\r\t"for variadic predicates"\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationPredicate,			#protocol : #clausification-general,			#sourceCode : 'testClausificationPredicate\r\t| prop res |\r\t"basic, should be  unafected by clausification"\r\t\r\t"for empty predicates"\r\tprop := (Predicate new:\'P\').\r\tres := (Predicate new:\'P\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t\t"for unary predicates"\r\tprop := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\tres := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\r\tself assert: prop fullClausification equals: res.\r\r\t"for variadic predicates"\r\tprop := Predicate new:\'P\' fromList:\r          (LinkedList new \r               add:(Term new:\'a\');\r               add:(Term new:\'b\');\r               add:(Term new:\'c\');\r               add:(Term new:\'d\');\r               yourself).\r\tres := Predicate new:\'P\' fromList:\r          (LinkedList new \r               add:(Term new:\'a\');\r               add:(Term new:\'b\');\r               add:(Term new:\'c\');\r               add:(Term new:\'d\');\r               yourself).\r\r\t"for variadic predicates"\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ],		#time : DateAndTime [ '2018-12-12T09:32:37.631733+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationPredicate,			#protocol : #clausification-general,			#sourceCode : 'testClausificationPredicate\r\t| prop res |\r\t"basic, should be  unafected by clausification"\r\t\r\t"for empty predicates"\r\tprop := (Predicate new:\'P\').\r\tres := (Predicate new:\'P\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t\t"for unary predicates"\r\tprop := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\tres := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\r\tself assert: prop fullClausification equals: res.\r\r\t"for variadic predicates"\r\tprop := Predicate new:\'P\' fromList:\r          (LinkedList new \r               add:(Term new:\'a\');\r               add:(Term new:\'b\');\r               add:(Term new:\'c\');\r               add:(Term new:\'d\');\r               yourself).\r\tres := Predicate new:\'P\' fromList:\r          (LinkedList new \r               add:(Term new:\'a\');\r               add:(Term new:\'b\');\r               add:(Term new:\'c\');\r               add:(Term new:\'d\');\r               yourself).\r\r\t"for variadic predicates"\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/7/2018 19:58',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationPredicate,			#protocol : #clausification-general,			#sourceCode : 'testClausificationPredicate\r\t| prop res |\r\t"basic, should be  unafected by clausification"\r\t\r\t"for empty predicates"\r\tprop := (Predicate new:\'P\').\r\tres := (Predicate new:\'P\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t\t"for unary predicates"\r\tprop := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\tres := (Predicate new:\'P\' variable: (Term new: \'a\')).\r\r\tself assert: prop fullClausification equals: res.\r\r\t"for variadic predicates"\r\tprop := Predicate new:\'P\' fromList:\r          (LinkedList new \r               add:(Term new:\'a\');\r               add:(Term new:\'b\');\r               add:(Term new:\'c\');\r               add:(Term new:\'d\');\r               yourself).\r\tres := Predicate new:\'P\' fromList:\r          (LinkedList new \r               add:(Term new:\'a\');\r               add:(Term new:\'b\');\r               add:(Term new:\'c\');\r               add:(Term new:\'d\');\r               yourself).\r\r\t"for variadic predicates"\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ],		#time : DateAndTime [ '2018-12-12T09:32:37.639107+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #Clausification,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t"basic test for equal\'s clausification"\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := Or new:(And new:\r\t    \t\t      \t\t\t(Predicate new:\'P\')\r\t\t\t\t\t\t    rightProp:\r\t\t\t\t\t         (Predicate new:\'Q\'))\r\t\t\t\trightProp:(And new:\r          \t\t\t(Not new: (Predicate new:\'P\'))\r\t\t\t\t     rightProp:\r\t\t\t          (Not new:(Predicate new:\'Q\'))).\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #clausification-general,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t"basic test for equal\'s clausification"\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := Or new:(And new:\r\t    \t\t      \t\t\t(Predicate new:\'P\')\r\t\t\t\t\t\t    rightProp:\r\t\t\t\t\t         (Predicate new:\'Q\'))\r\t\t\t\trightProp:(And new:\r          \t\t\t(Not new: (Predicate new:\'P\'))\r\t\t\t\t     rightProp:\r\t\t\t          (Not new:(Predicate new:\'Q\'))).\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ],		#time : DateAndTime [ '2018-12-12T09:32:37.640915+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #clausification-general,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t"basic test for equal\'s clausification"\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := Or new:(And new:\r\t    \t\t      \t\t\t(Predicate new:\'P\')\r\t\t\t\t\t\t    rightProp:\r\t\t\t\t\t         (Predicate new:\'Q\'))\r\t\t\t\trightProp:(And new:\r          \t\t\t(Not new: (Predicate new:\'P\'))\r\t\t\t\t     rightProp:\r\t\t\t          (Not new:(Predicate new:\'Q\'))).\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 20:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #clausification-general,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t"basic test for equal\'s clausification"\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := Or new:(And new:\r\t    \t\t      \t\t\t(Predicate new:\'P\')\r\t\t\t\t\t\t    rightProp:\r\t\t\t\t\t         (Predicate new:\'Q\'))\r\t\t\t\trightProp:(And new:\r          \t\t\t(Not new: (Predicate new:\'P\'))\r\t\t\t\t     rightProp:\r\t\t\t          (Not new:(Predicate new:\'Q\'))).\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ],		#time : DateAndTime [ '2018-12-12T09:32:37.647173+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationImply,			#protocol : #Clausification,			#sourceCode : 'testClausificationImply\r\t| prop res |\r\t\r\t"basic test for imply\'s clausification"\r\tprop := Imply\r\t\tnew: (Predicate new: \'P\')\r\t\trightProp: (Predicate new: \'Q\').\r\tres := Or\r\t\tnew: (Not new: (Predicate new: \'P\'))\r\t\trightProp: (Predicate new: \'Q\').\r\tself assert: prop fullClausification equals: res',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationImply,			#protocol : #clausification-general,			#sourceCode : 'testClausificationImply\r\t| prop res |\r\t\r\t"basic test for imply\'s clausification"\r\tprop := Imply\r\t\tnew: (Predicate new: \'P\')\r\t\trightProp: (Predicate new: \'Q\').\r\tres := Or\r\t\tnew: (Not new: (Predicate new: \'P\'))\r\t\trightProp: (Predicate new: \'Q\').\r\tself assert: prop fullClausification equals: res',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ],		#time : DateAndTime [ '2018-12-12T09:32:37.649682+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationImply,			#protocol : #clausification-general,			#sourceCode : 'testClausificationImply\r\t| prop res |\r\t\r\t"basic test for imply\'s clausification"\r\tprop := Imply\r\t\tnew: (Predicate new: \'P\')\r\t\trightProp: (Predicate new: \'Q\').\r\tres := Or\r\t\tnew: (Not new: (Predicate new: \'P\'))\r\t\trightProp: (Predicate new: \'Q\').\r\tself assert: prop fullClausification equals: res',			#stamp : 'pm 12/7/2018 20:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationImply,			#protocol : #clausification-general,			#sourceCode : 'testClausificationImply\r\t| prop res |\r\t\r\t"basic test for imply\'s clausification"\r\tprop := Imply\r\t\tnew: (Predicate new: \'P\')\r\t\trightProp: (Predicate new: \'Q\').\r\tres := Or\r\t\tnew: (Not new: (Predicate new: \'P\'))\r\t\trightProp: (Predicate new: \'Q\').\r\tself assert: prop fullClausification equals: res',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ],		#time : DateAndTime [ '2018-12-12T09:32:37.65264+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolAddition {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #Skolemn_test\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #Skolemn_test,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Skolemn_test class\r\tinstanceVariableNames: \'\''				},				#name : #'Skolemn_test class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Skolemn_test,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #clausification-Not	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ],		#time : DateAndTime [ '2018-12-12T09:32:37.715007+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpProtocolAddition {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #Skolemn_test\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #Skolemn_test,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Skolemn_test class\r\tinstanceVariableNames: \'\''				},				#name : #'Skolemn_test class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @8			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Skolemn_test,					#isMetaSide : false				},				#parent : @8,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #clausification-Or	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ],		#time : DateAndTime [ '2018-12-12T09:32:37.781549+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNotDistributedOnAnd,			#protocol : #clausification-Not,			#sourceCode : 'testClausificationNotDistributedOnAnd\r\t"Not on an And"\r\t| prop res |\r\tprop := Not new:\r     (And new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= Or new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ],		#time : DateAndTime [ '2018-12-12T09:32:37.792369+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNotDistributedOnOr,			#protocol : #clausification-Not,			#sourceCode : 'testClausificationNotDistributedOnOr\r\t| prop res |\r\t"Not on an Or"\r\tprop:=Not new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= And new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ],		#time : DateAndTime [ '2018-12-12T09:32:37.79795+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNotOnAtomes,			#protocol : #clausification-Not,			#sourceCode : 'testClausificationNotOnAtomes\r\t| prop res |\r\r\t"Complete test for the Not clausifications"\r\t\r\t"Polarity inversion"\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"Polarity inversion #2"\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"cancel Not"\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r\t\r\r\t\r\r',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ],		#time : DateAndTime [ '2018-12-12T09:32:37.820821+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationNot,			#protocol : #Clausification,			#sourceCode : 'testClausificationNot\r\t| prop res |\r\r\t"Complete test for the Not clausifications"\r\t\r\t"Polarity inversion"\r\tprop := Not new: False_Const new.\r\tres := True_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"Polarity inversion #2"\t\r\tprop := Not new: True_Const new.\r\tres := False_Const new.\r\r\tself assert: prop fullClausification equals: res.\r\r\t"cancel Not"\r\tprop := Not new: (Not new: (Predicate new:\'P\')).\r\tres := (Predicate new:\'P\').\r\r\tself assert: prop fullClausification equals: res.\r\t\r\t"Not on an Or"\r\tprop:=Not new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= And new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r\t"Not on an And"\r\tprop := Not new:\r     (And new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\r\tres:= Or new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Not new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\t\r\r',			#stamp : 'pm 12/7/2018 20:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ],		#time : DateAndTime [ '2018-12-12T09:32:37.827334+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOrDistributivity,			#protocol : #clausification-Or,			#sourceCode : 'testClausificationOrDistributivity\r\t| prop res |\r\t"Or\'s distributivity"\r\tprop:=Or new:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     )\r\trightProp:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ],		#time : DateAndTime [ '2018-12-12T09:32:37.831499+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOrDistributivitySymetric,			#protocol : #clausification-Or,			#sourceCode : 'testClausificationOrDistributivitySymetric\r\t| prop res |\r\r\t"And the symetric. "\r\tprop :=Or new:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     ).\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Or new:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ],		#time : DateAndTime [ '2018-12-12T09:32:37.836352+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOrOnAtomes,			#protocol : #clausification-Or,			#sourceCode : 'testClausificationOrOnAtomes\r\t| prop res |\r\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T \\/ P()-> T"\r\tprop := Or new: (True_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F \\/ P() -> P()"\t\t\r\tprop := Or new: (False_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ],		#time : DateAndTime [ '2018-12-12T09:32:37.840309+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOrStability,			#protocol : #clausification-Or,			#sourceCode : 'testClausificationOrStability\r\t| prop res |\r\t\r\t"stability of a clausified or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ],		#time : DateAndTime [ '2018-12-12T09:32:37.852609+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationOr,			#protocol : #Clausification,			#sourceCode : 'testClausificationOr\r\t| prop res |\r\t"Complete tests for Or\'s clausifications"\r\t\r\t"stability of a clausified or"\r\tprop := Or new: (Predicate new: \'P\') \r\t  \t\t\t  rightProp: (Predicate new: \'Q\').\r\t\r\tres := Or new: (Predicate new: \'P\')\r\t \t\t\t rightProp: (Predicate new: \'Q\').\r\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ T -> T"\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() \\/ F -> P()"\t\t\r\tprop := Or new: (Predicate new: \'P\')\r\t\t\t\t  rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T \\/ P()-> T"\r\tprop := Or new: (True_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tTrue_Const new.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F \\/ P() -> P()"\t\t\r\tprop := Or new: (False_Const new)\r\t\t\t\t  rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"Or\'s distributivity"\r\tprop:=Or new:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     )\r\trightProp:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Or new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r\t"And the symetric. "\r\tprop :=Or new:\r     (And new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     ).\r\r\tres:=And new:\r     (Or new:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Or new:\r          (Predicate new:\'R\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself assert: prop fullClausification equals: res.\r\r',			#stamp : 'pm 12/7/2018 21:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ],		#time : DateAndTime [ '2018-12-12T09:32:37.857572+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAndStability,			#protocol : #clausification-And,			#sourceCode : 'testClausificationAndStability\r\t| prop res |\r\t\r\t"stability of a clausified and"\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ],		#time : DateAndTime [ '2018-12-12T09:32:37.862479+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAndOnAtomes,			#protocol : #clausification-And,			#sourceCode : 'testClausificationAndOnAtomes\r\t| prop res |\r\t\r\t"P() /\\ T -> P()"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ F -> F"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T /\\ P() -> P()"\t\r\tprop := And new: (True_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F /\\ P() -> F"\t\r\tprop := And new: (False_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ],		#time : DateAndTime [ '2018-12-12T09:32:37.885938+01:00' ],		#trigger : OmReference [ '1' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationAnd,			#protocol : #Clausification,			#sourceCode : 'testClausificationAnd\r\t| prop res |\r\t\r\t"stability of a clausified and"\r\tprop := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ T -> P()"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (True_Const new).\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"P() /\\ F -> F"\t\r\tprop := And new: (Predicate new: \'P\')\r\t\t\t\t   rightProp: (False_Const new).\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\r\t"T /\\ P() -> P()"\t\r\tprop := And new: (True_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tPredicate new: \'P\'.\r\t\t\r\tself assert: prop fullClausification equals: res.\r\t\r\t"F /\\ P() -> F"\t\r\tprop := And new: (False_Const new)\r\t\t\t\t   rightProp: (Predicate new: \'P\').\r\t\t\t\t\r\tres:=\tFalse_Const new.\r\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/7/2018 21:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:32:49.069462+01:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #Skolemn_test\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #Skolemn_test,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Skolemn_test class\r\tinstanceVariableNames: \'\''				},				#name : #'Skolemn_test class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Skolemn_test,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #Clausification	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:35:03.040057+01:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #ConstituteOfOr,			#protocol : #'as yet unclassified',			#sourceCode : 'ConstituteOfOr\r\t"Used to check if there\'s only Or\'s in this prop tree, during the clausification process"\r\r\t"In an atome, it\'s always true. They aren\'t considered during the clausification process"\r\t^true',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #ConstituteOfOr,			#protocol : #clausification,			#sourceCode : 'ConstituteOfOr\r\t"Used to check if there\'s only Or\'s in this prop tree, during the clausification process"\r\r\t"In an atome, it\'s always true. They aren\'t considered during the clausification process"\r\t^true',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:35:26.897762+01:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpProtocolAddition {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Prop',				#traitCompositionSource : '{}',				#definitionSource : 'Prop subclass: #Operator\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Operator,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Operator class\r\tinstanceVariableNames: \'symb\''				},				#name : #'Operator class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Operator class',							#isMetaSide : true						},						#name : #symb,						#parent : @12					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Operator,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent an operator whith an unknown number of argument.\r\rI only factorise a method for now, but I allow possible future evolutions.',				#stamp : 'pm 10/9/2018 10:48'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #clausification	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:35:32.170039+01:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Operator,				#isMetaSide : false			},			#name : #ConstituteOfOr,			#protocol : #'as yet unclassified',			#sourceCode : 'ConstituteOfOr\r\t"Used to check if there\'s only Or\'s in this prop tree, during the clausification process"\r\r\t"This is basically the same as isClause, except for the And class."\r\t^self isClause',			#stamp : 'pm 12/11/2018 21:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Operator,				#isMetaSide : false			},			#name : #ConstituteOfOr,			#protocol : #clausification,			#sourceCode : 'ConstituteOfOr\r\t"Used to check if there\'s only Or\'s in this prop tree, during the clausification process"\r\r\t"This is basically the same as isClause, except for the And class."\r\t^self isClause',			#stamp : 'pm 12/11/2018 21:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:35:40.553233+01:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #And,				#isMetaSide : false			},			#name : #ConstituteOfOr,			#protocol : #'as yet unclassified',			#sourceCode : 'ConstituteOfOr\r\t"Used to check if there\'s only Or\'s in this prop tree, during the clausification process"\r\r\t"Since we\'re in an And, we\'re not in a or, so, false !"\r\t^false',			#stamp : 'pm 12/11/2018 21:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #And,				#isMetaSide : false			},			#name : #ConstituteOfOr,			#protocol : #clausification,			#sourceCode : 'ConstituteOfOr\r\t"Used to check if there\'s only Or\'s in this prop tree, during the clausification process"\r\r\t"Since we\'re in an And, we\'re not in a or, so, false !"\r\t^false',			#stamp : 'pm 12/11/2018 21:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:36:20.986596+01:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testIsClauseDoubleNotWithOnlyAtomes,			#protocol : #isClause,			#sourceCode : 'testIsClauseDoubleNotWithOnlyAtomes\r\t| input |\r\tinput:=Not new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself deny: input isClause.\r\r',			#stamp : 'pm 12/12/2018 09:36',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:36:31.149597+01:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testIsClauseSimpleNotWithOnlyAtomes,			#protocol : #isClause,			#sourceCode : 'testIsClauseSimpleNotWithOnlyAtomes\r\t| input |\r\tinput:=Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          ).\r\r\tself assert: input isClause.\r\r',			#stamp : 'pm 12/12/2018 09:36',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:36:34.68719+01:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testSimpleNotWithOnlyAtomes,			#protocol : #isClause,			#sourceCode : 'testSimpleNotWithOnlyAtomes\r\t| input |\r\tinput:=Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          ).\r\r\tself assert: input isClause.\r\r',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:36:37.912972+01:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testDoubleNotWithOnlyAtomes,			#protocol : #isClause,			#sourceCode : 'testDoubleNotWithOnlyAtomes\r\t| input |\r\tinput:=Not new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself deny: input isClause.\r\r',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:39:04.255535+01:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testIsClauseDoubleNotWithOnlyAtomes,			#protocol : #isClause,			#sourceCode : 'testIsClauseDoubleNotWithOnlyAtomes\r\t| input |\r\tinput:=Not new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself deny: input isClause.\r\r',			#stamp : 'pm 12/12/2018 09:36',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testIsClauseDoubleNotWithOnlyAtomes,			#protocol : #isClause,			#sourceCode : 'testIsClauseDoubleNotWithOnlyAtomes\r\t| input |\r\tinput:=Not new:\r     (Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\t"should fail, because the double Not can and should be removed through clausification"\r\tself deny: input isClause.\r\r',			#stamp : 'pm 12/12/2018 09:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:39:17.179097+01:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testIsClauseSimpleNotWithOnlyAtomes,			#protocol : #isClause,			#sourceCode : 'testIsClauseSimpleNotWithOnlyAtomes\r\t| input |\r\tinput:=Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          ).\r\r\tself assert: input isClause.\r\r',			#stamp : 'pm 12/12/2018 09:36',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testIsClauseSimpleNotWithOnlyAtomes,			#protocol : #isClause,			#sourceCode : 'testIsClauseSimpleNotWithOnlyAtomes\r\t| input |\r\tinput:=Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          ).\r\r\t"should be fine"\r\tself assert: input isClause.\r\r',			#stamp : 'pm 12/12/2018 09:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:39:23.353054+01:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testIsClauseSimpleNotWithOnlyAtomes,			#protocol : #isClause,			#sourceCode : 'testIsClauseSimpleNotWithOnlyAtomes\r\t| input |\r\tinput:=Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          ).\r\r\t"should be fine"\r\tself assert: input isClause.\r\r',			#stamp : 'pm 12/12/2018 09:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testIsClauseSimpleNotWithOnlyAtomes,			#protocol : #isClause,			#sourceCode : 'testIsClauseSimpleNotWithOnlyAtomes\r\t| input |\r\tinput:=Not new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          ).\r\r\tself assert: input isClause.\r\r',			#stamp : 'pm 12/12/2018 09:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:45:01.822585+01:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testIsClauseNotOnOperator,			#protocol : #isClause,			#sourceCode : 'testIsClauseNotOnOperator\r\t| input |\r\tinput:=Not new:\r\t\t(Imply new: \r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r\t\trightProp: \r\t\t\t(Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\t"should fail, because the double Not can and should be removed through clausification"\r\tself deny: input isClause.\r\r',			#stamp : 'pm 12/12/2018 09:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:46:39.691396+01:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testIsClauseNotOnOperator,			#protocol : #isClause,			#sourceCode : 'testIsClauseNotOnOperator\r\t| input |\r\tinput:=Not new:\r\t\t(Imply new: \r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r\t\trightProp: \r\t\t\t(Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\t"should fail, because the double Not can and should be removed through clausification"\r\tself deny: input isClause.\r\r',			#stamp : 'pm 12/12/2018 09:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testIsClauseNotOnOperator,			#protocol : #isClause,			#sourceCode : 'testIsClauseNotOnOperator\r\t| input |\r\tinput:=Not new:\r\t\t(Imply new: \r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r\t\trightProp: \r\t\t\t(Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\t"should fail, because the Not can and should be removed through clausification"\r\tself deny: input isClause.\r\r\tinput:=Not new:\r\t\t(Or new: \r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r\t\trightProp: \r\t\t\t(Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\t"should fail, because the Not can and should be removed through clausification"\r\tself deny: input isClause.\r\r',			#stamp : 'pm 12/12/2018 09:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T09:50:50.882861+01:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testIsClauseNotOnOperator,			#protocol : #isClause,			#sourceCode : 'testIsClauseNotOnOperator\r\t| input |\r\tinput:=Not new:\r\t\t(Imply new: \r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r\t\trightProp: \r\t\t\t(Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\t"should fail, because the Not can and should be removed through clausification"\r\tself deny: input isClause.\r\r\tinput:=Not new:\r\t\t(Or new: \r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r\t\trightProp: \r\t\t\t(Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\t"should fail, because the Not can and should be removed through clausification"\r\tself deny: input isClause.\r\r',			#stamp : 'pm 12/12/2018 09:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testIsClauseNotOnOperator,			#protocol : #isClause,			#sourceCode : 'testIsClauseNotOnOperator\r\t| input |\r\t\r\t"should fail, because the Not can and should be removed through clausification\r\tTest on every binary operator for the principle of it, but the result should be the same every time"\r\r\t"Equal"\r\tinput:=Not new:\r\t\t(Equal new: \r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r\t\trightProp: \r\t\t\t(Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself deny: input isClause.\r\r\t\r\t"Imply"\r\tinput:=Not new:\r\t\t(Imply new: \r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r\t\trightProp: \r\t\t\t(Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself deny: input isClause.\r\r\t"Or"\r\tinput:=Not new:\r\t\t(Or new: \r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r\t\trightProp: \r\t\t\t(Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself deny: input isClause.\r\r\t"And"\r\tinput:=Not new:\r\t\t(And new: \r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r\t\trightProp: \r\t\t\t(Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself deny: input isClause.\r',			#stamp : 'pm 12/12/2018 09:50',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T10:02:05.77034+01:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testIsClauseQuantifier,			#protocol : #isClause,			#sourceCode : 'testIsClauseQuantifier\r\t| input |\r\t\r\t"should fail, because the Not can and should be removed through clausification\r\tTest on every binary operator for the principle of it, but the result should be the same every time"\r\r\t"Equal"\r\tinput:=Exists new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    add:(Term new:\'x\');\r                    yourself)\r     ).\r\r\r\tinput:=ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    add:(Term new:\'x\');\r                    yourself)\r     ).\r\r\r\tself should: input isClause raise:Error.\r',			#stamp : 'pm 12/12/2018 10:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T10:02:34.002721+01:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testIsClauseQuantifier,			#protocol : #isClause,			#sourceCode : 'testIsClauseQuantifier\r\t| input |\r\t\r\t"should fail, because the Not can and should be removed through clausification\r\tTest on every binary operator for the principle of it, but the result should be the same every time"\r\r\t"Equal"\r\tinput:=Exists new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    add:(Term new:\'x\');\r                    yourself)\r     ).\r\r\r\tinput:=ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    add:(Term new:\'x\');\r                    yourself)\r     ).\r\r\r\tself should: input isClause raise:Error.\r',			#stamp : 'pm 12/12/2018 10:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testIsClauseQuantifier,			#protocol : #isClause,			#sourceCode : 'testIsClauseQuantifier\r\t| input |\r\t\r\t"should fail, because the Not can and should be removed through clausification\r\tTest on every binary operator for the principle of it, but the result should be the same every time"\r\r\t"Equal"\r\tinput:=Exists new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    add:(Term new:\'x\');\r                    yourself)\r     ).\r\r\tself should: input isClause raise:Error.\r\r\tinput:=ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    add:(Term new:\'x\');\r                    yourself)\r     ).\r\r\r\tself should: input isClause raise:Error.\r',			#stamp : 'pm 12/12/2018 10:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T10:04:41.883107+01:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testIsClauseQuantifier,			#protocol : #isClause,			#sourceCode : 'testIsClauseQuantifier\r\t| input |\r\t\r\t"should fail, because the Not can and should be removed through clausification\r\tTest on every binary operator for the principle of it, but the result should be the same every time"\r\r\t"Equal"\r\tinput:=Exists new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    add:(Term new:\'x\');\r                    yourself)\r     ).\r\r\tself should: input isClause raise:Error.\r\r\tinput:=ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    add:(Term new:\'x\');\r                    yourself)\r     ).\r\r\r\tself should: input isClause raise:Error.\r',			#stamp : 'pm 12/12/2018 10:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testIsClauseQuantifier,			#protocol : #isClause,			#sourceCode : 'testIsClauseQuantifier\r\t| input |\r\t\r\t"should fail, because the Not can and should be removed through clausification\r\tTest on every binary operator for the principle of it, but the result should be the same every time"\r\r\t"Equal"\r\tinput:=Exists new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    add:(Term new:\'x\');\r                    yourself)\r     ).\r\r\tself should:[input isClause] raise:Error.\r\r\tinput:=ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    add:(Term new:\'x\');\r                    yourself)\r     ).\r\r\r\tself should:[input isClause] raise:Error.\r',			#stamp : 'pm 12/12/2018 10:04',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T10:21:59.338636+01:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testIsClauseOrOnAnd,			#protocol : #isClause,			#sourceCode : 'testIsClauseOrOnAnd\r\t| input |\r\tinput :=Or new:\r     (And new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     ).\r\r\tself deny: input isClause.\r\r\tinput:=Or new:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     )\r\trightProp:\r     (And new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself deny: input isClause.\r\r',			#stamp : 'pm 12/12/2018 10:21',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T10:41:16.902092+01:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Or,				#isMetaSide : false			},			#name : #isClause,			#protocol : #clausification,			#sourceCode : 'isClause\r\t"tester"\r\t^(left isClause & right isClause)',			#stamp : 'pm 11/27/2018 07:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Or,				#isMetaSide : false			},			#name : #isClause,			#protocol : #clausification,			#sourceCode : 'isClause\r\t"tester"\r\t^(left constitureOfOr & right constituteOfOr)',			#stamp : 'pm 12/12/2018 10:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T10:41:34.209356+01:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #And,				#isMetaSide : false			},			#name : #constituteOfOr,			#protocol : #clausification,			#sourceCode : 'constituteOfOr\r\t"Used to check if there\'s only Or\'s in this prop tree, during the clausification process"\r\r\t"Since we\'re in an And, we\'re not in a or, so, false !"\r\t^false',			#stamp : 'pm 12/12/2018 10:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T10:41:40.624675+01:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #And,				#isMetaSide : false			},			#name : #ConstituteOfOr,			#protocol : #clausification,			#sourceCode : 'ConstituteOfOr\r\t"Used to check if there\'s only Or\'s in this prop tree, during the clausification process"\r\r\t"Since we\'re in an And, we\'re not in a or, so, false !"\r\t^false',			#stamp : 'pm 12/11/2018 21:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T10:43:36.152512+01:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #constituteOfOr,			#protocol : #'as yet unclassified',			#sourceCode : 'constituteOfOr\r\t^self beShouldBeImplemented.',			#stamp : 'pm 12/12/2018 10:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T10:43:36.318173+01:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #constituteOfOr,			#protocol : #'as yet unclassified',			#sourceCode : 'constituteOfOr\r\t^self beShouldBeImplemented.',			#stamp : 'pm 12/12/2018 10:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #constituteOfOr,			#protocol : #clausification,			#sourceCode : 'constituteOfOr\r\t^self beShouldBeImplemented.',			#stamp : 'pm 12/12/2018 10:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T10:43:45.761341+01:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #constituteOfOr,			#protocol : #clausification,			#sourceCode : 'constituteOfOr\r\t^self beShouldBeImplemented.',			#stamp : 'pm 12/12/2018 10:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #constituteOfOr,			#protocol : #clausification,			#sourceCode : 'constituteOfOr\r\t^self shouldBeImplemented .',			#stamp : 'pm 12/12/2018 10:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T10:43:48.013105+01:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #constituteOfOr,			#protocol : #clausification,			#sourceCode : 'constituteOfOr\r\t^self shouldBeImplemented .',			#stamp : 'pm 12/12/2018 10:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #constituteOfOr,			#protocol : #clausification,			#sourceCode : 'constituteOfOr\r\t^self shouldBeImplemented.',			#stamp : 'pm 12/12/2018 10:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T10:43:55.707185+01:00' ],		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #constituteOfOr,			#protocol : #clausification,			#sourceCode : 'constituteOfOr\r\t^self shouldBeImplemented.',			#stamp : 'pm 12/12/2018 10:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #constituteOfOr,			#protocol : #clausification,			#sourceCode : 'constituteOfOr\r\t^self subclassResponsibility .',			#stamp : 'pm 12/12/2018 10:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T10:43:58.40797+01:00' ],		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #constituteOfOr,			#protocol : #clausification,			#sourceCode : 'constituteOfOr\r\t^self subclassResponsibility .',			#stamp : 'pm 12/12/2018 10:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #constituteOfOr,			#protocol : #clausification,			#sourceCode : 'constituteOfOr\r\t^self subclassResponsibility.',			#stamp : 'pm 12/12/2018 10:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T10:46:24.063281+01:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #constituteOfOr,			#protocol : #clausification,			#sourceCode : 'constituteOfOr\r\t^self subclassResponsibility.',			#stamp : 'pm 12/12/2018 10:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #constituteOfOr,			#protocol : #clausification,			#sourceCode : 'constituteOfOr\r\t"Part of the isClause method. Used to check if a prop\'s tree is constitute of Or\'s"\r\t^self subclassResponsibility.',			#stamp : 'pm 12/12/2018 10:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T10:49:28.049182+01:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"abstract class, not meant to be instanciated"\r\t^SubclassResponsibility \r',			#stamp : 'pm 12/7/2018 19:53',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"abstract class, not meant to be instanciated"\r\t^self error: \'Prop is abstract and shouldn\'\'t be implemented\'\r',			#stamp : 'pm 12/12/2018 10:49',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T10:52:41.475888+01:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #constituteOfOr,			#protocol : #clausification,			#sourceCode : 'constituteOfOr\r\t"Used to check if there\'s only Or\'s in this prop tree, during the clausification process"\r\r\t"In an atome, it\'s always true. They aren\'t considered during the clausification process"\r\t^true',			#stamp : 'pm 12/12/2018 10:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T10:52:45.265273+01:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Atome,				#isMetaSide : false			},			#name : #ConstituteOfOr,			#protocol : #clausification,			#sourceCode : 'ConstituteOfOr\r\t"Used to check if there\'s only Or\'s in this prop tree, during the clausification process"\r\r\t"In an atome, it\'s always true. They aren\'t considered during the clausification process"\r\t^true',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T10:52:55.378515+01:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Operator,				#isMetaSide : false			},			#name : #constituteOfOr,			#protocol : #clausification,			#sourceCode : 'constituteOfOr\r\t"Used to check if there\'s only Or\'s in this prop tree, during the clausification process"\r\r\t"This is basically the same as isClause, except for the And class."\r\t^self isClause',			#stamp : 'pm 12/12/2018 10:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T10:53:00.495646+01:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Operator,				#isMetaSide : false			},			#name : #ConstituteOfOr,			#protocol : #clausification,			#sourceCode : 'ConstituteOfOr\r\t"Used to check if there\'s only Or\'s in this prop tree, during the clausification process"\r\r\t"This is basically the same as isClause, except for the And class."\r\t^self isClause',			#stamp : 'pm 12/11/2018 21:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T10:53:39.167608+01:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Or,				#isMetaSide : false			},			#name : #isClause,			#protocol : #clausification,			#sourceCode : 'isClause\r\t"tester"\r\t^(left constitureOfOr & right constituteOfOr)',			#stamp : 'pm 12/12/2018 10:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Or,				#isMetaSide : false			},			#name : #isClause,			#protocol : #clausification,			#sourceCode : 'isClause\r\t"tester"\r\t^(left constituteOfOr & right constituteOfOr)',			#stamp : 'pm 12/12/2018 10:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T10:53:59.473902+01:00' ],		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #And,				#isMetaSide : false			},			#name : #isClause,			#protocol : #clausification,			#sourceCode : 'isClause\r\t"a And is a clause only if the rest is constitute of Ors !"\r\t^((left isAnd ifTrue:[left isClause]ifFalse:[left ConstituteOfOr])\r\t\tand:[(right isAnd ifTrue:[right isClause]ifFalse:[right ConstituteOfOr])])',			#stamp : 'pm 12/11/2018 21:58',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #And,				#isMetaSide : false			},			#name : #isClause,			#protocol : #clausification,			#sourceCode : 'isClause\r\t"a And is a clause only if the rest is constitute of Ors !"\r\t^((left isAnd ifTrue:[left isClause]ifFalse:[left constituteOfOr])\r\t\tand:[(right isAnd ifTrue:[right isClause]ifFalse:[right constituteOfOr])])',			#stamp : 'pm 12/12/2018 10:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T10:59:49.41364+01:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testIsClauseOrOnAnd,			#protocol : #isClause,			#sourceCode : 'testIsClauseOrOnAnd\r\t| input |\r\tinput :=Or new:\r     (And new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     ).\r\r\tself deny: input isClause.\r\r\tinput:=Or new:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     )\r\trightProp:\r     (And new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself deny: input isClause.\r\r',			#stamp : 'pm 12/12/2018 10:21',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testIsClauseOrOnAnd,			#protocol : #isClause,			#sourceCode : 'testIsClauseOrOnAnd\r\t| input |\r\t"test that (or (and (stuff) stuff)) isn\'t a clause"\r\tinput :=Or new:\r     (And new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     )\r\trightProp:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     ).\r\r\tself deny: input isClause.\r\r\tinput:=Or new:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    yourself)\r     )\r\trightProp:\r     (And new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'Q\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     ).\r\r\tself deny: input isClause.\r\r',			#stamp : 'pm 12/12/2018 10:59',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T11:36:35.488078+01:00' ],		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t| t |\r\tt:=Or new: (And new: (self left) rightProp: (self right))\r\t\t rightProp: (And new:(Not new: (self left)) rightProp:(Not new: (self right))).\r\t(Prop debug) ifTrue:[Transcript show:\'in equal\';show: t prettyPrint;cr.].\r\t^t "clausification".',			#stamp : 'pm 10/1/2018 11:09',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t| t |\r\tt:=Or new: (And new: (self left) rightProp: (self right))\r\t\t rightProp: (And new:(Not new: (self left)) rightProp:(Not new: (self right))).\r\t(Prop debug) ifTrue:[Transcript show:\'in equal\';show: t prettyPrint;cr.].\r\tt isClause.\r\tself halt.\r\t^t "clausification".',			#stamp : 'pm 12/12/2018 11:36',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T11:38:23.35172+01:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t| t |\r\tt:=Or new: (And new: (self left) rightProp: (self right))\r\t\t rightProp: (And new:(Not new: (self left)) rightProp:(Not new: (self right))).\r\t(Prop debug) ifTrue:[Transcript show:\'in equal\';show: t prettyPrint;cr.].\r\tt isClause.\r\tself halt.\r\t^t "clausification".',			#stamp : 'pm 12/12/2018 11:36',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t| t |\r\tt:=And new: (Or new: (self left) rightProp: (self right))\r\t\t rightProp: (Or new:(Not new: (self left)) rightProp:(Not new: (self right))).\r\t(Prop debug) ifTrue:[Transcript show:\'in equal\';show: t prettyPrint;cr.].\r\t^t "clausification".',			#stamp : 'pm 12/12/2018 11:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T11:38:47.066461+01:00' ],		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #clausification-general,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t"basic test for equal\'s clausification"\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := Or new:(And new:\r\t    \t\t      \t\t\t(Predicate new:\'P\')\r\t\t\t\t\t\t    rightProp:\r\t\t\t\t\t         (Predicate new:\'Q\'))\r\t\t\t\trightProp:(And new:\r          \t\t\t(Not new: (Predicate new:\'P\'))\r\t\t\t\t     rightProp:\r\t\t\t          (Not new:(Predicate new:\'Q\'))).\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/12/2018 09:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #clausification-general,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t"basic test for equal\'s clausification"\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new:(Or new:\r\t    \t\t      \t\t\t(Predicate new:\'P\')\r\t\t\t\t\t\t    rightProp:\r\t\t\t\t\t         (Predicate new:\'Q\'))\r\t\t\t\trightProp:(Or new:\r          \t\t\t(Not new: (Predicate new:\'P\'))\r\t\t\t\t     rightProp:\r\t\t\t          (Not new:(Predicate new:\'Q\'))).\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/12/2018 11:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T11:38:47.079171+01:00' ],		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #clausification-general,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t"basic test for equal\'s clausification"\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new:(Or new:\r\t    \t\t      \t\t\t(Predicate new:\'P\')\r\t\t\t\t\t\t    rightProp:\r\t\t\t\t\t         (Predicate new:\'Q\'))\r\t\t\t\trightProp:(Or new:\r          \t\t\t(Not new: (Predicate new:\'P\'))\r\t\t\t\t     rightProp:\r\t\t\t          (Not new:(Predicate new:\'Q\'))).\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/12/2018 11:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #tests,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t"basic test for equal\'s clausification"\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new:(Or new:\r\t    \t\t      \t\t\t(Predicate new:\'P\')\r\t\t\t\t\t\t    rightProp:\r\t\t\t\t\t         (Predicate new:\'Q\'))\r\t\t\t\trightProp:(Or new:\r          \t\t\t(Not new: (Predicate new:\'P\'))\r\t\t\t\t     rightProp:\r\t\t\t          (Not new:(Predicate new:\'Q\'))).\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/12/2018 11:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T12:00:49.459621+01:00' ],		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t| t |\r\tt:=And new: (Or new: (self left) rightProp: (self right))\r\t\t rightProp: (Or new:(Not new: (self left)) rightProp:(Not new: (self right))).\r\t(Prop debug) ifTrue:[Transcript show:\'in equal\';show: t prettyPrint;cr.].\r\t^t "clausification".',			#stamp : 'pm 12/12/2018 11:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t"does an iteration of clausification the current proposition"\r\t| t |\r\tt:=And new: (Or new: (self left) rightProp: (self right))\r\t\t rightProp: (Or new:(Not new: (self left)) rightProp:(Not new: (self right))).\r\t(Prop debug) ifTrue:[Transcript show:\'in equal\';show: t prettyPrint;cr.].\r\t^t.',			#stamp : 'pm 12/12/2018 12:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T12:00:57.89079+01:00' ],		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t|t|\r\tt:=Or new: (Not new:left)  rightProp: right.\r\t(Prop debug) ifTrue:[Transcript show:\'in Imply\';show: t prettyPrint;cr.].\r\t^t "clausification".',			#stamp : 'pm 10/1/2018 11:09',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t"does an iteration of clausification the current proposition"\r\t|t|\r\tt:=Or new: (Not new:left)  rightProp: right.\r\t(Prop debug) ifTrue:[Transcript show:\'in Imply\';show: t prettyPrint;cr.].\r\t^t.',			#stamp : 'pm 12/12/2018 12:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T12:02:54.413079+01:00' ],		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Or,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t| t |\r\tt:=nil.\r \t((Or patternFalse) matchPatternWith: self)\r\tifTrue:[t:=left]\r\tifFalse:[\r\t\t((Or patternFalseSym) matchPatternWith: self)\r\t\tifTrue:[t:=right]\r\t\tifFalse:[\r\t\t\t((Or patternTrue) matchPatternWith: self)\r\t\t\tifTrue:[t:=right]\r\t\t\tifFalse:[\r\t\t\t\t((Or patternTrueSym) matchPatternWith: self)\r\t\t\t\tifTrue:[t:=left]\r\t\t\t\tifFalse:[\r\t\t\t\t\t((Or patternAnd) matchPatternWith: self)\r\t\t\t\t\tifTrue:[t:=And new: (Or new: ((self left) left) rightProp: (self right)) \r\t\t\t\t\t\t\t\t  rightProp: (Or new:((self left) right) rightProp: (self right))]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t((Or patternAndSym) matchPatternWith: self)\r\t\t\t\t\t\tifTrue:[t:=And new:(Or new: (self left) rightProp: ((self right) left)) \r\t\t\t\t\t\t\t\t\t  rightProp: (Or new: (self left) rightProp: ((self right) right))].\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\t\t(t isNil) ifTrue:[(Prop debug) ifTrue:[Transcript show:\'in Or\';show: self prettyPrint;cr.].\r\t\t\t\t\t\t\t\tself left:(left clausification).\r\t\t\t\t\t\t\t\tself right:(right clausification).\r\t\t\t\t\t\t\t\t^self]\r\t\t\t\t\t ifFalse:[(Prop debug) ifTrue:[Transcript show:\'in Or2\';show: t prettyPrint;cr.].\r\t\t\t\t\t\t^t "clausification" ]',			#stamp : 'pm 11/27/2018 07:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Or,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t"does an iteration of clausification the current proposition"\r\t\r\t"For this one, we have some different possible pattern."\r\t| t |\r\tt:=nil.\r \t((Or patternFalse) matchPatternWith: self)\r\tifTrue:[t:=left]\r\tifFalse:[\r\t\t((Or patternFalseSym) matchPatternWith: self)\r\t\tifTrue:[t:=right]\r\t\tifFalse:[\r\t\t\t((Or patternTrue) matchPatternWith: self)\r\t\t\tifTrue:[t:=right]\r\t\t\tifFalse:[\r\t\t\t\t((Or patternTrueSym) matchPatternWith: self)\r\t\t\t\tifTrue:[t:=left]\r\t\t\t\tifFalse:[\r\t\t\t\t\t((Or patternAnd) matchPatternWith: self)\r\t\t\t\t\tifTrue:[t:=And new: (Or new: ((self left) left) rightProp: (self right)) \r\t\t\t\t\t\t\t\t  rightProp: (Or new:((self left) right) rightProp: (self right))]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t((Or patternAndSym) matchPatternWith: self)\r\t\t\t\t\t\tifTrue:[t:=And new:(Or new: (self left) rightProp: ((self right) left)) \r\t\t\t\t\t\t\t\t\t  rightProp: (Or new: (self left) rightProp: ((self right) right))].\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\t\t(t isNil) ifTrue:[(Prop debug) ifTrue:[Transcript show:\'in Or\';show: self prettyPrint;cr.].\r\t\t\t\t\t\t\t\tself left:(left clausification).\r\t\t\t\t\t\t\t\tself right:(right clausification).\r\t\t\t\t\t\t\t\t^self]\r\t\t\t\t\t ifFalse:[(Prop debug) ifTrue:[Transcript show:\'in Or2\';show: t prettyPrint;cr.].\r\t\t\t\t\t\t^t "clausification" ]',			#stamp : 'pm 12/12/2018 12:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T12:03:06.390427+01:00' ],		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #And,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t| t |\r\tt:=nil.\r \t((And patternFalse) matchPatternWith: self)\r\tifTrue:[t:=right]\r\tifFalse:[\r\t\t((And patternFalseSym) matchPatternWith: self)\r\t\tifTrue:[t:=left]\r\t\tifFalse:[\r\t\t\t((And patternTrue) matchPatternWith: self)\r\t\t\tifTrue:[t:=left]\r\t\t\tifFalse:[\r\t\t\t\t((And patternTrueSym) matchPatternWith: self)\r\t\t\t\tifTrue:[t:=right]\r\t\t\t\tifFalse:[]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\t\t(t isNil) ifTrue:[ (Prop debug) ifTrue:[Transcript show:\'in And\';show: self prettyPrint;cr.].\r\t\t\tself left:(left clausification).\r\t\t\t\t\t\t\t\tself right:(right clausification).\r\t\t\t\t\t\t\t\t^self]\r\t\t\t\t\t ifFalse:[(Prop debug) ifTrue:[Transcript show:\'in And2\';show: t prettyPrint;cr.].\r\t\t\t\t\t\t^t "clausification"]. ',			#stamp : 'pm 12/7/2018 21:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #And,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t"does an iteration of clausification the current proposition"\r\t\r\t"For this one, we have some different possible pattern."\r\t\r\t| t |\r\tt:=nil.\r \t((And patternFalse) matchPatternWith: self)\r\tifTrue:[t:=right]\r\tifFalse:[\r\t\t((And patternFalseSym) matchPatternWith: self)\r\t\tifTrue:[t:=left]\r\t\tifFalse:[\r\t\t\t((And patternTrue) matchPatternWith: self)\r\t\t\tifTrue:[t:=left]\r\t\t\tifFalse:[\r\t\t\t\t((And patternTrueSym) matchPatternWith: self)\r\t\t\t\tifTrue:[t:=right]\r\t\t\t\tifFalse:[]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\t\t(t isNil) ifTrue:[ (Prop debug) ifTrue:[Transcript show:\'in And\';show: self prettyPrint;cr.].\r\t\t\tself left:(left clausification).\r\t\t\t\t\t\t\t\tself right:(right clausification).\r\t\t\t\t\t\t\t\t^self]\r\t\t\t\t\t ifFalse:[(Prop debug) ifTrue:[Transcript show:\'in And2\';show: t prettyPrint;cr.].\r\t\t\t\t\t\t^t "clausification"]. ',			#stamp : 'pm 12/12/2018 12:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T12:03:21.674621+01:00' ],		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t"documentation in Prop::clausification"\r\t"Only one clausification operation at time"\r\t"/!\\ since we\'re in an unary operator, the pattern doesn\'t start at self, but at operand"\r\t| t |\r\tt:=nil.\r\t((Not patternNot) matchPatternWith: operand)\r\tifTrue:[t:=operand operand.]\r\tifFalse:[\r\t\t\t((Not patternTrue) matchPatternWith: operand)\r\t\t\tifTrue:[t:=False_Const new]\r\t\t\tifFalse:[\r\t\t\t\t((Not patternFalse) matchPatternWith: operand)\r\t\t\t\tifTrue:[t:=True_Const new]\r\t\t\t\tifFalse:[\r\t\t\t\t\t((Not patternOr) matchPatternWith: operand)\r\t\t\t\t\tifTrue:[t:=And new: (Not new:(operand left)) rightProp:(Not new:(operand right))]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t((Not patternAnd) matchPatternWith: operand)\r\t\t\t\t\t\tifTrue:[t:=Or new: (Not new:(operand left)) rightProp:(Not new:(operand right))].\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t ]\r\t\t\t].\r\t\t(t isNil) ifTrue:[(Prop debug) ifTrue:[Transcript show:\'in Not\';show: self prettyPrint;cr.].\r\t\t\t self operand:(operand clausification).\r\t\t\t\t\t\t\t\t^self]\r\t\t\t\t\t ifFalse:[(Prop debug) ifTrue:[Transcript show:\'in Not2\';show: t prettyPrint;cr.].\r\t\t\t\t\t\t^t "clausification" ].',			#stamp : 'pm 11/27/2018 07:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t"does an iteration of clausification the current proposition"\r\t\r\t"For this one, we have some different possible pattern."\r\t"/!\\ since we\'re in an unary operator, the pattern doesn\'t start at self, but at operand"\r\t| t |\r\tt:=nil.\r\t((Not patternNot) matchPatternWith: operand)\r\tifTrue:[t:=operand operand.]\r\tifFalse:[\r\t\t\t((Not patternTrue) matchPatternWith: operand)\r\t\t\tifTrue:[t:=False_Const new]\r\t\t\tifFalse:[\r\t\t\t\t((Not patternFalse) matchPatternWith: operand)\r\t\t\t\tifTrue:[t:=True_Const new]\r\t\t\t\tifFalse:[\r\t\t\t\t\t((Not patternOr) matchPatternWith: operand)\r\t\t\t\t\tifTrue:[t:=And new: (Not new:(operand left)) rightProp:(Not new:(operand right))]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t((Not patternAnd) matchPatternWith: operand)\r\t\t\t\t\t\tifTrue:[t:=Or new: (Not new:(operand left)) rightProp:(Not new:(operand right))].\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t ]\r\t\t\t].\r\t\t(t isNil) ifTrue:[(Prop debug) ifTrue:[Transcript show:\'in Not\';show: self prettyPrint;cr.].\r\t\t\t self operand:(operand clausification).\r\t\t\t\t\t\t\t\t^self]\r\t\t\t\t\t ifFalse:[(Prop debug) ifTrue:[Transcript show:\'in Not2\';show: t prettyPrint;cr.].\r\t\t\t\t\t\t^t "clausification" ].',			#stamp : 'pm 12/12/2018 12:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T12:04:49.067097+01:00' ],		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #Clausification,			#protocol : #testing,			#sourceCode : 'Clausification\r\t"does an iteration of clausification the current proposition"\r\t\r\t"shouldn\'t exist anymore"\r\t^self error:\'Quantifiers shouldn\'\'t be there anymore, they can\'\'t be clausified. Did you skolemnise first?\'.',			#stamp : 'pm 12/12/2018 12:04',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T12:05:35.067507+01:00' ],		#prior : OmReference [ '72' ],		#self : OmReference [ '73' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #Skolemn_test\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #Skolemn_test,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Skolemn_test class\r\tinstanceVariableNames: \'\''				},				#name : #'Skolemn_test class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Skolemn_test,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #tests	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T12:05:35.234226+01:00' ],		#prior : OmReference [ '73' ],		#self : OmReference [ '74' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #tests,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t"basic test for equal\'s clausification"\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new:(Or new:\r\t    \t\t      \t\t\t(Predicate new:\'P\')\r\t\t\t\t\t\t    rightProp:\r\t\t\t\t\t         (Predicate new:\'Q\'))\r\t\t\t\trightProp:(Or new:\r          \t\t\t(Not new: (Predicate new:\'P\'))\r\t\t\t\t     rightProp:\r\t\t\t          (Not new:(Predicate new:\'Q\'))).\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/12/2018 11:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationEquals,			#protocol : #clausification-general,			#sourceCode : 'testClausificationEquals\r\t| prop res |\r\t"basic test for equal\'s clausification"\r\tprop := Equal new: (Predicate new:\'P\')\r\t\t\t\t\trightProp: (Predicate new:\'Q\').\r\t\r\tres := And new:(Or new:\r\t    \t\t      \t\t\t(Predicate new:\'P\')\r\t\t\t\t\t\t    rightProp:\r\t\t\t\t\t         (Predicate new:\'Q\'))\r\t\t\t\trightProp:(Or new:\r          \t\t\t(Not new: (Predicate new:\'P\'))\r\t\t\t\t     rightProp:\r\t\t\t          (Not new:(Predicate new:\'Q\'))).\r\t\t\t\t\t\t\r\tself assert: prop fullClausification equals: res.',			#stamp : 'pm 12/12/2018 11:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T12:07:58.360386+01:00' ],		#prior : OmReference [ '74' ],		#self : OmReference [ '75' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationQuantifier,			#protocol : #clausification-general,			#sourceCode : 'testClausificationQuantifier\r\t| input |\r\t\r\t"should fail, because the Not can and should be removed through clausification\r\tTest on every binary operator for the principle of it, but the result should be the same every time"\r\r\t"Equal"\r\tinput:=Exists new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    add:(Term new:\'x\');\r                    yourself)\r     ).\r\r\tself should:[input isClause] raise:Error.\r\r\tinput:=ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    add:(Term new:\'x\');\r                    yourself)\r     ).\r\r\r\tself should:[input isClause] raise:Error.\r',			#stamp : 'pm 12/12/2018 12:07',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T12:09:13.704559+01:00' ],		#prior : OmReference [ '75' ],		#self : OmReference [ '76' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationQuantifier,			#protocol : #clausification-general,			#sourceCode : 'testClausificationQuantifier\r\t| input |\r\t\r\t"should fail, because the Not can and should be removed through clausification\r\tTest on every binary operator for the principle of it, but the result should be the same every time"\r\r\t"Equal"\r\tinput:=Exists new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    add:(Term new:\'x\');\r                    yourself)\r     ).\r\r\tself should:[input isClause] raise:Error.\r\r\tinput:=ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    add:(Term new:\'x\');\r                    yourself)\r     ).\r\r\r\tself should:[input isClause] raise:Error.\r',			#stamp : 'pm 12/12/2018 12:07',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testClausificationQuantifier,			#protocol : #clausification-general,			#sourceCode : 'testClausificationQuantifier\r\t| input |\r\t\r\t"should fail, because the quantifier should be flushed before clausification, through skolemnisation."\r\t"exists"\r\tinput:=Exists new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    add:(Term new:\'x\');\r                    yourself)\r     ).\r\r\tself should:[input isClause] raise:Error.\r\r\t"forall"\r\tinput:=ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r               (LinkedList new \r                    add:(Term new:\'x\');\r                    yourself)\r     ).\r\r\tself should:[input isClause] raise:Error.\r',			#stamp : 'pm 12/12/2018 12:09',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T12:11:51.392884+01:00' ],		#prior : OmReference [ '76' ],		#self : OmReference [ '77' ]	},	#content : EpRenameClassRefactoring {		#newName : #TestClausification,		#oldName : #Skolemn_test	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '77' ],		#self : OmReference [ '78' ],		#time : DateAndTime [ '2018-12-12T12:11:51.412677+01:00' ],		#trigger : @3	},	#content : EpBehaviorNameChange {		#oldName : #Skolemn_test,		#newName : #TestClausification,		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestClausification\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestClausification,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestClausification class\r\tinstanceVariableNames: \'\''				},				#name : #'TestClausification class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestClausification,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T13:23:03.600133+01:00' ],		#prior : OmReference [ '78' ],		#self : OmReference [ '79' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestClausification,				#isMetaSide : false			},			#name : #testIsClauseImply,			#protocol : #isClause,			#sourceCode : 'testIsClauseImply\r\t| input |\r\t"Imply isn\'t a clause!"\r\tinput:=Imply new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          ).\r\r\tself deny: input isClause.\r\r',			#stamp : 'pm 12/12/2018 13:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T13:23:21.580678+01:00' ],		#prior : OmReference [ '79' ],		#self : OmReference [ '80' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestClausification,				#isMetaSide : false			},			#name : #testIsClauseEqual,			#protocol : #isClause,			#sourceCode : 'testIsClauseEqual\r\t| input |\r\t"Equal isn\'t a clause!"\r\tinput:=Equal new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          ).\r\r\tself deny: input isClause.\r\r',			#stamp : 'pm 12/12/2018 13:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T13:33:17.157607+01:00' ],		#prior : OmReference [ '80' ],		#self : OmReference [ '81' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestClausification,				#isMetaSide : false			},			#name : #testIsClauseLongOr,			#protocol : #isClause,			#sourceCode : 'testIsClauseLongOr\r\t| input |\r\t"an Equal isn\'t a clause!"\r\tinput:=Equal new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          ).\r\r\tself deny: input isClause.\r\r',			#stamp : 'pm 12/12/2018 13:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T13:33:50.048823+01:00' ],		#prior : OmReference [ '81' ],		#self : OmReference [ '82' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestClausification,				#isMetaSide : false			},			#name : #testIsClauseLongOr,			#protocol : #isClause,			#sourceCode : 'testIsClauseLongOr\r\t| input |\r\t"an Equal isn\'t a clause!"\r\tinput:=Equal new:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          ).\r\r\tself deny: input isClause.\r\r',			#stamp : 'pm 12/12/2018 13:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestClausification,				#isMetaSide : false			},			#name : #testIsClauseLongOr,			#protocol : #isClause,			#sourceCode : 'testIsClauseLongOr\r\t| input |\r\t"an Equal isn\'t a clause!"\r\tinput:=Or new:\r          (Or new:\r               (Or new:\r                    (Or new:\r                         (Or new:\r                              (Predicate new:\'P\' fromList:\r                                        (LinkedList new \r                                             yourself)\r                              )\r                         rightProp:\r                              (Predicate new:\'P\' fromList:\r                                        (LinkedList new \r                                             yourself)\r                              )\r                         )\r                    rightProp:\r                         (Predicate new:\'P\' fromList:\r                                   (LinkedList new \r                                        yourself)\r                         )\r                    )\r               rightProp:\r                    (Predicate new:\'P\' fromList:\r                              (LinkedList new \r                                   yourself)\r                    )\r               )\r          rightProp:\r               (Predicate new:\'P\' fromList:\r                         (LinkedList new \r                              yourself)\r               )\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          ).\r\r\r\r\r\tself assert: input isClause.\r\r',			#stamp : 'pm 12/12/2018 13:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T13:33:53.300101+01:00' ],		#prior : OmReference [ '82' ],		#self : OmReference [ '83' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestClausification,				#isMetaSide : false			},			#name : #testIsClauseLongOr,			#protocol : #isClause,			#sourceCode : 'testIsClauseLongOr\r\t| input |\r\t"an Equal isn\'t a clause!"\r\tinput:=Or new:\r          (Or new:\r               (Or new:\r                    (Or new:\r                         (Or new:\r                              (Predicate new:\'P\' fromList:\r                                        (LinkedList new \r                                             yourself)\r                              )\r                         rightProp:\r                              (Predicate new:\'P\' fromList:\r                                        (LinkedList new \r                                             yourself)\r                              )\r                         )\r                    rightProp:\r                         (Predicate new:\'P\' fromList:\r                                   (LinkedList new \r                                        yourself)\r                         )\r                    )\r               rightProp:\r                    (Predicate new:\'P\' fromList:\r                              (LinkedList new \r                                   yourself)\r                    )\r               )\r          rightProp:\r               (Predicate new:\'P\' fromList:\r                         (LinkedList new \r                              yourself)\r               )\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          ).\r\r\r\r\r\tself assert: input isClause.\r\r',			#stamp : 'pm 12/12/2018 13:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestClausification,				#isMetaSide : false			},			#name : #testIsClauseLongOr,			#protocol : #isClause,			#sourceCode : 'testIsClauseLongOr\r\t| input |\r\t"an Equal isn\'t a clause!"\r\tinput:=Or new:\r          (Or new:\r               (Or new:\r                    (Or new:\r                         (Or new:\r                              (Predicate new:\'P\' fromList:\r                                        (LinkedList new \r                                             yourself)\r                              )\r                         rightProp:\r                              (Predicate new:\'P\' fromList:\r                                        (LinkedList new \r                                             yourself)\r                              )\r                         )\r                    rightProp:\r                         (Predicate new:\'P\' fromList:\r                                   (LinkedList new \r                                        yourself)\r                         )\r                    )\r               rightProp:\r                    (Predicate new:\'P\' fromList:\r                              (LinkedList new \r                                   yourself)\r                    )\r               )\r          rightProp:\r               (Predicate new:\'P\' fromList:\r                         (LinkedList new \r                              yourself)\r               )\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          ).\r\r\r\tself assert: input isClause.\r\r',			#stamp : 'pm 12/12/2018 13:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T13:34:15.669115+01:00' ],		#prior : OmReference [ '83' ],		#self : OmReference [ '84' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestClausification,				#isMetaSide : false			},			#name : #testIsClauseLongAnd,			#protocol : #isClause,			#sourceCode : 'testIsClauseLongAnd\r\t| input |\r\t"an Equal isn\'t a clause!"\r\tinput:=And new:\r          (And new:\r               (And new:\r                    (And new:\r                         (And new:\r                              (Predicate new:\'P\' fromList:\r                                        (LinkedList new \r                                             yourself)\r                              )\r                         rightProp:\r                              (Predicate new:\'P\' fromList:\r                                        (LinkedList new \r                                             yourself)\r                              )\r                         )\r                    rightProp:\r                         (Predicate new:\'P\' fromList:\r                                   (LinkedList new \r                                        yourself)\r                         )\r                    )\r               rightProp:\r                    (Predicate new:\'P\' fromList:\r                              (LinkedList new \r                                   yourself)\r                    )\r               )\r          rightProp:\r               (Predicate new:\'P\' fromList:\r                         (LinkedList new \r                              yourself)\r               )\r          )\r     rightProp:\r          (Predicate new:\'P\' fromList:\r                    (LinkedList new \r                         yourself)\r          ).\r\r\r\tself assert: input isClause.\r\r',			#stamp : 'pm 12/12/2018 13:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T13:47:31.731025+01:00' ],		#prior : OmReference [ '84' ],		#self : OmReference [ '85' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestClausification,				#isMetaSide : false			},			#name : #testIsClauseAndOnOr,			#protocol : #isClause,			#sourceCode : 'testIsClauseAndOnOr\r\t| input |\r\t"test that (or (and (stuff) stuff)) isn\'t a clause"\r\tinput :=And new:\r          (Or new:\r               (Predicate new:\'P\' fromList:\r                         (LinkedList new \r                              yourself)\r               )\r          rightProp:\r               (Predicate new:\'Q\' fromList:\r                         (LinkedList new \r                              yourself)\r               )\r          )\r     rightProp:\r          (Or new:\r               (Predicate new:\'Q\' fromList:\r                         (LinkedList new \r                              yourself)\r               )\r          rightProp:\r               (Predicate new:\'P\' fromList:\r                         (LinkedList new \r                              yourself)\r               )\r          ).\r\r\r\r\tself deny: input isClause.\r\r\r\r',			#stamp : 'pm 12/12/2018 13:47',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T13:47:42.232856+01:00' ],		#prior : OmReference [ '85' ],		#self : OmReference [ '86' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestClausification,				#isMetaSide : false			},			#name : #testIsClauseAndOnOr,			#protocol : #isClause,			#sourceCode : 'testIsClauseAndOnOr\r\t| input |\r\t"test that (or (and (stuff) stuff)) isn\'t a clause"\r\tinput :=And new:\r          (Or new:\r               (Predicate new:\'P\' fromList:\r                         (LinkedList new \r                              yourself)\r               )\r          rightProp:\r               (Predicate new:\'Q\' fromList:\r                         (LinkedList new \r                              yourself)\r               )\r          )\r     rightProp:\r          (Or new:\r               (Predicate new:\'Q\' fromList:\r                         (LinkedList new \r                              yourself)\r               )\r          rightProp:\r               (Predicate new:\'P\' fromList:\r                         (LinkedList new \r                              yourself)\r               )\r          ).\r\r\r\r\tself deny: input isClause.\r\r\r\r',			#stamp : 'pm 12/12/2018 13:47',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestClausification,				#isMetaSide : false			},			#name : #testIsClauseAndOnOr,			#protocol : #isClause,			#sourceCode : 'testIsClauseAndOnOr\r\t| input |\r\t"test that (or (and (stuff) stuff)) isn\'t a clause"\r\tinput :=And new:\r          (Or new:\r               (Predicate new:\'P\' fromList:\r                         (LinkedList new \r                              yourself)\r               )\r          rightProp:\r               (Predicate new:\'Q\' fromList:\r                         (LinkedList new \r                              yourself)\r               )\r          )\r     rightProp:\r          (Or new:\r               (Predicate new:\'Q\' fromList:\r                         (LinkedList new \r                              yourself)\r               )\r          rightProp:\r               (Predicate new:\'P\' fromList:\r                         (LinkedList new \r                              yourself)\r               )\r          ).\r\r\r\r\tself assert: input isClause.\r\r\r\r',			#stamp : 'pm 12/12/2018 13:47',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T13:48:56.688857+01:00' ],		#prior : OmReference [ '86' ],		#self : OmReference [ '87' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestClausification,				#isMetaSide : false			},			#name : #testIsClauseAndOnOr,			#protocol : #isClause,			#sourceCode : 'testIsClauseAndOnOr\r\t| input |\r\t"test that (or (and (stuff) stuff)) isn\'t a clause"\r\tinput :=And new:\r          (Or new:\r               (Predicate new:\'P\' fromList:\r                         (LinkedList new \r                              yourself)\r               )\r          rightProp:\r               (Predicate new:\'Q\' fromList:\r                         (LinkedList new \r                              yourself)\r               )\r          )\r     rightProp:\r          (Or new:\r               (Predicate new:\'Q\' fromList:\r                         (LinkedList new \r                              yourself)\r               )\r          rightProp:\r               (Predicate new:\'P\' fromList:\r                         (LinkedList new \r                              yourself)\r               )\r          ).\r\r\r\r\tself assert: input isClause.\r\r\r\r',			#stamp : 'pm 12/12/2018 13:47',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestClausification,				#isMetaSide : false			},			#name : #testIsClauseAndOnOr,			#protocol : #isClause,			#sourceCode : 'testIsClauseAndOnOr\r\t| input |\r\t"test that (And (Or (stuff) stuff)) is a clause"\r\tinput :=And new:\r          (Or new:\r               (Predicate new:\'P\' fromList:\r                         (LinkedList new \r                              yourself)\r               )\r          rightProp:\r               (Predicate new:\'Q\' fromList:\r                         (LinkedList new \r                              yourself)\r               )\r          )\r     rightProp:\r          (Or new:\r               (Predicate new:\'Q\' fromList:\r                         (LinkedList new \r                              yourself)\r               )\r          rightProp:\r               (Predicate new:\'P\' fromList:\r                         (LinkedList new \r                              yourself)\r               )\r          ).\r\r\tself assert: input isClause.\r\r\r\r',			#stamp : 'pm 12/12/2018 13:48',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T13:51:29.859781+01:00' ],		#prior : OmReference [ '87' ],		#self : OmReference [ '88' ]	},	#content : EpClassAddition {		#class : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestSkolemnisation\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestSkolemnisation,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestSkolemnisation class\r\tinstanceVariableNames: \'\''				},				#name : #'TestSkolemnisation class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestSkolemnisation,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T13:51:52.076048+01:00' ],		#prior : OmReference [ '88' ],		#self : OmReference [ '89' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestClausification\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestClausification,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestClausification class\r\tinstanceVariableNames: \'\''				},				#name : #'TestClausification class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestClausification,					#isMetaSide : false				},				#parent : @7,				#content : 'Clausification tests',				#stamp : 'pm 12/12/2018 13:51'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'Clausification tests',		#newStamp : 'pm 12/12/2018 13:51'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T13:57:18.65719+01:00' ],		#prior : OmReference [ '89' ],		#self : OmReference [ '90' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestSkolemnisation\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestSkolemnisation,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestSkolemnisation class\r\tinstanceVariableNames: \'\''				},				#name : #'TestSkolemnisation class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestSkolemnisation,					#isMetaSide : false				},				#parent : @7,				#content : 'skolemnisation tests',				#stamp : 'pm 12/12/2018 13:57'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'skolemnisation tests',		#newStamp : 'pm 12/12/2018 13:57'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T13:57:26.566929+01:00' ],		#prior : OmReference [ '90' ],		#self : OmReference [ '91' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestSkolemnisation\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestSkolemnisation,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestSkolemnisation class\r\tinstanceVariableNames: \'\''				},				#name : #'TestSkolemnisation class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestSkolemnisation,					#isMetaSide : false				},				#parent : @7,				#content : 'Skolemnisation tests',				#stamp : 'pm 12/12/2018 13:57'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'skolemnisation tests',		#newComment : 'Skolemnisation tests',		#oldStamp : 'pm 12/12/2018 13:57',		#newStamp : 'pm 12/12/2018 13:57'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T13:58:02.816818+01:00' ],		#prior : OmReference [ '91' ],		#self : OmReference [ '92' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestSkolemnisation\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestSkolemnisation,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestSkolemnisation class\r\tinstanceVariableNames: \'\''				},				#name : #'TestSkolemnisation class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestSkolemnisation,					#isMetaSide : false				},				#parent : @7,				#content : 'Automated Skolemnisation tests',				#stamp : 'pm 12/12/2018 13:58'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'Skolemnisation tests',		#newComment : 'Automated Skolemnisation tests',		#oldStamp : 'pm 12/12/2018 13:57',		#newStamp : 'pm 12/12/2018 13:58'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T13:58:12.756516+01:00' ],		#prior : OmReference [ '92' ],		#self : OmReference [ '93' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestClausification\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestClausification,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestClausification class\r\tinstanceVariableNames: \'\''				},				#name : #'TestClausification class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestClausification,					#isMetaSide : false				},				#parent : @7,				#content : 'Automatiic Clausification tests',				#stamp : 'pm 12/12/2018 13:58'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'Clausification tests',		#newComment : 'Automatiic Clausification tests',		#oldStamp : 'pm 12/12/2018 13:51',		#newStamp : 'pm 12/12/2018 13:58'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T13:58:18.226754+01:00' ],		#prior : OmReference [ '93' ],		#self : OmReference [ '94' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestSkolemnisation\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestSkolemnisation,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestSkolemnisation class\r\tinstanceVariableNames: \'\''				},				#name : #'TestSkolemnisation class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestSkolemnisation,					#isMetaSide : false				},				#parent : @7,				#content : 'Automatic Skolemnisation tests',				#stamp : 'pm 12/12/2018 13:58'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'Automated Skolemnisation tests',		#newComment : 'Automatic Skolemnisation tests',		#oldStamp : 'pm 12/12/2018 13:58',		#newStamp : 'pm 12/12/2018 13:58'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T14:04:46.919102+01:00' ],		#prior : OmReference [ '94' ],		#self : OmReference [ '95' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'SkolemnTrace debug debugUnification resolutionTrace testNumber unifDone\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @7,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- FullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- PrettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 10/9/2018 10:52'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #SkolemnTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #debug,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #debugUnification,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unifDone,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'SkolemnTrace debug debugUnification resolutionTrace testNumber unifDone\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @33			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @33,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- FullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- PrettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 10/9/2018 10:52'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #SkolemnTrace,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #debug,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #debugUnification,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unifDone,					#parent : @33				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T14:05:03.326838+01:00' ],		#prior : OmReference [ '95' ],		#self : OmReference [ '96' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tdebug:=false.\r\tSkolemnTrace:=false.\r\tdebugUnification:=false.\r\tresolutionTrace:=true.\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/7/2018 11:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tdebug:=false.\r\tclausificationTrace:=false.\r\tSkolemnTrace:=false.\r\tdebugUnification:=false.\r\tresolutionTrace:=true.\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/12/2018 14:05',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T14:05:11.423609+01:00' ],		#prior : OmReference [ '96' ],		#self : OmReference [ '97' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #And,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t"does an iteration of clausification the current proposition"\r\t\r\t"For this one, we have some different possible pattern."\r\t\r\t| t |\r\tt:=nil.\r \t((And patternFalse) matchPatternWith: self)\r\tifTrue:[t:=right]\r\tifFalse:[\r\t\t((And patternFalseSym) matchPatternWith: self)\r\t\tifTrue:[t:=left]\r\t\tifFalse:[\r\t\t\t((And patternTrue) matchPatternWith: self)\r\t\t\tifTrue:[t:=left]\r\t\t\tifFalse:[\r\t\t\t\t((And patternTrueSym) matchPatternWith: self)\r\t\t\t\tifTrue:[t:=right]\r\t\t\t\tifFalse:[]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\t\t(t isNil) ifTrue:[ (Prop debug) ifTrue:[Transcript show:\'in And\';show: self prettyPrint;cr.].\r\t\t\tself left:(left clausification).\r\t\t\t\t\t\t\t\tself right:(right clausification).\r\t\t\t\t\t\t\t\t^self]\r\t\t\t\t\t ifFalse:[(Prop debug) ifTrue:[Transcript show:\'in And2\';show: t prettyPrint;cr.].\r\t\t\t\t\t\t^t "clausification"]. ',			#stamp : 'pm 12/12/2018 12:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #And,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t"does an iteration of clausification the current proposition"\r\t\r\t"For this one, we have some different possible pattern."\r\t\r\t| t |\r\tt:=nil.\r \t((And patternFalse) matchPatternWith: self)\r\tifTrue:[t:=right]\r\tifFalse:[\r\t\t((And patternFalseSym) matchPatternWith: self)\r\t\tifTrue:[t:=left]\r\t\tifFalse:[\r\t\t\t((And patternTrue) matchPatternWith: self)\r\t\t\tifTrue:[t:=left]\r\t\t\tifFalse:[\r\t\t\t\t((And patternTrueSym) matchPatternWith: self)\r\t\t\t\tifTrue:[t:=right]\r\t\t\t\tifFalse:[]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\t\t(t isNil) ifTrue:[ clausificationTrace ifTrue:[Transcript show:\'in And\';show: self prettyPrint;cr.].\r\t\t\tself left:(left clausification).\r\t\t\t\t\t\t\t\tself right:(right clausification).\r\t\t\t\t\t\t\t\t^self]\r\t\t\t\t\t ifFalse:[clausificationTrace  ifTrue:[Transcript show:\'in And2\';show: t prettyPrint;cr.].\r\t\t\t\t\t\t^t]. ',			#stamp : 'pm 12/12/2018 14:05',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T14:08:30.644733+01:00' ],		#prior : OmReference [ '97' ],		#self : OmReference [ '98' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t"does an iteration of clausification the current proposition"\r\t| t |\r\tt:=And new: (Or new: (self left) rightProp: (self right))\r\t\t rightProp: (Or new:(Not new: (self left)) rightProp:(Not new: (self right))).\r\t(Prop debug) ifTrue:[Transcript show:\'in equal\';show: t prettyPrint;cr.].\r\t^t.',			#stamp : 'pm 12/12/2018 12:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t"does an iteration of clausification the current proposition"\r\t| t |\r\tt:=And new: (Or new: (self left) rightProp: (self right))\r\t\t rightProp: (Or new:(Not new: (self left)) rightProp:(Not new: (self right))).\r\tclausificationTrace ifTrue:[Transcript show:\'in equal\';show: t prettyPrint;cr.].\r\t^t.',			#stamp : 'pm 12/12/2018 14:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T14:08:40.419621+01:00' ],		#prior : OmReference [ '98' ],		#self : OmReference [ '99' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t"does an iteration of clausification the current proposition"\r\t|t|\r\tt:=Or new: (Not new:left)  rightProp: right.\r\t(Prop debug) ifTrue:[Transcript show:\'in Imply\';show: t prettyPrint;cr.].\r\t^t.',			#stamp : 'pm 12/12/2018 12:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t"does an iteration of clausification the current proposition"\r\t|t|\r\tt:=Or new: (Not new:left)  rightProp: right.\r\tclausificationTrace ifTrue:[Transcript show:\'in Imply\';show: t prettyPrint;cr.].\r\t^t.',			#stamp : 'pm 12/12/2018 14:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T14:14:17.374716+01:00' ],		#prior : OmReference [ '99' ],		#self : OmReference [ '100' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Or,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t"does an iteration of clausification the current proposition"\r\t\r\t"For this one, we have some different possible pattern."\r\t| t |\r\tt:=nil.\r \t((Or patternFalse) matchPatternWith: self)\r\tifTrue:[t:=left]\r\tifFalse:[\r\t\t((Or patternFalseSym) matchPatternWith: self)\r\t\tifTrue:[t:=right]\r\t\tifFalse:[\r\t\t\t((Or patternTrue) matchPatternWith: self)\r\t\t\tifTrue:[t:=right]\r\t\t\tifFalse:[\r\t\t\t\t((Or patternTrueSym) matchPatternWith: self)\r\t\t\t\tifTrue:[t:=left]\r\t\t\t\tifFalse:[\r\t\t\t\t\t((Or patternAnd) matchPatternWith: self)\r\t\t\t\t\tifTrue:[t:=And new: (Or new: ((self left) left) rightProp: (self right)) \r\t\t\t\t\t\t\t\t  rightProp: (Or new:((self left) right) rightProp: (self right))]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t((Or patternAndSym) matchPatternWith: self)\r\t\t\t\t\t\tifTrue:[t:=And new:(Or new: (self left) rightProp: ((self right) left)) \r\t\t\t\t\t\t\t\t\t  rightProp: (Or new: (self left) rightProp: ((self right) right))].\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\t\t(t isNil) ifTrue:[(Prop debug) ifTrue:[Transcript show:\'in Or\';show: self prettyPrint;cr.].\r\t\t\t\t\t\t\t\tself left:(left clausification).\r\t\t\t\t\t\t\t\tself right:(right clausification).\r\t\t\t\t\t\t\t\t^self]\r\t\t\t\t\t ifFalse:[(Prop debug) ifTrue:[Transcript show:\'in Or2\';show: t prettyPrint;cr.].\r\t\t\t\t\t\t^t "clausification" ]',			#stamp : 'pm 12/12/2018 12:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Or,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t"does an iteration of clausification the current proposition"\r\t\r\t"For this one, we have some different possible pattern."\r\t| t |\r\tt:=nil.\r \t((Or patternFalse) matchPatternWith: self)\r\tifTrue:[t:=left]\r\tifFalse:[\r\t\t((Or patternFalseSym) matchPatternWith: self)\r\t\tifTrue:[t:=right]\r\t\tifFalse:[\r\t\t\t((Or patternTrue) matchPatternWith: self)\r\t\t\tifTrue:[t:=right]\r\t\t\tifFalse:[\r\t\t\t\t((Or patternTrueSym) matchPatternWith: self)\r\t\t\t\tifTrue:[t:=left]\r\t\t\t\tifFalse:[\r\t\t\t\t\t((Or patternAnd) matchPatternWith: self)\r\t\t\t\t\tifTrue:[t:=And new: (Or new: ((self left) left) rightProp: (self right)) \r\t\t\t\t\t\t\t\t  rightProp: (Or new:((self left) right) rightProp: (self right))]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t((Or patternAndSym) matchPatternWith: self)\r\t\t\t\t\t\tifTrue:[t:=And new:(Or new: (self left) rightProp: ((self right) left)) \r\t\t\t\t\t\t\t\t\t  rightProp: (Or new: (self left) rightProp: ((self right) right))].\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\t\t(t isNil) ifTrue:[clausificationTrace ifTrue:[Transcript show:\'in Or\';show: self prettyPrint;cr.].\r\t\t\t\t\t\t\t\tself left:(left clausification).\r\t\t\t\t\t\t\t\tself right:(right clausification).\r\t\t\t\t\t\t\t\t^self]\r\t\t\t\t\t ifFalse:[clausificationTrace ifTrue:[Transcript show:\'in Or2\';show: t prettyPrint;cr.].\r\t\t\t\t\t\t^t "clausification" ]',			#stamp : 'pm 12/12/2018 14:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T15:49:27.771058+01:00' ],		#prior : OmReference [ '100' ],		#self : OmReference [ '101' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t"does an iteration of clausification the current proposition"\r\t\r\t"For this one, we have some different possible pattern."\r\t"/!\\ since we\'re in an unary operator, the pattern doesn\'t start at self, but at operand"\r\t| t |\r\tt:=nil.\r\t((Not patternNot) matchPatternWith: operand)\r\tifTrue:[t:=operand operand.]\r\tifFalse:[\r\t\t\t((Not patternTrue) matchPatternWith: operand)\r\t\t\tifTrue:[t:=False_Const new]\r\t\t\tifFalse:[\r\t\t\t\t((Not patternFalse) matchPatternWith: operand)\r\t\t\t\tifTrue:[t:=True_Const new]\r\t\t\t\tifFalse:[\r\t\t\t\t\t((Not patternOr) matchPatternWith: operand)\r\t\t\t\t\tifTrue:[t:=And new: (Not new:(operand left)) rightProp:(Not new:(operand right))]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t((Not patternAnd) matchPatternWith: operand)\r\t\t\t\t\t\tifTrue:[t:=Or new: (Not new:(operand left)) rightProp:(Not new:(operand right))].\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t ]\r\t\t\t].\r\t\t(t isNil) ifTrue:[(Prop debug) ifTrue:[Transcript show:\'in Not\';show: self prettyPrint;cr.].\r\t\t\t self operand:(operand clausification).\r\t\t\t\t\t\t\t\t^self]\r\t\t\t\t\t ifFalse:[(Prop debug) ifTrue:[Transcript show:\'in Not2\';show: t prettyPrint;cr.].\r\t\t\t\t\t\t^t "clausification" ].',			#stamp : 'pm 12/12/2018 12:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #clausification,			#protocol : #clausification,			#sourceCode : 'clausification\r\t"does an iteration of clausification the current proposition"\r\t\r\t"For this one, we have some different possible pattern."\r\t"/!\\ since we\'re in an unary operator, the pattern doesn\'t start at self, but at operand"\r\t| t |\r\tt:=nil.\r\t((Not patternNot) matchPatternWith: operand)\r\tifTrue:[t:=operand operand.]\r\tifFalse:[\r\t\t\t((Not patternTrue) matchPatternWith: operand)\r\t\t\tifTrue:[t:=False_Const new]\r\t\t\tifFalse:[\r\t\t\t\t((Not patternFalse) matchPatternWith: operand)\r\t\t\t\tifTrue:[t:=True_Const new]\r\t\t\t\tifFalse:[\r\t\t\t\t\t((Not patternOr) matchPatternWith: operand)\r\t\t\t\t\tifTrue:[t:=And new: (Not new:(operand left)) rightProp:(Not new:(operand right))]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t((Not patternAnd) matchPatternWith: operand)\r\t\t\t\t\t\tifTrue:[t:=Or new: (Not new:(operand left)) rightProp:(Not new:(operand right))].\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t ]\r\t\t\t].\r\t\t(t isNil) ifTrue:[clausificationTrace  ifTrue:[Transcript show:\'in Not\';show: self prettyPrint;cr.].\r\t\t\t self operand:(operand clausification).\r\t\t\t\t\t\t\t\t^self]\r\t\t\t\t\t ifFalse:[clausificationTrace ifTrue:[Transcript show:\'in Not2\';show: t prettyPrint;cr.].\r\t\t\t\t\t\t^t].',			#stamp : 'pm 12/12/2018 15:49',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T15:55:52.019135+01:00' ],		#prior : OmReference [ '101' ],		#self : OmReference [ '102' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'SkolemnTrace clausificationTrace debug debugUnification resolutionTrace testNumber unifDone\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @7,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- FullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- PrettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 10/9/2018 10:52'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #SkolemnTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #debug,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #debugUnification,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unifDone,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'SkolemnTrace clausificationTrace debug debugUnification resolutionTrace testNumber unifDone\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @35			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @35,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- FullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- PrettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 10/9/2018 10:52'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #SkolemnTrace,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #debug,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #debugUnification,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @35				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unifDone,					#parent : @35				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T15:56:02.565443+01:00' ],		#prior : OmReference [ '102' ],		#self : OmReference [ '103' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tdebug:=false.\r\tclausificationTrace:=false.\r\tSkolemnTrace:=false.\r\tdebugUnification:=false.\r\tresolutionTrace:=true.\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/12/2018 14:05',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tclausificationTrace:=false.\r\tSkolemnTrace:=false.\r\tdebugUnification:=false.\r\tresolutionTrace:=true.\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/12/2018 15:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T15:56:24.219862+01:00' ],		#prior : OmReference [ '103' ],		#self : OmReference [ '104' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #fullClausification,			#protocol : #clausification,			#sourceCode : 'fullClausification\r\t| t |\r\tt:=self clausification.\r\t[t isClause] whileFalse:[\t\r\t\t(Prop debug) ifTrue:[Transcript show: t prettyPrint; show: t isClause;cr.].\r\t\tt:=t clausification.].\r\t^t',			#stamp : 'pm 10/1/2018 10:58',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #fullClausification,			#protocol : #clausification,			#sourceCode : 'fullClausification\r\t| t |\r\tt:=self clausification.\r\t[t isClause] whileFalse:[\t\r\t\tclausificationTrace ifTrue:[Transcript show: t prettyPrint; show: t isClause;cr.].\r\t\tt:=t clausification.].\r\t^t',			#stamp : 'pm 12/12/2018 15:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:05:12.193646+01:00' ],		#prior : OmReference [ '104' ],		#self : OmReference [ '105' ]	},	#content : EpMonticelloVersionSave {		#versionName : '_resolution_1erOrdre-pm.2',		#repositoryDescription : '/home/ariale/FORM/pharo6.1-64/shared/pharo-local/package-cache'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:05:12.309227+01:00' ],		#prior : OmReference [ '105' ],		#self : OmReference [ '106' ]	},	#content : EpMonticelloVersionSave {		#versionName : '_resolution_1erOrdre-pm.2',		#repositoryDescription : '/home/ariale/FORM/pharo6.1-64/Sources'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:09:21.383304+01:00' ],		#prior : OmReference [ '106' ],		#self : OmReference [ '107' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tTranscript show:\'Is \';show: self; show:\' valid?\';cr.\r\t\r\ttreatedProp:=Not new:self.\r\t\r\t(Prop resolutionTrace)ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp StartSkolemnisation.\r\t(Prop resolutionTrace)ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\t(Prop resolutionTrace)ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\t(Prop resolutionTrace)ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tTranscript show:\'Resolution method:\' ; show:t ; cr; cr; cr.\r\t^t ',			#stamp : 'pm 11/27/2018 20:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tTranscript show:\'Is \';show: self; show:\' valid?\';cr.\r\t\r\ttreatedProp:=Not new:self.\r\t\r\tresolutionTrace ifTrue:[Transcript show: \'initial: \'; show: treatedProp ; cr.].\r\tt:=treatedProp StartSkolemnisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tTranscript show:\'Resolution method:\' ; show:t ; cr; cr; cr.\r\t^t ',			#stamp : 'pm 12/12/2018 16:09',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:23:19.329345+01:00' ],		#prior : OmReference [ '107' ],		#self : OmReference [ '108' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t"application of the resolution method on self. Course algorithm"\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tTranscript show:self;cr.\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 11/11/2018 09:16',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t"application of the resolution method on self. Course algorithm"\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tTranscript show:self;cr.\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r\t   ((c isTautology) or:[sat contains:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 12/12/2018 16:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:23:38.535059+01:00' ],		#prior : OmReference [ '108' ],		#self : OmReference [ '109' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'SkolemnTrace clausificationTrace debugUnification resolutionTrace testNumber unifDone\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @7,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- FullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- PrettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 10/9/2018 10:52'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #SkolemnTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #debugUnification,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unifDone,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'SkolemnTrace clausificationTrace debugUnification resolutionTrace testNumber unifDone\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @33			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @33,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- FullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- PrettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 10/9/2018 10:52'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #SkolemnTrace,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #debugUnification,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @33				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unifDone,					#parent : @33				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:25:15.508369+01:00' ],		#prior : OmReference [ '109' ],		#self : OmReference [ '110' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\t(SkolemnTrace)ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars: setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.\t"(self class) new: ("\t")"\r\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 11/27/2018 21:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\t(skolemnTrace)ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars: setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.\t"(self class) new: ("\t")"\r\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/12/2018 16:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:25:22.849537+01:00' ],		#prior : OmReference [ '110' ],		#self : OmReference [ '111' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t(SkolemnTrace)ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\r\t^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.\r\t \r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 11/27/2018 21:20',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t(skolemnTrace)ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\r\t^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.\r\t \r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/12/2018 16:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:25:28.736852+01:00' ],		#prior : OmReference [ '111' ],		#self : OmReference [ '112' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t(SkolemnTrace)ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\t^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 11/27/2018 21:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t(skolemnTrace)ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\t^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/12/2018 16:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:25:32.950803+01:00' ],		#prior : OmReference [ '112' ],		#self : OmReference [ '113' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\t(SkolemnTrace)ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars:  setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.\r\t\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 11/27/2018 21:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\t(skolemnTrace)ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars:  setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.\r\t\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/12/2018 16:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:25:49.47041+01:00' ],		#prior : OmReference [ '113' ],		#self : OmReference [ '114' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t(SkolemnTrace)ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self operand Herbrandise: setOfLinkedVar CorrespondingValue: aMap).',			#stamp : 'pm 11/27/2018 21:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t(skolemnTrace)ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self operand Herbrandise: setOfLinkedVar CorrespondingValue: aMap).',			#stamp : 'pm 12/12/2018 16:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:25:52.788197+01:00' ],		#prior : OmReference [ '114' ],		#self : OmReference [ '115' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t(skolemnTrace)ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self operand Herbrandise: setOfLinkedVar CorrespondingValue: aMap).',			#stamp : 'pm 12/12/2018 16:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self operand Herbrandise: setOfLinkedVar CorrespondingValue: aMap).',			#stamp : 'pm 12/12/2018 16:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:25:58.068309+01:00' ],		#prior : OmReference [ '115' ],		#self : OmReference [ '116' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t(SkolemnTrace)ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self operand Skolemnise: setOfLinkedVar CorrespondingValue: aMap).',			#stamp : 'pm 11/27/2018 21:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Not,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self operand Skolemnise: setOfLinkedVar CorrespondingValue: aMap).',			#stamp : 'pm 12/12/2018 16:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:26:05.093294+01:00' ],		#prior : OmReference [ '116' ],		#self : OmReference [ '117' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t(skolemnTrace)ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\t^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/12/2018 16:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\t^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/12/2018 16:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:26:10.85213+01:00' ],		#prior : OmReference [ '117' ],		#self : OmReference [ '118' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\t(skolemnTrace)ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars:  setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.\r\t\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/12/2018 16:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Exists,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars:  setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.\r\t\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/12/2018 16:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:27:07.288141+01:00' ],		#prior : OmReference [ '118' ],		#self : OmReference [ '119' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t(skolemnTrace)ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\r\t^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.\r\t \r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/12/2018 16:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\r\tsetOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).\r\r\t^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.\r\t \r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/12/2018 16:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:27:13.270047+01:00' ],		#prior : OmReference [ '119' ],		#self : OmReference [ '120' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\t(skolemnTrace)ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars: setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.\t"(self class) new: ("\t")"\r\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/12/2018 16:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t| t |\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars: setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.\t"(self class) new: ("\t")"\r\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 12/12/2018 16:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:28:03.282425+01:00' ],		#prior : OmReference [ '120' ],		#self : OmReference [ '121' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t(SkolemnTrace)ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Skolemnise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Herbrandise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 11/27/2018 21:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t(skolemnTrace)ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Skolemnise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Herbrandise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/12/2018 16:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:28:07.599349+01:00' ],		#prior : OmReference [ '121' ],		#self : OmReference [ '122' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t(SkolemnTrace)ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Skolemnise: setOfLinkedVar CorrespondingValue: aMap).\r\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 11/27/2018 21:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t(skolemnTrace)ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Skolemnise: setOfLinkedVar CorrespondingValue: aMap).\r\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/12/2018 16:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:28:11.546419+01:00' ],		#prior : OmReference [ '122' ],		#self : OmReference [ '123' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t(SkolemnTrace)ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) Skolemnise:setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 11/27/2018 21:16',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t(skolemnTrace)ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) Skolemnise:setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/12/2018 16:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:28:22.324581+01:00' ],		#prior : OmReference [ '123' ],		#self : OmReference [ '124' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\t\r\t(SkolemnTrace)ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) Herbrandise: setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 11/27/2018 21:16',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\t\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) Herbrandise: setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/12/2018 16:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:28:46.14387+01:00' ],		#prior : OmReference [ '124' ],		#self : OmReference [ '125' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t(skolemnTrace)ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) Skolemnise:setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/12/2018 16:28',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Equal,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(And new: (Imply new: (self left) rightProp: (self right))\r\t rightProp: (Imply new: (self right) rightProp: (self left))) Skolemnise:setOfLinkedVar CorrespondingValue:aMap.\r',			#stamp : 'pm 12/12/2018 16:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:28:53.198664+01:00' ],		#prior : OmReference [ '125' ],		#self : OmReference [ '126' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t(skolemnTrace)ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Skolemnise: setOfLinkedVar CorrespondingValue: aMap).\r\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/12/2018 16:28',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Skolemnise: setOfLinkedVar CorrespondingValue: aMap).\r\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/12/2018 16:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:29:03.203759+01:00' ],		#prior : OmReference [ '126' ],		#self : OmReference [ '127' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t(skolemnTrace)ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Skolemnise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Herbrandise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/12/2018 16:28',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Imply,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Skolemnise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Herbrandise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/12/2018 16:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:32:48.263304+01:00' ],		#prior : OmReference [ '127' ],		#self : OmReference [ '128' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t(SkolemnTrace)ifTrue:[Transcript show:\'Herbran\'  ;space ; show:self ;cr].\r\t\r\t^self updateTerms: setOfLinkedVar CorrespondingValue: aMap.',			#stamp : 'pm 11/27/2018 21:16',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\'  ;space ; show:self ;cr].\r\t\r\t^self updateTerms: setOfLinkedVar CorrespondingValue: aMap.',			#stamp : 'pm 12/12/2018 16:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:32:54.865467+01:00' ],		#prior : OmReference [ '128' ],		#self : OmReference [ '129' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t(SkolemnTrace)ifTrue:[Transcript show:\'Skolem\' ;space ; show:self ;cr].\r\t\r\t^self updateTerms: setOfLinkedVar CorrespondingValue: aMap.',			#stamp : 'pm 11/27/2018 21:16',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ;space ; show:self ;cr].\r\t\r\t^self updateTerms: setOfLinkedVar CorrespondingValue: aMap.',			#stamp : 'pm 12/12/2018 16:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:33:07.799391+01:00' ],		#prior : OmReference [ '129' ],		#self : OmReference [ '130' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t(SkolemnTrace)ifTrue:[Transcript show:\'Herbran\' ; space ; show:self class name ;space ; show:self ;cr].\r\t^self.',			#stamp : 'pm 11/27/2018 21:08',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self class name ;space ; show:self ;cr].\r\t^self.',			#stamp : 'pm 12/12/2018 16:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T16:33:13.099186+01:00' ],		#prior : OmReference [ '130' ],		#self : OmReference [ '131' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\t(SkolemnTrace)ifTrue:[Transcript show:\'Skolem\' ; space ; show:self class name ;space ; show:self ;cr].\r\t^self.',			#stamp : 'pm 11/27/2018 21:08',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self class name ;space ; show:self ;cr].\r\t^self.',			#stamp : 'pm 12/12/2018 16:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T17:01:53.764565+01:00' ],		#prior : OmReference [ '131' ],		#self : OmReference [ '132' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tclausificationTrace:=false.\r\tSkolemnTrace:=false.\r\tdebugUnification:=false.\r\tresolutionTrace:=true.\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/12/2018 15:56',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tclausificationTrace:=false.\r\tskolemnTrace:=false.\r\tdebugUnification:=false.\r\tresolutionTrace:=true.\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/12/2018 17:01',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T17:03:10.997668+01:00' ],		#prior : OmReference [ '132' ],		#self : OmReference [ '133' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\t(SkolemnTrace)ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Skolemnise: (setOfLinkedVar veryDeepCopy)  CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Skolemnise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t"Works for Or & And."\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 11/28/2018 00:07',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'Skolemnise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Skolemnise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Skolem\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Skolemnise: (setOfLinkedVar veryDeepCopy)  CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Skolemnise: setOfLinkedVar CorrespondingValue: aMap).\r\t\t\t"Works for Or & And."\r\t\t\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/12/2018 17:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T17:03:20.722468+01:00' ],		#prior : OmReference [ '133' ],		#self : OmReference [ '134' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\t(SkolemnTrace)ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Herbrandise: setOfLinkedVar CorrespondingValue: aMap ).\r\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 11/27/2018 21:16',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t"factorisation for Or and And binaryOperator"\r\t"cf Prop::HerbranSkolemDocu"\r\tskolemnTrace ifTrue:[Transcript show:\'Herbran\' ; space ; show:self ;cr].\r\t\r\t^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) \r\t\t\trightProp: (self right Herbrandise: setOfLinkedVar CorrespondingValue: aMap ).\r\t\r\t"We pass veryDeepCopys to the leftProp, so each branch has it\'s own collections"',			#stamp : 'pm 12/12/2018 17:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T17:21:30.577407+01:00' ],		#prior : OmReference [ '134' ],		#self : OmReference [ '135' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestClausification,				#isMetaSide : false			},			#name : #testUnboundExistReplacedByConsts,			#protocol : #basic,			#sourceCode : 'testUnboundExistReplacedByConsts\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTermsForTesting: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 12/7/2018 19:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T17:22:23.354161+01:00' ],		#prior : OmReference [ '135' ],		#self : OmReference [ '136' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testUnboundExistReplacedByConsts,			#protocol : #'as yet unclassified',			#sourceCode : 'testUnboundExistReplacedByConsts\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTermsForTesting: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 12/12/2018 17:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T17:22:23.477092+01:00' ],		#prior : OmReference [ '136' ],		#self : OmReference [ '137' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testUnboundExistReplacedByConsts,			#protocol : #'as yet unclassified',			#sourceCode : 'testUnboundExistReplacedByConsts\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTermsForTesting: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 12/12/2018 17:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testUnboundExistReplacedByConsts,			#protocol : #tests,			#sourceCode : 'testUnboundExistReplacedByConsts\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTermsForTesting: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 12/12/2018 17:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T17:22:48.10278+01:00' ],		#prior : OmReference [ '137' ],		#self : OmReference [ '138' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestClausification,				#isMetaSide : false			},			#name : #testImplyAndNestedForAllWithSameNameForConstAndLinkedVar,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAllWithSameNameForConstAndLinkedVar\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTermsForTesting: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 12/7/2018 19:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T17:22:54.245996+01:00' ],		#prior : OmReference [ '138' ],		#self : OmReference [ '139' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testImplyAndNestedForAllWithSameNameForConstAndLinkedVar,			#protocol : #'as yet unclassified',			#sourceCode : 'testImplyAndNestedForAllWithSameNameForConstAndLinkedVar\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTermsForTesting: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 12/12/2018 17:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T17:22:54.338876+01:00' ],		#prior : OmReference [ '139' ],		#self : OmReference [ '140' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testImplyAndNestedForAllWithSameNameForConstAndLinkedVar,			#protocol : #'as yet unclassified',			#sourceCode : 'testImplyAndNestedForAllWithSameNameForConstAndLinkedVar\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTermsForTesting: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 12/12/2018 17:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testImplyAndNestedForAllWithSameNameForConstAndLinkedVar,			#protocol : #tests,			#sourceCode : 'testImplyAndNestedForAllWithSameNameForConstAndLinkedVar\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTermsForTesting: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 12/12/2018 17:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T17:53:02.406541+01:00' ],		#prior : OmReference [ '140' ],		#self : OmReference [ '141' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestClausification,				#isMetaSide : false			},			#name : #testBasicForAll,			#protocol : #basic,			#sourceCode : 'testBasicForAll\r\t| p res expected terms |\r\r\tterms:=LinkedList new add:(Term new:\'x\');add:(Term new:\'z\');yourself.\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\r\t\r\tterms:=LinkedList new add:(LinkedTerm new:(Term new:\'x\')); add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Or new: (Predicate new: \'P\' fromList: terms)\r\t\t\t\t\trightProp: (Predicate new: \'P\' fromList: terms).\r\t\r\t\r\tself assert:(res isSameForTesting: expected).',			#stamp : 'pm 12/7/2018 19:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T17:53:08.785287+01:00' ],		#prior : OmReference [ '141' ],		#self : OmReference [ '142' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testBasicForAll,			#protocol : #tests,			#sourceCode : 'testBasicForAll\r\t| p res expected terms |\r\r\tterms:=LinkedList new add:(Term new:\'x\');add:(Term new:\'z\');yourself.\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\r\t\r\tterms:=LinkedList new add:(LinkedTerm new:(Term new:\'x\')); add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Or new: (Predicate new: \'P\' fromList: terms)\r\t\t\t\t\trightProp: (Predicate new: \'P\' fromList: terms).\r\t\r\t\r\tself assert:(res isSameForTesting: expected).',			#stamp : 'pm 12/12/2018 17:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T17:53:26.16242+01:00' ],		#prior : OmReference [ '142' ],		#self : OmReference [ '143' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testBasicOnlyPredicate,			#protocol : #tests,			#sourceCode : 'testBasicOnlyPredicate\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\');yourself.\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t\r\tself assert:(res isSameForTesting: expected).',			#stamp : 'pm 12/12/2018 17:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T17:53:45.765295+01:00' ],		#prior : OmReference [ '143' ],		#self : OmReference [ '144' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestClausification,				#isMetaSide : false			},			#name : #testBasicOnlyPredicate,			#protocol : #basic,			#sourceCode : 'testBasicOnlyPredicate\r\t| p res expected terms terms2 |\r\tterms:=LinkedList new add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\');yourself.\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tres:=p StartSkolemnisation.\t\r\t\r\tterms2:=LinkedList new add:(LinkedTerm new:(Term new:\'x\'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:\'x\'))));add:(LinkedTerm new:(Term new:\'z\'));yourself.\r\texpected:=Predicate new: \'P\' fromList: terms2.\r\t\r\tself assert:(res isSameForTesting: expected).',			#stamp : 'pm 12/7/2018 19:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T17:53:58.558625+01:00' ],		#prior : OmReference [ '144' ],		#self : OmReference [ '145' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestClausification,				#isMetaSide : false			},			#name : #testImplyAndNestedForAll,			#protocol : #basic,			#sourceCode : 'testImplyAndNestedForAll\r\t| p res expected |\r\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'a\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).',			#stamp : 'pm 12/7/2018 19:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T17:54:02.465947+01:00' ],		#prior : OmReference [ '145' ],		#self : OmReference [ '146' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testImplyAndNestedForAll,			#protocol : #'as yet unclassified',			#sourceCode : 'testImplyAndNestedForAll\r\t| p res expected |\r\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'a\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).',			#stamp : 'pm 12/12/2018 17:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T17:54:02.562863+01:00' ],		#prior : OmReference [ '146' ],		#self : OmReference [ '147' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testImplyAndNestedForAll,			#protocol : #'as yet unclassified',			#sourceCode : 'testImplyAndNestedForAll\r\t| p res expected |\r\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'a\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).',			#stamp : 'pm 12/12/2018 17:54',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestSkolemnisation,				#isMetaSide : false			},			#name : #testImplyAndNestedForAll,			#protocol : #tests,			#sourceCode : 'testImplyAndNestedForAll\r\t| p res expected |\r\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:(\r\t\t\t\t\tOr new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'a\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'a\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).',			#stamp : 'pm 12/12/2018 17:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T20:39:43.237294+01:00' ],		#prior : OmReference [ '147' ],		#self : OmReference [ '148' ]	},	#content : EpProtocolAddition {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestSkolemnisation\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestSkolemnisation,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestSkolemnisation class\r\tinstanceVariableNames: \'\''				},				#name : #'TestSkolemnisation class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestSkolemnisation,					#isMetaSide : false				},				#parent : @7,				#content : 'Automatic Skolemnisation tests',				#stamp : 'pm 12/12/2018 13:58'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #skolemnisationOperator	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T20:40:12.456704+01:00' ],		#prior : OmReference [ '148' ],		#self : OmReference [ '149' ]	},	#content : EpProtocolAddition {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestSkolemnisation\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestSkolemnisation,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestSkolemnisation class\r\tinstanceVariableNames: \'\''				},				#name : #'TestSkolemnisation class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestSkolemnisation,					#isMetaSide : false				},				#parent : @7,				#content : 'Automatic Skolemnisation tests',				#stamp : 'pm 12/12/2018 13:58'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #atomes	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T20:40:16.076744+01:00' ],		#prior : OmReference [ '149' ],		#self : OmReference [ '150' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestSkolemnisation\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestSkolemnisation,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestSkolemnisation class\r\tinstanceVariableNames: \'\''				},				#name : #'TestSkolemnisation class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestSkolemnisation,					#isMetaSide : false				},				#parent : @7,				#content : 'Automatic Skolemnisation tests',				#stamp : 'pm 12/12/2018 13:58'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #skolemnisationOperator	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T20:40:31.00497+01:00' ],		#prior : OmReference [ '150' ],		#self : OmReference [ '151' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestClausification\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestClausification,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestClausification class\r\tinstanceVariableNames: \'\''				},				#name : #'TestClausification class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestClausification,					#isMetaSide : false				},				#parent : @7,				#content : 'Automatiic Clausification tests',				#stamp : 'pm 12/12/2018 13:58'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #basic	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T20:57:52.540662+01:00' ],		#prior : OmReference [ '151' ],		#self : OmReference [ '152' ]	},	#content : EpMonticelloVersionSave {		#versionName : '_resolution_1erOrdre-pm.3',		#repositoryDescription : '/home/ariale/FORM/pharo6.1-64/shared/pharo-local/package-cache'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T20:57:52.652328+01:00' ],		#prior : OmReference [ '152' ],		#self : OmReference [ '153' ]	},	#content : EpMonticelloVersionSave {		#versionName : '_resolution_1erOrdre-pm.3',		#repositoryDescription : '/home/ariale/FORM/pharo6.1-64/Sources'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-12T20:58:09.751783+01:00' ],		#prior : OmReference [ '153' ],		#self : OmReference [ '154' ]	},	#content : EpMonticelloVersionSave {		#versionName : '_resolution_1erOrdre-pm.3',		#repositoryDescription : '/home/ariale/FORM/pharo6.1-64/shared/pharo-local/package-cache'	}}