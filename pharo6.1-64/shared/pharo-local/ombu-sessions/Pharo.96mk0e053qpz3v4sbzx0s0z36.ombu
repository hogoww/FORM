OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T09:56:59.394418+01:00' ],		#prior : OmReference [ 'Pharo.1rbdhwbl4qqntdr4wu596o6ed', '322' ],		#self : OmReference [ '1' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'clausificationTrace resolutionTrace skolemnTrace testNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @7,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- fullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- prettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 12/15/2018 15:14'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'clausificationTrace resolutionTrace skolemnTrace testNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @31			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @31,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- fullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- prettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 12/15/2018 15:14'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @31				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @31				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T09:58:11.386512+01:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see a program trace"\r\r\t"Variable to activate traces or not."\r\tskolemnTrace:=false.\r\tclausificationTrace:=false.\r\tunificationTrace:=false.\r\tresolutionTrace:=true.\r\t\r\t"Used to provided context during the textual tests available in the Prop class "\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/20/2018 12:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see a program trace"\r\r\t"Variable to activate traces or not."\r\tskolemnTrace:=false.\r\tclausificationTrace:=false.\r\tunificationTrace:=false.\r\tresolutionTrace:=true.\r\t\r\t"Activate the trace of the progress for amIValid."\r\tResolutionSteps:=true.\r\t\r\t"Used to provided context during the textual tests available in the Prop class "\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/21/2018 09:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T09:58:15.995624+01:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see a program trace"\r\r\t"Variable to activate traces or not."\r\tskolemnTrace:=false.\r\tclausificationTrace:=false.\r\tunificationTrace:=false.\r\tresolutionTrace:=true.\r\t\r\t"Activate the trace of the progress for amIValid."\r\tResolutionSteps:=true.\r\t\r\t"Used to provided context during the textual tests available in the Prop class "\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/21/2018 09:58',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"Initialisation of the Prop class"\r\t"It\'s mostly about activating visual variables, to see a program trace"\r\r\t"Variable to activate traces or not."\r\tskolemnTrace:=false.\r\tclausificationTrace:=false.\r\tunificationTrace:=false.\r\tresolutionTrace:=false.\r\t\r\t"Activate the trace of the progress for amIValid."\r\tResolutionSteps:=true.\r\t\r\t"Used to provided context during the textual tests available in the Prop class "\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/21/2018 09:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T09:58:45.596119+01:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tresolutionTrace ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\tresolutionTrace ifTrue:[Transcript show: \'Initial: \'; show: treatedProp ; cr.].\r\ttreatedProp launchRenameVariables.\r\tresolutionTrace ifTrue:[Transcript show: \'Renamed: \'; show: treatedProp ; cr.].\r\tt:=treatedProp startSkolemisation.\r\tresolutionTrace ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tresolutionTrace ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tresolutionTrace ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tresolutionTrace ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/20/2018 13:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tResolutionSteps ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\tResolutionSteps ifTrue:[Transcript show: \'Initial: \'; show: treatedProp ; cr.].\r\ttreatedProp launchRenameVariables.\r\tResolutionSteps ifTrue:[Transcript show: \'Renamed: \'; show: treatedProp ; cr.].\r\tt:=treatedProp startSkolemisation.\r\tResolutionSteps ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tResolutionSteps ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tResolutionSteps ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tResolutionSteps ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/21/2018 09:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:14:27.918764+01:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term newVar |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: 0)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVar:=((assoc key , assoc value asString) asString).\r\tnewVal:=Term new:newVar.\r\tself var:newVar.\r\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/20/2018 12:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term newVar |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: -1)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tassoc value=0\r\tifTrue:[\r\t\tnewVar:=assoc key.\r\t\t]\r\tifFalse:[\r\t\tnewVar:=((assoc key , assoc value asString) asString).\r\t\t].\r\tnewVal:=Term new:newVar.\r\tself var:newVar.\r\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/21/2018 10:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:15:07.279443+01:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term newVar |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: -1)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tassoc value=0\r\tifTrue:[\r\t\tnewVar:=assoc key.\r\t\t]\r\tifFalse:[\r\t\tnewVar:=((assoc key , assoc value asString) asString).\r\t\t].\r\tnewVal:=Term new:newVar.\r\tself var:newVar.\r\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/21/2018 10:14',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Quantifier,				#isMetaSide : false			},			#name : #'renameVars:with:',			#protocol : #skolemisation,			#sourceCode : 'renameVars: aDictionary with:aMap\r\t"pre-skolem phase, to ensure that every name is unique when it\'s necessary."\r\t"One exemple is forall x (forall x P(x)) or P(x) should give back (forall x (forall x1 P(x1)) or P(x)"\r\t| newVal oldVal assoc term newVar |\r\t\r\tterm:=self var.\r\toldVal:=aMap at:term ifAbsent:[nil].\r\tassoc:=aDictionary associationAt:term ifAbsent:[\r\t\taDictionary add:(Association key: term value: -1)\r\t\t].\r\tassoc value: (assoc value + 1).\r\tnewVar:=\r\t\t(assoc value=0)\r\t\tifTrue:[\r\t\t\tassoc key.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((assoc key , assoc value asString) asString).\r\t\t\t].\r\tnewVal:=Term new:newVar.\r\tself var:newVar.\r\r\taMap at:term put:newVal.\r\tsuper renameVars:aDictionary with:aMap.\r\taMap at:term put:oldVal.\r',			#stamp : 'pm 12/21/2018 10:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:15:57.144374+01:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestGeneral,				#isMetaSide : false			},			#name : #testLaunchRenameVariables,			#protocol : #initialization,			#sourceCode : 'testLaunchRenameVariables \r\t\r\t| initial expected |\r\tinitial:=ForAll new:\'x\' Property:\r \t  (ForAll new:\'x\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x\');\r \t      yourself)\r \t   )\r \t  ).\r\t\r\texpected:=ForAll new:\'x1\' Property:\r \t  (ForAll new:\'x2\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x2\');\r \t      yourself)\r \t   )\r \t  ).\r\tself assert: initial launchRenameVariables equals:expected.\r\t\r\tinitial:=ForAll new:\'x\' Property:\r   (Or new:\r    (ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x\');\r        yourself)\r     )\r    )\r   rightProp:\r    (ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x\');\r        yourself)\r     )\r    )\r   ).\r\r\texpected:=ForAll new:\'x1\' Property:\r   (Or new:\r    (ForAll new:\'x2\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x2\');\r        yourself)\r     )\r    )\r   rightProp:\r    (ForAll new:\'x3\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x3\');\r        yourself)\r     )\r    )\r   ).\t\r\t\r\tself assert: initial launchRenameVariables equals:expected.',			#stamp : 'pm 12/20/2018 12:56',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestGeneral,				#isMetaSide : false			},			#name : #testLaunchRenameVariables,			#protocol : #initialization,			#sourceCode : 'testLaunchRenameVariables \r\t\r\t| initial expected |\r\tinitial:=ForAll new:\'x\' Property:\r \t  (ForAll new:\'x\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x\');\r \t      yourself)\r \t   )\r \t  ).\r\t\r\texpected:=ForAll new:\'x\' Property:\r \t  (ForAll new:\'x1\' Property:\r \t   (Predicate new:\'P\' fromList:\r \t     (LinkedList new \r \t      add:(Term new:\'x1\');\r \t      yourself)\r \t   )\r \t  ).\r\tself assert: initial launchRenameVariables equals:expected.\r\t\r\tinitial:=ForAll new:\'x\' Property:\r   (Or new:\r    (ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x\');\r        yourself)\r     )\r    )\r   rightProp:\r    (ForAll new:\'x\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x\');\r        yourself)\r     )\r    )\r   ).\r\r\texpected:=ForAll new:\'x\' Property:\r   (Or new:\r    (ForAll new:\'x1\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x1\');\r        yourself)\r     )\r    )\r   rightProp:\r    (ForAll new:\'x2\' Property:\r     (Predicate new:\'P\' fromList:\r       (LinkedList new \r        add:(Term new:\'x2\');\r        yourself)\r     )\r    )\r   ).\t\r\t\r\tself assert: initial launchRenameVariables equals:expected.',			#stamp : 'pm 12/21/2018 10:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:22:02.266549+01:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #anonymous,			#protocol : #accessing,			#sourceCode : 'anonymous\r\t^anonymous',			#stamp : 'pm 11/5/2018 09:20',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #anonymous,			#protocol : #accessing,			#sourceCode : 'anonymous\r\t"accessor"\r\t^anonymous',			#stamp : 'pm 12/21/2018 10:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:22:05.408893+01:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #'anonymous:',			#protocol : #accessing,			#sourceCode : 'anonymous:aBool\r\tanonymous:=aBool',			#stamp : 'pm 11/5/2018 09:20',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #'anonymous:',			#protocol : #accessing,			#sourceCode : 'anonymous:aBool\r\t"accessor"\r\tanonymous:=aBool',			#stamp : 'pm 12/21/2018 10:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:22:18.369122+01:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #isConstTerm,			#protocol : #testing,			#sourceCode : 'isConstTerm\r\t^true',			#stamp : 'pm 12/14/2018 12:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #isConstTerm,			#protocol : #testing,			#sourceCode : 'isConstTerm\r\t"tester"\r\t^true',			#stamp : 'pm 12/21/2018 10:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:22:24.523522+01:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #testing,			#sourceCode : 'isSameForTesting: anotherTerm\r\t\r\t^self anonymous \r\t\tifTrue:[\r\t\t\tanotherTerm anonymous\r\t\t\t]\r\t\tifFalse:[\r\t\t\tself term = anotherTerm term.\r\t\t\t].',			#stamp : 'pm 11/5/2018 09:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #testing,			#sourceCode : 'isSameForTesting: anotherTerm\r\t\t"tester"\r\t^self anonymous \r\t\tifTrue:[\r\t\t\tanotherTerm anonymous\r\t\t\t]\r\t\tifFalse:[\r\t\t\tself term = anotherTerm term.\r\t\t\t].',			#stamp : 'pm 12/21/2018 10:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:23:52.542006+01:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #testing,			#sourceCode : 'isSameForTesting: anotherTerm\r\t\t"tester"\r\t^self anonymous \r\t\tifTrue:[\r\t\t\tanotherTerm anonymous\r\t\t\t]\r\t\tifFalse:[\r\t\t\tself term = anotherTerm term.\r\t\t\t].',			#stamp : 'pm 12/21/2018 10:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ConstTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #testing,			#sourceCode : 'isSameForTesting: anotherTerm\r\t"tester for automated testing, takes into account that we can\'t predict the names of the anonymous elements."\r\t^self anonymous \r\t\tifTrue:[\r\t\t\tanotherTerm anonymous\r\t\t\t]\r\t\tifFalse:[\r\t\t\tself term = anotherTerm term.\r\t\t\t].',			#stamp : 'pm 12/21/2018 10:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:24:11.699919+01:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #testing,			#sourceCode : 'isSameTermsForTesting:anotherFuncTerm\r\t| selfTerms anotherFuncTerms |\r\tselfTerms:=self terms.\r\tanotherFuncTerms:=anotherFuncTerm terms.\r\t1 to: (terms size) do:[:i|\r\t\t((selfTerms at:i) isSameForTesting: (anotherFuncTerms at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 11/5/2018 09:44',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #testing,			#sourceCode : 'isSameTermsForTesting:anotherFuncTerm\r\t| selfTerms anotherFuncTerms |\r\t"tester for automated testing, takes into account that we can\'t predict the names of the anonymous elements."\r\tselfTerms:=self terms.\r\tanotherFuncTerms:=anotherFuncTerm terms.\r\t1 to: (terms size) do:[:i|\r\t\t((selfTerms at:i) isSameForTesting: (anotherFuncTerms at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 12/21/2018 10:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:24:24.450459+01:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #testing,			#sourceCode : 'isSameTermsForTesting:anotherFuncTerm\r\t| selfTerms anotherFuncTerms |\r\t"tester for automated testing, takes into account that we can\'t predict the names of the anonymous elements."\r\tselfTerms:=self terms.\r\tanotherFuncTerms:=anotherFuncTerm terms.\r\t1 to: (terms size) do:[:i|\r\t\t((selfTerms at:i) isSameForTesting: (anotherFuncTerms at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 12/21/2018 10:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'isSameTermsForTesting:',			#protocol : #testing,			#sourceCode : 'isSameTermsForTesting:anotherFuncTerm\r\t| selfTerms anotherFuncTerms |\r\t"tester for automated testing, takes into account that we can\'t predict the names of the anonymous elements."\r\t\r\tselfTerms:=self terms.\r\tanotherFuncTerms:=anotherFuncTerm terms.\r\t1 to: (terms size) do:[:i|\r\t\t((selfTerms at:i) isSameForTesting: (anotherFuncTerms at:i))\r\t\tifFalse:[\r\t\t\t^false\r\t\t\t]\r\t\t].\r\t^true',			#stamp : 'pm 12/21/2018 10:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:24:37.614427+01:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #isFuncTerm,			#protocol : #testing,			#sourceCode : 'isFuncTerm\r\t^true',			#stamp : 'pm 12/14/2018 12:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #isFuncTerm,			#protocol : #testing,			#sourceCode : 'isFuncTerm\r\t"tester"\r\t^true',			#stamp : 'pm 12/21/2018 10:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:24:45.328617+01:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isAbstractTerm,			#protocol : #testing,			#sourceCode : 'isAbstractTerm\r\t^true',			#stamp : 'pm 12/14/2018 12:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isAbstractTerm,			#protocol : #testing,			#sourceCode : 'isAbstractTerm\r\t"tester"\r\t^true',			#stamp : 'pm 12/21/2018 10:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:24:53.887745+01:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isConstTerm,			#protocol : #testing,			#sourceCode : 'isConstTerm\r\t^false',			#stamp : 'pm 12/14/2018 12:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isConstTerm,			#protocol : #testing,			#sourceCode : 'isConstTerm\r\t"tester"\r\t^false',			#stamp : 'pm 12/21/2018 10:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:24:56.683797+01:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isFuncTerm,			#protocol : #testing,			#sourceCode : 'isFuncTerm\r\t^false',			#stamp : 'pm 12/14/2018 12:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isFuncTerm,			#protocol : #testing,			#sourceCode : 'isFuncTerm\r\t"tester"\r\t^false',			#stamp : 'pm 12/21/2018 10:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:24:59.83866+01:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isLinkedTerm,			#protocol : #testing,			#sourceCode : 'isLinkedTerm\r\t^false',			#stamp : 'pm 12/14/2018 12:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isLinkedTerm,			#protocol : #testing,			#sourceCode : 'isLinkedTerm\r\t"tester"\r\t^false',			#stamp : 'pm 12/21/2018 10:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:25:11.229638+01:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #accessing,			#sourceCode : 'isSameForTesting: aTerm\r\t^ self subclassResponsibility',			#stamp : 'pm 12/15/2018 16:16',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #accessing,			#sourceCode : 'isSameForTesting: aTerm\t\r\t"tester"\r\t^ self subclassResponsibility',			#stamp : 'pm 12/21/2018 10:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:25:14.833467+01:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isTerm,			#protocol : #testing,			#sourceCode : 'isTerm\r\t^false',			#stamp : 'pm 12/14/2018 12:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isTerm,			#protocol : #testing,			#sourceCode : 'isTerm\r\t"tester"\r\t^false',			#stamp : 'pm 12/21/2018 10:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:25:21.712983+01:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isUnaryTerm,			#protocol : #testing,			#sourceCode : 'isUnaryTerm\r\t^false',			#stamp : 'pm 12/14/2018 12:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #isUnaryTerm,			#protocol : #testing,			#sourceCode : 'isUnaryTerm\r\t"tester"\r\t^false',			#stamp : 'pm 12/21/2018 10:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:25:52.903454+01:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #accessing,			#sourceCode : 'isSameForTesting: aTerm\t\r\t"tester"\r\t^ self subclassResponsibility',			#stamp : 'pm 12/21/2018 10:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #accessing,			#sourceCode : 'isSameForTesting: aTerm\t\r\t\t"tester for automated testing, takes into account that we can\'t predict the names of the anonymous elements."\r\t^ self subclassResponsibility',			#stamp : 'pm 12/21/2018 10:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:25:54.323391+01:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #accessing,			#sourceCode : 'isSameForTesting: aTerm\t\r\t\t"tester for automated testing, takes into account that we can\'t predict the names of the anonymous elements."\r\t^ self subclassResponsibility',			#stamp : 'pm 12/21/2018 10:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #accessing,			#sourceCode : 'isSameForTesting: aTerm\t\r\t"tester for automated testing, takes into account that we can\'t predict the names of the anonymous elements."\r\t^ self subclassResponsibility',			#stamp : 'pm 12/21/2018 10:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:26:11.709304+01:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t"CF AbstractTerm"\r\t| newVars t|\r\tnewVars:=LinkedList new.\r\tterms do: [ :each | newVars add: (each WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].\r\tt:=(FuncTerm new: (self getSymb) Variables:newVars).\r\t^t.',			#stamp : 'pm 10/28/2018 14:28',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t"CF AbstractTerm class comment"\r\t| newVars t|\r\tnewVars:=LinkedList new.\r\tterms do: [ :each | newVars add: (each WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].\r\tt:=(FuncTerm new: (self getSymb) Variables:newVars).\r\t^t.',			#stamp : 'pm 12/21/2018 10:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:26:48.667448+01:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t"CF AbstractTerm class comment"\r\t| newVars t|\r\tnewVars:=LinkedList new.\r\tterms do: [ :each | newVars add: (each WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].\r\tt:=(FuncTerm new: (self getSymb) Variables:newVars).\r\t^t.',			#stamp : 'pm 12/21/2018 10:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t"CF AbstractTerm::WhatAmI: CorrespondingValue:"\r\t| newVars t|\r\tnewVars:=LinkedList new.\r\tterms do: [ :each | newVars add: (each WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].\r\tt:=(FuncTerm new: (self getSymb) Variables:newVars).\r\t^t.',			#stamp : 'pm 12/21/2018 10:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:28:33.478603+01:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #isTerm,			#protocol : #testing,			#sourceCode : 'isTerm\r\t^true',			#stamp : 'pm 12/14/2018 12:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #isTerm,			#protocol : #testing,			#sourceCode : 'isTerm\r\t"tester"\r\t^true',			#stamp : 'pm 12/21/2018 10:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:28:41.200133+01:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #testing,			#sourceCode : 'isSameForTesting: anotherTerm\r\t^self=anotherTerm.',			#stamp : 'pm 11/5/2018 09:44',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Term,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #testing,			#sourceCode : 'isSameForTesting: anotherTerm\r\t"tester for automated testing, takes into account that we can\'t predict the names of the anonymous elements."\r\t^self=anotherTerm.',			#stamp : 'pm 12/21/2018 10:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:29:06.786365+01:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #isUnaryTerm,			#protocol : #testing,			#sourceCode : 'isUnaryTerm\r\t^true',			#stamp : 'pm 12/14/2018 12:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #isUnaryTerm,			#protocol : #testing,			#sourceCode : 'isUnaryTerm\r\t"tester"\r\t^true',			#stamp : 'pm 12/21/2018 10:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:29:11.521469+01:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #testing,			#sourceCode : 'isSameForTesting: anotherTerm\r\t^self term = anotherTerm term.',			#stamp : 'pm 11/5/2018 09:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'isSameForTesting:',			#protocol : #testing,			#sourceCode : 'isSameForTesting: anotherTerm\r\t"tester for automated testing, takes into account that we can\'t predict the names of the anonymous elements."\r\t^self term = anotherTerm term.',			#stamp : 'pm 12/21/2018 10:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:29:32.069129+01:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LinkedTerm,				#isMetaSide : false			},			#name : #isLinkedTerm,			#protocol : #testing,			#sourceCode : 'isLinkedTerm\r\t^true',			#stamp : 'pm 12/14/2018 12:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LinkedTerm,				#isMetaSide : false			},			#name : #isLinkedTerm,			#protocol : #testing,			#sourceCode : 'isLinkedTerm\r\t"tester"\r\t^true',			#stamp : 'pm 12/21/2018 10:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:34:20.009825+01:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #adding,			#sourceCode : 'addAll: clausifiedProp\r\r\t"badly designed, NEEDS a refactor."\t\r\t\r\t\t\t\r\t((clausifiedProp  isOr) | (clausifiedProp isAtome))"If i\'m in a or, there\'s only or(s) under him."\r\tifTrue:[self add: (Clause new:clausifiedProp)]\r\tifFalse:[\r\t\t(clausifiedProp isNot)\r\t\tifTrue:[\r\t\t\t((clausifiedProp operand) isAtome)\r\t\t\tifTrue:[^self add:(Clause new:clausifiedProp).]\r\t\t\tifFalse:[^Error new:\'A not isn\'\'t englobing an atome.\'.].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(clausifiedProp isAnd)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (clausifiedProp left).\r\t\t\t\tself addAll: (clausifiedProp right).\r\t\t\t\t]\r\t\tifFalse:[\r\t\t\tError new: \'Tried to add a non clause object to a clausaleForm.\'.].\r\t\t\t].\r\t\t].',			#stamp : 'pm 12/15/2018 16:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #adding,			#sourceCode : 'addAll: clausifiedProp\r\t"badly designed, NEEDS a refactor."\t\r\t\r\t"adds several clauses to the current Clausal form."\r\t"they need to be from a proposition, not a clause."\r\t((clausifiedProp  isOr) | (clausifiedProp isAtome))"If i\'m in a or, there\'s only or(s) under him."\r\tifTrue:[self add: (Clause new:clausifiedProp)]\r\tifFalse:[\r\t\t(clausifiedProp isNot)\r\t\tifTrue:[\r\t\t\t((clausifiedProp operand) isAtome)\r\t\t\tifTrue:[^self add:(Clause new:clausifiedProp).]\r\t\t\tifFalse:[^Error new:\'A not isn\'\'t englobing an atome.\'.].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(clausifiedProp isAnd)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (clausifiedProp left).\r\t\t\t\tself addAll: (clausifiedProp right).\r\t\t\t\t]\r\t\tifFalse:[\r\t\t\tError new: \'Tried to add a non clause object to a clausaleForm.\'.].\r\t\t\t].\r\t\t].',			#stamp : 'pm 12/21/2018 10:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:35:59.84493+01:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #adding,			#sourceCode : 'addAll: orProp\r\r\t"BADLY DESIGNED, NEEDS REFACTOR"\r\t\r\t(orProp isAtome)\r\tifTrue:[self add:orProp.]\r\tifFalse:[\r\t\t((orProp) isNot)\r\t\tifTrue:["we\'re in a not"\r\t\t\t(orProp operand isAtome)\r\t\t\t\tifTrue:["we\'re in an atom"\r\t\t\t\t\t((orProp operand) isPredicate)\r\t\t\t\t\tifTrue:[self add:(NotPredicate new: (orProp operand) getSymb fromList: (orProp operand) terms).]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t((orProp operand) isVar)\r\t\t\t\t\t\tifTrue:[self add:(NotVar new:((orProp operand) getSymb)).]\r\t\t\t\t\t\tifFalse: [ Error new: \'shouldn\'\'t be any True or false here\' ]].\r\t\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tError new:\'Error, shouldn\'\'t be any more not ( binaryOp )\'\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(orProp isOr)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (orProp left).\r\t\t\t\tself addAll: (orProp right).\r\t\t\t\t]\r\t\t\tifFalse:["switch to Error new:"\r\t\t\t\tError new:\'Error, shouldn\'\'t be any other kind of prop here.\'.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 11/11/2018 09:20',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #adding,			#sourceCode : 'addAll: orProp\r\t"BADLY DESIGNED, NEEDS REFACTOR"\r\t\r\t"adds several clauses to the current Clause"\r\t"they need to be from a proposition, constituted of Or(s)"\r\t\r\t(orProp isAtome)\r\tifTrue:[self add:orProp.]\r\tifFalse:[\r\t\t((orProp) isNot)\r\t\tifTrue:["we\'re in a not"\r\t\t\t(orProp operand isAtome)\r\t\t\t\tifTrue:["we\'re in an atom"\r\t\t\t\t\t((orProp operand) isPredicate)\r\t\t\t\t\tifTrue:[self add:(NotPredicate new: (orProp operand) getSymb fromList: (orProp operand) terms).]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t((orProp operand) isVar)\r\t\t\t\t\t\tifTrue:[self add:(NotVar new:((orProp operand) getSymb)).]\r\t\t\t\t\t\tifFalse: [ Error new: \'shouldn\'\'t be any True or false here\' ]].\r\t\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tError new:\'Error, shouldn\'\'t be any more not ( binaryOp )\'\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(orProp isOr)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (orProp left).\r\t\t\t\tself addAll: (orProp right).\r\t\t\t\t]\r\t\t\tifFalse:["switch to Error new:"\r\t\t\t\tError new:\'Error, shouldn\'\'t be any other kind of prop here.\'.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 12/21/2018 10:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:36:46.536087+01:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'applyUnifier:onClause:',			#protocol : #resolutionMethod,			#sourceCode : 'applyUnifier: u onClause:aClause\r\taClause do:[:each| (self applyUnifier: u onPredicate: each)].\r\t^aClause',			#stamp : 'pm 12/14/2018 22:08',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'applyUnifier:onClause:',			#protocol : #resolutionMethod,			#sourceCode : 'applyUnifier: u onClause:aClause\r\t"Apply the found unifier on every predicate in the clause"\r\taClause do:[:each| (self applyUnifier: u onPredicate: each)].\r\t^aClause',			#stamp : 'pm 12/21/2018 10:36',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:37:12.687048+01:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'applyUnifier:onPredicate:',			#protocol : #resolutionMethod,			#sourceCode : 'applyUnifier: u onPredicate:aPredicate\r\tu setOfPairs do:[:each | aPredicate replace: each left by: each right].\r',			#stamp : 'pm 12/14/2018 22:08',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'applyUnifier:onPredicate:',			#protocol : #resolutionMethod,			#sourceCode : 'applyUnifier: u onPredicate:aPredicate\r\t"Apply the found unifier on a Predicate"\r\tu setOfPairs do:[:each | aPredicate replace: each left by: each right].\r',			#stamp : 'pm 12/21/2018 10:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:38:13.90552+01:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #clausificationUnitTest,			#protocol : #unit-testing,			#sourceCode : 'clausificationUnitTest\r\t|t|\r\tTranscript show: self prettyPrint; show: \'  \' ;show: self isClause; cr.\r\tt:=self fullClausification.\r\tTranscript show: t prettyPrint; show: \'  \' ;show: t isClause; cr;cr.\r\t^t.',			#stamp : 'pm 10/9/2018 13:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #clausificationUnitTest,			#protocol : #unit-testing,			#sourceCode : 'clausificationUnitTest\r\t"unit test for clausification"\r\t|t|\r\tTranscript show: self prettyPrint; show: \'  \' ;show: self isClause; cr.\r\tt:=self fullClausification.\r\tTranscript show: t prettyPrint; show: \'  \' ;show: t isClause; cr;cr.\r\t^t.',			#stamp : 'pm 12/21/2018 10:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:39:26.576+01:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #factorisationUnitTest,			#protocol : #unit-testing,			#sourceCode : 'factorisationUnitTest\r\t|r fc|\r\tProp testInc.\r\tself assert:[self isClause.].\r\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\t\r\tfc:=ClausalForm new:self.\r\tr:=Resolvante new.\r\tr factorisation: (fc at:1).\r\t\r\t\r\tTranscript show:r;cr;cr;cr.',			#stamp : 'pm 10/26/2018 18:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #factorisationUnitTest,			#protocol : #unit-testing,			#sourceCode : 'factorisationUnitTest\r\t"Unit test for unification\'s factorisation."\r\t"Automated testing available too"\r\t|r fc|\r\tProp testInc.\r\tself assert:[self isClause.].\r\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\t\r\tfc:=ClausalForm new:self.\r\tr:=Resolvante new.\r\tr factorisation: (fc at:1).\r\t\r\t\r\tTranscript show:r;cr;cr;cr.',			#stamp : 'pm 12/21/2018 10:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:39:35.023553+01:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #clausificationUnitTest,			#protocol : #unit-testing,			#sourceCode : 'clausificationUnitTest\r\t"unit test for clausification"\r\t|t|\r\tTranscript show: self prettyPrint; show: \'  \' ;show: self isClause; cr.\r\tt:=self fullClausification.\r\tTranscript show: t prettyPrint; show: \'  \' ;show: t isClause; cr;cr.\r\t^t.',			#stamp : 'pm 12/21/2018 10:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #clausificationUnitTest,			#protocol : #unit-testing,			#sourceCode : 'clausificationUnitTest\r\t"unit test for clausification"\r\t"Automated testing available too"\r\t|t|\r\tTranscript show: self prettyPrint; show: \'  \' ;show: self isClause; cr.\r\tt:=self fullClausification.\r\tTranscript show: t prettyPrint; show: \'  \' ;show: t isClause; cr;cr.\r\t^t.',			#stamp : 'pm 12/21/2018 10:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:42:17.504389+01:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #fullClausification,			#protocol : #clausification,			#sourceCode : 'fullClausification\r\t| t |\r\tt:=self clausification.\r\t[t isClause] whileFalse:[\t\r\t\tclausificationTrace ifTrue:[Transcript show: t prettyPrint; show: t isClause;cr.].\r\t\tt:=t clausification.].\r\t^t',			#stamp : 'pm 12/19/2018 20:31',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #fullClausification,			#protocol : #clausification,			#sourceCode : 'fullClausification\r\t"takes care of the clausification process."\r\t| t |\r\tt:=self clausification.\r\t[t isClause] whileFalse:[\t\r\t\tclausificationTrace ifTrue:[Transcript show: t prettyPrint; show: t isClause;cr.].\r\t\tt:=t clausification.].\r\t^t',			#stamp : 'pm 12/21/2018 10:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:42:37.411395+01:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isClause,			#protocol : #clausification,			#sourceCode : 'isClause\r\t^SubclassResponsibility ',			#stamp : 'pm 12/7/2018 13:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #isClause,			#protocol : #clausification,			#sourceCode : 'isClause\r\t"tester"\r\t^SubclassResponsibility ',			#stamp : 'pm 12/21/2018 10:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:45:11.909445+01:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #launchRenameVariables,			#protocol : #skolemisation,			#sourceCode : 'launchRenameVariables\r\tself renameVars: Dictionary new with: Dictionary new.',			#stamp : 'pm 12/19/2018 22:42',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #launchRenameVariables,			#protocol : #skolemisation,			#sourceCode : 'launchRenameVariables\r\t"starting point for the renaming the quantified terms"\r\tself renameVars: Dictionary new with: Dictionary new.',			#stamp : 'pm 12/21/2018 10:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:48:21.402406+01:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'matchingUnitTest:',			#protocol : #unit-testing,			#sourceCode : 'matchingUnitTest: prop\r\t"self will be considered as a pattern"\r\tTranscript cr;\r\t\tshow: \'prop : \' ; \r\t\tshow: (prop prettyPrint);\r\t\tcr;\r\t\tshow: \'pattern : \';\r\t\tshow: (self prettyPrint);\r\t\tcr.\r\t\t(self matchPatternWith: prop)\r\t\t\tifTrue:[ Transcript show: \'matched!\';cr.]\r\t\t\tifFalse:[ Transcript show: \'didn\'\'t match!\';cr]\r\t',			#stamp : 'pm 9/30/2018 12:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'matchingUnitTest:',			#protocol : #unit-testing,			#sourceCode : 'matchingUnitTest: prop\r\t"Matching unit test, for the function matchPatternWith."\r\t"No automated testing available."\r\t"self will be considered as a pattern"\r\tTranscript cr;\r\t\tshow: \'prop : \' ; \r\t\tshow: (prop prettyPrint);\r\t\tcr;\r\t\tshow: \'pattern : \';\r\t\tshow: (self prettyPrint);\r\t\tcr.\r\t\t(self matchPatternWith: prop)\r\t\t\tifTrue:[ Transcript show: \'matched!\';cr.]\r\t\t\tifFalse:[ Transcript show: \'didn\'\'t match!\';cr]\r\t',			#stamp : 'pm 12/21/2018 10:48',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:48:47.165313+01:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\taStream nextPutAll: (self prettyPrint).',			#stamp : 'pm 10/18/2018 15:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\t"override, for ouput tostring"\r\taStream nextPutAll: (self prettyPrint).',			#stamp : 'pm 12/21/2018 10:48',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:50:30.454179+01:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'unificationUnitTest:',			#protocol : #unit-testing,			#sourceCode : 'unificationUnitTest: otherPredicate\r\t|t newPair|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tnewPair:=t unifiedPair.\r\t(t hasFailed)\r\tifFalse:[\r\t\tTranscript show:newPair;cr;cr.\r\t]\r\tifTrue:[\r\t\tTranscript show: \'Unification failed.\';cr;cr.\r\t\t].\r\t^t',			#stamp : 'pm 10/25/2018 08:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'unificationUnitTest:',			#protocol : #unit-testing,			#sourceCode : 'unificationUnitTest: otherPredicate\r\t"Unification unit test"\r\t|t newPair|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tnewPair:=t unifiedPair.\r\t(t hasFailed)\r\tifFalse:[\r\t\tTranscript show:newPair;cr;cr.\r\t]\r\tifTrue:[\r\t\tTranscript show: \'Unification failed.\';cr;cr.\r\t\t].\r\t^t',			#stamp : 'pm 12/21/2018 10:50',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:52:36.535216+01:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #skolemnisationTest,			#protocol : #unit-testing,			#sourceCode : 'skolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self startSkolemisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr.\r\tt:=t resolutionMethod.\r\r\tTranscript show:\'Resolution method:\' ;show:t;cr;cr;cr.\r\t^t ',			#stamp : 'pm 12/19/2018 20:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #skolemnisationTest,			#protocol : #unit-testing,			#sourceCode : 'skolemnisationTest\r\t"Used to be skolemisation unit test.\r\tIt\'s not as relevant now."\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'Deprecated, doesn\'\'t correspond to a skolemisation test anymore\'.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self startSkolemisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr.\r\tt:=t resolutionMethod.\r\r\tTranscript show:\'Resolution method:\' ;show:t;cr;cr;cr.\r\t^t ',			#stamp : 'pm 12/21/2018 10:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:52:48.68123+01:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #herbranSkolemDocu,			#protocol : #skolemisation,			#sourceCode : 'herbranSkolemDocu\r\t^Error new:\'documentation of Skolemnisation\'.\r\t"return the proposition skolemnised"\r\t\r\t"Herbrandise: setOfLinkedVar CorrespondingValue: aMap"\r\t"setOfLinkedVar is a set of linked var (incredible, i know)\r\tIt\'s used to know if a variable was linked in that branch, following the rules of Skolemn/Herbran\r\t\r\tCorrespondingValue: aMap \r\tMap containing the correspondance between a variable, and the associated object term that we stored along the way. This will be used in Predicate::UpdateTerms.\r\t\r\tThe rules were taken from the course of David Delahaye, professor, science faculty, university of montpellier\r\t\t\r\t(Not sure the credit is enought)\r\t"',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #herbranSkolemDocu,			#protocol : #skolemisation,			#sourceCode : 'herbranSkolemDocu\r\t^Error new:\'documentation of Skolemnisation\'.\r\t"return the proposition skolemised"\r\t\r\t"Herbrandise: setOfLinkedVar CorrespondingValue: aMap"\r\t"setOfLinkedVar is a set of linked var (incredible, i know)\r\tIt\'s used to know if a variable was linked in that branch, following the rules of Skolemn/Herbran\r\t\r\tCorrespondingValue: aMap \r\tMap containing the correspondance between a variable, and the associated object term that we stored along the way. This will be used in Predicate::UpdateTerms.\r\t\r\tThe rules were taken from the course of David Delahaye, professor, science faculty, university of montpellier\r\t\t\r\t(Not sure the credit is enought)\r\t"',			#stamp : 'pm 12/21/2018 10:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:53:05.51801+01:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #herbranSkolemDocu,			#protocol : #skolemisation,			#sourceCode : 'herbranSkolemDocu\r\t^Error new:\'documentation of Skolemnisation\'.\r\t"return the proposition skolemised"\r\t\r\t"Herbrandise: setOfLinkedVar CorrespondingValue: aMap"\r\t"setOfLinkedVar is a set of linked var (incredible, i know)\r\tIt\'s used to know if a variable was linked in that branch, following the rules of Skolemn/Herbran\r\t\r\tCorrespondingValue: aMap \r\tMap containing the correspondance between a variable, and the associated object term that we stored along the way. This will be used in Predicate::UpdateTerms.\r\t\r\tThe rules were taken from the course of David Delahaye, professor, science faculty, university of montpellier\r\t\t\r\t(Not sure the credit is enought)\r\t"',			#stamp : 'pm 12/21/2018 10:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #herbranSkolemDocu,			#protocol : #skolemisation,			#sourceCode : 'herbranSkolemDocu\r\t^Error new:\'documentation of Skolemisation\'.\r\t"return the proposition skolemised"\r\t\r\t"Herbrandise: setOfLinkedVar CorrespondingValue: aMap"\r\t"setOfLinkedVar is a set of linked var (incredible, i know)\r\tIt\'s used to know if a variable was linked in that branch, following the rules of Skolem/Herbran\r\t\r\tCorrespondingValue: aMap \r\tMap containing the correspondance between a variable, and the associated object term that we stored along the way. This will be used in Predicate::UpdateTerms.\r\t\r\tThe rules were taken from the course of David Delahaye, professor, science faculty, university of montpellier\r\t\t\r\t(Not sure the credit is enought)\r\t"',			#stamp : 'pm 12/21/2018 10:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:54:00.740554+01:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #herbranSkolemDocu,			#protocol : #skolemisation,			#sourceCode : 'herbranSkolemDocu\r\t^Error new:\'documentation of Skolemisation\'.\r\t"return the proposition skolemised"\r\t\r\t"Herbrandise: setOfLinkedVar CorrespondingValue: aMap"\r\t"setOfLinkedVar is a set of linked var (incredible, i know)\r\tIt\'s used to know if a variable was linked in that branch, following the rules of Skolem/Herbran\r\t\r\tCorrespondingValue: aMap \r\tMap containing the correspondance between a variable, and the associated object term that we stored along the way. This will be used in Predicate::UpdateTerms.\r\t\r\tThe rules were taken from the course of David Delahaye, professor, science faculty, university of montpellier\r\t\t\r\t(Not sure the credit is enought)\r\t"',			#stamp : 'pm 12/21/2018 10:53',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #herbranSkolemDocu,			#protocol : #skolemisation,			#sourceCode : 'herbranSkolemDocu\r\t^Error new:\'documentation of Skolemisation\'.\r\t"return the proposition skolemised"\r\t\r\t"Herbrandise: setOfLinkedVar CorrespondingValue: aMap"\r\t"setOfLinkedVar is a set of linked var (incredible, i know)\r\tIt\'s used to know if a variable was linked in that branch, following the rules of Skolem/Herbran\r\t\r\tCorrespondingValue: aMap \r\tMap containing the correspondance between a variable, and the associated object term that we stored along the way. This will be used in Predicate::UpdateTerms to specialize the terms to a Const/linked/func terms.\r\t\r\tThe rules were taken from the course of David Delahaye, professor, science faculty, university of montpellier\r\t\t\r\t(Not sure the credit is enought)\r\t"',			#stamp : 'pm 12/21/2018 10:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:54:21.599706+01:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #startSkolemisation,			#protocol : #skolemisation,			#sourceCode : 'startSkolemisation\r\t| set aMap |\r\tset:=MinimalOrderedSet new.\r\taMap:=Dictionary new.\r\t^self skolemise: set CorrespondingValue: aMap',			#stamp : 'pm 12/19/2018 20:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #startSkolemisation,			#protocol : #skolemisation,			#sourceCode : 'startSkolemisation\r\t"starter for skolemisation"\r\t| set aMap |\r\tset:=MinimalOrderedSet new.\r\taMap:=Dictionary new.\r\t^self skolemise: set CorrespondingValue: aMap',			#stamp : 'pm 12/21/2018 10:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:54:41.574891+01:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpRenameMethodRefactoring {		#oldSelector : #skolemnisationTest,		#newSelector : #skolemisationTest,		#affectedClassName : #Prop	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ],		#time : DateAndTime [ '2018-12-21T10:54:41.59781+01:00' ],		#trigger : @3	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #skolemisationTest,			#protocol : #unit-testing,			#sourceCode : 'skolemisationTest\r\t"Used to be skolemisation unit test.\r\tIt\'s not as relevant now."\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'Deprecated, doesn\'\'t correspond to a skolemisation test anymore\'.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self startSkolemisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr.\r\tt:=t resolutionMethod.\r\r\tTranscript show:\'Resolution method:\' ;show:t;cr;cr;cr.\r\t^t ',			#stamp : 'pm 12/21/2018 10:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ],		#time : DateAndTime [ '2018-12-21T10:54:41.604742+01:00' ],		#trigger : OmReference [ '50' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2 |\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\r\tTranscript show: \'basic one #1\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp skolemnisationTest.\r\r\tTranscript show: \'basic one #2\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'z\').\t\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp skolemnisationTest.\r\r\r\tTranscript show: \'with imply and nested forall.\'.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tp skolemnisationTest.\r\t\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\'.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp skolemnisationTest.\t\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\'.\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp skolemnisationTest.\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' .\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r\tp skolemnisationTest.\r\t\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\tp skolemnisationTest.\r\t\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp skolemnisationTest .\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp skolemnisationTest.\r\t\r\tTranscript show:\'Class exemple.\';cr.\r\tp:=Imply new: (And new: (Predicate new: \'P\' variable:(Term new: \'a\'))\r\t\t\t\t\t\t\trightProp: (Predicate new:\'Q\' variable:(Term new:\'b\')))\r\t rightProp: (Predicate new: \'P\' variable:(Term new: \'a\')).\r\tp skolemnisationTest.\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 12/19/2018 20:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2 |\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\r\tTranscript show: \'basic one #1\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp skolemisationTest.\r\r\tTranscript show: \'basic one #2\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'z\').\t\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp skolemisationTest.\r\r\r\tTranscript show: \'with imply and nested forall.\'.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tp skolemisationTest.\r\t\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\'.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp skolemisationTest.\t\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\'.\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp skolemisationTest.\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' .\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r\tp skolemisationTest.\r\t\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\tp skolemisationTest.\r\t\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp skolemisationTest .\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp skolemisationTest.\r\t\r\tTranscript show:\'Class exemple.\';cr.\r\tp:=Imply new: (And new: (Predicate new: \'P\' variable:(Term new: \'a\'))\r\t\t\t\t\t\t\trightProp: (Predicate new:\'Q\' variable:(Term new:\'b\')))\r\t rightProp: (Predicate new: \'P\' variable:(Term new: \'a\')).\r\tp skolemisationTest.\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 12/21/2018 10:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ],		#time : DateAndTime [ '2018-12-21T10:54:41.623308+01:00' ],		#trigger : OmReference [ '50' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #skolemnisationTest,			#protocol : #unit-testing,			#sourceCode : 'skolemnisationTest\r\t"Used to be skolemisation unit test.\r\tIt\'s not as relevant now."\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'Deprecated, doesn\'\'t correspond to a skolemisation test anymore\'.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self startSkolemisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr.\r\tt:=t resolutionMethod.\r\r\tTranscript show:\'Resolution method:\' ;show:t;cr;cr;cr.\r\t^t ',			#stamp : 'pm 12/21/2018 10:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:56:26.592514+01:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #propUnitTest,			#protocol : #unit-testing,			#sourceCode : 'propUnitTest\r\tTranscript show: self prettyPrint; show: \'  \' ;show: self isClause; cr; cr.\r\t^self',			#stamp : 'pm 10/9/2018 12:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #propUnitTest,			#protocol : #unit-testing,			#sourceCode : 'propUnitTest\r\t"basic unit test to see the result of the toString, and see if it\'s a clause"\r\tTranscript show: self prettyPrint; show: \'  \' ;show: self isClause; cr; cr.\r\t^self',			#stamp : 'pm 12/21/2018 10:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:57:33.234012+01:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tResolutionSteps ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\tResolutionSteps ifTrue:[Transcript show: \'Initial: \'; show: treatedProp ; cr.].\r\ttreatedProp launchRenameVariables.\r\tResolutionSteps ifTrue:[Transcript show: \'Renamed: \'; show: treatedProp ; cr.].\r\tt:=treatedProp startSkolemisation.\r\tResolutionSteps ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tResolutionSteps ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tResolutionSteps ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tResolutionSteps ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/21/2018 09:58',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t"Complete process of checking if a proposition is valid."\r\t"Trace available in prop::ResolutionSteps attribute"\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tResolutionSteps ifTrue:[Transcript show:\'Is \';show: self; show:\' valid?\';cr].\r\t\r\ttreatedProp:=Not new:self.\r\tResolutionSteps ifTrue:[Transcript show: \'Initial: \'; show: treatedProp ; cr.].\r\ttreatedProp launchRenameVariables.\r\tResolutionSteps ifTrue:[Transcript show: \'Renamed: \'; show: treatedProp ; cr.].\r\tt:=treatedProp startSkolemisation.\r\tResolutionSteps ifTrue:[Transcript show: \'Skolemn: \';show: t ;cr.].\r\tt:=t fullClausification.\r\tResolutionSteps ifTrue:[Transcript show: \'Clausified:\';show: t ;cr.].\r\tt:=ClausalForm new:t.\r\tResolutionSteps ifTrue:[Transcript show: \'ClausalForm:\';show: t ;cr.].\r\tt:=t resolutionMethod.\r\r\tResolutionSteps ifTrue:[Transcript show:\'Resolution method:\' ; show:t ; cr; cr; cr].\r\t^t ',			#stamp : 'pm 12/21/2018 10:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:58:12.843372+01:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherAtome\r\t^self class = anotherAtome class.',			#stamp : 'pm 12/7/2018 20:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Constant,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherAtome\r\t"Comparison Operator"\r\t^self class = anotherAtome class.',			#stamp : 'pm 12/21/2018 10:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T10:59:35.637345+01:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t((terms at:i) isFuncTerm)\r\t\tifTrue: [\r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].\r\t^self',			#stamp : 'pm 12/14/2018 21:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t"Replace a term in the Predicate by another"\r\t| i |\r\ti:=1.\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t((terms at:i) isFuncTerm)\r\t\tifTrue: [\r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].\r\t^self',			#stamp : 'pm 12/21/2018 10:59',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:04:42.443303+01:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'updateTerms:CorrespondingValue:',			#protocol : #skolemisation,			#sourceCode : 'updateTerms: setOfLinkedVar CorrespondingValue: aMap\r\t| res |\r\tres := LinkedList new.\r\tterms do:[ :term | res add: (term WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].\r\t^Predicate new: (self getSymb) fromList:res.\r',			#stamp : 'pm 11/27/2018 21:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'updateTerms:CorrespondingValue:',			#protocol : #skolemisation,			#sourceCode : 'updateTerms: setOfLinkedVar CorrespondingValue: aMap\r\t"during the skolemisation process, we specialize the terms in their \'right\' type"\r\t| res |\r\tres := LinkedList new.\r\tterms do:[ :term | res add: (term WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].\r\t^Predicate new: (self getSymb) fromList:res.\r',			#stamp : 'pm 12/21/2018 11:04',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:05:03.795692+01:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherPredicate\r\t| res |\r\t"comparaison operator"\r\t\r\tres:=anotherPredicate isKindOf: self class."checking the input"\r\tres:=res and:[self isSameSymb: anotherPredicate]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[self isSameTerms: anotherPredicate]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 12/7/2018 18:27',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherPredicate\r\t| res |\r\t"comparison operator"\r\t\r\tres:=anotherPredicate isKindOf: self class."checking the input"\r\tres:=res and:[self isSameSymb: anotherPredicate]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherPredicate]."comparing arity"\r\tres:=res and:[self isSameTerms: anotherPredicate]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 12/21/2018 11:05',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:06:21.313407+01:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Operator,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherOperator\r\t^self getSymb = anotherOperator getSymb',			#stamp : 'pm 12/7/2018 18:16',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Operator,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherOperator\r\t"comparison operator"\r\t^self getSymb = anotherOperator getSymb',			#stamp : 'pm 12/21/2018 11:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:06:48.539978+01:00' ],		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'matchPatternWith:',			#protocol : #matching,			#sourceCode : 'matchPatternWith: prop\r\t(self compareSymbol: prop)\r\t\tifTrue:[\r\t\t\t^(left matchPatternWith: (prop left))\r\t\t\t& (right matchPatternWith: (prop right))\r\t\t\t]\r\t\tifFalse:[^false].',			#stamp : 'pm 9/30/2018 12:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'matchPatternWith:',			#protocol : #matching,			#sourceCode : 'matchPatternWith: prop\r\t"see Prop::matchPatterWith for documentation"\r\t(self compareSymbol: prop)\r\t\tifTrue:[\r\t\t\t^(left matchPatternWith: (prop left))\r\t\t\t& (right matchPatternWith: (prop right))\r\t\t\t]\r\t\tifFalse:[^false].',			#stamp : 'pm 12/21/2018 11:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:07:13.45548+01:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherBinaryOperator\r\t^ super = anotherBinaryOperator \r\t\tand:[self left = anotherBinaryOperator left\r\t\t\tand:[self right = anotherBinaryOperator right]\r\t\t\t]',			#stamp : 'pm 12/7/2018 17:59',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Binary,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherBinaryOperator\r\t"comparison operator"\r\t^ super = anotherBinaryOperator \r\t\tand:[self left = anotherBinaryOperator left\r\t\t\tand:[self right = anotherBinaryOperator right]\r\t\t\t]',			#stamp : 'pm 12/21/2018 11:07',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:10:15.297004+01:00' ],		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherUnaryOperator\r\t^ super = anotherUnaryOperator \r\t\tand:[self operand = anotherUnaryOperator operand]',			#stamp : 'pm 12/7/2018 18:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherUnaryOperator\r\t"comparison operator"\r\t^ super = anotherUnaryOperator \r\t\tand:[self operand = anotherUnaryOperator operand]',			#stamp : 'pm 12/21/2018 11:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:10:35.270726+01:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #'matchPatternWith:',			#protocol : #Matching,			#sourceCode : 'matchPatternWith: prop\r\t(self compareSymbol: prop)\r\tifTrue:[^operand matchPatternWith: (prop operand)]\r\tifFalse:[^false].',			#stamp : 'pm 11/27/2018 11:21',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #'matchPatternWith:',			#protocol : #Matching,			#sourceCode : 'matchPatternWith: prop\r\t"see Prop::matchPatternWith"\r\t(self compareSymbol: prop)\r\tifTrue:[^operand matchPatternWith: (prop operand)]\r\tifFalse:[^false].',			#stamp : 'pm 12/21/2018 11:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:10:40.390812+01:00' ],		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #'matchPatternWith:',			#protocol : #Matching,			#sourceCode : 'matchPatternWith: prop\r\t"see Prop::matchPatternWith"\r\t(self compareSymbol: prop)\r\tifTrue:[^operand matchPatternWith: (prop operand)]\r\tifFalse:[^false].',			#stamp : 'pm 12/21/2018 11:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unary,				#isMetaSide : false			},			#name : #'matchPatternWith:',			#protocol : #Matching,			#sourceCode : 'matchPatternWith: prop\r\t"see Prop::matchPatternWith for documentation"\r\t(self compareSymbol: prop)\r\tifTrue:[^operand matchPatternWith: (prop operand)]\r\tifFalse:[^false].',			#stamp : 'pm 12/21/2018 11:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:12:08.806744+01:00' ],		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'add:',			#protocol : #add/remove,			#sourceCode : 'add: aPair\r\tsetOfPairs add: aPair.\r\t^self',			#stamp : 'pm 10/15/2018 16:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'add:',			#protocol : #add/remove,			#sourceCode : 'add: aPair\r\t"add aPair to the underlying class"\r\tsetOfPairs add: aPair.\r\t^self',			#stamp : 'pm 12/21/2018 11:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:12:38.441791+01:00' ],		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'add:Value2:',			#protocol : #add/remove,			#sourceCode : 'add: value1 Value2: value2\r\tsetOfPairs add:(Pair left: value1 right: value2).',			#stamp : 'pm 10/15/2018 19:14',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'add:Value2:',			#protocol : #add/remove,			#sourceCode : 'add: value1 Value2: value2\r\t"add a pair to the set of pairs"\r\tsetOfPairs add:(Pair left: value1 right: value2).',			#stamp : 'pm 12/21/2018 11:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:12:44.36342+01:00' ],		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'addUnifier:',			#protocol : #add/remove,			#sourceCode : 'addUnifier: anotherUnifier\r\tsetOfPairs merge: (anotherUnifier setOfPairs ).\r\t^self',			#stamp : 'pm 10/15/2018 16:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'addUnifier:',			#protocol : #add/remove,			#sourceCode : 'addUnifier: anotherUnifier\r\t"accessor"\r\tsetOfPairs merge: (anotherUnifier setOfPairs ).\r\t^self',			#stamp : 'pm 12/21/2018 11:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:13:32.65886+01:00' ],		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'addUnifier:',			#protocol : #add/remove,			#sourceCode : 'addUnifier: anotherUnifier\r\t"accessor"\r\tsetOfPairs merge: (anotherUnifier setOfPairs ).\r\t^self',			#stamp : 'pm 12/21/2018 11:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'addUnifier:',			#protocol : #add/remove,			#sourceCode : 'addUnifier: anotherUnifier\r\t"add another unifier to self."\r\tsetOfPairs merge: (anotherUnifier setOfPairs ).\r\t^self',			#stamp : 'pm 12/21/2018 11:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:14:04.873533+01:00' ],		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'check:',			#protocol : #unification,			#sourceCode : 'check: aPair\r\r\t(Prop unificationTrace)\r\tifTrue:[Transcript show:\'check\';cr.].\r\t\r\t^aPair right contains: aPair left term',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'check:',			#protocol : #unification,			#sourceCode : 'check: aPair\r\t"check primitive for the Robinson algorithm"\r\t(Prop unificationTrace)\r\tifTrue:[Transcript show:\'check\';cr.].\r\t\r\t^aPair right contains: aPair left term',			#stamp : 'pm 12/21/2018 11:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:14:13.661384+01:00' ],		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'conflict:',			#protocol : #unification,			#sourceCode : 'conflict: aPair\r\tProp unificationTrace\r\tifTrue:[Transcript show:\'[Unification] conflict between : \'; show:aPair ; cr.].\r',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'conflict:',			#protocol : #unification,			#sourceCode : 'conflict: aPair\r\t"conflict primitive for the Robinson algorithm"\r\tProp unificationTrace\r\tifTrue:[Transcript show:\'[Unification] conflict between : \'; show:aPair ; cr.].\r',			#stamp : 'pm 12/21/2018 11:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:14:19.883107+01:00' ],		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t|left right i|\r\tProp unificationTrace\r\tifTrue:[Transcript show:\'decompose \'; show:aPair ;cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\ti:=1.\r\tsetOfPairs remove: aPair.\r\t[i<=(left arity)]"arity is the same, as we tested in the caller."\r\twhileTrue:[\r\t\tself add: (Pair left: (left at: i) right: (right at: i)).\r\t\ti:=i+1.\r\t\t].\t',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'decompose:',			#protocol : #unification,			#sourceCode : 'decompose: aPair\r\t"decompose primitive for the Robinson algorithm"\r\t|left right i|\r\tProp unificationTrace\r\tifTrue:[Transcript show:\'decompose \'; show:aPair ;cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\ti:=1.\r\tsetOfPairs remove: aPair.\r\t[i<=(left arity)]"arity is the same, as we tested in the caller."\r\twhileTrue:[\r\t\tself add: (Pair left: (left at: i) right: (right at: i)).\r\t\ti:=i+1.\r\t\t].\t',			#stamp : 'pm 12/21/2018 11:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:14:25.113793+01:00' ],		#prior : OmReference [ '72' ],		#self : OmReference [ '73' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'delete:',			#protocol : #unification,			#sourceCode : 'delete:aPair\r\tProp unificationTrace\r\tifTrue:[Transcript show:\'delete\'; show:aPair ;cr.].\r\tsetOfPairs remove:aPair.',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'delete:',			#protocol : #unification,			#sourceCode : 'delete:aPair\r\t"delete primitive for the Robinson algorithm"\r\tProp unificationTrace\r\tifTrue:[Transcript show:\'delete\'; show:aPair ;cr.].\r\tsetOfPairs remove:aPair.',			#stamp : 'pm 12/21/2018 11:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:14:36.640285+01:00' ],		#prior : OmReference [ '73' ],		#self : OmReference [ '74' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t|left right previousSet newSet |\r\t\r\tProp unificationTrace\r\tifTrue:[Transcript show:\'eliminate with \'; show:aPair ;cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\t\r\tpreviousSet:=setOfPairs veryDeepCopy."we need to work on a copy, to avoid having another iteration"\r\tpreviousSet remove:aPair.\r\t\r\tpreviousSet do:[:each |\r\t\t"tempVar:=each veryDeepCopy.""since we modify the underlying data, we work on a copy"\r\t\tnewSet add: (self replacementPair:each replaced:left by:right).\r\t\t].\r\t(previousSet = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r ',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'eliminate:',			#protocol : #unification,			#sourceCode : 'eliminate: aPair\r\t"emiminate primitive for the Robinson algorithm"\r\t|left right previousSet newSet |\r\t\r\tProp unificationTrace\r\tifTrue:[Transcript show:\'eliminate with \'; show:aPair ;cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tnewSet:=MinimalOrderedSet new.\r\t\r\tpreviousSet:=setOfPairs veryDeepCopy."we need to work on a copy, to avoid having another iteration"\r\tpreviousSet remove:aPair.\r\t\r\tpreviousSet do:[:each |\r\t\t"tempVar:=each veryDeepCopy.""since we modify the underlying data, we work on a copy"\r\t\tnewSet add: (self replacementPair:each replaced:left by:right).\r\t\t].\r\t(previousSet = newSet)\r\tifTrue:[\r\t\t^false "Nothing changed"\r\t\t]\r\tifFalse:[\r\t\tnewSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"\r\t\tsetOfPairs:=newSet."replace with new set"\r\t\t^true. "modifications were mades"\r\t\t].\r\t\r ',			#stamp : 'pm 12/21/2018 11:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:14:45.22848+01:00' ],		#prior : OmReference [ '74' ],		#self : OmReference [ '75' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #firstPredicate,			#protocol : #initialization,			#sourceCode : 'firstPredicate\r\t^unifiedPair left.',			#stamp : 'pm 10/25/2018 08:07',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #firstPredicate,			#protocol : #initialization,			#sourceCode : 'firstPredicate\r\t"accessor"\r\t^unifiedPair left.',			#stamp : 'pm 12/21/2018 11:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:14:50.699188+01:00' ],		#prior : OmReference [ '75' ],		#self : OmReference [ '76' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #hasFailed,			#protocol : #accessing,			#sourceCode : 'hasFailed\r\t^hasFailed',			#stamp : 'pm 10/20/2018 08:53',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #hasFailed,			#protocol : #accessing,			#sourceCode : 'hasFailed\r\t"accessor"\r\t^hasFailed',			#stamp : 'pm 12/21/2018 11:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:15:00.601518+01:00' ],		#prior : OmReference [ '76' ],		#self : OmReference [ '77' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t| t |\r\tt:=\'{\'.\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do: [:each| t:=t,each prettyPrintUnifier.] separatedBy: [ t:=t,\',\'.].\r\t\t].\r\tt:=t,\'}\'.\r\t^t',			#stamp : 'pm 10/20/2018 08:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t"toString"\r\t| t |\r\tt:=\'{\'.\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do: [:each| t:=t,each prettyPrintUnifier.] separatedBy: [ t:=t,\',\'.].\r\t\t].\r\tt:=t,\'}\'.\r\t^t',			#stamp : 'pm 12/21/2018 11:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:16:04.965025+01:00' ],		#prior : OmReference [ '77' ],		#self : OmReference [ '78' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\taStream nextPutAll: (self prettyPrint).',			#stamp : 'pm 10/20/2018 08:21',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\t"override for output the toString"\r\taStream nextPutAll: (self prettyPrint).',			#stamp : 'pm 12/21/2018 11:16',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:17:40.299217+01:00' ],		#prior : OmReference [ '78' ],		#self : OmReference [ '79' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacement:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacement:aTerm replaced:x by:t\r\t((aTerm isFuncTerm)or:[aTerm isPredicate])\r\tifTrue:[\r\t\t^aTerm replace:x by:t.\r\t\t]"if it\'s something else than a functerm, "\r\tifFalse:[\r\t\t(aTerm=x)\r\t\tifTrue:[^t]\r\t\tifFalse:[^aTerm].\r\t\t].\r ',			#stamp : 'pm 12/15/2018 16:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacement:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacement:aTerm replaced:x by:t\r\t"replacement process during unification"\r\t((aTerm isFuncTerm)or:[aTerm isPredicate])\r\tifTrue:[\r\t\t^aTerm replace:x by:t.\r\t\t]"if it\'s something else than a functerm, "\r\tifFalse:[\r\t\t(aTerm=x)\r\t\tifTrue:[^t]\r\t\tifFalse:[^aTerm].\r\t\t].\r ',			#stamp : 'pm 12/21/2018 11:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:18:47.034549+01:00' ],		#prior : OmReference [ '79' ],		#self : OmReference [ '80' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacementPair:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacementPair:aPair replaced:x by:t\r\t^Pair left:(self replacement: (aPair left) replaced:x by:t)\r\t\t  right:(self replacement: (aPair right) replaced:x by:t).\r',			#stamp : 'pm 10/21/2018 09:15',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacementPair:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacementPair:aPair replaced:x by:t\r\t"replacement during the elim process"\r\t^Pair left:(self replacement: (aPair left) replaced:x by:t)\r\t\t  right:(self replacement: (aPair right) replaced:x by:t).\r',			#stamp : 'pm 12/21/2018 11:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:18:53.488624+01:00' ],		#prior : OmReference [ '80' ],		#self : OmReference [ '81' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacement:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacement:aTerm replaced:x by:t\r\t"replacement process during unification"\r\t((aTerm isFuncTerm)or:[aTerm isPredicate])\r\tifTrue:[\r\t\t^aTerm replace:x by:t.\r\t\t]"if it\'s something else than a functerm, "\r\tifFalse:[\r\t\t(aTerm=x)\r\t\tifTrue:[^t]\r\t\tifFalse:[^aTerm].\r\t\t].\r ',			#stamp : 'pm 12/21/2018 11:17',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacement:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacement:aTerm replaced:x by:t\r\t"replacement during the elim process"\r\t((aTerm isFuncTerm)or:[aTerm isPredicate])\r\tifTrue:[\r\t\t^aTerm replace:x by:t.\r\t\t]"if it\'s something else than a functerm, "\r\tifFalse:[\r\t\t(aTerm=x)\r\t\tifTrue:[^t]\r\t\tifFalse:[^aTerm].\r\t\t].\r ',			#stamp : 'pm 12/21/2018 11:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:19:00.235255+01:00' ],		#prior : OmReference [ '81' ],		#self : OmReference [ '82' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #secondPredicate,			#protocol : #initialization,			#sourceCode : 'secondPredicate\r\t^unifiedPair right.',			#stamp : 'pm 10/25/2018 08:07',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #secondPredicate,			#protocol : #initialization,			#sourceCode : 'secondPredicate\r\t"accessor"\r\t^unifiedPair right.',			#stamp : 'pm 12/21/2018 11:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:19:05.150497+01:00' ],		#prior : OmReference [ '82' ],		#self : OmReference [ '83' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #setOfPairs,			#protocol : #accessors,			#sourceCode : 'setOfPairs\r\t^setOfPairs',			#stamp : 'pm 10/15/2018 16:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #setOfPairs,			#protocol : #accessors,			#sourceCode : 'setOfPairs\r\t"accessor"\r\t^setOfPairs',			#stamp : 'pm 12/21/2018 11:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:19:12.161692+01:00' ],		#prior : OmReference [ '83' ],		#self : OmReference [ '84' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'setOfPairs:',			#protocol : #accessors,			#sourceCode : 'setOfPairs: anotherSet\r\tsetOfPairs:=anotherSet.\r\t^self.',			#stamp : 'pm 10/15/2018 16:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'setOfPairs:',			#protocol : #accessors,			#sourceCode : 'setOfPairs: anotherSet\r\t"accessor"\r\tsetOfPairs:=anotherSet.\r\t^self.',			#stamp : 'pm 12/21/2018 11:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:20:33.311657+01:00' ],		#prior : OmReference [ '84' ],		#self : OmReference [ '85' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'add:',			#protocol : #add/remove,			#sourceCode : 'add: aPair\r\t"add aPair to the underlying class"\r\tsetOfPairs add: aPair.\r\t^self',			#stamp : 'pm 12/21/2018 11:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'add:',			#protocol : #add/remove,			#sourceCode : 'add: aPair\r\t"add aPair to the underlying class"\r\t"Note that we return self, instead of the classic norme in Smalltalk which return the added value. Raise a false flag in the critic browser\'"\r\tsetOfPairs add: aPair.\r\t^self',			#stamp : 'pm 12/21/2018 11:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:20:51.201294+01:00' ],		#prior : OmReference [ '85' ],		#self : OmReference [ '86' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'swap:',			#protocol : #unification,			#sourceCode : 'swap: aPair\r\t|left right|\r\tProp unificationTrace\r\tifTrue:[Transcript show:\'swaping : \'; show:aPair ;cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tsetOfPairs remove:aPair.\r\tself add: (Pair left: right right: left).\r\t',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'swap:',			#protocol : #unification,			#sourceCode : 'swap: aPair\r\t"Swap primitive for the Robinson algorithm"\r\t|left right|\r\tProp unificationTrace\r\tifTrue:[Transcript show:\'swaping : \'; show:aPair ;cr.].\r\t\r\tleft:=aPair left.\r\tright:=aPair right.\r\tsetOfPairs remove:aPair.\r\tself add: (Pair left: right right: left).\r\t',			#stamp : 'pm 12/21/2018 11:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:21:18.395976+01:00' ],		#prior : OmReference [ '86' ],		#self : OmReference [ '87' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFuncTerm)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:["Decompose is possible"\r\t\t\t\tself decompose:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t]\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:[\r\t\t\tright isLinkedTerm\t\t\t\r\t\t\tifTrue:[\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t]\r\t\t\tifFalse:["it\'s a const term"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible :=true.\t\t\t\t\r\t\t\t\t]\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\tleft=right\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\tnotPossible:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/15/2018 19:55',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t"Try every operation for the Robinson algorithm."\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFuncTerm)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:["Decompose is possible"\r\t\t\t\tself decompose:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t]\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:[\r\t\t\tright isLinkedTerm\t\t\t\r\t\t\tifTrue:[\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t]\r\t\t\tifFalse:["it\'s a const term"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible :=true.\t\t\t\t\r\t\t\t\t]\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\tleft=right\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\tnotPossible:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/21/2018 11:21',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:21:26.807561+01:00' ],		#prior : OmReference [ '87' ],		#self : OmReference [ '88' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperationsOld:',			#protocol : #unification,			#sourceCode : 'tryOperationsOld: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t\r\t((left isConstTerm) and:[right isConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.]"delete"\r\t\tifFalse:[\t\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].]\r\tifFalse:[\r\t\t(((left isFuncTerm) and:[right isFuncTerm])\r\t\tor:[(left isPredicate) and:[right isPredicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(((left isConst) and:[right isLinkedTerm.])\r\t\t\tor:[left isFuncTerm])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isLinkedTerm) \r\t\t\t\tand:[(right isLinkedTerm) or:[right isConst]])"eliminate if x=t or x=f(t)[...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isLinkedTerm) and:[right isFuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 14:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:21:40.666321+01:00' ],		#prior : OmReference [ '88' ],		#self : OmReference [ '89' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifiedPair,			#protocol : #unification,			#sourceCode : 'unifiedPair\r\t^unifiedPair. ',			#stamp : 'pm 10/25/2018 08:36',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifiedPair,			#protocol : #unification,			#sourceCode : 'unifiedPair\r\t"accessor"\r\t^unifiedPair. ',			#stamp : 'pm 12/21/2018 11:21',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:22:00.209814+01:00' ],		#prior : OmReference [ '89' ],		#self : OmReference [ '90' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\t[ modified ]\r\twhileTrue:[\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp unificationTrace ifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right"=not possible"\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\t"Transcript show: \'Unification impossible\'; cr."\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\thasFailed:=true.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t\r\t\t]. ',			#stamp : 'pm 12/15/2018 13:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t"Loop for the unification process"\r\t| modified operationAnswer i |\r\tmodified := true.\r\t[ modified ]\r\twhileTrue:[\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp unificationTrace ifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right"=not possible"\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\t"Transcript show: \'Unification impossible\'; cr."\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\thasFailed:=true.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t\r\t\t]. ',			#stamp : 'pm 12/21/2018 11:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:22:46.260918+01:00' ],		#prior : OmReference [ '90' ],		#self : OmReference [ '91' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t\r\t(hasFailed)\r\tifTrue:[\r\t\tunifiedPair := nil."Failed to unify anything"\r\t\t^nil."return value doesn\'t matter, we just want to breakout."\r\t\t].\r\r\tunifiedPair := initialPair veryDeepCopy.\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\t"((((each left) isConst) not) and:[(each right) isConst])\r\t\t\t\tifTrue:[""They both should be predicates, so they can use replace: by:"\r\t\t\t\t\t(unifiedPair left) replace: (each left) by: (each right).\r\t\t\t\t\t(unifiedPair right) replace: (each left) by: (each right).\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t"]."\r\t"else it was already the same  predicate"',			#stamp : 'pm 12/15/2018 14:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\t"apply the result of the unification to the base pair."\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t\r\t(hasFailed)\r\tifTrue:[\r\t\tunifiedPair := nil."Failed to unify anything"\r\t\t^nil."return value doesn\'t matter, we just want to breakout."\r\t\t].\r\r\tunifiedPair := initialPair veryDeepCopy.\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\t"((((each left) isConst) not) and:[(each right) isConst])\r\t\t\t\tifTrue:[""They both should be predicates, so they can use replace: by:"\r\t\t\t\t\t(unifiedPair left) replace: (each left) by: (each right).\r\t\t\t\t\t(unifiedPair right) replace: (each left) by: (each right).\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t"]."\r\t"else it was already the same  predicate"',			#stamp : 'pm 12/21/2018 11:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:22:50.355389+01:00' ],		#prior : OmReference [ '91' ],		#self : OmReference [ '92' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\t"apply the result of the unification to the base pair."\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t\r\t(hasFailed)\r\tifTrue:[\r\t\tunifiedPair := nil."Failed to unify anything"\r\t\t^nil."return value doesn\'t matter, we just want to breakout."\r\t\t].\r\r\tunifiedPair := initialPair veryDeepCopy.\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\t"((((each left) isConst) not) and:[(each right) isConst])\r\t\t\t\tifTrue:[""They both should be predicates, so they can use replace: by:"\r\t\t\t\t\t(unifiedPair left) replace: (each left) by: (each right).\r\t\t\t\t\t(unifiedPair right) replace: (each left) by: (each right).\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t"]."\r\t"else it was already the same  predicate"',			#stamp : 'pm 12/21/2018 11:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\t"apply the result of the unification to the base pair."\r\t\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t\r\t(hasFailed)\r\tifTrue:[\r\t\tunifiedPair := nil."Failed to unify anything"\r\t\t^nil."return value doesn\'t matter, we just want to breakout."\r\t\t].\r\r\tunifiedPair := initialPair veryDeepCopy.\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\t"((((each left) isConst) not) and:[(each right) isConst])\r\t\t\t\tifTrue:[""They both should be predicates, so they can use replace: by:"\r\t\t\t\t\t(unifiedPair left) replace: (each left) by: (each right).\r\t\t\t\t\t(unifiedPair right) replace: (each left) by: (each right).\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t"]."\r\t"else it was already the same  predicate"',			#stamp : 'pm 12/21/2018 11:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:23:06.376231+01:00' ],		#prior : OmReference [ '92' ],		#self : OmReference [ '93' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Unifier\r\tinstanceVariableNames: \'setOfPairs hasFailed initialPair unifiedPair\'\r\tclassVariableNames: \'UnifiedTerm\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Clausal Form\''			},			#name : #Unifier,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #setOfPairs,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #hasFailed,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #initialPair,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #unifiedPair,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Unifier class\r\tinstanceVariableNames: \'\''				},				#name : #'Unifier class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Unifier,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent an Unifier object.\r\rMy purpose is to unify two predicate.\r\rPublic API and Key Messages\r\r-Unifier new: Predicate2:\r- UnifyThis -> will unify the two predicates\r\rp1:=Predicate new:(..)\rp2:=Predicate new:(...)\rUnifier new: p1 Predicate2:p2\r \rInstance Variables\r\thasFailed:\tBoolean to see if the unification failed.\r\rFor reference, the table of possible operations used is:\rVery unsure on some of those, but i\'m missing some examples.VERY unsure about  what to do on a const=Func or the other way arround.\r\r             =        |     const      |   Linked    |     Func\r        Const    |  Conflict     |  Swap       |   conflict\r                        |  Delete        |                    |\r                        |                       |                     | \r     Linked    | Eliminate  |  Delete     |    Check\r                        |                       |                     | \rFunc             | Conflict      |  Swap        |   Decompose\r                        |                       |                      |   Conflict\r                        |                       |                      | ',				#stamp : 'pm 12/21/2018 11:23'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #UnifiedTerm,					#parent : @7				}			],			#category : #'_resolution_1erOrdre-Clausal Form',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'I represent an Unifier object.\r\rMy purpose is to unify two predicate.\r\rPublic API and Key Messages\r\r-Unifier new: Predicate2:\r- UnifyThis\r\rp1:=Predicate new:(..)\rp2:=Predicate new:(...)\rUnifier new: p1 Predicate2:p2\r \rInstance Variables\r\thasFailed:\tBoolean to see if the unification failed.\r\rFor reference, the table of possible operations used is:\rVery unsure on some of those, but i\'m missing some examples.VERY unsure about  what to do on a const=Func or the other way arround.\r\r             =        |     const      |   Linked    |     Func\r        Const    |  Conflict     |  Swap       |   conflict\r                        |  Delete        |                    |\r                        |                       |                     | \r     Linked    | Eliminate  |  Delete     |    Check\r                        |                       |                     | \rFunc             | Conflict      |  Swap        |   Decompose\r                        |                       |                      |   Conflict\r                        |                       |                      | ',		#newComment : 'I represent an Unifier object.\r\rMy purpose is to unify two predicate.\r\rPublic API and Key Messages\r\r-Unifier new: Predicate2:\r- UnifyThis -> will unify the two predicates\r\rp1:=Predicate new:(..)\rp2:=Predicate new:(...)\rUnifier new: p1 Predicate2:p2\r \rInstance Variables\r\thasFailed:\tBoolean to see if the unification failed.\r\rFor reference, the table of possible operations used is:\rVery unsure on some of those, but i\'m missing some examples.VERY unsure about  what to do on a const=Func or the other way arround.\r\r             =        |     const      |   Linked    |     Func\r        Const    |  Conflict     |  Swap       |   conflict\r                        |  Delete        |                    |\r                        |                       |                     | \r     Linked    | Eliminate  |  Delete     |    Check\r                        |                       |                     | \rFunc             | Conflict      |  Swap        |   Decompose\r                        |                       |                      |   Conflict\r                        |                       |                      | ',		#oldStamp : 'pm 12/19/2018 17:53',		#newStamp : 'pm 12/21/2018 11:23'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:24:17.509958+01:00' ],		#prior : OmReference [ '93' ],		#self : OmReference [ '94' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"initlize of the class, which is the chosen name for an anonymous const terms and the number of the first anonymous const term"\r\tfactoryVar:=\'c\'.\r\tfactoryNum:=0.',			#stamp : 'pm 11/5/2018 09:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ConstTerm class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\t"initialize of the class, which is the chosen name for an anonymous const terms and the number of the first anonymous const term"\r\tfactoryVar:=\'c\'.\r\tfactoryNum:=0.',			#stamp : 'pm 12/21/2018 11:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:25:23.753313+01:00' ],		#prior : OmReference [ '94' ],		#self : OmReference [ '95' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Constant class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t^self basicNew.',			#stamp : 'pm 12/7/2018 17:19',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Constant class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t"new for constants"\r\t^self basicNew.',			#stamp : 'pm 12/21/2018 11:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:25:30.4572+01:00' ],		#prior : OmReference [ '95' ],		#self : OmReference [ '96' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Constant class',				#isMetaSide : true			},			#name : #symb,			#protocol : #accessing,			#sourceCode : 'symb\r\t^symb',			#stamp : 'pm 11/28/2018 01:13',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Constant class',				#isMetaSide : true			},			#name : #symb,			#protocol : #accessing,			#sourceCode : 'symb\r\t"accessor"\r\t^symb',			#stamp : 'pm 12/21/2018 11:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:25:45.429927+01:00' ],		#prior : OmReference [ '96' ],		#self : OmReference [ '97' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'False_Const class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialize,			#sourceCode : 'initialize\r\tsymb:=\'F\'.',			#stamp : 'pm 9/28/2018 20:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'False_Const class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialize,			#sourceCode : 'initialize\r\t"the output symbol"\r\tsymb:=\'F\'.',			#stamp : 'pm 12/21/2018 11:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:25:54.723013+01:00' ],		#prior : OmReference [ '97' ],		#self : OmReference [ '98' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'False_Const class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialize,			#sourceCode : 'initialize\r\t"the output symbol"\r\tsymb:=\'F\'.',			#stamp : 'pm 12/21/2018 11:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'False_Const class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialize,			#sourceCode : 'initialize\r\t"the chosen output symbol"\r\tsymb:=\'F\'.',			#stamp : 'pm 12/21/2018 11:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:25:59.63905+01:00' ],		#prior : OmReference [ '98' ],		#self : OmReference [ '99' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'True_Const class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialize,			#sourceCode : 'initialize\r\tsymb:=\'T\'.',			#stamp : 'pm 9/28/2018 20:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'True_Const class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialize,			#sourceCode : 'initialize\r\t"the chosen output symbol"\r\tsymb:=\'T\'.',			#stamp : 'pm 12/21/2018 11:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:27:09.708556+01:00' ],		#prior : OmReference [ '99' ],		#self : OmReference [ '100' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Var class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #initialize,			#sourceCode : 'new: varName\r\t^self basicNew initialize: varName.',			#stamp : 'pm 9/28/2018 20:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Var class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #initialize,			#sourceCode : 'new: varName\r\t"basic creator, that takes a string as a name"\r\t^self basicNew initialize: varName.',			#stamp : 'pm 12/21/2018 11:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:29:15.89405+01:00' ],		#prior : OmReference [ '100' ],		#self : OmReference [ '101' ]	},	#content : EpMonticelloVersionSave {		#versionName : '_resolution_1erOrdre-pm.10',		#repositoryDescription : '/home/ariale/FORM/pharo6.1-64/shared/pharo-local/package-cache'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:29:16.019455+01:00' ],		#prior : OmReference [ '101' ],		#self : OmReference [ '102' ]	},	#content : EpMonticelloVersionSave {		#versionName : '_resolution_1erOrdre-pm.10',		#repositoryDescription : '/home/ariale/FORM/pharo6.1-64/Sources'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:36:43.939658+01:00' ],		#prior : OmReference [ '102' ],		#self : OmReference [ '103' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'ResolutionSteps clausificationTrace resolutionTrace skolemnTrace testNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @7,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r-AmIValid -> launch the full process to check if a proposition is valid \r\r\r-launchRenameVariables -> differenciate same names that aren\'t related\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- fullClausification -> return a Clausified version of  a Proposition\r- prettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 12/21/2018 11:36'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #ResolutionSteps,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- fullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- prettyPrint -> returns a string representing my  internal state.',		#newComment : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r-AmIValid -> launch the full process to check if a proposition is valid \r\r\r-launchRenameVariables -> differenciate same names that aren\'t related\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- fullClausification -> return a Clausified version of  a Proposition\r- prettyPrint -> returns a string representing my  internal state.',		#oldStamp : 'pm 12/15/2018 15:14',		#newStamp : 'pm 12/21/2018 11:36'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:36:45.471927+01:00' ],		#prior : OmReference [ '103' ],		#self : OmReference [ '104' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'ResolutionSteps clausificationTrace resolutionTrace skolemnTrace testNumber unificationTrace\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Propositions\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @7,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r-AmIValid -> launch the full process to check if a proposition is valid \r\r-launchRenameVariables -> differenciate same names that aren\'t related\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- fullClausification -> return a Clausified version of  a Proposition\r- prettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 12/21/2018 11:36'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #ResolutionSteps,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #clausificationTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #resolutionTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #skolemnTrace,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #testNumber,					#parent : @7				},				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Prop,						#isMetaSide : false					},					#name : #unificationTrace,					#parent : @7				}			],			#category : #_resolution_1erOrdre-Propositions,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r-AmIValid -> launch the full process to check if a proposition is valid \r\r\r-launchRenameVariables -> differenciate same names that aren\'t related\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- fullClausification -> return a Clausified version of  a Proposition\r- prettyPrint -> returns a string representing my  internal state.',		#newComment : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r-AmIValid -> launch the full process to check if a proposition is valid \r\r-launchRenameVariables -> differenciate same names that aren\'t related\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- fullClausification -> return a Clausified version of  a Proposition\r- prettyPrint -> returns a string representing my  internal state.',		#oldStamp : 'pm 12/21/2018 11:36',		#newStamp : 'pm 12/21/2018 11:36'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:38:26.927922+01:00' ],		#prior : OmReference [ '104' ],		#self : OmReference [ '105' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestGeneral\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestGeneral,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestGeneral class\r\tinstanceVariableNames: \'\''				},				#name : #'TestGeneral class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestGeneral,					#isMetaSide : false				},				#parent : @7,				#content : 'General testing for smaller process',				#stamp : 'pm 12/21/2018 11:38'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'General testing for smaller process',		#newStamp : 'pm 12/21/2018 11:38'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:38:28.310879+01:00' ],		#prior : OmReference [ '105' ],		#self : OmReference [ '106' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'TestCase',				#traitCompositionSource : '{}',				#definitionSource : 'TestCase subclass: #TestGeneral\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Testing class\''			},			#name : #TestGeneral,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'TestGeneral class\r\tinstanceVariableNames: \'\''				},				#name : #'TestGeneral class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #TestGeneral,					#isMetaSide : false				},				#parent : @7,				#content : 'General testing for smaller processes',				#stamp : 'pm 12/21/2018 11:38'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Testing class',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'General testing for smaller process',		#newComment : 'General testing for smaller processes',		#oldStamp : 'pm 12/21/2018 11:38',		#newStamp : 'pm 12/21/2018 11:38'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:46:04.945377+01:00' ],		#prior : OmReference [ '106' ],		#self : OmReference [ '107' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestresolutionerOrdre class',				#isMetaSide : true			},			#name : #ruleCodeCruftLeftInMethodsRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleCodeCruftLeftInMethodsRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#\'Prop class\' #testEverything #true)) #\'2018-12-19T20:39:57.001145+01:00\') #(#(#RGMethodDefinition #(#\'Prop class\' #testingMatch #true)) #\'2018-12-19T20:39:57.001483+01:00\') #(#(#RGMethodDefinition #(#\'Prop class\' #testingSkolemn #true)) #\'2018-12-19T20:39:57.001316+01:00\') )',			#stamp : 'pm 12/19/2018 20:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestresolutionerOrdre class',				#isMetaSide : true			},			#name : #ruleCodeCruftLeftInMethodsRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleCodeCruftLeftInMethodsRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#\'Prop class\' #testEverything #true)) #\'2018-12-19T20:39:57.001145+01:00\') #(#(#RGMethodDefinition #(#\'Prop class\' #testingMatch #true)) #\'2018-12-19T20:39:57.001483+01:00\') #(#(#RGMethodDefinition #(#\'Prop class\' #testingSkolemn #true)) #\'2018-12-19T20:39:57.001316+01:00\') #(#(#RGMethodDefinition #(#Prop #skolemisationTest #false)) #\'2018-12-21T11:46:04.935164+01:00\') )',			#stamp : 'pm 12/21/2018 11:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:46:04.961919+01:00' ],		#prior : OmReference [ '107' ],		#self : OmReference [ '108' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestresolutionerOrdre class',				#isMetaSide : true			},			#name : #ruleMissingSubclassResponsibilityRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleMissingSubclassResponsibilityRuleV1FalsePositive\r\t^ #()',			#stamp : 'pm 12/21/2018 11:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:46:04.964587+01:00' ],		#prior : OmReference [ '108' ],		#self : OmReference [ '109' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestresolutionerOrdre class',				#isMetaSide : true			},			#name : #ruleMissingSubclassResponsibilityRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleMissingSubclassResponsibilityRuleV1FalsePositive\r\t^ #()',			#stamp : 'pm 12/21/2018 11:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestresolutionerOrdre class',				#isMetaSide : true			},			#name : #ruleMissingSubclassResponsibilityRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleMissingSubclassResponsibilityRuleV1FalsePositive\r\t^ #(#(#(#RGClassDefinition #(#AbstractTerm)) #\'2018-12-21T11:46:04.962318+01:00\') )',			#stamp : 'pm 12/21/2018 11:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:46:04.980034+01:00' ],		#prior : OmReference [ '109' ],		#self : OmReference [ '110' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestresolutionerOrdre class',				#isMetaSide : true			},			#name : #ruleUsesAddRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleUsesAddRuleV1FalsePositive\r\t^ #()',			#stamp : 'pm 12/21/2018 11:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-21T11:46:04.985694+01:00' ],		#prior : OmReference [ '110' ],		#self : OmReference [ '111' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestresolutionerOrdre class',				#isMetaSide : true			},			#name : #ruleUsesAddRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleUsesAddRuleV1FalsePositive\r\t^ #()',			#stamp : 'pm 12/21/2018 11:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'ManifestresolutionerOrdre class',				#isMetaSide : true			},			#name : #ruleUsesAddRuleV1FalsePositive,			#protocol : #code-critics,			#sourceCode : 'ruleUsesAddRuleV1FalsePositive\r\t^ #(#(#(#RGMethodDefinition #(#ClausalForm #addAll: #false)) #\'2018-12-21T11:46:04.98012+01:00\') )',			#stamp : 'pm 12/21/2018 11:46',			#package : #_resolution_1erOrdre		}	}}