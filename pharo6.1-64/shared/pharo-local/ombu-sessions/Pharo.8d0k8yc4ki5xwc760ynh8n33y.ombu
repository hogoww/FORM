OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T16:17:20.488888+02:00' ],		#prior : OmReference [ 'Pharo.ebb2sdcfkoz74h1vrmjzk2zgo', '167' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| newVars t|\r\tnewVars:=LinkedList new.\r\tTranscript show:setOfLinkedVar ;show:aMap ;cr.\r\tterms do: [ :each | newVars add: (each WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].\r\tTranscript show:self prettyPrint;cr.\r\tt:=(FuncTerm new: (self getSymb) Variables:newVars).\r\tTranscript show:t prettyPrint;cr.\r\t^t.',			#stamp : 'pm 10/11/2018 15:49',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t| newVars t|\r\tnewVars:=LinkedList new.\r\tterms do: [ :each | newVars add: (each WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].\r\tt:=(FuncTerm new: (self getSymb) Variables:newVars).\r\t^t.',			#stamp : 'pm 10/11/2018 16:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T16:17:41.001229+02:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t| t |\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars: setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\tTranscript show:aMap;cr.\r\t^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.\t"(self class) new: ("\t")"\r\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 10/11/2018 16:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ForAll,				#isMetaSide : false			},			#name : #'Herbrandise:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'Herbrandise: setOfLinkedVar CorrespondingValue: aMap\r\t| t |\r\tt := setOfLinkedVar isEmpty\r\t\tifTrue: [ ConstTerm new ]"then it\'s a generated constant, same as an Exists"\r\t\tifFalse: [ FuncTerm newFuncWithVars: setOfLinkedVar ].\t\t"then it\'s a skolem function"\r\taMap add: (Association key: var value: t).\r\t^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.\t"(self class) new: ("\t")"\r\r\t"We don\'t keep the Quantifiers in the formula"',			#stamp : 'pm 10/11/2018 16:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T16:21:37.660187+02:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tTranscript show: self prettyPrint; show: \'  \' ; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: t prettyPrint; show: \'  \' ; cr;cr.\r\t^t',			#stamp : 'pm 10/8/2018 22:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\t\t\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr;cr.\r\tt:=self fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr.\r\t^t',			#stamp : 'pm 10/11/2018 16:21',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T16:23:02.37681+02:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint ;cr;cr.\r\r\r\tTranscript show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint ;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint;cr;cr.\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint;cr;cr.\r\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' ; cr.\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint;cr;cr.\r\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\t  p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r     Transcript show:p prettyPrint;cr.\t\r\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'\t ; cr.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r   Transcript show:p prettyPrint;cr.\t\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'; cr.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r   Transcript show:p prettyPrint;cr.\t\r\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/11/2018 16:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\r\tTranscript show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' ; cr.\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint;cr;cr.\r\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'\t ; cr.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r   Transcript show:p prettyPrint;cr.\t\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'; cr.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/11/2018 16:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T16:23:25.76755+02:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'debug\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Prop class',							#isMetaSide : true						},						#name : #debug,						#parent : @12					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @7,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- FullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- PrettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 10/9/2018 10:52'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'debug testNumber\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Prop class',							#isMetaSide : true						},						#name : #debug,						#parent : @28					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Prop class',							#isMetaSide : true						},						#name : #testNumber,						#parent : @28					}				],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @23,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- FullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- PrettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 10/9/2018 10:52'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T16:23:26.165067+02:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tdebug:=false.',			#stamp : 'pm 10/11/2018 09:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tdebug:=false.\r\ttestNumber:=0.',			#stamp : 'pm 10/11/2018 16:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T16:24:20.987559+02:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\t\t\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr;cr.\r\tt:=self fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr.\r\t^t',			#stamp : 'pm 10/11/2018 16:21',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\t\r\tTranscript show: \'test #\'; show:(Prop testNumber).\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr;cr.\r\tt:=self fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr.\r\t^t',			#stamp : 'pm 10/11/2018 16:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T16:24:39.890077+02:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\t\r\tTranscript show: \'test #\'; show:(Prop testNumber).\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr;cr.\r\tt:=self fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr.\r\t^t',			#stamp : 'pm 10/11/2018 16:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\t\r\tTranscript show: \'test #\'; show:(Prop testNumber).\r\tProp testInc.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr;cr.\r\tt:=self fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr.\r\t^t',			#stamp : 'pm 10/11/2018 16:24',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T16:25:17.501733+02:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testInc,			#protocol : #'as yet unclassified',			#sourceCode : 'testInc\r\ttestNumber:=testNumber+1.',			#stamp : 'pm 10/11/2018 16:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T16:25:17.698508+02:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testInc,			#protocol : #'as yet unclassified',			#sourceCode : 'testInc\r\ttestNumber:=testNumber+1.',			#stamp : 'pm 10/11/2018 16:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testInc,			#protocol : #tests,			#sourceCode : 'testInc\r\ttestNumber:=testNumber+1.',			#stamp : 'pm 10/11/2018 16:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T16:25:57.912914+02:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testNumber,			#protocol : #'as yet unclassified',			#sourceCode : 'testNumber\r\t^testNumber',			#stamp : 'pm 10/11/2018 16:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T16:25:57.993271+02:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testNumber,			#protocol : #'as yet unclassified',			#sourceCode : 'testNumber\r\t^testNumber',			#stamp : 'pm 10/11/2018 16:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testNumber,			#protocol : #accessing,			#sourceCode : 'testNumber\r\t^testNumber',			#stamp : 'pm 10/11/2018 16:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T16:26:59.118109+02:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\t\r\tTranscript show: \'test #\'; show:(Prop testNumber).\r\tProp testInc.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr;cr.\r\tt:=self fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr.\r\t^t',			#stamp : 'pm 10/11/2018 16:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr;cr.\r\tt:=self fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr.\r\t^t',			#stamp : 'pm 10/11/2018 16:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T16:28:11.689431+02:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr;cr.\r\tt:=self fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr.\r\t^t',			#stamp : 'pm 10/11/2018 16:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr;cr.\r\tt:=self fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr.\r\t^t',			#stamp : 'pm 10/11/2018 16:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T16:28:32.236571+02:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\r\tTranscript show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' ; cr.\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint;cr;cr.\r\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'\t ; cr.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r   Transcript show:p prettyPrint;cr.\t\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'; cr.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/11/2018 16:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\r\tTranscript show: \'basic one\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\r\tTranscript show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' ; cr.\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint;cr;cr.\r\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'\t ; cr.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r   Transcript show:p prettyPrint;cr.\t\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'; cr.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/11/2018 16:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T16:29:08.183188+02:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\r\tTranscript show: \'basic one\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\r\tTranscript show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' ; cr.\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint;cr;cr.\r\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t ; cr.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'\t ; cr.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r   Transcript show:p prettyPrint;cr.\t\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'; cr.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/11/2018 16:28',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\r\tTranscript show: \'basic one\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\r\tTranscript show: \'with imply and nested forall.\'.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\'.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\'.\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' .\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint;cr;cr.\r\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r   Transcript show:p prettyPrint;cr.\t\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/11/2018 16:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T16:29:27.138872+02:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr;cr.\r\tt:=self fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr.\r\t^t',			#stamp : 'pm 10/11/2018 16:28',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber).\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr;cr.\r\tt:=self fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr.\r\t^t',			#stamp : 'pm 10/11/2018 16:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T16:31:44.098366+02:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber).\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr;cr.\r\tt:=self fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr.\r\t^t',			#stamp : 'pm 10/11/2018 16:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr;cr.\r\tt:=self fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr.\r\t^t',			#stamp : 'pm 10/11/2018 16:31',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T16:39:13.976776+02:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr;cr.\r\tt:=self fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr.\r\t^t',			#stamp : 'pm 10/11/2018 16:31',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr.\r\t^t',			#stamp : 'pm 10/11/2018 16:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T16:40:57.519895+02:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\r\tTranscript show: \'basic one\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\r\tTranscript show: \'with imply and nested forall.\'.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\'.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\'.\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' .\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint;cr;cr.\r\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r   Transcript show:p prettyPrint;cr.\t\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/11/2018 16:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\r\tTranscript show: \'basic one\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\r\tTranscript show: \'with imply and nested forall.\'.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\'.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\'.\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' .\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint;cr;cr.\r\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest .\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/11/2018 16:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T16:41:19.180943+02:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\r\tTranscript show: \'basic one\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\r\tTranscript show: \'with imply and nested forall.\'.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\'.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\'.\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' .\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r        p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r        Transcript show:p prettyPrint;cr;cr.\r\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest .\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/11/2018 16:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\r\tTranscript show: \'basic one\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\r\tTranscript show: \'with imply and nested forall.\'.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\'.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\'.\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' .\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r\tp SkolemnisationTest.\r\t\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest .\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/11/2018 16:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-11T16:42:26.797862+02:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr.\r\t^t',			#stamp : 'pm 10/11/2018 16:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr;cr.\r\t^t',			#stamp : 'pm 10/11/2018 16:42',			#package : #_resolution_1erOrdre		}	}}