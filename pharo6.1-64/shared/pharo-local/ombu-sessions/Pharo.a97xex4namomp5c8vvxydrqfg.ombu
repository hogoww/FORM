OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-27T21:57:12.974445+02:00' ],		#prior : OmReference [ 'Pharo.971mkgoj2vpz6lxin8bd23axh', '5' ],		#self : OmReference [ '1' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #ClausalForm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ClausalForm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClausalForm class\r\tinstanceVariableNames: \'\''				},				#name : #'ClausalForm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClausalForm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions.\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\rPublic API and Key Messages\r\r- resolutionMethod : I\'m using the resolutionMethod on myself\r\r   One simple example is simply gorgeous.\r \rInternal Representation and Key Implementation Points.\r\r    Instance Variables\r\tclauses:\t\t<Object>\r\r\r    Implementation Points',				#stamp : 'pm 10/27/2018 21:57'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions.\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\r\rPublic API and Key Messages\r\r- message one   \r- message two \r- (for bonus points) how to create instances.\r\r   One simple example is simply gorgeous.\r \rInternal Representation and Key Implementation Points.\r\r    Instance Variables\r\tclauses:\t\t<Object>\r\r\r    Implementation Points',		#newComment : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions.\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\rPublic API and Key Messages\r\r- resolutionMethod : I\'m using the resolutionMethod on myself\r\r   One simple example is simply gorgeous.\r \rInternal Representation and Key Implementation Points.\r\r    Instance Variables\r\tclauses:\t\t<Object>\r\r\r    Implementation Points',		#oldStamp : 'pm 10/23/2018 12:16',		#newStamp : 'pm 10/27/2018 21:57'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-27T21:57:34.503906+02:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #ClausalForm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ClausalForm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClausalForm class\r\tinstanceVariableNames: \'\''				},				#name : #'ClausalForm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClausalForm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions.\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\rPublic API and Key Messages\r\r- resolutionMethod : I\'m using the resolutionMethod on myself\r\r \rInternal Representation and Key Implementation Points.\r\r    Instance Variables\r\tclauses:\t\t<Object>\r\r\r    Implementation Points',				#stamp : 'pm 10/27/2018 21:57'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions.\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\rPublic API and Key Messages\r\r- resolutionMethod : I\'m using the resolutionMethod on myself\r\r   One simple example is simply gorgeous.\r \rInternal Representation and Key Implementation Points.\r\r    Instance Variables\r\tclauses:\t\t<Object>\r\r\r    Implementation Points',		#newComment : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions.\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\rPublic API and Key Messages\r\r- resolutionMethod : I\'m using the resolutionMethod on myself\r\r \rInternal Representation and Key Implementation Points.\r\r    Instance Variables\r\tclauses:\t\t<Object>\r\r\r    Implementation Points',		#oldStamp : 'pm 10/27/2018 21:57',		#newStamp : 'pm 10/27/2018 21:57'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-27T21:58:27.669377+02:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #ClausalForm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ClausalForm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClausalForm class\r\tinstanceVariableNames: \'\''				},				#name : #'ClausalForm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClausalForm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions.\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\rPublic API and Key Messages\r\r- resolutionMethod : I\'m using the resolutionMethod on myself\r\rI can be created empty or with a Prop object as input.\r\rClausalForm new: aFullProp. \r',				#stamp : 'pm 10/27/2018 21:58'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions.\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\rPublic API and Key Messages\r\r- resolutionMethod : I\'m using the resolutionMethod on myself\r\r \rInternal Representation and Key Implementation Points.\r\r    Instance Variables\r\tclauses:\t\t<Object>\r\r\r    Implementation Points',		#newComment : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions.\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\rPublic API and Key Messages\r\r- resolutionMethod : I\'m using the resolutionMethod on myself\r\rI can be created empty or with a Prop object as input.\r\rClausalForm new: aFullProp. \r',		#oldStamp : 'pm 10/27/2018 21:57',		#newStamp : 'pm 10/27/2018 21:58'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-27T21:59:38.154938+02:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #Clause\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Clause,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Clause class\r\tinstanceVariableNames: \'\''				},				#name : #'Clause class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Clause,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a clause, which is a set of predicate (positive or negative)  related by a variadic Or operator.\r\rFor the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.\r\rFor the Collaborators Part: State my main collaborators and one line about how I interact with them. \r\rPublic API and Key Messages\r\r- message one   \r- message two \r- (for bonus points) how to create instances.\r\r   One simple example is simply gorgeous.\r \rInternal Representation and Key Implementation Points.\r\r\r    Implementation Points',				#stamp : 'pm 10/27/2018 21:59'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'I represent a clause, which is a set of predicate (positive or negative)  related by a variadic Or operator.\r\rFor the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.\r\rFor the Collaborators Part: State my main collaborators and one line about how I interact with them. \r\rPublic API and Key Messages\r\r- message one   \r- message two \r- (for bonus points) how to create instances.\r\r   One simple example is simply gorgeous.\r \rInternal Representation and Key Implementation Points.\r\r\r    Implementation Points',		#newStamp : 'pm 10/27/2018 21:59'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-27T22:00:09.292997+02:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #ClausalForm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ClausalForm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClausalForm class\r\tinstanceVariableNames: \'\''				},				#name : #'ClausalForm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClausalForm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions(Clauses).\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\rPublic API and Key Messages\r\r- resolutionMethod : I\'m using the resolutionMethod on myself\r\rI can be created empty or with a Prop object as input.\r\rClausalForm new: aFullProp. \r',				#stamp : 'pm 10/27/2018 22:00'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions.\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\rPublic API and Key Messages\r\r- resolutionMethod : I\'m using the resolutionMethod on myself\r\rI can be created empty or with a Prop object as input.\r\rClausalForm new: aFullProp. \r',		#newComment : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions(Clauses).\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\rPublic API and Key Messages\r\r- resolutionMethod : I\'m using the resolutionMethod on myself\r\rI can be created empty or with a Prop object as input.\r\rClausalForm new: aFullProp. \r',		#oldStamp : 'pm 10/27/2018 21:58',		#newStamp : 'pm 10/27/2018 22:00'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-27T22:00:16.672383+02:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #Clause\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Clause,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Clause class\r\tinstanceVariableNames: \'\''				},				#name : #'Clause class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Clause,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a clause, which is a set of predicate (positive or negative)  related by a variadic Or operator.\r\r\rFor the Collaborators Part: State my main collaborators and one line about how I interact with them. \r\rPublic API and Key Messages\r\r- message one   \r- message two \r- (for bonus points) how to create instances.\r\r   One simple example is simply gorgeous.\r \rInternal Representation and Key Implementation Points.\r\r\r    Implementation Points',				#stamp : 'pm 10/27/2018 22:00'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'I represent a clause, which is a set of predicate (positive or negative)  related by a variadic Or operator.\r\rFor the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.\r\rFor the Collaborators Part: State my main collaborators and one line about how I interact with them. \r\rPublic API and Key Messages\r\r- message one   \r- message two \r- (for bonus points) how to create instances.\r\r   One simple example is simply gorgeous.\r \rInternal Representation and Key Implementation Points.\r\r\r    Implementation Points',		#newComment : 'I represent a clause, which is a set of predicate (positive or negative)  related by a variadic Or operator.\r\r\rFor the Collaborators Part: State my main collaborators and one line about how I interact with them. \r\rPublic API and Key Messages\r\r- message one   \r- message two \r- (for bonus points) how to create instances.\r\r   One simple example is simply gorgeous.\r \rInternal Representation and Key Implementation Points.\r\r\r    Implementation Points',		#oldStamp : 'pm 10/27/2018 21:59',		#newStamp : 'pm 10/27/2018 22:00'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-27T22:03:22.908006+02:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #ClausalForm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ClausalForm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClausalForm class\r\tinstanceVariableNames: \'\''				},				#name : #'ClausalForm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClausalForm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions(Clauses).\r\rI\'m conceived to be instanciated by  the method "amIValid, of propositions"\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\rPublic API and Key Messages\r\r- resolutionMethod : I\'m using the resolutionMethod on myself\r\rI can be created empty or with a Prop object as input.\r\rClausalForm new: aFullProp. \r',				#stamp : 'pm 10/27/2018 22:03'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions(Clauses).\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\rPublic API and Key Messages\r\r- resolutionMethod : I\'m using the resolutionMethod on myself\r\rI can be created empty or with a Prop object as input.\r\rClausalForm new: aFullProp. \r',		#newComment : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions(Clauses).\r\rI\'m conceived to be instanciated by  the method "amIValid, of propositions"\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\rPublic API and Key Messages\r\r- resolutionMethod : I\'m using the resolutionMethod on myself\r\rI can be created empty or with a Prop object as input.\r\rClausalForm new: aFullProp. \r',		#oldStamp : 'pm 10/27/2018 22:00',		#newStamp : 'pm 10/27/2018 22:03'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-27T22:04:00.700303+02:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #Clause\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Clause,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Clause class\r\tinstanceVariableNames: \'\''				},				#name : #'Clause class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Clause,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a clause, which is a set of predicate (positive or negative)  related by a variadic Or operator.\r\rI should be instanciated by ClausalForm only.\r\rPublic API and Key Messages\r\r- message one   \r- message two \r- (for bonus points) how to create instances.\r\r   One simple example is simply gorgeous.\r \rInternal Representation and Key Implementation Points.\r\r\r    Implementation Points',				#stamp : 'pm 10/27/2018 22:04'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'I represent a clause, which is a set of predicate (positive or negative)  related by a variadic Or operator.\r\r\rFor the Collaborators Part: State my main collaborators and one line about how I interact with them. \r\rPublic API and Key Messages\r\r- message one   \r- message two \r- (for bonus points) how to create instances.\r\r   One simple example is simply gorgeous.\r \rInternal Representation and Key Implementation Points.\r\r\r    Implementation Points',		#newComment : 'I represent a clause, which is a set of predicate (positive or negative)  related by a variadic Or operator.\r\rI should be instanciated by ClausalForm only.\r\rPublic API and Key Messages\r\r- message one   \r- message two \r- (for bonus points) how to create instances.\r\r   One simple example is simply gorgeous.\r \rInternal Representation and Key Implementation Points.\r\r\r    Implementation Points',		#oldStamp : 'pm 10/27/2018 22:00',		#newStamp : 'pm 10/27/2018 22:04'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-27T22:04:22.233028+02:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #Clause\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Clause,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Clause class\r\tinstanceVariableNames: \'\''				},				#name : #'Clause class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Clause,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a clause, which is a set of predicate (positive or negative)  related by a variadic Or operator.\r\rI should be instanciated by ClausalForm only.\r',				#stamp : 'pm 10/27/2018 22:04'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'I represent a clause, which is a set of predicate (positive or negative)  related by a variadic Or operator.\r\rI should be instanciated by ClausalForm only.\r\rPublic API and Key Messages\r\r- message one   \r- message two \r- (for bonus points) how to create instances.\r\r   One simple example is simply gorgeous.\r \rInternal Representation and Key Implementation Points.\r\r\r    Implementation Points',		#newComment : 'I represent a clause, which is a set of predicate (positive or negative)  related by a variadic Or operator.\r\rI should be instanciated by ClausalForm only.\r',		#oldStamp : 'pm 10/27/2018 22:04',		#newStamp : 'pm 10/27/2018 22:04'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-27T22:04:49.37976+02:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #Resolvante\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Resolvante,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Resolvante class\r\tinstanceVariableNames: \'\''				},				#name : #'Resolvante class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Resolvante,					#isMetaSide : false				},				#parent : @7,				#content : 'Utility class for ClausalForm::ResolutionMethod.',				#stamp : 'pm 10/27/2018 22:04'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : '',		#newComment : 'Utility class for ClausalForm::ResolutionMethod.',		#newStamp : 'pm 10/27/2018 22:04'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-27T22:08:57.23227+02:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t(sub1=sub2)\r\t\t\t\tifTrue:[\r\t\t\t\t\t"newClause:=Clause new. We create a new clause with everything but the Atomes used"\r\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 21:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\r\t"self is an Unifier\r\taClause is the clause we want to factorise"\r\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t(sub1=sub2)\r\t\t\t\tifTrue:[\r\t\t\t\t\t"newClause:=Clause new. We create a new clause with everything but the Atomes used"\r\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/27/2018 22:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-27T22:09:01.742291+02:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #Resolvante\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Resolvante,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Resolvante class\r\tinstanceVariableNames: \'\''				},				#name : #'Resolvante class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Resolvante,					#isMetaSide : false				},				#parent : @7,				#content : 'Utility class for ClausalForm::ResolutionMethod.',				#stamp : 'pm 10/27/2018 22:04'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #adding	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-27T22:10:21.601013+02:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\r\t"self is an Unifier\r\taClause is the clause we want to factorise"\r\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t(sub1=sub2)\r\t\t\t\tifTrue:[\r\t\t\t\t\t"newClause:=Clause new. We create a new clause with everything but the Atomes used"\r\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/27/2018 22:08',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t"This method factorise positively AND negatively at the same time.\r\tself is an Unifier\r\taClause is the clause we want to factorise\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t(sub1=sub2)\r\t\t\t\tifTrue:[\r\t\t\t\t\t"newClause:=Clause new. We create a new clause with everything but the Atomes used"\r\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/27/2018 22:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-27T22:12:39.727546+02:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #methodeDeResolution,			#sourceCode : 'resolvante: aClause1 with: aClause2\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\t\r\t[ i<=(aClause1 size). ]\r\twhileTrue:[\r\t\ta1:=aClause1 at:i.\r\t\t\r\t\tj:=1.\r\t\t[ j<=(aClause2 size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause2 at:j.\r\r\t\t\t(a1 isOppositePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t(sub1=sub2)\r\t\t\t\tifTrue:[\r\t\t\t\t\t"newClause:=Clause new.we create a new clause with everything but the Atomes used"\r\t\t\t\t\tnewClause:=(aClause1 without:i).\r\t\t\t\t\tnewClause addFromList: (aClause2 without:j).\r\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/26/2018 22:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #methodeDeResolution,			#sourceCode : 'resolvante: aClause1 with: aClause2\r\t"This method gets all the resolvantes between aClause1 and aClause2, modulo a subtitution of two terms.\r\tself is an Unifier\r\taClause1 and aClause2 are the clauses we want to get the resolvant off.\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\t\r\t[ i<=(aClause1 size). ]\r\twhileTrue:[\r\t\ta1:=aClause1 at:i.\r\t\t\r\t\tj:=1.\r\t\t[ j<=(aClause2 size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause2 at:j.\r\r\t\t\t(a1 isOppositePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t(sub1=sub2)\r\t\t\t\tifTrue:[\r\t\t\t\t\t"newClause:=Clause new.we create a new clause with everything but the Atomes used"\r\t\t\t\t\tnewClause:=(aClause1 without:i).\r\t\t\t\t\tnewClause addFromList: (aClause2 without:j).\r\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/27/2018 22:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-27T22:12:50.841556+02:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #methodeDeResolution,			#sourceCode : 'resolvante: aClause1 with: aClause2\r\t"This method gets all the resolvantes between aClause1 and aClause2, modulo a subtitution of two terms.\r\tself is an Unifier\r\taClause1 and aClause2 are the clauses we want to get the resolvant off.\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\t\r\t[ i<=(aClause1 size). ]\r\twhileTrue:[\r\t\ta1:=aClause1 at:i.\r\t\t\r\t\tj:=1.\r\t\t[ j<=(aClause2 size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause2 at:j.\r\r\t\t\t(a1 isOppositePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t(sub1=sub2)\r\t\t\t\tifTrue:[\r\t\t\t\t\t"newClause:=Clause new.we create a new clause with everything but the Atomes used"\r\t\t\t\t\tnewClause:=(aClause1 without:i).\r\t\t\t\t\tnewClause addFromList: (aClause2 without:j).\r\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/27/2018 22:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #methodeDeResolution,			#sourceCode : 'resolvante: aClause1 with: aClause2\r\t"This method gets all the resolvantes between aClause1 and aClause2, modulo a subtitution of two terms.\r\tself is an Unifier\r\taClause1 and aClause2 are the clauses we want to get the resolvant off.\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\t\r\t[ i<=(aClause1 size). ]\r\twhileTrue:[\r\t\ta1:=aClause1 at:i.\r\t\t\r\t\tj:=1.\r\t\t[ j<=(aClause2 size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause2 at:j.\r\r\t\t\t(a1 isOppositePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t(sub1=sub2)\r\t\t\t\tifTrue:[\r\t\t\t\t\t"newClause:=Clause new.we create a new clause with everything but the Atomes used"\r\t\t\t\t\tnewClause:=(aClause1 without:i).\r\t\t\t\t\tnewClause addFromList: (aClause2 without:j).\r\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/27/2018 22:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-27T22:13:02.057353+02:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t"This method factorise positively AND negatively at the same time.\r\tself is an Unifier\r\taClause is the clause we want to factorise\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t(sub1=sub2)\r\t\t\t\tifTrue:[\r\t\t\t\t\t"newClause:=Clause new. We create a new clause with everything but the Atomes used"\r\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/27/2018 22:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t"This method factorise positively AND negatively at the same time.\r\tself is an Unifier\r\taClause is the clause we want to factorise\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t(sub1=sub2)\r\t\t\t\tifTrue:[\r\t\t\t\t\t"newClause:=Clause new. We create a new clause with everything but the Atomes used"\r\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/27/2018 22:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-27T22:13:34.933266+02:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpBehaviorCommentChange {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Unifier\r\tinstanceVariableNames: \'setOfPairs hasFailed initialPair unifiedPair\'\r\tclassVariableNames: \'UnifiedTerm\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Unifier,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #setOfPairs,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #hasFailed,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #initialPair,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #unifiedPair,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Unifier class\r\tinstanceVariableNames: \'\''				},				#name : #'Unifier class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Unifier,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent an Unifier object.\r\rMy purpose is to unify two predicate.\r\rPublic API and Key Messages\r\r-Unifier new: Predicate2:\r- UnifyThis\r\rp1:=Predicate new:(..)\rp2:=Predicate new:(...)\rUnifier new: p1 Predicate2:p2\r \rInstance Variables\r\thasFailed:\tBoolean to see if the unification failed.\r',				#stamp : 'pm 10/27/2018 22:13'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #UnifiedTerm,					#parent : @7				}			],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#oldComment : 'I represent an Unifier object.\r\rMy purpose is to unify two predicate.\r\rPublic API and Key Messages\r\r-Unifier new: Predicate2:\r- UnifyThis\r\rp1:=Predicate new:(..)\rp2:=Predicate new:(...)\rUnifier new: p1 Predicate2:p2\r \rInternal Representation and Key Implementation Points.\r\r    Instance Variables\r\thasFailed:\tBoolean to see if the unification failed.\r\r\tPrivate:\r\tinitialPair:\t\t<Object>\r\tsetOfPairs:\t\t<Object>\r\r\r    Implementation Points',		#newComment : 'I represent an Unifier object.\r\rMy purpose is to unify two predicate.\r\rPublic API and Key Messages\r\r-Unifier new: Predicate2:\r- UnifyThis\r\rp1:=Predicate new:(..)\rp2:=Predicate new:(...)\rUnifier new: p1 Predicate2:p2\r \rInstance Variables\r\thasFailed:\tBoolean to see if the unification failed.\r',		#oldStamp : 'pm 10/23/2018 12:15',		#newStamp : 'pm 10/27/2018 22:13'	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-27T22:14:35.351849+02:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpProtocolAddition {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Prop\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Prop,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Prop class\r\tinstanceVariableNames: \'debug debugUnification testNumber unifDone resolutionTrace\''				},				#name : #'Prop class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Prop class',							#isMetaSide : true						},						#name : #debug,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Prop class',							#isMetaSide : true						},						#name : #debugUnification,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Prop class',							#isMetaSide : true						},						#name : #testNumber,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Prop class',							#isMetaSide : true						},						#name : #unifDone,						#parent : @12					},					RGClassInstanceVariableDefinition {						#annotations : IdentityDictionary {							#className : #'Prop class',							#isMetaSide : true						},						#name : #resolutionTrace,						#parent : @12					}				],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Prop,					#isMetaSide : false				},				#parent : @7,				#content : 'Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.\r\rI allow a proposition to be clausified.\rI allow propositions of First order to be skolemnise, then clausified\r\rPublic API:\r- FullClausification -> return a Clausified version of  a Proposition\r- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)\r- PrettyPrint -> returns a string representing my  internal state.',				#stamp : 'pm 10/9/2018 10:52'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #resolution	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-27T22:14:40.194905+02:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #'as yet unclassified',			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tTranscript show:\'Is \';show: self; show:\' valid?\';cr.\r\t\r\ttreatedProp:=Not new:self.\r\t\r\t(Prop resolutionTrace)ifTrue:[Transcript show: \'initial: \'; show: self prettyPrint; cr.].\r\tt:=treatedProp StartSkolemnisation.\r\t(Prop resolutionTrace)ifTrue:[Transcript show: \'Skolemn: \';show: t prettyPrint;cr.].\r\tt:=t fullClausification.\r\t(Prop resolutionTrace)ifTrue:[Transcript show: \'Clausified:\';show: t prettyPrint ;cr.].\r\tt:=ClausalForm new:t.\r\t(Prop resolutionTrace)ifTrue:[Transcript show: \'ClausalForm:\';show: t prettyPrint ;cr.].\r\tt:=t resolutionMethod.\r\r\tTranscript show:\'Resolution method:\' ;show:t;cr;cr;cr.\r\t^t ',			#stamp : 'pm 10/27/2018 08:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #amIValid,			#protocol : #resolution,			#sourceCode : 'amIValid\r\t|t treatedProp|\r\tProp testInc.\t\r\r\tTranscript show:\'Is \';show: self; show:\' valid?\';cr.\r\t\r\ttreatedProp:=Not new:self.\r\t\r\t(Prop resolutionTrace)ifTrue:[Transcript show: \'initial: \'; show: self prettyPrint; cr.].\r\tt:=treatedProp StartSkolemnisation.\r\t(Prop resolutionTrace)ifTrue:[Transcript show: \'Skolemn: \';show: t prettyPrint;cr.].\r\tt:=t fullClausification.\r\t(Prop resolutionTrace)ifTrue:[Transcript show: \'Clausified:\';show: t prettyPrint ;cr.].\r\tt:=ClausalForm new:t.\r\t(Prop resolutionTrace)ifTrue:[Transcript show: \'ClausalForm:\';show: t prettyPrint ;cr.].\r\tt:=t resolutionMethod.\r\r\tTranscript show:\'Resolution method:\' ;show:t;cr;cr;cr.\r\t^t ',			#stamp : 'pm 10/27/2018 08:33',			#package : #_resolution_1erOrdre		}	}}