OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-19T17:48:23.034602+02:00' ],		#prior : OmReference [ 'Pharo.1wfmfgix63evsmpfb9g586vwz', '9' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t(term = x term)\r\tifTrue:[term:=x.]\r\t',			#stamp : 'pm 10/18/2018 20:19',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t(term = x term)\r\tifTrue:[term:=t.]\r\t',			#stamp : 'pm 10/19/2018 17:48',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-19T18:02:00.863802+02:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t(term = x term)\r\tifTrue:[term:=t.]\r\t',			#stamp : 'pm 10/19/2018 17:48',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #UnaryTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t(term = x term)\r\tifTrue:[term:=t.]',			#stamp : 'pm 10/19/2018 18:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-19T18:02:17.994458+02:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:oldVersion:',			#protocol : #adding,			#sourceCode : 'replace:x by:t oldVersion:v\r\tterms do:[:each| each replace:x by:t].',			#stamp : 'pm 10/19/2018 18:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-19T18:07:32.803573+02:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\tterms do:[:each| each replace:x by:t].',			#stamp : 'pm 10/18/2018 19:53',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\tterms do:[:each| \r\t\t(each isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\teach replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((each term)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\teach term:x.\r\t\t\t\t]\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/19/2018 18:07',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-19T18:07:35.397476+02:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\tterms do:[:each| \r\t\t(each isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\teach replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((each term)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\teach term:x.\r\t\t\t\t]\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/19/2018 18:07',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\tterms do:[:each| \r\t\t(each isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\teach replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((each term)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\teach term:x.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/19/2018 18:07',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T08:10:19.981513+02:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\tterms do:[:each| \r\t\t(each isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\teach replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((each term)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\teach term:x.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/19/2018 18:07',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i term |\r\ti:=0.\r\t[i<self arity]\r\twhileFalse: [  \r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:1) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((term at:1)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:1 put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 08:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T08:10:24.194434+02:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i term |\r\ti:=0.\r\t[i<self arity]\r\twhileFalse: [  \r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:1) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((term at:1)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:1 put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 08:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i term |\r\ti:=0.\r\t[i<self arity]\r\twhileFalse: [  \r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:1) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:1)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:1 put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 08:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T08:10:32.69712+02:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i term |\r\ti:=0.\r\t[i<self arity]\r\twhileFalse: [  \r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:1) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:1)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:1 put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 08:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<self arity]\r\twhileFalse: [  \r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:1) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:1)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:1 put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 08:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T08:11:23.896025+02:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<self arity]\r\twhileFalse: [  \r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:1) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:1)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:1 put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 08:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<self arity]\r\twhileFalse: [  \r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 08:11',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T08:12:17.182493+02:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\tterms do:[:each| each replace:x by:t].',			#stamp : 'pm 10/18/2018 14:09',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<self arity]\r\twhileFalse: [  \r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 08:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T08:18:10.858099+02:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\tsetOfPairs do:[ :each | \r\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t].\r\t^initialPair',			#stamp : 'pm 10/19/2018 17:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:\'Trying to unify stuff\';cr.\r\tTranscript show:initialPair;cr.\r\tTranscript show:self;cr.\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\tsetOfPairs do:[ :each | \r\t\tTranscript show:each;cr.\r\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t].\r\t^initialPair',			#stamp : 'pm 10/20/2018 08:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T08:21:12.668368+02:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\taStream nextPutAll: (self prettyPrint)',			#stamp : 'pm 10/18/2018 17:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\taStream nextPutAll: (self prettyPrint).',			#stamp : 'pm 10/20/2018 08:21',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T08:21:58.075583+02:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t| t |\r\tt:=\'{\'.\r\tsetOfPairs do: [:each| t:=t,each prettyPrintUnifier.] separatedBy: [ t:=t,\',\'.].\r\tt:=t,\'}\'.\r\t^t',			#stamp : 'pm 10/18/2018 15:44',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t| t |\r\tt:=\'{\',setOfPairs.  "do: [:each| t:=t,each prettyPrintUnifier.] separatedBy: [ t:=t,\',\'.]."\r\tt:=t,\'}\'.\r\t^t',			#stamp : 'pm 10/20/2018 08:21',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T08:22:28.332222+02:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t| t |\r\tt:=\'{\',setOfPairs.  "do: [:each| t:=t,each prettyPrintUnifier.] separatedBy: [ t:=t,\',\'.]."\r\tt:=t,\'}\'.\r\t^t',			#stamp : 'pm 10/20/2018 08:21',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t| t |\r\tt:=\'{\'.\r\tsetOfPairs do: [:each| t:=t,each prettyPrintUnifier.] separatedBy: [ t:=t,\',\'.].\r\tt:=t,\'}\'.\r\t^t',			#stamp : 'pm 10/20/2018 08:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T08:23:46.814708+02:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t| t |\r\tt:=\'{\'.\r\tsetOfPairs do: [:each| t:=t,each prettyPrintUnifier.] separatedBy: [ t:=t,\',\'.].\r\tt:=t,\'}\'.\r\t^t',			#stamp : 'pm 10/20/2018 08:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t| t |\r\tt:=\'{\'.\r\tsetOfPairs do: [:each| t:=t,each prettyPrint.] separatedBy: [ t:=t,\',\'.].\r\tt:=t,\'}\'.\r\t^t',			#stamp : 'pm 10/20/2018 08:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T08:26:18.292101+02:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t| t |\r\tt:=\'{\'.\r\tsetOfPairs do: [:each| t:=t,each prettyPrint.] separatedBy: [ t:=t,\',\'.].\r\tt:=t,\'}\'.\r\t^t',			#stamp : 'pm 10/20/2018 08:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t| t |\r\tt:=\'{\'.\r\tsetOfPairs do: [:each| t:=t,each prettyPrintUnifier.] separatedBy: [ t:=t,\',\'.].\r\tt:=t,\'}\'.\r\t^t',			#stamp : 'pm 10/20/2018 08:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T08:31:55.058016+02:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tt:=\tt unifyThis.\r\tTranscript show:t;cr;cr.\r\t^t',			#stamp : 'pm 10/19/2018 17:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tt:=t unifyThis.\r\t(t isNil)\r\tifTrue:[\r\t\tTranscript show:t;cr;cr.\r\t]\r\tifFalse:[\r\t\tTranscript show: \'Unification failed.\';cr;cr.\r\t\t].\r\t^t',			#stamp : 'pm 10/20/2018 08:31',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T08:36:35.147052+02:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:\'Trying to unify stuff\';cr.\r\tTranscript show:initialPair;cr.\r\tTranscript show:self;cr.\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\tsetOfPairs do:[ :each | \r\t\tTranscript show:each;cr.\r\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t].\r\t^initialPair',			#stamp : 'pm 10/20/2018 08:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:\'Trying to unify stuff\';cr.\r\tTranscript show:initialPair;cr.\r\tTranscript show:self;cr.\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifTrue:[\r\t\t^nil."already the same predicate"\r\t\t]\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\tTranscript show:each;cr.\r\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t].\r\t\t].\r\t^initialPair',			#stamp : 'pm 10/20/2018 08:36',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T08:36:37.256251+02:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:\'Trying to unify stuff\';cr.\r\tTranscript show:initialPair;cr.\r\tTranscript show:self;cr.\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifTrue:[\r\t\t^nil."already the same predicate"\r\t\t]\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\tTranscript show:each;cr.\r\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t].\r\t\t].\r\t^initialPair',			#stamp : 'pm 10/20/2018 08:36',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:\'Trying to unify stuff\';cr.\r\tTranscript show:initialPair;cr.\r\tTranscript show:self;cr.\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifTrue:[\r\t\t^nil."already the same predicate "\r\t\t]\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\tTranscript show:each;cr.\r\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t].\r\t\t].\r\t^initialPair',			#stamp : 'pm 10/20/2018 08:36',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T08:36:38.089346+02:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:\'Trying to unify stuff\';cr.\r\tTranscript show:initialPair;cr.\r\tTranscript show:self;cr.\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifTrue:[\r\t\t^nil."already the same predicate "\r\t\t]\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\tTranscript show:each;cr.\r\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t].\r\t\t].\r\t^initialPair',			#stamp : 'pm 10/20/2018 08:36',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:\'Trying to unify stuff\';cr.\r\tTranscript show:initialPair;cr.\r\tTranscript show:self;cr.\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifTrue:[\r\t\t^nil."already the same predicate"\r\t\t]\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\tTranscript show:each;cr.\r\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t].\r\t\t].\r\t^initialPair',			#stamp : 'pm 10/20/2018 08:36',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T08:37:30.938469+02:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t| t |\r\tt:=\'{\'.\r\tsetOfPairs do: [:each| t:=t,each prettyPrintUnifier.] separatedBy: [ t:=t,\',\'.].\r\tt:=t,\'}\'.\r\t^t',			#stamp : 'pm 10/20/2018 08:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t| t |\r\tt:=\'{\'.\r\t(setOfPairs isNil)\r\tifTrue:[\r\t\tsetOfPairs do: [:each| t:=t,each prettyPrintUnifier.] separatedBy: [ t:=t,\',\'.].\r\t].\r\tt:=t,\'}\'.\r\t^t',			#stamp : 'pm 10/20/2018 08:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T08:37:34.814455+02:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t| t |\r\tt:=\'{\'.\r\t(setOfPairs isNil)\r\tifTrue:[\r\t\tsetOfPairs do: [:each| t:=t,each prettyPrintUnifier.] separatedBy: [ t:=t,\',\'.].\r\t].\r\tt:=t,\'}\'.\r\t^t',			#stamp : 'pm 10/20/2018 08:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t| t |\r\tt:=\'{\'.\r\t(setOfPairs isNil)\r\tifTrue:[\r\t\tsetOfPairs do: [:each| t:=t,each prettyPrintUnifier.] separatedBy: [ t:=t,\',\'.].\r\t\t].\r\tt:=t,\'}\'.\r\t^t',			#stamp : 'pm 10/20/2018 08:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T08:40:13.430747+02:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t| t |\r\tt:=\'{\'.\r\t(setOfPairs isNil)\r\tifTrue:[\r\t\tsetOfPairs do: [:each| t:=t,each prettyPrintUnifier.] separatedBy: [ t:=t,\',\'.].\r\t\t].\r\tt:=t,\'}\'.\r\t^t',			#stamp : 'pm 10/20/2018 08:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t| t |\r\tt:=\'{\'.\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do: [:each| t:=t,each prettyPrintUnifier.] separatedBy: [ t:=t,\',\'.].\r\t\t].\r\tt:=t,\'}\'.\r\t^t',			#stamp : 'pm 10/20/2018 08:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T08:46:44.143493+02:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:\'Trying to unify stuff\';cr.\r\tTranscript show:initialPair;cr.\r\tTranscript show:self;cr.\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifTrue:[\r\t\t^nil."already the same predicate"\r\t\t]\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\tTranscript show:each;cr.\r\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t].\r\t\t].\r\t^initialPair',			#stamp : 'pm 10/20/2018 08:36',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:\'Trying to unify stuff\';cr.\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifTrue:[\r\t\t^nil."already the same predicate"\r\t\t]\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\tTranscript show:each;cr.\r\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t].\r\t\t].\r\t^initialPair',			#stamp : 'pm 10/20/2018 08:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T08:53:49.622988+02:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #hasFailed,			#protocol : #'as yet unclassified',			#sourceCode : 'hasFailed\r\t^hasFailed',			#stamp : 'pm 10/20/2018 08:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T08:53:49.738337+02:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #hasFailed,			#protocol : #'as yet unclassified',			#sourceCode : 'hasFailed\r\t^hasFailed',			#stamp : 'pm 10/20/2018 08:53',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #hasFailed,			#protocol : #accessing,			#sourceCode : 'hasFailed\r\t^hasFailed',			#stamp : 'pm 10/20/2018 08:53',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T08:55:10.956341+02:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tt:=t unifyThis.\r\t(t isNil)\r\tifTrue:[\r\t\tTranscript show:t;cr;cr.\r\t]\r\tifFalse:[\r\t\tTranscript show: \'Unification failed.\';cr;cr.\r\t\t].\r\t^t',			#stamp : 'pm 10/20/2018 08:31',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tt:=t unifyThis.\r\t(t hasFailed)\r\tifTrue:[\r\t\tTranscript show:t;cr;cr.\r\t]\r\tifFalse:[\r\t\tTranscript show: \'Unification failed.\';cr;cr.\r\t\t].\r\t^t',			#stamp : 'pm 10/20/2018 08:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T08:55:23.029966+02:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tt:=t unifyThis.\r\t(t hasFailed)\r\tifTrue:[\r\t\tTranscript show:t;cr;cr.\r\t]\r\tifFalse:[\r\t\tTranscript show: \'Unification failed.\';cr;cr.\r\t\t].\r\t^t',			#stamp : 'pm 10/20/2018 08:55',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tt:=t unifyThis.\r\t(t hasFailed)\r\tifFalse:[\r\t\tTranscript show:t;cr;cr.\r\t]\r\tifTrue:[\r\t\tTranscript show: \'Unification failed.\';cr;cr.\r\t\t].\r\t^t',			#stamp : 'pm 10/20/2018 08:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T08:56:08.603845+02:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tt:=t unifyThis.\r\t(t hasFailed)\r\tifFalse:[\r\t\tTranscript show:t;cr;cr.\r\t]\r\tifTrue:[\r\t\tTranscript show: \'Unification failed.\';cr;cr.\r\t\t].\r\t^t',			#stamp : 'pm 10/20/2018 08:55',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t newPair|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tnewPair:=t unifyThis.\r\t(t hasFailed)\r\tifFalse:[\r\t\tTranscript show:t;cr;cr.\r\t]\r\tifTrue:[\r\t\tTranscript show: \'Unification failed.\';cr;cr.\r\t\t].\r\t^t',			#stamp : 'pm 10/20/2018 08:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:00:17.951797+02:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<self arity]\r\twhileFalse: [  \r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 08:11',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<self arity]\r\twhileFalse: [  \r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tTranscript show:\'pouet\'.\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:00:54.10959+02:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<self arity]\r\twhileFalse: [  \r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tTranscript show:\'pouet\'.\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<self arity]\r\twhileFalse: [  \r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\tTranscript show:\'pouet\'.\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:01:25.9319+02:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<self arity]\r\twhileFalse: [  \r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\tTranscript show:\'pouet\'.\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<self arity]\r\twhileFalse: [  \r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\tTranscript cr;cr;show:\'pouet\';cr;cr.\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:01',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:01:40.626336+02:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<self arity]\r\twhileFalse: [  \r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\tTranscript cr;cr;show:\'pouet\';cr;cr.\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:01',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<self arity]\r\twhileFalse: [  \r\t\tTranscript cr;cr;show:\'pouet\';cr;cr.\r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:01',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:02:11.91644+02:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<self arity]\r\twhileFalse: [  \r\t\tTranscript cr;cr;show:\'pouet\';cr;cr.\r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:01',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t[i<=self arity]\r\twhileFalse: [  \r\r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:03:11.735601+02:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t[i<=self arity]\r\twhileFalse: [  \r\r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t[i<=self arity+1]\r\twhileFalse: [  \r\r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:03:29.331232+02:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t[i<=self arity+1]\r\twhileFalse: [  \r\r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t[i<=(self arity+1)]\r\twhileFalse: [  \r\r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:03:43.745658+02:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t[i<=(self arity+1)]\r\twhileFalse: [  \r\r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\tTranscript cr;cr;show:\'pouet\';cr;cr.\r\t[i<=(self arity+1)]\r\twhileFalse: [  \r\r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:03:51.385477+02:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\tTranscript cr;cr;show:\'pouet\';cr;cr.\r\t[i<=(self arity+1)]\r\twhileFalse: [  \r\r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\r\t[i<=(self arity+1)]\r\twhileFalse: [  \r\tTranscript cr;cr;show:\'pouet\';cr;cr.\r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:04:38.417608+02:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\r\t[i<=(self arity+1)]\r\twhileFalse: [  \r\tTranscript cr;cr;show:\'pouet\';cr;cr.\r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\r\t[i<=(self arity+1)]\r\twhileFalse: [  \r\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:04',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:05:08.119305+02:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<self arity]\r\twhileFalse: [  \r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 08:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<=(self arity+1)]\r\twhileFalse: [  \r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:05',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:06:09.97073+02:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t newPair|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tnewPair:=t unifyThis.\r\t(t hasFailed)\r\tifFalse:[\r\t\tTranscript show:t;cr;cr.\r\t]\r\tifTrue:[\r\t\tTranscript show: \'Unification failed.\';cr;cr.\r\t\t].\r\t^t',			#stamp : 'pm 10/20/2018 08:56',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t newPair|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tnewPair:=t unifyThis.\r\t(t hasFailed)\r\tifFalse:[\r\t\tTranscript show:newPair;cr;cr.\r\t\t\r\t]\r\tifTrue:[\r\t\tTranscript show: \'Unification failed.\';cr;cr.\r\t\t].\r\t^t',			#stamp : 'pm 10/20/2018 09:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:06:12.233543+02:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t newPair|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tnewPair:=t unifyThis.\r\t(t hasFailed)\r\tifFalse:[\r\t\tTranscript show:newPair;cr;cr.\r\t\t\r\t]\r\tifTrue:[\r\t\tTranscript show: \'Unification failed.\';cr;cr.\r\t\t].\r\t^t',			#stamp : 'pm 10/20/2018 09:06',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'UnificationUnitTest:',			#protocol : #testing,			#sourceCode : 'UnificationUnitTest: otherPredicate\r\t|t newPair|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tnewPair:=t unifyThis.\r\t(t hasFailed)\r\tifFalse:[\r\t\tTranscript show:newPair;cr;cr.\r\t]\r\tifTrue:[\r\t\tTranscript show: \'Unification failed.\';cr;cr.\r\t\t].\r\t^t',			#stamp : 'pm 10/20/2018 09:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:07:19.209787+02:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:\'Trying to unify stuff\';cr.\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifTrue:[\r\t\t^nil."already the same predicate"\r\t\t]\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\tTranscript show:each;cr.\r\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t].\r\t\t].\r\t^initialPair',			#stamp : 'pm 10/20/2018 08:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:\'Trying to unify stuff\';cr.\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifTrue:[\r\t\t^initialPair."already the same predicate"\r\t\t]\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\tTranscript show:each;cr.\r\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t].\r\t\t].\r\t^initialPair',			#stamp : 'pm 10/20/2018 09:07',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:09:17.645926+02:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:\'Trying to unify stuff\';cr.\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifTrue:[\r\t\t^initialPair."already the same predicate"\r\t\t]\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\tTranscript show:each;cr.\r\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t].\r\t\t].\r\t^initialPair',			#stamp : 'pm 10/20/2018 09:07',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifTrue:[\r\t\t^initialPair."already the same predicate"\r\t\t]\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t].\r\t\t].\r\t^initialPair',			#stamp : 'pm 10/20/2018 09:09',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:12:09.905756+02:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifTrue:[\r\t\t^initialPair."already the same predicate"\r\t\t]\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t].\r\t\t].\r\t^initialPair',			#stamp : 'pm 10/20/2018 09:09',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifTrue:[\r\t\t^initialPair."already the same predicate"\r\t\t]\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t((((initialPair left) isConst) not) and:[(initialPair right) isConst])\r\t\t\tifTrue:[\t\t\t\r\t\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t^initialPair',			#stamp : 'pm 10/20/2018 09:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:14:07.040481+02:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #isConst,			#protocol : #testing,			#sourceCode : 'isConst\r\tterms do:[:each | (each isConst)ifFalse:[^false]].\r\t^true',			#stamp : 'pm 10/20/2018 09:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:30:06.911538+02:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<=(self arity+1)]\r\twhileFalse: [  \r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:05',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<=(self arity+1)]\r\twhileFalse: [  \r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tTranscript cr;cr;show:\'pouet\';cr;cr.\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:30:26.991963+02:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<=(self arity+1)]\r\twhileFalse: [  \r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tTranscript cr;cr;show:\'pouet\';cr;cr.\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<=(self arity+1)]\r\twhileFalse: [  \r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t\t\t\t\tTranscript cr;cr;show:\'pouet\';cr;cr.\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:30:39.781508+02:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<=(self arity+1)]\r\twhileFalse: [  \r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t\t\t\t\tTranscript cr;cr;show:\'pouet\';cr;cr.\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<=(self arity+1)]\r\twhileFalse: [  \r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:30:50.338952+02:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<=(self arity+1)]\r\twhileFalse: [  \r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<=(self arity+1)]\r\twhileFalse: [  \r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [\r\t\t\tTranscript cr;cr;show:\'pouet\';cr;cr.\r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:39:20.769272+02:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\r\t[i<=(self arity+1)]\r\twhileFalse: [  \r\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:04',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\r\t[i<=(self arity+1)]\r\twhileTrue: [  \r\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:39:31.296478+02:00' ],		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<=(self arity+1)]\r\twhileFalse: [  \r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [\r\t\t\tTranscript cr;cr;show:\'pouet\';cr;cr.\r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<=(self arity+1)]\r\twhileTrue: [  \r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [\r\t\t\tTranscript cr;cr;show:\'pouet\';cr;cr.\r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:39:41.038301+02:00' ],		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<=(self arity+1)]\r\twhileTrue: [  \r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [\r\t\t\tTranscript cr;cr;show:\'pouet\';cr;cr.\r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<=(self arity)]\r\twhileTrue: [  \r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [\r\t\t\tTranscript cr;cr;show:\'pouet\';cr;cr.\r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:39:54.027552+02:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\r\t[i<=(self arity+1)]\r\twhileTrue: [  \r\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\r\t[i<=(self arity)]\r\twhileTrue: [  \r\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:40:30.399931+02:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\r\t[i<=(self arity)]\r\twhileTrue: [  \r\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\r\t[i<=(self arity)]\r\twhileTrue: [  \r\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/20/2018 09:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:40:57.623655+02:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=0.\r\t[i<=(self arity)]\r\twhileTrue: [  \r\t\ti:=i+1.\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [\r\t\t\tTranscript cr;cr;show:\'pouet\';cr;cr.\r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/20/2018 09:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\t[i<=(self arity)]\r\twhileTrue: [  \r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [\r\t\t\tTranscript cr;cr;show:\'pouet\';cr;cr.\r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/20/2018 09:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:44:27.801521+02:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\r\t[i<=(self arity)]\r\twhileTrue: [  \r\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/20/2018 09:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\r\t[i<=(self arity)]\r\twhileTrue: [\r\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/20/2018 09:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:45:02.155862+02:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\r\t[i<=(self arity)]\r\twhileTrue: [\r\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/20/2018 09:44',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue:[ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/20/2018 09:45',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:47:09.561186+02:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue:[ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/20/2018 09:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue:[ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tTranscript cr;cr;show:\'pouet\';cr;cr.\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/20/2018 09:47',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:47:38.954297+02:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue:[ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tTranscript cr;cr;show:\'pouet\';cr;cr.\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/20/2018 09:47',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\r\t[i<=(self arity)]\r\twhileTrue:[\r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue:[ \r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/20/2018 09:47',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:49:47.863732+02:00' ],		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\t[i<=(self arity)]\r\twhileTrue: [  \r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [\r\t\t\tTranscript cr;cr;show:\'pouet\';cr;cr.\r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/20/2018 09:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Predicate,				#isMetaSide : false			},			#name : #'replace:by:',			#protocol : #adding,			#sourceCode : 'replace:x by:t\r\t| i |\r\ti:=1.\r\t[i<=(self arity)]\r\twhileTrue: [  \r\t\t((terms at:i) isKindOf: FuncTerm)\r\t\tifTrue: [\r\t\t\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\t\t\t(terms at:i) replace:x by:t.\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."\r\t\t\tifTrue:[\r\t\t\t\tterms at:i put:t.\r\t\t\t\t].\r\t\t\t].\r\t\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/20/2018 09:49',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:55:13.091223+02:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifTrue:[\r\t\t^initialPair."already the same predicate"\r\t\t]\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t((((initialPair left) isConst) not) and:[(initialPair right) isConst])\r\t\t\tifTrue:[\t\t\t\r\t\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t^initialPair',			#stamp : 'pm 10/20/2018 09:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:self;cr.\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifTrue:[\r\t\t^initialPair."already the same predicate"\r\t\t]\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t((((initialPair left) isConst) not) and:[(initialPair right) isConst])\r\t\t\tifTrue:[\t\t\t\r\t\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t^initialPair',			#stamp : 'pm 10/20/2018 09:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T09:58:52.84091+02:00' ],		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:self;cr.\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifTrue:[\r\t\t^initialPair."already the same predicate"\r\t\t]\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t((((initialPair left) isConst) not) and:[(initialPair right) isConst])\r\t\t\tifTrue:[\t\t\t\r\t\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t^initialPair',			#stamp : 'pm 10/20/2018 09:55',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:self;cr.\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifTrue:[\r\t\t^initialPair."already the same predicate"\r\t\t]\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\tifTrue:[\t\t\t\r\t\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t^initialPair',			#stamp : 'pm 10/20/2018 09:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T10:36:51.15276+02:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl UnificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\t\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/18/2018 21:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl UnificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\t\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/20/2018 10:36',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T10:38:06.767081+02:00' ],		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl UnificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\t\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/20/2018 10:36',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl UnificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\t\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\'));add:(ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/20/2018 10:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T10:38:42.541305+02:00' ],		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl UnificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\t\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\'));add:(ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/20/2018 10:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl UnificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl UnificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\t\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\r\t\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'x\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl UnificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/20/2018 10:38',			#package : #_resolution_1erOrdre		}	}}