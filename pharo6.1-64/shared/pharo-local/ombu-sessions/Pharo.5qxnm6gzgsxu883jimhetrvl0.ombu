OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-21T09:54:54.209682+02:00' ],		#prior : OmReference [ 'Pharo.dpl34zx7moemhdbskogoacjc1', '2' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:self;cr.\r\tself halt.\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\tifTrue:[\t\t\t\r\t\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t"else it was already the same  predicate"\r\t^initialPair',			#stamp : 'pm 10/21/2018 09:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:self;cr.\r\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\tifTrue:[\t\t\t\r\t\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t"else it was already the same  predicate"\r\t^initialPair',			#stamp : 'pm 10/21/2018 09:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-21T09:58:04.347314+02:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl unificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\t\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t\r\t"should replace x by y at the end of the unification"\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:( LinkedTerm new:(Term new:\'x\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/20/2018 17:21',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\t"Transcript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl unificationUnitTest:r."\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\t"Transcript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\t"\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\t"Transcript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r."\r\t\r\t\r\t"should replace x by y at the end of the unification"\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:( LinkedTerm new:(Term new:\'x\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/21/2018 09:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-21T10:01:41.513356+02:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:self;cr.\r\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\tifTrue:[\t\t\t\r\t\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t"else it was already the same  predicate"\r\t^initialPair',			#stamp : 'pm 10/21/2018 09:54',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:self;cr.\r\t\r\tself halt.\r\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\tifTrue:[\t\t\t\r\t\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t"else it was already the same  predicate"\r\t^initialPair',			#stamp : 'pm 10/21/2018 10:01',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-21T10:01:59.00086+02:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:self;cr.\r\t\r\tself halt.\r\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\tifTrue:[\t\t\t\r\t\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t"else it was already the same  predicate"\r\t^initialPair',			#stamp : 'pm 10/21/2018 10:01',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:self;cr.\r\t\r\tself halt.\r\r\t(hasFailed)\r\tifTrue:[\r\t\tself halt.\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\tifTrue:[\t\t\t\r\t\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t"else it was already the same  predicate"\r\t^initialPair',			#stamp : 'pm 10/21/2018 10:01',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-21T10:02:38.996459+02:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:self;cr.\r\t\r\tself halt.\r\r\t(hasFailed)\r\tifTrue:[\r\t\tself halt.\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\tifTrue:[\t\t\t\r\t\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t"else it was already the same  predicate"\r\t^initialPair',			#stamp : 'pm 10/21/2018 10:01',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:self;cr.\r\t\r\tself halt.\r\r\t(hasFailed)\r\tifTrue:[\r\t\tself halt.\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\tifTrue:[\r\t\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\tself halt.\r\t"else it was already the same  predicate"\r\t^initialPair',			#stamp : 'pm 10/21/2018 10:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-21T10:02:49.932539+02:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:self;cr.\r\t\r\tself halt.\r\r\t(hasFailed)\r\tifTrue:[\r\t\tself halt.\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\tifTrue:[\r\t\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\tself halt.\r\t"else it was already the same  predicate"\r\t^initialPair',			#stamp : 'pm 10/21/2018 10:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:self;cr.\r\t\r\tself halt.\r\r\t(hasFailed)\r\tifTrue:[\r\t\tself halt.\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tself halt.\r\t\tsetOfPairs do:[ :each | \r\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\tifTrue:[\r\t\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\tself halt.\r\t"else it was already the same  predicate"\r\t^initialPair',			#stamp : 'pm 10/21/2018 10:02',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-21T10:03:01.241971+02:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:self;cr.\r\t\r\tself halt.\r\r\t(hasFailed)\r\tifTrue:[\r\t\tself halt.\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tself halt.\r\t\tsetOfPairs do:[ :each | \r\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\tifTrue:[\r\t\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\tself halt.\r\t"else it was already the same  predicate"\r\t^initialPair',			#stamp : 'pm 10/21/2018 10:02',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:self;cr.\r\t\r\tself halt.\r\r\t(hasFailed)\r\tifTrue:[\r\t\tself halt.\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tself halt.\r\t\tsetOfPairs do:[ :each | \r\t\tself halt.\r\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\tifTrue:[\r\t\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\tself halt.\r\t"else it was already the same  predicate"\r\t^initialPair',			#stamp : 'pm 10/21/2018 10:03',			#package : #_resolution_1erOrdre		}	}}