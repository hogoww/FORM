OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T18:00:47.451674+02:00' ],		#prior : OmReference [ 'Pharo.7xa1og22jso6qfv05sj133exx', '4' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacement:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacement:aTerm replaced:left by:right\r\t(aTerm isKindOf: FuncTerm)\r\tifTrue:[\r\t\t^aTerm replace:left by:right.\r\t\t]"if it\'s something else than a functerm, "\r\tifFalse:[\r\t\t(aTerm=left)\r\t\tifTrue:[^right]\r\t\tifFalse:[^aTerm].\r\t\t].\r ',			#stamp : 'pm 10/20/2018 17:21',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacement:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacement:aTerm replaced:left by:right\r\t(aTerm isKindOf: FuncTerm or:[aTerm isKindOf: Predicate])\r\tifTrue:[\r\t\t^aTerm replace:left by:right.\r\t\t]"if it\'s something else than a functerm, "\r\tifFalse:[\r\t\t(aTerm=left)\r\t\tifTrue:[^right]\r\t\tifFalse:[^aTerm].\r\t\t].\r ',			#stamp : 'pm 10/20/2018 18:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T18:00:58.319199+02:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacement:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacement:aTerm replaced:left by:right\r\t(aTerm isKindOf: FuncTerm or:[aTerm isKindOf: Predicate])\r\tifTrue:[\r\t\t^aTerm replace:left by:right.\r\t\t]"if it\'s something else than a functerm, "\r\tifFalse:[\r\t\t(aTerm=left)\r\t\tifTrue:[^right]\r\t\tifFalse:[^aTerm].\r\t\t].\r ',			#stamp : 'pm 10/20/2018 18:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'replacement:replaced:by:',			#protocol : #unification,			#sourceCode : 'replacement:aTerm replaced:left by:right\r\t((aTerm isKindOf: FuncTerm)or:[aTerm isKindOf: Predicate])\r\tifTrue:[\r\t\t^aTerm replace:left by:right.\r\t\t]"if it\'s something else than a functerm, "\r\tifFalse:[\r\t\t(aTerm=left)\r\t\tifTrue:[^right]\r\t\tifFalse:[^aTerm].\r\t\t].\r ',			#stamp : 'pm 10/20/2018 18:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T18:01:17.913431+02:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i timeout|\r\ttimeout:=0.\r\tmodified := true.\r\t[ modified ]\r\twhileTrue: [\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\t"TEMPORARY"\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t"-1 is for when we won\'t break." \r\t\t\ttimeout:=timeout+1.\r\t\t\ttimeout<500\r\t\t\tifTrue:[^nil]\r\t\t]. ',			#stamp : 'pm 10/20/2018 17:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i timeout|\r\ttimeout:=0.\r\tmodified := true.\r\t[ modified ]\r\twhileTrue: [\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\t"TEMPORARY"\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t"-1 is for when we won\'t break." \r\t\t\ttimeout:=timeout+1.\r\t\t\ttimeout<50000\r\t\t\tifTrue:[^nil]\r\t\t]. ',			#stamp : 'pm 10/20/2018 18:01',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T18:01:28.314443+02:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i timeout|\r\ttimeout:=0.\r\tmodified := true.\r\t[ modified ]\r\twhileTrue: [\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\t"TEMPORARY"\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t"-1 is for when we won\'t break." \r\t\t\ttimeout:=timeout+1.\r\t\t\ttimeout<50000\r\t\t\tifTrue:[^nil]\r\t\t]. ',			#stamp : 'pm 10/20/2018 18:01',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i timeout|\r\ttimeout:=0.\r\tmodified := true.\r\t[ modified ]\r\twhileTrue: [\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\t"TEMPORARY"\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t"-1 is for when we won\'t break." \r\t\t\ttimeout:=timeout+1.\r\t\t\ttimeout<50\r\t\t\tifFalse:[^nil]\r\t\t]. ',			#stamp : 'pm 10/20/2018 18:01',			#package : #_resolution_1erOrdre		}	}}