OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T16:18:15.558209+02:00' ],		#prior : OmReference [ 'Pharo.arxgna7xxgbtxr5du3pu8k65r', '2' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms |\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\r\r\tTranscript cr;show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\t\t\r\tTranscript cr; show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint;show:\'pouet\'.\r\t\t\r\tTranscript cr; show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint.\r\t\t\r\t\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/9/2018 13:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms |\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\r\r\tTranscript cr;show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\t\t\r\tTranscript cr; show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint;show:\'pouet\'.\r\t\t\r\tTranscript cr; show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint.\r\t\t\r\tp:=Not new:(\r\t\tForAll new: \'x\' Property: \r\t\tImply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r\t\t rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\'))\r\t\t\r\t).\r\t\t\r\t\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/10/2018 16:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T16:18:30.653376+02:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms |\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\r\r\tTranscript cr;show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\t\t\r\tTranscript cr; show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint;show:\'pouet\'.\r\t\t\r\tTranscript cr; show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint.\r\t\t\r\tp:=Not new:(\r\t\tForAll new: \'x\' Property: \r\t\tImply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r\t\t rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\'))\r\t\t\r\t).\r\t\t\r\t\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/10/2018 16:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms |\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\r\r\tTranscript cr;show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\t\t\r\tTranscript cr; show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint;show:\'pouet\'.\r\t\t\r\tTranscript cr; show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint.\r\t\t\r\tp:=Not new:(\r\t\tForAll new: \'x\' Property: \r\t\t(Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r\t\t rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).\t\t\r\t\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/10/2018 16:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-10T16:19:13.361563+02:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms |\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\r\r\tTranscript cr;show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\t\t\r\tTranscript cr; show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint;show:\'pouet\'.\r\t\t\r\tTranscript cr; show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint.\r\t\t\r\tp:=Not new:(\r\t\tForAll new: \'x\' Property: \r\t\t(Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r\t\t rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).\t\t\r\t\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/10/2018 16:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms |\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\tTranscript show: \'basic one\';cr.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\r\r\tTranscript cr;show: \'with imply and nested forall.\';cr.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr;show:p prettyPrint.\r\t\t\r\tTranscript cr; show: \'same as previous one, but with x representing a variable in one, and a const in the other.\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript cr; show:p prettyPrint;show:\'pouet\'.\r\t\t\r\tTranscript cr; show: \'same as previous one, check Unbound Exists is replaced by consts\';cr.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint.\r\t\t\r\tp:=Not new:(\r\t\tForAll new: \'x\' Property: \r\t\t(Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r\t\t rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).\t\t\r\t\tp:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).\r\t\tTranscript show:p prettyPrint.\r\t\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 10/10/2018 16:19',			#package : #_resolution_1erOrdre		}	}}