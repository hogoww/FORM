OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T07:51:51.853022+02:00' ],		#prior : OmReference [ 'Pharo.7jajagu7cy3mg1pyour2046b2', '11' ],		#self : OmReference [ '1' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Unifier\r\tinstanceVariableNames: \'setOfPairs hasFailed initialPair\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Unifier,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #setOfPairs,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #hasFailed,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #initialPair,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Unifier class\r\tinstanceVariableNames: \'\''				},				#name : #'Unifier class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Unifier,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent an Unifier object.\r\rMy purpose is to unify two predicate.\r\rPublic API and Key Messages\r\r-Unifier new: Predicate2:\r- UnifyThis\r\rp1:=Predicate new:(..)\rp2:=Predicate new:(...)\rUnifier new: p1 Predicate2:p2\r \rInternal Representation and Key Implementation Points.\r\r    Instance Variables\r\thasFailed:\tBoolean to see if the unification failed.\r\r\tPrivate:\r\tinitialPair:\t\t<Object>\r\tsetOfPairs:\t\t<Object>\r\r\r    Implementation Points',				#stamp : 'pm 10/23/2018 12:15'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Unifier\r\tinstanceVariableNames: \'setOfPairs hasFailed initialPair\'\r\tclassVariableNames: \'UnifiedTerm\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Unifier,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #setOfPairs,					#parent : @27				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #hasFailed,					#parent : @27				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #initialPair,					#parent : @27				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Unifier class\r\tinstanceVariableNames: \'\''				},				#name : #'Unifier class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @27			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Unifier,					#isMetaSide : false				},				#parent : @27,				#content : 'I represent an Unifier object.\r\rMy purpose is to unify two predicate.\r\rPublic API and Key Messages\r\r-Unifier new: Predicate2:\r- UnifyThis\r\rp1:=Predicate new:(..)\rp2:=Predicate new:(...)\rUnifier new: p1 Predicate2:p2\r \rInternal Representation and Key Implementation Points.\r\r    Instance Variables\r\thasFailed:\tBoolean to see if the unification failed.\r\r\tPrivate:\r\tinitialPair:\t\t<Object>\r\tsetOfPairs:\t\t<Object>\r\r\r    Implementation Points',				#stamp : 'pm 10/23/2018 12:15'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #UnifiedTerm,					#parent : @27				}			],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T07:51:51.884004+02:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'initialize:Predicate2:',			#protocol : #initialization,			#sourceCode : 'initialize: p1 Predicate2: p2\r\t"initialized with two predicates, that we\'ll try to unify."\r\r\t"init two different pair to be sure that we have the initial\r\tone to unify at the end."\r\tinitialPair:=(Pair left: (p1 veryDeepCopy) right: (p2 veryDeepCopy)).\r\tsetOfPairs:=MinimalOrderedSet new.\r\tsetOfPairs add:(Pair left: p1 right: p2).\r\thasFailed:=false.\r',			#stamp : 'pm 10/21/2018 08:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'initialize:Predicate2:',			#protocol : #initialization,			#sourceCode : 'initialize: p1 Predicate2: p2\r\t"initialized with two predicates, that we\'ll try to unify."\r\r\t"init two different pair to be sure that we have the initial\r\tone to unify at the end."\r\tinitialPair:=(Pair left: (p1 veryDeepCopy) right: (p2 veryDeepCopy)).\r\tsetOfPairs:=MinimalOrderedSet new.\r\tsetOfPairs add:(Pair left: p1 right: p2).\r\thasFailed:=false.\r\tUnifiedTerm:=Pair left:nil right nil.\r',			#stamp : 'pm 10/25/2018 07:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T07:52:16.229013+02:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Unifier\r\tinstanceVariableNames: \'setOfPairs hasFailed initialPair\'\r\tclassVariableNames: \'UnifiedTerm\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Unifier,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #setOfPairs,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #hasFailed,					#parent : @7				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #initialPair,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Unifier class\r\tinstanceVariableNames: \'\''				},				#name : #'Unifier class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Unifier,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent an Unifier object.\r\rMy purpose is to unify two predicate.\r\rPublic API and Key Messages\r\r-Unifier new: Predicate2:\r- UnifyThis\r\rp1:=Predicate new:(..)\rp2:=Predicate new:(...)\rUnifier new: p1 Predicate2:p2\r \rInternal Representation and Key Implementation Points.\r\r    Instance Variables\r\thasFailed:\tBoolean to see if the unification failed.\r\r\tPrivate:\r\tinitialPair:\t\t<Object>\r\tsetOfPairs:\t\t<Object>\r\r\r    Implementation Points',				#stamp : 'pm 10/23/2018 12:15'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #UnifiedTerm,					#parent : @7				}			],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Unifier\r\tinstanceVariableNames: \'setOfPairs hasFailed initialPair unifiedPair\'\r\tclassVariableNames: \'UnifiedTerm\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Unifier,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #setOfPairs,					#parent : @29				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #hasFailed,					#parent : @29				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #initialPair,					#parent : @29				},				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #unifiedPair,					#parent : @29				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Unifier class\r\tinstanceVariableNames: \'\''				},				#name : #'Unifier class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @29			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Unifier,					#isMetaSide : false				},				#parent : @29,				#content : 'I represent an Unifier object.\r\rMy purpose is to unify two predicate.\r\rPublic API and Key Messages\r\r-Unifier new: Predicate2:\r- UnifyThis\r\rp1:=Predicate new:(..)\rp2:=Predicate new:(...)\rUnifier new: p1 Predicate2:p2\r \rInternal Representation and Key Implementation Points.\r\r    Instance Variables\r\thasFailed:\tBoolean to see if the unification failed.\r\r\tPrivate:\r\tinitialPair:\t\t<Object>\r\tsetOfPairs:\t\t<Object>\r\r\r    Implementation Points',				#stamp : 'pm 10/23/2018 12:15'			},			#classVariables : OrderedCollection [				RGClassVariableDefinition {					#annotations : IdentityDictionary {						#className : #Unifier,						#isMetaSide : false					},					#name : #UnifiedTerm,					#parent : @29				}			],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T07:52:25.629978+02:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'initialize:Predicate2:',			#protocol : #initialization,			#sourceCode : 'initialize: p1 Predicate2: p2\r\t"initialized with two predicates, that we\'ll try to unify."\r\r\t"init two different pair to be sure that we have the initial\r\tone to unify at the end."\r\tinitialPair:=(Pair left: (p1 veryDeepCopy) right: (p2 veryDeepCopy)).\r\tsetOfPairs:=MinimalOrderedSet new.\r\tsetOfPairs add:(Pair left: p1 right: p2).\r\thasFailed:=false.\r\tUnifiedTerm:=Pair left:nil right nil.\r',			#stamp : 'pm 10/25/2018 07:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'initialize:Predicate2:',			#protocol : #initialization,			#sourceCode : 'initialize: p1 Predicate2: p2\r\t"initialized with two predicates, that we\'ll try to unify."\r\r\t"init two different pair to be sure that we have the initial\r\tone to unify at the end."\r\tinitialPair:=(Pair left: (p1 veryDeepCopy) right: (p2 veryDeepCopy)).\r\tsetOfPairs:=MinimalOrderedSet new.\r\tsetOfPairs add:(Pair left: p1 right: p2).\r\thasFailed:=false.\r\tUnifiedTerm:=Pair left:nil right:nil.\r',			#stamp : 'pm 10/25/2018 07:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T07:55:53.875921+02:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:self;cr.\r\t(hasFailed)\r\tifTrue:[\r\t\t^nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\t\tifTrue:["They both should be predicates, so they can use replace: by:"\r\t\t\t\t\t(initialPair left) replace: (each left) by: (each right).\r\t\t\t\t\t(initialPair right) replace: (each left) by: (each right).\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t"else it was already the same  predicate"\r\t^initialPair',			#stamp : 'pm 10/22/2018 10:06',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:self;cr.\r\t(hasFailed)\r\tifTrue:[\r\t\tunifiedPair := nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tunifiedPair := initialPair veryDeepCopy.\r\t\tsetOfPairs do:[ :each | \r\t\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\t\tifTrue:["They both should be predicates, so they can use replace: by:"\r\t\t\t\t\t(unifiedPair left) replace: (each left) by: (each right).\r\t\t\t\t\t(unifiedPair right) replace: (each left) by: (each right).\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t"else it was already the same  predicate"',			#stamp : 'pm 10/25/2018 07:55',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T07:56:25.48795+02:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:self;cr.\r\t(hasFailed)\r\tifTrue:[\r\t\tunifiedPair := nil."Failed to unify thing"\r\t\t].\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tunifiedPair := initialPair veryDeepCopy.\r\t\tsetOfPairs do:[ :each | \r\t\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\t\tifTrue:["They both should be predicates, so they can use replace: by:"\r\t\t\t\t\t(unifiedPair left) replace: (each left) by: (each right).\r\t\t\t\t\t(unifiedPair right) replace: (each left) by: (each right).\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t"else it was already the same  predicate"',			#stamp : 'pm 10/25/2018 07:55',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyThis,			#protocol : #unification,			#sourceCode : 'unifyThis\r\tself unifyMe."Now setOfPairs contains my unifier"\r\tTranscript show:self;cr.\r\t(hasFailed)\r\tifTrue:[\r\t\tunifiedPair := nil."Failed to unify thing"\r\t\t].\r\r\tunifiedPair := initialPair veryDeepCopy.\r\t(setOfPairs isNil)\r\tifFalse:[\r\t\tsetOfPairs do:[ :each | \r\t\t\t((((each left) isConst) not) and:[(each right) isConst])\r\t\t\t\tifTrue:["They both should be predicates, so they can use replace: by:"\r\t\t\t\t\t(unifiedPair left) replace: (each left) by: (each right).\r\t\t\t\t\t(unifiedPair right) replace: (each left) by: (each right).\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t"else it was already the same  predicate"',			#stamp : 'pm 10/25/2018 07:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T07:58:47.787067+02:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'initialize:Predicate2:',			#protocol : #initialization,			#sourceCode : 'initialize: p1 Predicate2: p2\r\t"initialized with two predicates, that we\'ll try to unify."\r\r\t"init two different pair to be sure that we have the initial\r\tone to unify at the end."\r\tinitialPair:=(Pair left: (p1 veryDeepCopy) right: (p2 veryDeepCopy)).\r\tsetOfPairs:=MinimalOrderedSet new.\r\tsetOfPairs add:(Pair left: p1 right: p2).\r\thasFailed:=false.\r\tUnifiedTerm:=Pair left:nil right:nil.\r',			#stamp : 'pm 10/25/2018 07:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'initialize:Predicate2:',			#protocol : #initialization,			#sourceCode : 'initialize: p1 Predicate2: p2\r\t"initialized with two predicates, that we\'ll try to unify."\r\r\t"init two different pair to be sure that we have the initial\r\tone to unify at the end."\r\tinitialPair:=(Pair left: (p1 veryDeepCopy) right: (p2 veryDeepCopy)).\r\tsetOfPairs:=MinimalOrderedSet new.\r\tsetOfPairs add:(Pair left: p1 right: p2).\r\thasFailed:=false.\r\t\r\tUnifiedTerm:=Pair left:nil right:nil."not sure if needed"\r\t\r\t"And we try to unify it instantly"\r\tself unifyThis.\r',			#stamp : 'pm 10/25/2018 07:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T08:06:20.401239+02:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #'as yet unclassified',			#sourceCode : 'factorisation: aClause\r\t| i j c1 c2 |\r\ti:=0.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\tc1:=aClause at:i.\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\tc2:=aClause at:j.\r\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/24/2018 20:49',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #'as yet unclassified',			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 |"{i j}=iterator  {atomes} = atome (predicates) { sub1 sub2 }= Predicate substitution"\r\ti:=0.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t\r\t\t\tUnifier new: a1 Predicate2: a2.\r\t\t\t\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\t\r\t\t\t\t].\r\t\t\t\r\t\t\t\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 08:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T08:07:19.654632+02:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #firstPredicate,			#protocol : #initialization,			#sourceCode : 'firstPredicate\r\t^unifiedPair left.',			#stamp : 'pm 10/25/2018 08:07',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T08:07:34.722059+02:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #secondPredicate,			#protocol : #initialization,			#sourceCode : 'secondPredicate\r\t^unifiedPair right.',			#stamp : 'pm 10/25/2018 08:07',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T08:10:32.926981+02:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #'as yet unclassified',			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 |"{i j}=iterator  {atomes} = atome (predicates) { sub1 sub2 }= Predicate substitution"\r\ti:=0.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t\r\t\t\tUnifier new: a1 Predicate2: a2.\r\t\t\t\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\t\r\t\t\t\t].\r\t\t\t\r\t\t\t\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 08:06',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #'as yet unclassified',			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u|"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier don\'t need that much variable, it\'s for clarity"\r\ti:=0.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\t\r\t\t\t\t].\r\t\t\t\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 08:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T08:10:38.724162+02:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #'as yet unclassified',			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u|"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier don\'t need that much variable, it\'s for clarity"\r\ti:=0.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\t\r\t\t\t\t].\r\t\t\t\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 08:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #'as yet unclassified',			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u|"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier don\'t need that much variable, it\'s for clarity"\r\ti:=0.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2!=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\t\r\t\t\t\t].\r\t\t\t\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 08:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T08:10:46.850546+02:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #'as yet unclassified',			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u|"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier don\'t need that much variable, it\'s for clarity"\r\ti:=0.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2!=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\t\r\t\t\t\t].\r\t\t\t\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 08:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #'as yet unclassified',			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u|"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier don\'t need that much variable, it\'s for clarity"\r\ti:=0.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\t\r\t\t\t\t].\r\t\t\t\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 08:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T08:32:24.565258+02:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t(Prop debugUnification)\r\t\t\tifTrue:[Transcript show:\'conflict\';cr.].\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[right isConst])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"notPossible:=self check:aPair"\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 10/21/2018 09:24',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t(Prop debugUnification)\r\t\t\tifTrue:[Transcript show:\'conflict\';cr.].\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[right isKindOf: LinkedTerm])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"notPossible:=self check:aPair"\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 10/25/2018 08:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T08:33:25.203377+02:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t(Prop debugUnification)\r\t\t\tifTrue:[Transcript show:\'conflict\';cr.].\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[right isKindOf: LinkedTerm])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"notPossible:=self check:aPair"\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 10/25/2018 08:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t(Prop debugUnification)\r\t\t\tifTrue:[Transcript show:\'conflict\';cr.].\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[right isKindOf: LinkedTerm or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"notPossible:=self check:aPair"\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 10/25/2018 08:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T08:33:31.774147+02:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t(Prop debugUnification)\r\t\t\tifTrue:[Transcript show:\'conflict\';cr.].\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[right isKindOf: LinkedTerm or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"notPossible:=self check:aPair"\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 10/25/2018 08:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\t"Transcript cr;cr;show:\'pouet\';cr;cr."\r\r\tnotPossible:=false.\r\tmodified:=false.\r\t((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])\r\tifTrue:[\r\t\t(left = right) "check underlying symbols, and that"\r\t\tifTrue:[self delete:aPair. modified:=true.].]"delete"\r\tifFalse:[\r\t\t(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])\r\t\tor:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])\r\t\tifTrue:["try a decompose or conflict "\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict ->"\r\t\t\t(Prop debugUnification)\r\t\t\tifTrue:[Transcript show:\'conflict\';cr.].\r\t\t\t\tnotPossible:=true.\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((left isConst) and:[right isKindOf: LinkedTerm.])\r\t\t\tifTrue:[ "swap"\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t ]\r\t\t\tifFalse:[  \r\t\t\t\t((left isKindOf: LinkedTerm) and:[(right isKindOf: LinkedTerm) or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"\r\t\t\t\tifTrue:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["check, not implemented for now"\r\t\t\t\t\t((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"notPossible:=self check:aPair"\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\t].\r\t\t].\r\t\r\t\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 10/25/2018 08:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T08:36:39.968928+02:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifiedPair,			#protocol : #unification,			#sourceCode : 'unifiedPair\r\t^unifiedPair. ',			#stamp : 'pm 10/25/2018 08:36',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T08:37:01.897187+02:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'unificationUnitTest:',			#protocol : #testing,			#sourceCode : 'unificationUnitTest: otherPredicate\r\t|t newPair|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tnewPair:=t unifyThis.\r\t(t hasFailed)\r\tifFalse:[\r\t\tTranscript show:newPair;cr;cr.\r\t]\r\tifTrue:[\r\t\tTranscript show: \'Unification failed.\';cr;cr.\r\t\t].\r\t^t',			#stamp : 'pm 10/20/2018 12:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #'unificationUnitTest:',			#protocol : #testing,			#sourceCode : 'unificationUnitTest: otherPredicate\r\t|t newPair|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to Unify \';show: self; show:\' and \';show: otherPredicate;cr.\r\tt:=Unifier new: self Predicate2: otherPredicate.\r\tnewPair:=t unifiedPair.\r\t(t hasFailed)\r\tifFalse:[\r\t\tTranscript show:newPair;cr;cr.\r\t]\r\tifTrue:[\r\t\tTranscript show: \'Unification failed.\';cr;cr.\r\t\t].\r\t^t',			#stamp : 'pm 10/25/2018 08:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T08:41:42.066373+02:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #initialization,			#sourceCode : 'addAll: clausifiedProp\r\t((clausifiedProp  isOr) | (clausifiedProp isAtome))\r\t "If i\'m in a or, there\'s only or(s) under him."\r\tifTrue:[self clauses add: (Clause new:clausifiedProp)]\r\tifFalse:[\r\t\t(clausifiedProp isNot)\r\t\tifTrue:[\r\t\t\t((clausifiedProp operand) isAtome)\r\t\t\tifTrue:[^self clauses add:(Clause new:clausifiedProp).]\r\t\t\tifFalse:[^Error new:\'a not isn\'\'t englobing an atome\'.].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(clausifiedProp isAnd)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (clausifiedProp left).\r\t\t\t\tself addAll: (clausifiedProp right).\r\t\t\t\t]\r\t\tifFalse:[\r\t\t\tError new: \'Tried to add a non clause object to a clausaleForm\'.].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/24/2018 20:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #initialization,			#sourceCode : 'addAll: clausifiedProp\r\t((clausifiedProp  isOr) | (clausifiedProp isAtome))"If i\'m in a or, there\'s only or(s) under him."\r\tifTrue:[self clauses add: (Clause new:clausifiedProp)]\r\tifFalse:[\r\t\t(clausifiedProp isNot)\r\t\tifTrue:[\r\t\t\t((clausifiedProp operand) isAtome)\r\t\t\tifTrue:[^self clauses add:(Clause new:clausifiedProp).]\r\t\t\tifFalse:[^Error new:\'A not isn\'\'t englobing an atome\'.].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(clausifiedProp isAnd)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (clausifiedProp left).\r\t\t\t\tself addAll: (clausifiedProp right).\r\t\t\t\t]\r\t\tifFalse:[\r\t\t\tError new: \'Tried to add a non clause object to a clausaleForm\'.].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/25/2018 08:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T08:43:37.432732+02:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #initialization,			#sourceCode : 'addAll: clausifiedProp\r\t((clausifiedProp  isOr) | (clausifiedProp isAtome))"If i\'m in a or, there\'s only or(s) under him."\r\tifTrue:[self clauses add: (Clause new:clausifiedProp)]\r\tifFalse:[\r\t\t(clausifiedProp isNot)\r\t\tifTrue:[\r\t\t\t((clausifiedProp operand) isAtome)\r\t\t\tifTrue:[^self clauses add:(Clause new:clausifiedProp).]\r\t\t\tifFalse:[^Error new:\'A not isn\'\'t englobing an atome\'.].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(clausifiedProp isAnd)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (clausifiedProp left).\r\t\t\t\tself addAll: (clausifiedProp right).\r\t\t\t\t]\r\t\tifFalse:[\r\t\t\tError new: \'Tried to add a non clause object to a clausaleForm\'.].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/25/2018 08:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #initialization,			#sourceCode : 'addAll: clausifiedProp\r\t((clausifiedProp  isOr) | (clausifiedProp isAtome))"If i\'m in a or, there\'s only or(s) under him."\r\tifTrue:[self clauses add: (Clause new:clausifiedProp)]\r\tifFalse:[\r\t\t(clausifiedProp isNot)\r\t\tifTrue:[\r\t\t\t((clausifiedProp operand) isAtome)\r\t\t\tifTrue:[^self clauses add:(Clause new:clausifiedProp).]\r\t\t\tifFalse:[^Error new:\'A not isn\'\'t englobing an atome.\'.].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(clausifiedProp isAnd)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (clausifiedProp left).\r\t\t\t\tself addAll: (clausifiedProp right).\r\t\t\t\t]\r\t\tifFalse:[\r\t\t\tError new: \'Tried to add a non clause object to a clausaleForm.\'.].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/25/2018 08:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T08:44:58.629144+02:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #accessing,			#sourceCode : 'addAll: orProp\r\t(orProp isKindOf: Atome)\r\tifTrue:[self add:orProp.]\r\tifFalse:[\r\t\t((orProp) isKindOf: Not)\r\t\tifTrue:["we\'re in a not"\r\t\t\t(orProp operand isKindOf:Atome)\r\t\t\t\tifTrue:["we\'re in an atom"\r\t\t\t\t\t((orProp operand) isKindOf: Predicate)\r\t\t\t\t\tifTrue:[self add:(NotPredicate new: (orProp operand) getSymb fromList: (orProp operand) terms).]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t((orProp operand) isKindOf: Var)\r\t\t\t\t\t\tifTrue:[self add:(NotVar new:((orProp operand) getSymb)).]\r\t\t\t\t\t\tifFalse: [ Error new: \'shouldn\'\'t be any True or false here\' ]].\r\t\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tError new:\'Error, shouldn\'\'t be any more not ( binaryOp )\'\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t((orProp) isKindOf: Or)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (orProp left).\r\t\t\t\tself addAll: (orProp right).\r\t\t\t\t]\r\t\t\tifFalse:["switch to Error new:"\r\t\t\t\tError new:\'Error, shouldn\'\'t be any other kind of prop here.\'.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/9/2018 13:36',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #accessing,			#sourceCode : 'addAll: orProp\r\t(orProp isAtome)\r\tifTrue:[self add:orProp.]\r\tifFalse:[\r\t\t((orProp) isNot)\r\t\tifTrue:["we\'re in a not"\r\t\t\t(orProp operand isAtome)\r\t\t\t\tifTrue:["we\'re in an atom"\r\t\t\t\t\t((orProp operand) isPredicate)\r\t\t\t\t\tifTrue:[self add:(NotPredicate new: (orProp operand) getSymb fromList: (orProp operand) terms).]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t((orProp operand) isVar)\r\t\t\t\t\t\tifTrue:[self add:(NotVar new:((orProp operand) getSymb)).]\r\t\t\t\t\t\tifFalse: [ Error new: \'shouldn\'\'t be any True or false here\' ]].\r\t\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tError new:\'Error, shouldn\'\'t be any more not ( binaryOp )\'\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(orProp isOr)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (orProp left).\r\t\t\t\tself addAll: (orProp right).\r\t\t\t\t]\r\t\t\tifFalse:["switch to Error new:"\r\t\t\t\tError new:\'Error, shouldn\'\'t be any other kind of prop here.\'.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/25/2018 08:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T11:03:52.397361+02:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #'as yet unclassified',			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u|"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier don\'t need that much variable, it\'s for clarity"\r\ti:=0.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\t\r\t\t\t\t].\r\t\t\t\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 08:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #'as yet unclassified',			#sourceCode : 'factorisation: aClause\r\t| i j k a1 a2 sub1 sub2 u|"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier don\'t need that much variable, it\'s for clarity"\r\ti:=0.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\taClause collect:[ :each | each~=(aClause at:i) and:[each~=(aClause at:j)]].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 11:03',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T11:04:58.535576+02:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #'as yet unclassified',			#sourceCode : 'factorisation: aClause\r\t| i j k a1 a2 sub1 sub2 u|"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier don\'t need that much variable, it\'s for clarity"\r\ti:=0.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\taClause collect:[ :each | each~=(aClause at:i) and:[each~=(aClause at:j)]].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 11:03',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #'as yet unclassified',			#sourceCode : 'factorisation: aClause\r\t| i j k a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier don\'t need that much variable, it\'s for clarity"\r\ti:=0.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new: aClause collect:[ :each | each~=(aClause at:i) and:[each~=(aClause at:j)]].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 11:04',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T11:06:32.757075+02:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'addFromList:',			#protocol : #accessing,			#sourceCode : 'addFromList: aLinkedList\r\taLinkedList do:[:each|\r\t\tself add.\r\t\t].',			#stamp : 'pm 10/25/2018 11:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T11:07:15.755187+02:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'addFromList:',			#protocol : #accessing,			#sourceCode : 'addFromList: aLinkedList\r\taLinkedList do:[:each|\r\t\tself add.\r\t\t].',			#stamp : 'pm 10/25/2018 11:06',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'addFromList:',			#protocol : #accessing,			#sourceCode : 'addFromList: aLinkedList\r\taLinkedList do:[:each|\r\t\tself add: each.\r\t\t].',			#stamp : 'pm 10/25/2018 11:07',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T11:09:20.393302+02:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #'as yet unclassified',			#sourceCode : 'factorisation: aClause\r\t| i j k a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier don\'t need that much variable, it\'s for clarity"\r\ti:=0.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new: aClause collect:[ :each | each~=(aClause at:i) and:[each~=(aClause at:j)]].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 11:04',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #'as yet unclassified',			#sourceCode : 'factorisation: aClause\r\t| i j k a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier don\'t need that much variable, it\'s for clarity"\r\ti:=0.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause collect:[ :each | each~=(aClause at:i) and:[each~=(aClause at:j)]]).\r\t\t\t\tself add:newClause.\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 11:09',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T11:11:29.934968+02:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #'as yet unclassified',			#sourceCode : 'factorisation: aClause\r\t| i j k a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier don\'t need that much variable, it\'s for clarity"\r\ti:=0.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause collect:[ :each | each~=(aClause at:i) and:[each~=(aClause at:j)]]).\r\t\t\t\tself add:newClause.\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 11:09',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #'as yet unclassified',			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=0.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause collect:[ :each | each~=(aClause at:i) and:[each~=(aClause at:j)]]).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 11:11',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T11:11:42.774011+02:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpProtocolAddition {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #Resolvante\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Resolvante,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Resolvante class\r\tinstanceVariableNames: \'\''				},				#name : #'Resolvante class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Resolvante,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #methodeDeResolution	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T11:11:45.561364+02:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #'as yet unclassified',			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=0.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause collect:[ :each | each~=(aClause at:i) and:[each~=(aClause at:j)]]).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 11:11',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=0.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause collect:[ :each | each~=(aClause at:i) and:[each~=(aClause at:j)]]).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 11:11',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T11:11:47.611738+02:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #'as yet unclassified',			#sourceCode : 'resolvante: clause1 with: clause2\r\r\r\t^self error:\'todo\'.',			#stamp : 'pm 10/24/2018 20:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #methodeDeResolution,			#sourceCode : 'resolvante: clause1 with: clause2\r\r\r\t^self error:\'todo\'.',			#stamp : 'pm 10/24/2018 20:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T12:06:30.73846+02:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=0.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause collect:[ :each | each~=(aClause at:i) and:[each~=(aClause at:j)]]).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 11:11',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=0.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause collect:[ :each | each~=(aClause at:i) and:[each~=(aClause at:j)]]).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 12:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T13:33:01.841421+02:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #ResolvanteUnitTest,			#protocol : #testing,			#sourceCode : 'ResolvanteUnitTest\r\t|r newPair|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tr:=Resolvante new.\r\tr factorisation: self.\r\t\r\tnewPair:=r unifiedPair.\r\r\r\t^self error:\'todo\'',			#stamp : 'pm 10/25/2018 13:33',			#package : #_resolution_1erOrdre		}	}}