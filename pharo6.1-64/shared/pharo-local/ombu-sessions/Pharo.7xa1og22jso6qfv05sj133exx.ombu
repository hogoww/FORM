OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T17:49:22.132328+02:00' ],		#prior : OmReference [ 'Pharo.au6pfv6ac2didy7e215dne5ba', '6' ],		#self : OmReference [ '1' ]	},	#content : EpRedo {		#entryReferences : OrderedCollection [			OmReference [ '7xa1og2mctjca45vo0qofra3z', '1' ]		]	}}OmEntry {	#tags : {		#author : 'pm',		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ],		#time : DateAndTime [ '2018-10-20T17:49:22.170149+02:00' ],		#trigger : @3	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\ti := 1.\r\t[ modified ]\r\twhileTrue: [\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(i <= (setOfPairs size) and: [ i ~= -1 ])]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\t"TEMPORARY"\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:= modified\r\t\t\tifTrue: [ -1 ]\r\t\t\tifFalse: [ i + 1 ]. \r\t\t\t].\t"-1 is for when we won\'t break." \r\t\t].',			#stamp : 'pm 10/20/2018 17:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\ti := 1.\r\t[ modified ]\r\twhileTrue: [\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\t"TEMPORARY"\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t"-1 is for when we won\'t break." \r\t\t]. ',			#stamp : 'pm 10/20/2018 17:49',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T17:57:07.720865+02:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\ti := 1.\r\t[ modified ]\r\twhileTrue: [\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\t"TEMPORARY"\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t"-1 is for when we won\'t break." \r\t\t]. ',			#stamp : 'pm 10/20/2018 17:49',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i timeout|\r\ttimeout:=0.\r\tmodified := true.\r\t[ modified ]\r\twhileTrue: [\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\t"TEMPORARY"\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t"-1 is for when we won\'t break." \r\t\t]. ',			#stamp : 'pm 10/20/2018 17:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T17:57:36.763599+02:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i timeout|\r\ttimeout:=0.\r\tmodified := true.\r\t[ modified ]\r\twhileTrue: [\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\t"TEMPORARY"\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t"-1 is for when we won\'t break." \r\t\t]. ',			#stamp : 'pm 10/20/2018 17:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i timeout|\r\ttimeout:=0.\r\tmodified := true.\r\t[ modified ]\r\twhileTrue: [\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\t"TEMPORARY"\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t"-1 is for when we won\'t break." \r\t\t\ttimeout:=timeout+1.\r\t\t\ttimeout<500\r\t\t\tifTrue:[^nil]\r\t\t]. ',			#stamp : 'pm 10/20/2018 17:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T17:58:07.454809+02:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i timeout|\r\ttimeout:=0.\r\tmodified := true.\r\t[ modified ]\r\twhileTrue: [\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\t"TEMPORARY"\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t"-1 is for when we won\'t break." \r\t\t\ttimeout:=timeout+1.\r\t\t\ttimeout<500\r\t\t\tifTrue:[^nil]\r\t\t]. ',			#stamp : 'pm 10/20/2018 17:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i timeout|\r\ttimeout:=0.\r\tmodified := true.\r\t[ modified ]\r\twhileTrue: [\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\t"TEMPORARY"\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t"-1 is for when we won\'t break." \r\t\t\ttimeout:=timeout+1.\r\t\t\ttimeout<10000\r\t\t\tifTrue:[^nil]\r\t\t]. ',			#stamp : 'pm 10/20/2018 17:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T17:58:16.680558+02:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i timeout|\r\ttimeout:=0.\r\tmodified := true.\r\t[ modified ]\r\twhileTrue: [\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\t"TEMPORARY"\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t"-1 is for when we won\'t break." \r\t\t\ttimeout:=timeout+1.\r\t\t\ttimeout<10000\r\t\t\tifTrue:[^nil]\r\t\t]. ',			#stamp : 'pm 10/20/2018 17:58',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i timeout|\r\ttimeout:=0.\r\tmodified := true.\r\t[ modified ]\r\twhileTrue: [\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\t"TEMPORARY"\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t"-1 is for when we won\'t break." \r\t\t\ttimeout:=timeout+1.\r\t\t\ttimeout<50000\r\t\t\tifTrue:[^nil]\r\t\t]. ',			#stamp : 'pm 10/20/2018 17:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T17:58:24.234636+02:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i timeout|\r\ttimeout:=0.\r\tmodified := true.\r\t[ modified ]\r\twhileTrue: [\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\t"TEMPORARY"\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t"-1 is for when we won\'t break." \r\t\t\ttimeout:=timeout+1.\r\t\t\ttimeout<50000\r\t\t\tifTrue:[^nil]\r\t\t]. ',			#stamp : 'pm 10/20/2018 17:58',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i timeout|\r\ttimeout:=0.\r\tmodified := true.\r\t[ modified ]\r\twhileTrue: [\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\t"TEMPORARY"\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t"-1 is for when we won\'t break." \r\t\t\ttimeout:=timeout+1.\r\t\t\ttimeout<500000\r\t\t\tifTrue:[^nil]\r\t\t]. ',			#stamp : 'pm 10/20/2018 17:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T17:58:29.676595+02:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i timeout|\r\ttimeout:=0.\r\tmodified := true.\r\t[ modified ]\r\twhileTrue: [\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\t"TEMPORARY"\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t"-1 is for when we won\'t break." \r\t\t\ttimeout:=timeout+1.\r\t\t\ttimeout<500000\r\t\t\tifTrue:[^nil]\r\t\t]. ',			#stamp : 'pm 10/20/2018 17:58',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i timeout|\r\ttimeout:=0.\r\tmodified := true.\r\t[ modified ]\r\twhileTrue: [\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\t"TEMPORARY"\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t"-1 is for when we won\'t break." \r\t\t\ttimeout:=timeout+1.\r\t\t\ttimeout<5000000\r\t\t\tifTrue:[^nil]\r\t\t]. ',			#stamp : 'pm 10/20/2018 17:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T17:58:34.494671+02:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i timeout|\r\ttimeout:=0.\r\tmodified := true.\r\t[ modified ]\r\twhileTrue: [\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\t"TEMPORARY"\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t"-1 is for when we won\'t break." \r\t\t\ttimeout:=timeout+1.\r\t\t\ttimeout<5000000\r\t\t\tifTrue:[^nil]\r\t\t]. ',			#stamp : 'pm 10/20/2018 17:58',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i timeout|\r\ttimeout:=0.\r\tmodified := true.\r\t[ modified ]\r\twhileTrue: [\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\t"TEMPORARY"\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t"-1 is for when we won\'t break." \r\t\t\ttimeout:=timeout+1.\r\t\t\ttimeout<500000000\r\t\t\tifTrue:[^nil]\r\t\t]. ',			#stamp : 'pm 10/20/2018 17:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T17:58:41.991247+02:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i timeout|\r\ttimeout:=0.\r\tmodified := true.\r\t[ modified ]\r\twhileTrue: [\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\t"TEMPORARY"\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t"-1 is for when we won\'t break." \r\t\t\ttimeout:=timeout+1.\r\t\t\ttimeout<500000000\r\t\t\tifTrue:[^nil]\r\t\t]. ',			#stamp : 'pm 10/20/2018 17:58',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i timeout|\r\ttimeout:=0.\r\tmodified := true.\r\t[ modified ]\r\twhileTrue: [\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\t"TEMPORARY"\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t"-1 is for when we won\'t break." \r\t\t\ttimeout:=timeout+1.\r\t\t\ttimeout<50000000000\r\t\t\tifTrue:[^nil]\r\t\t]. ',			#stamp : 'pm 10/20/2018 17:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-20T17:59:18.366496+02:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i timeout|\r\ttimeout:=0.\r\tmodified := true.\r\t[ modified ]\r\twhileTrue: [\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\t"TEMPORARY"\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t"-1 is for when we won\'t break." \r\t\t\ttimeout:=timeout+1.\r\t\t\ttimeout<50000000000\r\t\t\tifTrue:[^nil]\r\t\t]. ',			#stamp : 'pm 10/20/2018 17:58',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i timeout|\r\ttimeout:=0.\r\tmodified := true.\r\t[ modified ]\r\twhileTrue: [\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification\r\t\t\tifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\tTranscript show: \'Unification impossible\'; cr.\t"TEMPORARY"\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t"-1 is for when we won\'t break." \r\t\t\ttimeout:=timeout+1.\r\t\t\ttimeout<5000\r\t\t\tifFalse:[^nil]\r\t\t]. ',			#stamp : 'pm 10/20/2018 17:59',			#package : #_resolution_1erOrdre		}	}}