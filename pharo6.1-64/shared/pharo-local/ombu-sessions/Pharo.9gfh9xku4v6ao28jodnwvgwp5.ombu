OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T17:18:51.623557+02:00' ],		#prior : OmReference [ 'Pharo.bnaj4d6gghv18kjcn01wg8ykq', '32' ],		#self : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #FactorisationUnitTest,			#protocol : #testing,			#sourceCode : 'FactorisationUnitTest\r\t|r newPair|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tr:=Resolvante new.\r\tr factorisation: self.\r\tTranscript show: r;cr.',			#stamp : 'pm 10/25/2018 17:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T17:18:58.659937+02:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #FactorisationUnitTest,			#protocol : #testing,			#sourceCode : 'FactorisationUnitTest\r\t|r newPair|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tr:=Resolvante new.\r\tr factorisation: self.\r\tTranscript show: r;cr.',			#stamp : 'pm 10/25/2018 17:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #FactorisationUnitTest,			#protocol : #testing,			#sourceCode : 'FactorisationUnitTest\r\t|r|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tr:=Resolvante new.\r\tr factorisation: self.\r\tTranscript show: r;cr.',			#stamp : 'pm 10/25/2018 17:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T17:22:07.669801+02:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #FactorisationUnitTest,			#protocol : #testing,			#sourceCode : 'FactorisationUnitTest\r\t|r|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tr:=Resolvante new.\r\tr factorisation: self.\r\tTranscript show: r;cr.',			#stamp : 'pm 10/25/2018 17:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #FactorisationUnitTest,			#protocol : #testing,			#sourceCode : 'FactorisationUnitTest\r\t|r|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\r\tr:=Resolvante new.\r\tr factorisation: self.\r\r\tTranscript show: r;cr.',			#stamp : 'pm 10/25/2018 17:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T17:22:43.665116+02:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\r\tTranscript show: \'basic one #1\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'basic one #2\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'z\').\t\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\r\tTranscript show: \'with imply and nested forall.\'.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\'.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\'.\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' .\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r\tp SkolemnisationTest.\r\t\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest .\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/15/2018 15:42',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2 |\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\r\tTranscript show: \'basic one #1\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'basic one #2\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'z\').\t\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\r\tTranscript show: \'with imply and nested forall.\'.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\'.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\'.\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' .\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r\tp SkolemnisationTest.\r\t\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest .\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/25/2018 17:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:31:47.894799+02:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #ResolvanteUnitTest,			#protocol : #testing,			#sourceCode : 'ResolvanteUnitTest\r\t|r newPair|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tr:=Resolvante new.\r\tr factorisation: self.\r\t\r\tnewPair:=r unifiedPair.\r\r\r\t^self error:\'todo\'',			#stamp : 'pm 10/25/2018 13:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #ResolvanteUnitTest,			#protocol : #testing,			#sourceCode : 'ResolvanteUnitTest\r\t|r newPair|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tr:=Resolvante new.\r\tr factorisation: self.\r\t\r\tTranscript show:(r unifiedPair);cr.',			#stamp : 'pm 10/25/2018 18:31',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:33:55.18812+02:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr;cr.\r\t^t',			#stamp : 'pm 10/18/2018 15:13',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t r|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr;cr.\r\tr:=Resolvante new.\r\tr factorisation: (t at:1).\r\t\r\tTranscript show:\'Factorisation\' ;show:(t unifiedPair);cr.\r\t^t',			#stamp : 'pm 10/25/2018 18:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:34:18.101232+02:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t r|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr;cr.\r\tr:=Resolvante new.\r\tr factorisation: (t at:1).\r\t\r\tTranscript show:\'Factorisation\' ;show:(t unifiedPair);cr.\r\t^t',			#stamp : 'pm 10/25/2018 18:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t r|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr;cr.\r\tr:=Resolvante new.\r\tr factorisation: ((t clauses) at:1).\r\t\r\tTranscript show:\'Factorisation\' ;show:(t unifiedPair);cr.\r\t^t',			#stamp : 'pm 10/25/2018 18:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:35:07.542971+02:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #size,			#protocol : #accessing,			#sourceCode : 'size\r\t^atomes size.',			#stamp : 'pm 10/25/2018 18:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:35:43.826284+02:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'at: index\r\t^atomes at:index',			#stamp : 'pm 10/25/2018 18:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:36:17.057192+02:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=0.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause collect:[ :each | each~=(aClause at:i) and:[each~=(aClause at:j)]]).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 12:06',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause collect:[ :each | each~=(aClause at:i) and:[each~=(aClause at:j)]]).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 18:36',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:38:21.978497+02:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t r|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr;cr.\r\tr:=Resolvante new.\r\tr factorisation: ((t clauses) at:1).\r\t\r\tTranscript show:\'Factorisation\' ;show:(t unifiedPair);cr.\r\t^t',			#stamp : 'pm 10/25/2018 18:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t r|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr;cr.\r\tr:=Resolvante new.\r\tr factorisation: ((t clauses) at:1).\r\t\r\tTranscript show:\'Factorisation\' ;show:t;cr.\r\t^t',			#stamp : 'pm 10/25/2018 18:38',			#package : #_resolution_1erOrdre		}	}}