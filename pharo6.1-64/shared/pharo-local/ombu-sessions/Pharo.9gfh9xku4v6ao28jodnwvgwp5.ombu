OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T17:18:51.623557+02:00' ],		#prior : OmReference [ 'Pharo.bnaj4d6gghv18kjcn01wg8ykq', '32' ],		#self : OmReference [ '1' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #FactorisationUnitTest,			#protocol : #testing,			#sourceCode : 'FactorisationUnitTest\r\t|r newPair|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tr:=Resolvante new.\r\tr factorisation: self.\r\tTranscript show: r;cr.',			#stamp : 'pm 10/25/2018 17:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T17:18:58.659937+02:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #FactorisationUnitTest,			#protocol : #testing,			#sourceCode : 'FactorisationUnitTest\r\t|r newPair|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tr:=Resolvante new.\r\tr factorisation: self.\r\tTranscript show: r;cr.',			#stamp : 'pm 10/25/2018 17:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #FactorisationUnitTest,			#protocol : #testing,			#sourceCode : 'FactorisationUnitTest\r\t|r|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tr:=Resolvante new.\r\tr factorisation: self.\r\tTranscript show: r;cr.',			#stamp : 'pm 10/25/2018 17:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T17:22:07.669801+02:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #FactorisationUnitTest,			#protocol : #testing,			#sourceCode : 'FactorisationUnitTest\r\t|r|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tr:=Resolvante new.\r\tr factorisation: self.\r\tTranscript show: r;cr.',			#stamp : 'pm 10/25/2018 17:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #FactorisationUnitTest,			#protocol : #testing,			#sourceCode : 'FactorisationUnitTest\r\t|r|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\r\tr:=Resolvante new.\r\tr factorisation: self.\r\r\tTranscript show: r;cr.',			#stamp : 'pm 10/25/2018 17:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T17:22:43.665116+02:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2|\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\r\tTranscript show: \'basic one #1\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'basic one #2\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'z\').\t\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\r\tTranscript show: \'with imply and nested forall.\'.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\'.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\'.\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' .\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r\tp SkolemnisationTest.\r\t\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest .\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/15/2018 15:42',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #testingSkolemn,			#protocol : #testing,			#sourceCode : 'testingSkolemn\r \t"everything is tested in those few lines"\r\t"Binary"\r\t| p terms terms2 |\r\t\r\t"Transcript clear."\r\tTranscript show: \'Testing Skolemnisation related stuff\';cr.\r\t\r\r\tTranscript show: \'basic one #1\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'y\');add:(Term new:\'z\').\t\r\tp:=ForAll new: \'x\' Property: (Exists new: \'y\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'basic one #2\'.\r\tterms:=LinkedList new.\r\tterms add:(Term new:\'x\');add:(Term new:\'z\').\t\r\tp:=Or new: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms )))\r\t rightProp: (ForAll new: \'x\' Property: (ForAll new: \'z\' Property: (Predicate new: \'P\' fromList: terms ))).\r\tp SkolemnisationTest.\r\r\r\tTranscript show: \'with imply and nested forall.\'.\r\tp:=Not new: \r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'a\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'a\')))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'same as previous one, but with x representing a variable in one, and a const in the other.\'.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\t\r\tTranscript show: \'same as previous one, check Unbound Exists is replaced by consts\'.\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(Exists new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tp SkolemnisationTest.\t\r\t\r\tTranscript show: \'Teacher\'\'s stress test#1\' .\r\tp:=Not new:(\r        ForAll new: \'x\' Property: \r        (Imply new: (ForAll new: \'y\' Property: (Predicate new: \'P\' variable: (Term new:\'y\')))\r         rightProp: (Predicate new:\'Q\' variable: (Term new:\'x\')))).        \r\tp SkolemnisationTest.\r\t\t\r\tTranscript show: \'Teacher\'\'s stress test#2\'\t.\r\tterms:=LinkedList new.\r    terms add:(Term new: \'x\') ; add:(Term new:\'z\').\r    terms2:=LinkedList new.\r    terms2 add:(Term new:\'y\') ; add: (Term new:\'t\').\r    p:=Not new:\r            (ForAll new: \'x\' Property:\r                (ForAll new: \'y\' Property:\r                    (Exists new: \'z\' Property: \r                        (ForAll new: \'t\' Property: \r                            (Imply new: \r                                (Predicate new: \'P\' fromList: terms)\r                             rightProp: \r                                (Predicate new: \'Q\' fromList: terms2)))))).\r\tp SkolemnisationTest.\r\t\t\t\r\tTranscript show: \'Test functionnal term in initial Predicate \'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'z\')).\r\r   p:=Not new:\r            (ForAll new: \'x\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest .\r\t\r\tTranscript show: \'Test functionnal term in initial Predicate  with needed inner replacement\'.\r\tterms:=LinkedList new.\r   terms add:(Term new: \'x\') ; add:(FuncTerm new: \'f\' Variable: (Term new:\'y\')).\r\r   p:=ForAll new: \'x\' Property:\r\t\t\t\t\t(Exists new: \'y\' Property:\r                  (Predicate new: \'P\' fromList: terms)).\r\tp SkolemnisationTest.\r\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr. ',			#stamp : 'pm 10/25/2018 17:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:31:47.894799+02:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #ResolvanteUnitTest,			#protocol : #testing,			#sourceCode : 'ResolvanteUnitTest\r\t|r newPair|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tr:=Resolvante new.\r\tr factorisation: self.\r\t\r\tnewPair:=r unifiedPair.\r\r\r\t^self error:\'todo\'',			#stamp : 'pm 10/25/2018 13:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #ResolvanteUnitTest,			#protocol : #testing,			#sourceCode : 'ResolvanteUnitTest\r\t|r newPair|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tr:=Resolvante new.\r\tr factorisation: self.\r\t\r\tTranscript show:(r unifiedPair);cr.',			#stamp : 'pm 10/25/2018 18:31',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:33:55.18812+02:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr;cr.\r\t^t',			#stamp : 'pm 10/18/2018 15:13',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t r|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr;cr.\r\tr:=Resolvante new.\r\tr factorisation: (t at:1).\r\t\r\tTranscript show:\'Factorisation\' ;show:(t unifiedPair);cr.\r\t^t',			#stamp : 'pm 10/25/2018 18:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:34:18.101232+02:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t r|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr;cr.\r\tr:=Resolvante new.\r\tr factorisation: (t at:1).\r\t\r\tTranscript show:\'Factorisation\' ;show:(t unifiedPair);cr.\r\t^t',			#stamp : 'pm 10/25/2018 18:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t r|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr;cr.\r\tr:=Resolvante new.\r\tr factorisation: ((t clauses) at:1).\r\t\r\tTranscript show:\'Factorisation\' ;show:(t unifiedPair);cr.\r\t^t',			#stamp : 'pm 10/25/2018 18:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:35:07.542971+02:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #size,			#protocol : #accessing,			#sourceCode : 'size\r\t^atomes size.',			#stamp : 'pm 10/25/2018 18:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:35:43.826284+02:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'at: index\r\t^atomes at:index',			#stamp : 'pm 10/25/2018 18:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:36:17.057192+02:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=0.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause collect:[ :each | each~=(aClause at:i) and:[each~=(aClause at:j)]]).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 12:06',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause collect:[ :each | each~=(aClause at:i) and:[each~=(aClause at:j)]]).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 18:36',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:38:21.978497+02:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t r|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr;cr.\r\tr:=Resolvante new.\r\tr factorisation: ((t clauses) at:1).\r\t\r\tTranscript show:\'Factorisation\' ;show:(t unifiedPair);cr.\r\t^t',			#stamp : 'pm 10/25/2018 18:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t r|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr;cr.\r\tr:=Resolvante new.\r\tr factorisation: ((t clauses) at:1).\r\t\r\tTranscript show:\'Factorisation\' ;show:t;cr.\r\t^t',			#stamp : 'pm 10/25/2018 18:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:39:53.518361+02:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Clause\r\tinstanceVariableNames: \'atomes\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Clause,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Clause,						#isMetaSide : false					},					#name : #atomes,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Clause class\r\tinstanceVariableNames: \'\''				},				#name : #'Clause class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Clause,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Clause\r\tinstanceVariableNames: \'atomes\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Clause,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Clause,						#isMetaSide : false					},					#name : #atomes,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Clause class\r\tinstanceVariableNames: \'\''				},				#name : #'Clause class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Clause,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:39:53.64461+02:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #Clause\r\tinstanceVariableNames: \'atomes\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Clause,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Clause,						#isMetaSide : false					},					#name : #atomes,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Clause class\r\tinstanceVariableNames: \'\''				},				#name : #'Clause class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Clause,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #Clause\r\tinstanceVariableNames: \'atomes\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Clause,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Clause,						#isMetaSide : false					},					#name : #atomes,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Clause class\r\tinstanceVariableNames: \'\''				},				#name : #'Clause class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Clause,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:40:08.107464+02:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #size,			#protocol : #accessing,			#sourceCode : 'size\r\t^atomes size.',			#stamp : 'pm 10/25/2018 18:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:40:16.179503+02:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'at:',			#protocol : #accessing,			#sourceCode : 'at: index\r\t^atomes at:index',			#stamp : 'pm 10/25/2018 18:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:40:47.984382+02:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #Clause\r\tinstanceVariableNames: \'atomes\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Clause,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #Clause,						#isMetaSide : false					},					#name : #atomes,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Clause class\r\tinstanceVariableNames: \'\''				},				#name : #'Clause class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Clause,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #Clause\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Clause,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Clause class\r\tinstanceVariableNames: \'\''				},				#name : #'Clause class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Clause,					#isMetaSide : false				},				#parent : @23,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:40:59.427367+02:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: stream\r\tsuper printOn:stream.\r\tstream nextPutAll: (self prettyPrint).',			#stamp : 'pm 10/14/2018 15:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: stream\r\tstream nextPutAll: (self prettyPrint).',			#stamp : 'pm 10/25/2018 18:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:41:03.601008+02:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t|t|\r\tt:=\'{\'.\r\t\tatomes do:[  :each | t:=t,(each prettyPrint). ] separatedBy:[t:=t,\',\'].\r\tt:=t,\'}\'.\r\t^t.',			#stamp : 'pm 10/9/2018 17:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t|t|\r\tt:=\'{\'.\r\t\tself do:[  :each | t:=t,(each prettyPrint). ] separatedBy:[t:=t,\',\'].\r\tt:=t,\'}\'.\r\t^t.',			#stamp : 'pm 10/25/2018 18:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:41:05.533515+02:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t|t|\r\tt:=\'{\'.\r\t\tself do:[  :each | t:=t,(each prettyPrint). ] separatedBy:[t:=t,\',\'].\r\tt:=t,\'}\'.\r\t^t.',			#stamp : 'pm 10/25/2018 18:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t|t|\r\tt:=\'{\'.\r\tself do:[  :each | t:=t,(each prettyPrint). ] separatedBy:[t:=t,\',\'].\r\tt:=t,\'}\'.\r\t^t.',			#stamp : 'pm 10/25/2018 18:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:41:13.137759+02:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #isTautology,			#protocol : #testing,			#sourceCode : 'isTautology\r\tatomes do:[ :p1 |\r\t\tatomes do:[ :p2 | \r\t\t\t(p1 isOpposite: p2)\r\t\t\tifTrue:[^true].\r\t\t\t].\r\t\t].\r\t^false',			#stamp : 'pm 10/24/2018 07:55',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #isTautology,			#protocol : #testing,			#sourceCode : 'isTautology\r\tself do:[ :p1 |\r\t\tself do:[ :p2 | \r\t\t\t(p1 isOpposite: p2)\r\t\t\tifTrue:[^true].\r\t\t\t].\r\t\t].\r\t^false',			#stamp : 'pm 10/25/2018 18:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:41:19.994049+02:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #isEmptyClause,			#protocol : #testing,			#sourceCode : 'isEmptyClause\r\t^atomes empty.',			#stamp : 'pm 10/23/2018 21:28',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #isEmptyClause,			#protocol : #testing,			#sourceCode : 'isEmptyClause\r\t^self empty.',			#stamp : 'pm 10/25/2018 18:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:41:34.463267+02:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialize,			#sourceCode : 'initialize: OrProp\r\tatomes:=MinimalOrderedSet new.\r\tself addAll:OrProp.',			#stamp : 'pm 10/15/2018 15:14',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialize,			#sourceCode : 'initialize: OrProp\r\tself addAll:OrProp.',			#stamp : 'pm 10/25/2018 18:41',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:41:50.782002+02:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #initialize,			#protocol : #initialize,			#sourceCode : 'initialize\r\tatomes:=MinimalOrderedSet new.',			#stamp : 'pm 10/15/2018 15:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:42:13.955928+02:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #atomes,			#protocol : #accessing,			#sourceCode : 'atomes\r\t^atomes.',			#stamp : 'pm 10/1/2018 20:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:42:43.083154+02:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'add:',			#protocol : #accessing,			#sourceCode : 'add: var\r\t(var isKindOf: Atome)\r\t\tifTrue:[\r\t\t\t(self atomes) add:var.\r\t\t\t^self."able chaining operation"\r\t\t\t]\r\t\tifFalse:[\r\t\t\t\tError new: \'wrong type in clause\'.\r\t\t\t].',			#stamp : 'pm 10/9/2018 13:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'add:',			#protocol : #accessing,			#sourceCode : 'add: var\r\t(var isAtome)\r\t\tifTrue:[\r\t\t\t(self atomes) add:var.\r\t\t\t^self."able chaining operation"\r\t\t\t]\r\t\tifFalse:[\r\t\t\t\tError new: \'wrong type in clause\'.\r\t\t\t].',			#stamp : 'pm 10/25/2018 18:42',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:43:48.850734+02:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'add:',			#protocol : #accessing,			#sourceCode : 'add: var\r\t(var isAtome)\r\t\tifTrue:[\r\t\t\t(self atomes) add:var.\r\t\t\t^self."able chaining operation"\r\t\t\t]\r\t\tifFalse:[\r\t\t\t\tError new: \'wrong type in clause\'.\r\t\t\t].',			#stamp : 'pm 10/25/2018 18:42',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'add:',			#protocol : #accessing,			#sourceCode : 'add: var\r\t(var isAtome)\r\tifTrue:[\r\t\t(self atomes) add:var.\r\t\t^self."able chaining operation"\r\t\t]\r\tifFalse:[\r\t\t\tError new: \'Trying to add a wrong type in a clause\'.\r\t\t].',			#stamp : 'pm 10/25/2018 18:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:44:58.555192+02:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Clause class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t^self basicNew initialize.',			#stamp : 'pm 10/2/2018 17:06',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Clause class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t^self basicNew.',			#stamp : 'pm 10/25/2018 18:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:45:12.405871+02:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Clause class',				#isMetaSide : true			},			#name : #new,			#protocol : #'instance creation',			#sourceCode : 'new\r\t^self basicNew.',			#stamp : 'pm 10/25/2018 18:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:54:14.064248+02:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'add:',			#protocol : #accessing,			#sourceCode : 'add: var\r\t(var isAtome)\r\tifTrue:[\r\t\t(self atomes) add:var.\r\t\t^self."able chaining operation"\r\t\t]\r\tifFalse:[\r\t\t\tError new: \'Trying to add a wrong type in a clause\'.\r\t\t].',			#stamp : 'pm 10/25/2018 18:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'add:',			#protocol : #accessing,			#sourceCode : 'add: var\r\t(var isAtome)\r\tifTrue:[\r\t\tself add:var.\r\t\t^self."able chaining operation"\r\t\t]\r\tifFalse:[\r\t\t\tError new: \'Trying to add a wrong type in a clause\'.\r\t\t].',			#stamp : 'pm 10/25/2018 18:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:57:23.226291+02:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #ClausalForm\r\tinstanceVariableNames: \'clauses\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ClausalForm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ClausalForm,						#isMetaSide : false					},					#name : #clauses,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClausalForm class\r\tinstanceVariableNames: \'\''				},				#name : #'ClausalForm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClausalForm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions.\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\r\rPublic API and Key Messages\r\r- message one   \r- message two \r- (for bonus points) how to create instances.\r\r   One simple example is simply gorgeous.\r \rInternal Representation and Key Implementation Points.\r\r    Instance Variables\r\tclauses:\t\t<Object>\r\r\r    Implementation Points',				#stamp : 'pm 10/23/2018 12:16'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #ClausalForm\r\tinstanceVariableNames: \'clauses\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ClausalForm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ClausalForm,						#isMetaSide : false					},					#name : #clauses,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClausalForm class\r\tinstanceVariableNames: \'\''				},				#name : #'ClausalForm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClausalForm,					#isMetaSide : false				},				#parent : @23,				#content : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions.\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\r\rPublic API and Key Messages\r\r- message one   \r- message two \r- (for bonus points) how to create instances.\r\r   One simple example is simply gorgeous.\r \rInternal Representation and Key Implementation Points.\r\r    Instance Variables\r\tclauses:\t\t<Object>\r\r\r    Implementation Points',				#stamp : 'pm 10/23/2018 12:16'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:57:24.837357+02:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'Object',				#traitCompositionSource : '{}',				#definitionSource : 'Object subclass: #ClausalForm\r\tinstanceVariableNames: \'clauses\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ClausalForm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ClausalForm,						#isMetaSide : false					},					#name : #clauses,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClausalForm class\r\tinstanceVariableNames: \'\''				},				#name : #'ClausalForm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClausalForm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions.\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\r\rPublic API and Key Messages\r\r- message one   \r- message two \r- (for bonus points) how to create instances.\r\r   One simple example is simply gorgeous.\r \rInternal Representation and Key Implementation Points.\r\r    Instance Variables\r\tclauses:\t\t<Object>\r\r\r    Implementation Points',				#stamp : 'pm 10/23/2018 12:16'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #ClausalForm\r\tinstanceVariableNames: \'clauses\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ClausalForm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ClausalForm,						#isMetaSide : false					},					#name : #clauses,					#parent : @23				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClausalForm class\r\tinstanceVariableNames: \'\''				},				#name : #'ClausalForm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClausalForm,					#isMetaSide : false				},				#parent : @23,				#content : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions.\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\r\rPublic API and Key Messages\r\r- message one   \r- message two \r- (for bonus points) how to create instances.\r\r   One simple example is simply gorgeous.\r \rInternal Representation and Key Implementation Points.\r\r    Instance Variables\r\tclauses:\t\t<Object>\r\r\r    Implementation Points',				#stamp : 'pm 10/23/2018 12:16'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:57:39.957424+02:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: stream\r\tsuper printOn:stream.\r\tstream nextPutAll: (self prettyPrint).',			#stamp : 'pm 10/14/2018 15:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: stream\r\tstream nextPutAll: (self prettyPrint).',			#stamp : 'pm 10/25/2018 18:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:57:44.396306+02:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #initialization,			#sourceCode : 'prettyPrint\r\t|t|\r\tt:=\'{\'.\r\t\tclauses do: [  :each | t:=t,(each prettyPrint). ] separatedBy: [t:=t,\',\'].\r\tt:=t,\'}\'.\r\t^t.',			#stamp : 'pm 10/9/2018 17:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #initialization,			#sourceCode : 'prettyPrint\r\t|t|\r\tt:=\'{\'.\r\t\tself do: [  :each | t:=t,(each prettyPrint). ] separatedBy: [t:=t,\',\'].\r\tt:=t,\'}\'.\r\t^t.',			#stamp : 'pm 10/25/2018 18:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:58:42.305873+02:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpClassModification {		#oldClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #ClausalForm\r\tinstanceVariableNames: \'clauses\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ClausalForm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [				RGInstanceVariableDefinition {					#annotations : IdentityDictionary {						#className : #ClausalForm,						#isMetaSide : false					},					#name : #clauses,					#parent : @7				}			],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClausalForm class\r\tinstanceVariableNames: \'\''				},				#name : #'ClausalForm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClausalForm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions.\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\r\rPublic API and Key Messages\r\r- message one   \r- message two \r- (for bonus points) how to create instances.\r\r   One simple example is simply gorgeous.\r \rInternal Representation and Key Implementation Points.\r\r    Instance Variables\r\tclauses:\t\t<Object>\r\r\r    Implementation Points',				#stamp : 'pm 10/23/2018 12:16'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#newClass : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #ClausalForm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ClausalForm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClausalForm class\r\tinstanceVariableNames: \'\''				},				#name : #'ClausalForm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @23			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClausalForm,					#isMetaSide : false				},				#parent : @23,				#content : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions.\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\r\rPublic API and Key Messages\r\r- message one   \r- message two \r- (for bonus points) how to create instances.\r\r   One simple example is simply gorgeous.\r \rInternal Representation and Key Implementation Points.\r\r    Instance Variables\r\tclauses:\t\t<Object>\r\r\r    Implementation Points',				#stamp : 'pm 10/23/2018 12:16'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:58:57.937998+02:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'add:',			#protocol : #initialization,			#sourceCode : 'add: clause\r\t(clause isKindOf: Clause)\r\tifTrue: [ self clauses add: clause ]\r\tifFalse:[Error new: \'Tried to add a non clause object to a clausaleForm\'].',			#stamp : 'pm 10/9/2018 13:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'add:',			#protocol : #initialization,			#sourceCode : 'add: clause\r\t(clause isKindOf: Clause)\r\tifTrue: [ self add: clause ]\r\tifFalse:[Error new: \'Tried to add a non clause object to a clausaleForm\'].',			#stamp : 'pm 10/25/2018 18:58',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:59:19.425626+02:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'add:',			#protocol : #initialization,			#sourceCode : 'add: clause\r\t(clause isKindOf: Clause)\r\tifTrue: [ self add: clause ]\r\tifFalse:[Error new: \'Tried to add a non clause object to a clausaleForm\'].',			#stamp : 'pm 10/25/2018 18:58',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'add:',			#protocol : #initialization,			#sourceCode : 'add: aClause\r\t(aClause isClause)\r\tifTrue: [ self add: aClause ]\r\tifFalse:[Error new: \'Tried to add a non clause object to a clausaleForm\'].',			#stamp : 'pm 10/25/2018 18:59',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:59:34.825376+02:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #clauses,			#protocol : #accessing,			#sourceCode : 'clauses\r\t^clauses.',			#stamp : 'pm 10/1/2018 20:17',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:59:42.944055+02:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tclauses:=MinimalOrderedSet new.\r\t',			#stamp : 'pm 10/15/2018 15:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:59:51.725169+02:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: ClausifiedFormula\r\tclauses:=MinimalOrderedSet new.\r\tself addAll: ClausifiedFormula.',			#stamp : 'pm 10/15/2018 15:13',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialization,			#sourceCode : 'initialize: ClausifiedFormula\r\tself addAll: ClausifiedFormula.',			#stamp : 'pm 10/25/2018 18:59',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T18:59:57.731257+02:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #isEmpty,			#protocol : #testing,			#sourceCode : 'isEmpty\r\t^clauses empty',			#stamp : 'pm 10/23/2018 21:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T19:00:07.421537+02:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c t |\r\tsat:=MinimalOrderedSet new.\r\t(clauses isEmpty)\r\twhileFalse: [ \r\t\tc:=clauses removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:c.])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tt:= Resolvante new.\r\t\t\t\t\tt resolvante: c1 with: c.\r\t\t\t\t\tself addAll:t.\r\t\t\t\t\t].\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/24/2018 10:13',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c t |\r\tsat:=MinimalOrderedSet new.\r\t(self isEmpty)\r\twhileFalse: [ \r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:c.])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tt:= Resolvante new.\r\t\t\t\t\tt resolvante: c1 with: c.\r\t\t\t\t\tself addAll:t.\r\t\t\t\t\t].\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/25/2018 19:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T19:00:56.669272+02:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #initialization,			#sourceCode : 'addAll: clausifiedProp\r\t((clausifiedProp  isOr) | (clausifiedProp isAtome))"If i\'m in a or, there\'s only or(s) under him."\r\tifTrue:[self clauses add: (Clause new:clausifiedProp)]\r\tifFalse:[\r\t\t(clausifiedProp isNot)\r\t\tifTrue:[\r\t\t\t((clausifiedProp operand) isAtome)\r\t\t\tifTrue:[^self clauses add:(Clause new:clausifiedProp).]\r\t\t\tifFalse:[^Error new:\'A not isn\'\'t englobing an atome.\'.].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(clausifiedProp isAnd)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (clausifiedProp left).\r\t\t\t\tself addAll: (clausifiedProp right).\r\t\t\t\t]\r\t\tifFalse:[\r\t\t\tError new: \'Tried to add a non clause object to a clausaleForm.\'.].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/25/2018 08:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #initialization,			#sourceCode : 'addAll: clausifiedProp\r\t((clausifiedProp  isOr) | (clausifiedProp isAtome))"If i\'m in a or, there\'s only or(s) under him."\r\tifTrue:[self add: (Clause new:clausifiedProp)]\r\tifFalse:[\r\t\t(clausifiedProp isNot)\r\t\tifTrue:[\r\t\t\t((clausifiedProp operand) isAtome)\r\t\t\tifTrue:[^self add:(Clause new:clausifiedProp).]\r\t\t\tifFalse:[^Error new:\'A not isn\'\'t englobing an atome.\'.].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(clausifiedProp isAnd)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (clausifiedProp left).\r\t\t\t\tself addAll: (clausifiedProp right).\r\t\t\t\t]\r\t\tifFalse:[\r\t\t\tError new: \'Tried to add a non clause object to a clausaleForm.\'.].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/25/2018 19:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T19:04:41.777493+02:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'add:',			#protocol : #initialization,			#sourceCode : 'add: aClause\r\t(aClause isClause)\r\tifTrue: [ self add: aClause ]\r\tifFalse:[Error new: \'Tried to add a non clause object to a clausaleForm\'].',			#stamp : 'pm 10/25/2018 18:59',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'add:',			#protocol : #initialization,			#sourceCode : 'add: aClause\r\t(aClause isClause)\r\tifTrue: [ super add: aClause ]\r\tifFalse:[Error new: \'Tried to add a non clause object to a clausaleForm\'].',			#stamp : 'pm 10/25/2018 19:04',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T19:04:48.970076+02:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'add:',			#protocol : #accessing,			#sourceCode : 'add: var\r\t(var isAtome)\r\tifTrue:[\r\t\tself add:var.\r\t\t^self."able chaining operation"\r\t\t]\r\tifFalse:[\r\t\t\tError new: \'Trying to add a wrong type in a clause\'.\r\t\t].',			#stamp : 'pm 10/25/2018 18:54',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'add:',			#protocol : #accessing,			#sourceCode : 'add: var\r\t(var isAtome)\r\tifTrue:[\r\t\tsuper add:var.\r\t\t^self."able chaining operation"\r\t\t]\r\tifFalse:[\r\t\t\tError new: \'Trying to add a wrong type in a clause\'.\r\t\t].',			#stamp : 'pm 10/25/2018 19:04',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T19:05:04.78812+02:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'add:',			#protocol : #initialization,			#sourceCode : 'add: aClause\r\t(aClause isClause)\r\tifTrue: [ super add: aClause ]\r\tifFalse:[Error new: \'Tried to add a non clause object to a clausaleForm\'].',			#stamp : 'pm 10/25/2018 19:04',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'add:',			#protocol : #initialization,			#sourceCode : 'add: aClause\r\t(aClause isClause)\r\tifTrue: [ super add: aClause ]\r\tifFalse:[Error new: \'Tried to add a non clause object to a clausaleForm\'].\r\t^self "enable chaining operation"',			#stamp : 'pm 10/25/2018 19:05',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T19:08:02.905653+02:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'add:',			#protocol : #initialization,			#sourceCode : 'add: aClause\r\t(aClause isClause)\r\tifTrue: [ super add: aClause ]\r\tifFalse:[Error new: \'Tried to add a non clause object to a clausaleForm\'].\r\t^self "enable chaining operation"',			#stamp : 'pm 10/25/2018 19:05',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'add:',			#protocol : #initialization,			#sourceCode : 'add: aClause\r\t(aClause isKindOf: Clause)\r\tifTrue: [ super add: aClause ]\r\tifFalse:[Error new: \'Tried to add a non clause object to a clausaleForm\'].\r\t^self "enable chaining operation"',			#stamp : 'pm 10/25/2018 19:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T19:08:13.830734+02:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpProtocolAddition {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #ClausalForm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ClausalForm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClausalForm class\r\tinstanceVariableNames: \'\''				},				#name : #'ClausalForm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClausalForm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions.\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\r\rPublic API and Key Messages\r\r- message one   \r- message two \r- (for bonus points) how to create instances.\r\r   One simple example is simply gorgeous.\r \rInternal Representation and Key Implementation Points.\r\r    Instance Variables\r\tclauses:\t\t<Object>\r\r\r    Implementation Points',				#stamp : 'pm 10/23/2018 12:16'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #adding	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T19:08:18.022211+02:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'add:',			#protocol : #initialization,			#sourceCode : 'add: aClause\r\t(aClause isKindOf: Clause)\r\tifTrue: [ super add: aClause ]\r\tifFalse:[Error new: \'Tried to add a non clause object to a clausaleForm\'].\r\t^self "enable chaining operation"',			#stamp : 'pm 10/25/2018 19:08',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: aClause\r\t(aClause isKindOf: Clause)\r\tifTrue: [ super add: aClause ]\r\tifFalse:[Error new: \'Tried to add a non clause object to a clausaleForm\'].\r\t^self "enable chaining operation"',			#stamp : 'pm 10/25/2018 19:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T19:08:19.370869+02:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #initialization,			#sourceCode : 'addAll: clausifiedProp\r\t((clausifiedProp  isOr) | (clausifiedProp isAtome))"If i\'m in a or, there\'s only or(s) under him."\r\tifTrue:[self add: (Clause new:clausifiedProp)]\r\tifFalse:[\r\t\t(clausifiedProp isNot)\r\t\tifTrue:[\r\t\t\t((clausifiedProp operand) isAtome)\r\t\t\tifTrue:[^self add:(Clause new:clausifiedProp).]\r\t\t\tifFalse:[^Error new:\'A not isn\'\'t englobing an atome.\'.].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(clausifiedProp isAnd)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (clausifiedProp left).\r\t\t\t\tself addAll: (clausifiedProp right).\r\t\t\t\t]\r\t\tifFalse:[\r\t\t\tError new: \'Tried to add a non clause object to a clausaleForm.\'.].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/25/2018 19:00',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #adding,			#sourceCode : 'addAll: clausifiedProp\r\t((clausifiedProp  isOr) | (clausifiedProp isAtome))"If i\'m in a or, there\'s only or(s) under him."\r\tifTrue:[self add: (Clause new:clausifiedProp)]\r\tifFalse:[\r\t\t(clausifiedProp isNot)\r\t\tifTrue:[\r\t\t\t((clausifiedProp operand) isAtome)\r\t\t\tifTrue:[^self add:(Clause new:clausifiedProp).]\r\t\t\tifFalse:[^Error new:\'A not isn\'\'t englobing an atome.\'.].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(clausifiedProp isAnd)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (clausifiedProp left).\r\t\t\t\tself addAll: (clausifiedProp right).\r\t\t\t\t]\r\t\tifFalse:[\r\t\t\tError new: \'Tried to add a non clause object to a clausaleForm.\'.].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/25/2018 19:00',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T19:08:24.155735+02:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #ClausalForm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ClausalForm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClausalForm class\r\tinstanceVariableNames: \'\''				},				#name : #'ClausalForm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClausalForm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions.\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\r\rPublic API and Key Messages\r\r- message one   \r- message two \r- (for bonus points) how to create instances.\r\r   One simple example is simply gorgeous.\r \rInternal Representation and Key Implementation Points.\r\r    Instance Variables\r\tclauses:\t\t<Object>\r\r\r    Implementation Points',				#stamp : 'pm 10/23/2018 12:16'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #accessing	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T19:08:29.991087+02:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #ClausalForm\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #ClausalForm,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'ClausalForm class\r\tinstanceVariableNames: \'\''				},				#name : #'ClausalForm class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #ClausalForm,					#isMetaSide : false				},				#parent : @7,				#content : 'I represent a clausal form, which means i\'m a long \'and\' statement with \'or\' as my propositions.\r\rI know my clauses (which are represented by the class Clause)\rMy responsability is to use the resolution method on myself\r\r\rPublic API and Key Messages\r\r- message one   \r- message two \r- (for bonus points) how to create instances.\r\r   One simple example is simply gorgeous.\r \rInternal Representation and Key Implementation Points.\r\r    Instance Variables\r\tclauses:\t\t<Object>\r\r\r    Implementation Points',				#stamp : 'pm 10/23/2018 12:16'			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #testing	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T19:08:35.985442+02:00' ],		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ]	},	#content : EpProtocolAddition {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #Clause\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Clause,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Clause class\r\tinstanceVariableNames: \'\''				},				#name : #'Clause class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Clause,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #adding	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T19:08:39.11196+02:00' ],		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'add:',			#protocol : #accessing,			#sourceCode : 'add: var\r\t(var isAtome)\r\tifTrue:[\r\t\tsuper add:var.\r\t\t^self."able chaining operation"\r\t\t]\r\tifFalse:[\r\t\t\tError new: \'Trying to add a wrong type in a clause\'.\r\t\t].',			#stamp : 'pm 10/25/2018 19:04',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: var\r\t(var isAtome)\r\tifTrue:[\r\t\tsuper add:var.\r\t\t^self."able chaining operation"\r\t\t]\r\tifFalse:[\r\t\t\tError new: \'Trying to add a wrong type in a clause\'.\r\t\t].',			#stamp : 'pm 10/25/2018 19:04',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T19:08:41.634702+02:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #accessing,			#sourceCode : 'addAll: orProp\r\t(orProp isAtome)\r\tifTrue:[self add:orProp.]\r\tifFalse:[\r\t\t((orProp) isNot)\r\t\tifTrue:["we\'re in a not"\r\t\t\t(orProp operand isAtome)\r\t\t\t\tifTrue:["we\'re in an atom"\r\t\t\t\t\t((orProp operand) isPredicate)\r\t\t\t\t\tifTrue:[self add:(NotPredicate new: (orProp operand) getSymb fromList: (orProp operand) terms).]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t((orProp operand) isVar)\r\t\t\t\t\t\tifTrue:[self add:(NotVar new:((orProp operand) getSymb)).]\r\t\t\t\t\t\tifFalse: [ Error new: \'shouldn\'\'t be any True or false here\' ]].\r\t\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tError new:\'Error, shouldn\'\'t be any more not ( binaryOp )\'\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(orProp isOr)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (orProp left).\r\t\t\t\tself addAll: (orProp right).\r\t\t\t\t]\r\t\t\tifFalse:["switch to Error new:"\r\t\t\t\tError new:\'Error, shouldn\'\'t be any other kind of prop here.\'.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/25/2018 08:44',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #adding,			#sourceCode : 'addAll: orProp\r\t(orProp isAtome)\r\tifTrue:[self add:orProp.]\r\tifFalse:[\r\t\t((orProp) isNot)\r\t\tifTrue:["we\'re in a not"\r\t\t\t(orProp operand isAtome)\r\t\t\t\tifTrue:["we\'re in an atom"\r\t\t\t\t\t((orProp operand) isPredicate)\r\t\t\t\t\tifTrue:[self add:(NotPredicate new: (orProp operand) getSymb fromList: (orProp operand) terms).]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t((orProp operand) isVar)\r\t\t\t\t\t\tifTrue:[self add:(NotVar new:((orProp operand) getSymb)).]\r\t\t\t\t\t\tifFalse: [ Error new: \'shouldn\'\'t be any True or false here\' ]].\r\t\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tError new:\'Error, shouldn\'\'t be any more not ( binaryOp )\'\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(orProp isOr)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (orProp left).\r\t\t\t\tself addAll: (orProp right).\r\t\t\t\t]\r\t\t\tifFalse:["switch to Error new:"\r\t\t\t\tError new:\'Error, shouldn\'\'t be any other kind of prop here.\'.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/25/2018 08:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T19:08:43.679686+02:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #Clause\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre\''			},			#name : #Clause,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Clause class\r\tinstanceVariableNames: \'\''				},				#name : #'Clause class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Clause,					#isMetaSide : false				},				#parent : @7,				#content : ''			},			#classVariables : OrderedCollection [ ],			#category : #_resolution_1erOrdre,			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #accessing	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T19:08:43.761006+02:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'addFromList:',			#protocol : #accessing,			#sourceCode : 'addFromList: aLinkedList\r\taLinkedList do:[:each|\r\t\tself add: each.\r\t\t].',			#stamp : 'pm 10/25/2018 11:07',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'addFromList:',			#protocol : #adding,			#sourceCode : 'addFromList: aLinkedList\r\taLinkedList do:[:each|\r\t\tself add: each.\r\t\t].',			#stamp : 'pm 10/25/2018 11:07',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T19:10:35.800402+02:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t r|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr;cr.\r\tr:=Resolvante new.\r\tr factorisation: ((t clauses) at:1).\r\t\r\tTranscript show:\'Factorisation\' ;show:t;cr.\r\t^t',			#stamp : 'pm 10/25/2018 18:38',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t r|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr;cr.\r\tr:=Resolvante new.\r\tr factorisation: (t at:1).\r\t\r\tTranscript show:\'Factorisation\' ;show:t;cr.\r\t^t',			#stamp : 'pm 10/25/2018 19:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T20:36:51.260687+02:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'without:or:',			#protocol : #'as yet unclassified',			#sourceCode : 'without:index or:index2\r',			#stamp : 'pm 10/25/2018 20:36',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T20:37:29.982631+02:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause collect:[ :each | each~=(aClause at:i) and:[each~=(aClause at:j)]]).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 18:36',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\t":[ :each | each~=(aClause at:i) and:[each~=(aClause at:j)]])."\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 20:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T20:43:43.931267+02:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'without:or:',			#protocol : #'as yet unclassified',			#sourceCode : 'without:index or:index2\r',			#stamp : 'pm 10/25/2018 20:36',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'without:or:',			#protocol : #'as yet unclassified',			#sourceCode : 'without:index1 or:index2\r\t|i resClause|\r\tresClause:=Clause new.\r\ti:=1.\r\t\r\t[i<=self size]\r\twhileTrue:[\r\t\t(i~=index1 or:[i~=index2])\r\t\tifTrue:[\r\t\t\tresClause add:(self at:i).\r\t\t\ti:=i+1.\r\t\t\t].\r\t\t].\r\t^resClause ',			#stamp : 'pm 10/25/2018 20:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T20:46:00.114375+02:00' ],		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t r|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr;cr.\r\tr:=Resolvante new.\r\tr factorisation: (t at:1).\r\t\r\tTranscript show:\'Factorisation\' ;show:t;cr.\r\t^t',			#stamp : 'pm 10/25/2018 19:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t r|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr;cr.\r\tr:=Resolvante new.\r\tr factorisation: (t at:1).\r\tTranscript show:\'Factorisation\' ;show:t;cr.\r\t^t',			#stamp : 'pm 10/25/2018 20:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T20:47:12.838835+02:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t r|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr;cr;cr.\r\tr:=Resolvante new.\r\tr factorisation: (t at:1).\r\tTranscript show:\'Factorisation\' ;show:t;cr.\r\t^t',			#stamp : 'pm 10/25/2018 20:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t r|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr.\r\tr:=Resolvante new.\r\tr factorisation: (t at:1).\r\tTranscript show:\'Factorisation\' ;show:t;cr;cr;cr.\r\t^t',			#stamp : 'pm 10/25/2018 20:47',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T20:51:55.988651+02:00' ],		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #And,				#isMetaSide : false			},			#name : #isOr,			#protocol : #testing,			#sourceCode : 'isOr\r\t^true\r',			#stamp : 'pm 10/23/2018 07:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T20:52:58.533136+02:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t r|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr.\r\tr:=Resolvante new.\r\tr factorisation: (t at:1).\r\tTranscript show:\'Factorisation\' ;show:t;cr;cr;cr.\r\t^t',			#stamp : 'pm 10/25/2018 20:47',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t r|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr.\r\tr:=Resolvante new.\r\tr factorisation: (t at:1).\r\tTranscript show:\'Factorisation\' ;show:r;cr;cr;cr.\r\t^t',			#stamp : 'pm 10/25/2018 20:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T20:54:05.153702+02:00' ],		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #'as yet unclassified',			#sourceCode : 'printOn: aStream\r\tsuper printOn:aStream.',			#stamp : 'pm 10/25/2018 20:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T20:54:05.231068+02:00' ],		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #'as yet unclassified',			#sourceCode : 'printOn: aStream\r\tsuper printOn:aStream.',			#stamp : 'pm 10/25/2018 20:54',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\tsuper printOn:aStream.',			#stamp : 'pm 10/25/2018 20:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T20:54:32.374765+02:00' ],		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\tsuper printOn:aStream.',			#stamp : 'pm 10/25/2018 20:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T20:56:24.175403+02:00' ],		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #methodeDeResolution,			#sourceCode : 'resolvante: clause1 with: clause2\r\r\r\t^self error:\'todo\'.',			#stamp : 'pm 10/24/2018 20:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #methodeDeResolution,			#sourceCode : 'resolvante: clause1 with: clause2\r\t^self error:\'todo\'.',			#stamp : 'pm 10/25/2018 20:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T20:56:37.58054+02:00' ],		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\t":[ :each | each~=(aClause at:i) and:[each~=(aClause at:j)]])."\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 20:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t| i j a1 a2 sub1 sub2 u newClause |"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t[ i<(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\t\t\t"We can check if a1 & a2 are the same type to avoid useless unifications."\t\t\t\r\t\t\t"Maybe later. Basic version so far."\r\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\tsub1:=u firstPredicate.\r\t\t\tsub2:=u secondPredicate.\r\t\t\t(sub1=sub2)\r\t\t\tifTrue:[\r\t\t\t\tnewClause:=Clause new."we create a new clause with everything but the Atomes used"\r\t\t\t\tnewClause addFromList: (aClause without:i or:j).\r\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/25/2018 20:56',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T20:57:27.659375+02:00' ],		#prior : OmReference [ '69' ],		#self : OmReference [ '70' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t r|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr.\r\tr:=Resolvante new.\r\tr factorisation: (t at:1).\r\tTranscript show:\'Factorisation\' ;show:r;cr;cr;cr.\r\t^t',			#stamp : 'pm 10/25/2018 20:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t |\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr.\r\t"r:=Resolvante new.\r\tr factorisation: (t at:1).\r\tTranscript show:\'Factorisation\' ;show:r;cr;cr;cr."\r\t^t',			#stamp : 'pm 10/25/2018 20:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T20:57:28.708563+02:00' ],		#prior : OmReference [ '70' ],		#self : OmReference [ '71' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t |\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr.\r\t"r:=Resolvante new.\r\tr factorisation: (t at:1).\r\tTranscript show:\'Factorisation\' ;show:r;cr;cr;cr."\r\t^t',			#stamp : 'pm 10/25/2018 20:57',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #SkolemnisationTest,			#protocol : #testing,			#sourceCode : 'SkolemnisationTest\r\t|t|\r\tProp testInc.\t\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'initial: \'; show: self prettyPrint; cr.\r\tt:=self StartSkolemnisation.\r\tTranscript show: \'Skolemn: \';show: t prettyPrint;cr.\r\tt:=t fullClausification.\r\tTranscript show: \'Clausified:\';show: t prettyPrint ;cr.\r\tt:=ClausalForm new:t.\r\tTranscript show: \'ClausalForm:\';show: t prettyPrint ;cr.\r\t"r:=Resolvante new.\r\tr factorisation: (t at:1).\r\tTranscript show:\'Factorisation\' ;show:r;cr;cr;cr."\r\t^t',			#stamp : 'pm 10/25/2018 20:57',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-10-25T21:10:51.152988+02:00' ],		#prior : OmReference [ '71' ],		#self : OmReference [ '72' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Prop,				#isMetaSide : false			},			#name : #resolvanteUnitTest,			#protocol : #testing,			#sourceCode : 'resolvanteUnitTest\r\t|r|\r\tProp testInc.\r\tTranscript show: \'test #\'; show:(Prop testNumber);cr.\r\tTranscript show: \'Trying to factorise \';show: self;cr.\r\tr:=Resolvante new.\r\tr factorisation: self.\r\tTranscript show:r;cr.',			#stamp : 'pm 10/25/2018 21:10',			#package : #_resolution_1erOrdre		}	}}