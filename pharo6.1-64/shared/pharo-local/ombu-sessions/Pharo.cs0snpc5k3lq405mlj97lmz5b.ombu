OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:06:22.247154+01:00' ],		#prior : OmReference [ 'Pharo.60i4hu2ak795ibwowoiwwyes8', '7' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t"Part of the skolemnisation process.\r\tStep which determines what kind of term each term in each predicate is (func/const/Linked"\r\t"For argument, see documentation in Prop::SkolemnisationDocu."\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\telem:=aMap at:(self prettyPrint) ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 10/28/2018 14:25',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #AbstractTerm,				#isMetaSide : false			},			#name : #'WhatAmI:CorrespondingValue:',			#protocol : #Skoleminsation,			#sourceCode : 'WhatAmI:setOfLinkedVar CorrespondingValue: aMap\r\t"Part of the skolemnisation process.\r\tStep which determines what kind of term each term in each predicate is (func/const/Linked)"\r\t"For argument, see documentation in Prop::SkolemnisationDocu."\r\t| elem |\r\t(setOfLinkedVar haveYouSeenThisObject:self)\r\tifTrue:[^LinkedTerm new:self.]\r\tifFalse:[\r\t\telem:=aMap at:(self prettyPrint) ifAbsent:[(ConstTerm new: self)].\r\t\t^elem.].',			#stamp : 'pm 11/11/2018 09:06',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:08:24.336416+01:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #anonymous,			#protocol : #accessing,			#sourceCode : 'anonymous\r\t^anonymous',			#stamp : 'pm 11/5/2018 09:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #anonymous,			#protocol : #accessing,			#sourceCode : 'anonymous\r\t"Accessors\r\tThis knoledge is needed for automated testing"\r\t^anonymous',			#stamp : 'pm 11/11/2018 09:08',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:09:33.102143+01:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'anonymous:',			#protocol : #accessing,			#sourceCode : 'anonymous:aBool\r\tanonymous:=aBool',			#stamp : 'pm 11/5/2018 09:20',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'anonymous:',			#protocol : #accessing,			#sourceCode : 'anonymous:aBool\r\t"Accessors\r\tThis knoledge is needed for automated testing"\r\tanonymous:=aBool',			#stamp : 'pm 11/11/2018 09:09',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:14:24.365706+01:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LinkedListFix,				#isMetaSide : false			},			#name : #'at:put:',			#protocol : #accessing,			#sourceCode : 'at:index put: anObject\r\t"Override since the basic one seems to rather do a infinite loop for no reason."\r\r\t| currentLink i |\r\tcurrentLink:=self firstLink.\r\ti:=1.\r\r \t[(index=(i)) and:[(currentLink isNil) not]]\r\twhileFalse:[\r\t\ti:=i+1.\r\t\tcurrentLink:=currentLink nextLink.\r\t\t].\r\t\r\t(currentLink isNil)\r\tifTrue:[^self error:\'index out of bound\']\r\tifFalse:[currentLink value: anObject ].',			#stamp : 'pm 10/22/2018 09:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #LinkedListFix,				#isMetaSide : false			},			#name : #'at:put:',			#protocol : #accessing,			#sourceCode : 'at:index put: anObject\r\t"Override since the basic one seems to rather do a infinite loop for no good reason."\r\r\t| currentLink i |\r\tcurrentLink:=self firstLink.\r\ti:=1.\r\r \t[(index=(i)) and:[(currentLink isNil) not]]\r\twhileFalse:[\r\t\ti:=i+1.\r\t\tcurrentLink:=currentLink nextLink.\r\t\t].\r\t\r\t(currentLink isNil)\r\tifTrue:[^self error:\'index out of bound\']\r\tifFalse:[currentLink value: anObject ].',			#stamp : 'pm 11/11/2018 09:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:16:10.80379+01:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MinimalOrderedSet,				#isMetaSide : false			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: anObject\r\t"Override to add the set component on a LinkedList"\r\tself do: [ :each | \r\t\t(each=anObject) \r\t\tifTrue:[^self]"Object\'s already in, we\'re done"\r\t\t].\r\t super add: anObject."we let LinkedList add the object"\r\t^self."to be chainable"',			#stamp : 'pm 10/28/2018 15:15',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #MinimalOrderedSet,				#isMetaSide : false			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: anObject\r\t"Override to add the set component on a LinkedList"\r\t\r\tself do: [ :each | \r\t\t(each=anObject) \r\t\tifTrue:[^self]"Object\'s already in, we\'re done"\r\t\t].\r\t super add: anObject."we let LinkedList add the object"\r\t^self."to be chainable"',			#stamp : 'pm 11/11/2018 09:16',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:16:43.602486+01:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tTranscript show:self;cr.\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 10/26/2018 22:45',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t"application of the resolution method on self."\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tTranscript show:self;cr.\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 11/11/2018 09:16',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:16:52.307202+01:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t"application of the resolution method on self."\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tTranscript show:self;cr.\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 11/11/2018 09:16',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t"application of the resolution method on self. Course algorithm"\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tTranscript show:self;cr.\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r"TODO"   ((c isTautology) or:[sat contains:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 11/11/2018 09:16',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:18:46.671262+01:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: var\r\t(var isAtome)\r\tifTrue:[\r\t\tsuper add:var.\r\t\t^self."able chaining operation"\r\t\t]\r\tifFalse:[\r\t\t\t^self error: \'Trying to add a wrong type in a clause\'.\r\t\t].',			#stamp : 'pm 10/28/2018 15:28',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: aPredicate\r\t"Add an atomic predicate"\r\t(aPredicate isAtome)\r\tifTrue:[\r\t\tsuper add:aPredicate.\r\t\t^self."able chaining operation"\r\t\t]\r\tifFalse:[\r\t\t\t^self error: \'Trying to add a wrong type in a clause\'.\r\t\t].',			#stamp : 'pm 11/11/2018 09:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:18:57.848214+01:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: aPredicate\r\t"Add an atomic predicate"\r\t(aPredicate isAtome)\r\tifTrue:[\r\t\tsuper add:aPredicate.\r\t\t^self."able chaining operation"\r\t\t]\r\tifFalse:[\r\t\t\t^self error: \'Trying to add a wrong type in a clause\'.\r\t\t].',			#stamp : 'pm 11/11/2018 09:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: aPredicate\r\t"Add an atomic predicate to self. Either a const or a predicate"\r\t(aPredicate isAtome)\r\tifTrue:[\r\t\tsuper add:aPredicate.\r\t\t^self."able chaining operation"\r\t\t]\r\tifFalse:[\r\t\t\t^self error: \'Trying to add a wrong type in a clause\'.\r\t\t].',			#stamp : 'pm 11/11/2018 09:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:19:19.382151+01:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: aPredicate\r\t"Add an atomic predicate to self. Either a const or a predicate"\r\t(aPredicate isAtome)\r\tifTrue:[\r\t\tsuper add:aPredicate.\r\t\t^self."able chaining operation"\r\t\t]\r\tifFalse:[\r\t\t\t^self error: \'Trying to add a wrong type in a clause\'.\r\t\t].',			#stamp : 'pm 11/11/2018 09:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'add:',			#protocol : #adding,			#sourceCode : 'add: anAtome\r\t"Add an atomic predicate to self. Either a const or a predicate"\r\t(anAtome isAtome)\r\tifTrue:[\r\t\tsuper add:anAtome.\r\t\t^self."able chaining operation"\r\t\t]\r\tifFalse:[\r\t\t\t^self error: \'Trying to add a wrong type in a clause\'.\r\t\t].',			#stamp : 'pm 11/11/2018 09:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:20:35.403082+01:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #adding,			#sourceCode : 'addAll: orProp\r\t(orProp isAtome)\r\tifTrue:[self add:orProp.]\r\tifFalse:[\r\t\t((orProp) isNot)\r\t\tifTrue:["we\'re in a not"\r\t\t\t(orProp operand isAtome)\r\t\t\t\tifTrue:["we\'re in an atom"\r\t\t\t\t\t((orProp operand) isPredicate)\r\t\t\t\t\tifTrue:[self add:(NotPredicate new: (orProp operand) getSymb fromList: (orProp operand) terms).]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t((orProp operand) isVar)\r\t\t\t\t\t\tifTrue:[self add:(NotVar new:((orProp operand) getSymb)).]\r\t\t\t\t\t\tifFalse: [ Error new: \'shouldn\'\'t be any True or false here\' ]].\r\t\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tError new:\'Error, shouldn\'\'t be any more not ( binaryOp )\'\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(orProp isOr)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (orProp left).\r\t\t\t\tself addAll: (orProp right).\r\t\t\t\t]\r\t\t\tifFalse:["switch to Error new:"\r\t\t\t\tError new:\'Error, shouldn\'\'t be any other kind of prop here.\'.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 10/25/2018 08:44',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'addAll:',			#protocol : #adding,			#sourceCode : 'addAll: orProp\r\r\t"BADLY DESIGNED, NEEDS REFACTOR"\r\t\r\t(orProp isAtome)\r\tifTrue:[self add:orProp.]\r\tifFalse:[\r\t\t((orProp) isNot)\r\t\tifTrue:["we\'re in a not"\r\t\t\t(orProp operand isAtome)\r\t\t\t\tifTrue:["we\'re in an atom"\r\t\t\t\t\t((orProp operand) isPredicate)\r\t\t\t\t\tifTrue:[self add:(NotPredicate new: (orProp operand) getSymb fromList: (orProp operand) terms).]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t((orProp operand) isVar)\r\t\t\t\t\t\tifTrue:[self add:(NotVar new:((orProp operand) getSymb)).]\r\t\t\t\t\t\tifFalse: [ Error new: \'shouldn\'\'t be any True or false here\' ]].\r\t\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tError new:\'Error, shouldn\'\'t be any more not ( binaryOp )\'\r\t\t\t\t].\r\t\t\t]\r\t\tifFalse:[\r\t\t\t(orProp isOr)\r\t\t\tifTrue:[\r\t\t\t\tself addAll: (orProp left).\r\t\t\t\tself addAll: (orProp right).\r\t\t\t\t]\r\t\t\tifFalse:["switch to Error new:"\r\t\t\t\tError new:\'Error, shouldn\'\'t be any other kind of prop here.\'.\r\t\t\t\t].\r\t\t\t].\r\t\t].',			#stamp : 'pm 11/11/2018 09:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:23:30.279254+01:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'addFromList:',			#protocol : #adding,			#sourceCode : 'addFromList: aLinkedList\r\taLinkedList do:[:each|\r\t\tself add: each.\r\t\t].',			#stamp : 'pm 10/26/2018 21:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'addFromList:',			#protocol : #adding,			#sourceCode : 'addFromList: aLinkedList\r\t"Add every atomes in the linked list to self"\r\taLinkedList do:[:each|\r\t\tself add: each.\r\t\t].',			#stamp : 'pm 11/11/2018 09:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:25:28.247784+01:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialize,			#sourceCode : 'initialize: OrProp\r\tself addAll:OrProp.',			#stamp : 'pm 10/25/2018 18:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'initialize:',			#protocol : #initialize,			#sourceCode : 'initialize: OrProp\r\t"initialization using an OrProp. Should only contain predicates/const"\r\tself addAll:OrProp.',			#stamp : 'pm 11/11/2018 09:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:25:53.918092+01:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #isEmptyClause,			#protocol : #testing,			#sourceCode : 'isEmptyClause\r\t^self isEmpty.',			#stamp : 'pm 10/26/2018 21:15',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #isEmptyClause,			#protocol : #testing,			#sourceCode : 'isEmptyClause\r\t"Check if we don\'t have any terms in self. Used in resolution method."\r\t^self isEmpty.',			#stamp : 'pm 11/11/2018 09:25',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:28:00.027859+01:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #isTautology,			#protocol : #testing,			#sourceCode : 'isTautology\r\tself do:[ :p1 |\r\t\tself do:[ :p2 | \r\t\t\t(p1 isOpposite: p2)\r\t\t\tifTrue:[^true].\r\t\t\t].\r\t\t].\r\t^false',			#stamp : 'pm 10/25/2018 18:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #isTautology,			#protocol : #testing,			#sourceCode : 'isTautology\r\t"Check if self contains a tautology"\r\tself do:[ :p1 |\r\t\tself do:[ :p2 | \r\t\t\t(p1 isOpposite: p2)\r\t\t\tifTrue:[^true].\r\t\t\t].\r\t\t].\r\t^false',			#stamp : 'pm 11/11/2018 09:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:28:07.154599+01:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t|t|\r\tt:=\'{\'.\r\tself do:[  :each | t:=t,(each prettyPrint). ] separatedBy:[t:=t,\',\'].\r\tt:=t,\'}\'.\r\t^t.',			#stamp : 'pm 10/25/2018 18:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t"tostring"\r\t|t|\r\tt:=\'{\'.\r\tself do:[  :each | t:=t,(each prettyPrint). ] separatedBy:[t:=t,\',\'].\r\tt:=t,\'}\'.\r\t^t.',			#stamp : 'pm 11/11/2018 09:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:29:19.243696+01:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: stream\r\tstream nextPutAll: (self prettyPrint).',			#stamp : 'pm 10/25/2018 18:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: stream\r\t"Override to print the to string on transcript\t"\r\tstream nextPutAll: (self prettyPrint).',			#stamp : 'pm 11/11/2018 09:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:33:59.674581+01:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'without:',			#protocol : #adding,			#sourceCode : 'without:index\r\t|i resClause|\r\tresClause:=Clause new.\r\ti:=1.\r\t\r\t[i<=self size]\r\twhileTrue:[\r\t\t(i~=index)\r\t\tifTrue:[\r\t\t\tresClause add:(self at:i).\r\t\t\t].\r\t\ti:=i+1.\r\t\t].\r\t^resClause ',			#stamp : 'pm 10/26/2018 16:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'without:',			#protocol : #adding,			#sourceCode : 'without:index\r\t"return self without the object at an index"\r\t|i resClause|\r\tresClause:=Clause new.\r\ti:=1.\r\t\r\t[i<=self size]\r\twhileTrue:[\r\t\t(i~=index)\r\t\tifTrue:[\r\t\t\tresClause add:(self at:i).\r\t\t\t].\r\t\ti:=i+1.\r\t\t].\r\t^resClause ',			#stamp : 'pm 11/11/2018 09:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:35:15.253735+01:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'without:nor:',			#protocol : #adding,			#sourceCode : 'without:index1 nor:index2\r\t|i resClause|\r\tresClause:=Clause new.\r\ti:=1.\r\t\r\t[i<=self size]\r\twhileTrue:[\r\t\t(i~=index1 and:[i~=index2])\r\t\tifTrue:[\r\t\t\tresClause add:(self at:i).\r\t\t\t].\r\t\ti:=i+1.\r\t\t].\r\t^resClause ',			#stamp : 'pm 10/26/2018 16:52',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Clause,				#isMetaSide : false			},			#name : #'without:nor:',			#protocol : #adding,			#sourceCode : 'without:index1 nor:index2\r\t"return self without the object at an index1 nor index2"\r\t|i resClause|\r\tresClause:=Clause new.\r\ti:=1.\r\t\r\t[i<=self size]\r\twhileTrue:[\r\t\t(i~=index1 and:[i~=index2])\r\t\tifTrue:[\r\t\t\tresClause add:(self at:i).\r\t\t\t].\r\t\ti:=i+1.\r\t\t].\r\t^resClause ',			#stamp : 'pm 11/11/2018 09:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:35:26.186211+01:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Clause class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: OrProp\r\t"creation of a new clause of a OrProp"\r\t^self basicNew initialize:OrProp.',			#stamp : 'pm 10/28/2018 15:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Clause class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: OrProp\t""\r\t"creation of a new clause of a OrProp"\r\t^self basicNew initialize:OrProp.',			#stamp : 'pm 11/11/2018 09:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:35:27.768598+01:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Clause class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: OrProp\t""\r\t"creation of a new clause of a OrProp"\r\t^self basicNew initialize:OrProp.',			#stamp : 'pm 11/11/2018 09:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Clause class',				#isMetaSide : true			},			#name : #'new:',			#protocol : #'instance creation',			#sourceCode : 'new: OrProp\r\t"creation of a new clause of a OrProp"\r\t^self basicNew initialize:OrProp.',			#stamp : 'pm 11/11/2018 09:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:36:06.147584+01:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpProtocolRemoval {		#behavior : RGClassDefinition {			#annotations : IdentityDictionary {				#superclassName : 'MinimalOrderedSet',				#traitCompositionSource : '{}',				#definitionSource : 'MinimalOrderedSet subclass: #Resolvante\r\tinstanceVariableNames: \'\'\r\tclassVariableNames: \'\'\r\tpoolDictionaries: \'\'\r\tcategory: \'_resolution_1erOrdre-Clausal Form\''			},			#name : #Resolvante,			#methods : IdentityDictionary { },			#protocols : Set [ ],			#instanceVariables : OrderedCollection [ ],			#metaClass : RGMetaclassDefinition {				#annotations : IdentityDictionary {					#traitCompositionSource : '{}',					#definitionSource : 'Resolvante class\r\tinstanceVariableNames: \'\''				},				#name : #'Resolvante class',				#methods : IdentityDictionary { },				#protocols : Set [ ],				#instanceVariables : OrderedCollection [ ],				#baseClass : @7			},			#comment : RGCommentDefinition {				#annotations : IdentityDictionary {					#className : #Resolvante,					#isMetaSide : false				},				#parent : @7,				#content : 'Utility class for ClausalForm::ResolutionMethod.',				#stamp : 'pm 10/27/2018 22:04'			},			#classVariables : OrderedCollection [ ],			#category : #'_resolution_1erOrdre-Clausal Form',			#package : #_resolution_1erOrdre,			#sharedPools : OrderedCollection [ ]		},		#protocol : #printing	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:37:12.551982+01:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherPair\r\t^(self left)=(anotherPair left) and:[(self right)=(anotherPair right)].',			#stamp : 'pm 10/18/2018 16:31',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherPair\r\t"comparator "\r\tself assert: ((anotherPair class)=(self class)).\r\t^(self left)=(anotherPair left) and:[(self right)=(anotherPair right)].',			#stamp : 'pm 11/11/2018 09:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:37:20.991488+01:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherPair\r\t"comparator "\r\tself assert: ((anotherPair class)=(self class)).\r\t^(self left)=(anotherPair left) and:[(self right)=(anotherPair right)].',			#stamp : 'pm 11/11/2018 09:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '= anotherPair\r\t"comparator"\r\tself assert: ((anotherPair class)=(self class)).\r\t^(self left)=(anotherPair left) and:[(self right)=(anotherPair right)].',			#stamp : 'pm 11/11/2018 09:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:37:27.34747+01:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #left,			#protocol : #accessing,			#sourceCode : 'left\r\t^left',			#stamp : 'pm 10/15/2018 16:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #left,			#protocol : #accessing,			#sourceCode : 'left\r\t"accessor"\r\t^left',			#stamp : 'pm 11/11/2018 09:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:37:36.876079+01:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #'left:',			#protocol : #accessing,			#sourceCode : 'left: anObject\r\tleft:=anObject.\r\t^left',			#stamp : 'pm 10/15/2018 16:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #'left:',			#protocol : #accessing,			#sourceCode : 'left: anObject\r\t"accessor"\r\tleft:=anObject.\r\t^left',			#stamp : 'pm 11/11/2018 09:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:37:48.959466+01:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #'left:right:',			#protocol : #initialize-release,			#sourceCode : 'left:l right:r\r\tleft:=l.\r\tright:=r.',			#stamp : 'pm 10/15/2018 16:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #'left:right:',			#protocol : #initialize-release,			#sourceCode : 'left:l right:r\r\t"initializer"\r\tleft:=l.\r\tright:=r.',			#stamp : 'pm 11/11/2018 09:37',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:38:09.04799+01:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #'left:right:',			#protocol : #initialize-release,			#sourceCode : 'left:l right:r\r\t"initializer"\r\tleft:=l.\r\tright:=r.',			#stamp : 'pm 11/11/2018 09:37',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #'left:right:',			#protocol : #initialize-release,			#sourceCode : 'left:l right:r\r\t"initializer/accessor"\r\tleft:=l.\r\tright:=r.',			#stamp : 'pm 11/11/2018 09:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:38:14.207441+01:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t^\'(\',(self left prettyPrint),\',\',(self right prettyPrint),\')\'.',			#stamp : 'pm 10/15/2018 16:47',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #prettyPrint,			#protocol : #printing,			#sourceCode : 'prettyPrint\r\t"tostring"\r\t^\'(\',(self left prettyPrint),\',\',(self right prettyPrint),\')\'.',			#stamp : 'pm 11/11/2018 09:38',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:39:04.706433+01:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #prettyPrintUnifier,			#protocol : #printing,			#sourceCode : 'prettyPrintUnifier\r\t^\'(\',(self left prettyPrint),\'=\',(self right prettyPrint),\')\'.',			#stamp : 'pm 10/18/2018 15:27',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #prettyPrintUnifier,			#protocol : #printing,			#sourceCode : 'prettyPrintUnifier\r\t"prettyPrint in the context of the unifier. Better visualisation of it\'s state."\r\t^\'(\',(self left prettyPrint),\'=\',(self right prettyPrint),\')\'.',			#stamp : 'pm 11/11/2018 09:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:39:29.51772+01:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\taStream nextPutAll: (self prettyPrint)',			#stamp : 'pm 10/18/2018 16:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #'printOn:',			#protocol : #printing,			#sourceCode : 'printOn: aStream\r\t"tostring for transcript"\r\taStream nextPutAll: (self prettyPrint)',			#stamp : 'pm 11/11/2018 09:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:39:40.951212+01:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #right,			#protocol : #accessing,			#sourceCode : 'right\r\t^right',			#stamp : 'pm 10/15/2018 16:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #right,			#protocol : #accessing,			#sourceCode : 'right\r\t"accessor"\r\t^right',			#stamp : 'pm 11/11/2018 09:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:40:05.288082+01:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #'right:',			#protocol : #accessing,			#sourceCode : 'right: anObject\r\tright:=anObject.\r\t^right',			#stamp : 'pm 10/15/2018 16:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Pair,				#isMetaSide : false			},			#name : #'right:',			#protocol : #accessing,			#sourceCode : 'right: anObject\r\t"accessor"\r\tright:=anObject.\r\t^right',			#stamp : 'pm 11/11/2018 09:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:43:32.451196+01:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Unifier class',				#isMetaSide : true			},			#name : #'new:Predicate2:',			#protocol : #'instance creation',			#sourceCode : 'new: p1 Predicate2: p2\r\t^(self basicNew) initialize: p1 Predicate2:p2.',			#stamp : 'pm 10/15/2018 16:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Unifier class',				#isMetaSide : true			},			#name : #'new:Predicate2:',			#protocol : #'instance creation',			#sourceCode : 'new: p1 Predicate2: p2\r\t"takes two predicate as initialization arguments"\r\t^(self basicNew) initialize: p1 Predicate2:p2.',			#stamp : 'pm 11/11/2018 09:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:44:55.698376+01:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'initialize:Predicate2:',			#protocol : #initialization,			#sourceCode : 'initialize: p1 Predicate2: p2\r\t"initialized with two predicates, that we\'ll try to unify."\r\r\t"init two different pair to be sure that we have the initial\r\tone to unify at the end."\r\tinitialPair:=(Pair left: (p1 veryDeepCopy) right: (p2 veryDeepCopy)).\r\tsetOfPairs:=MinimalOrderedSet new.\r\tsetOfPairs add:(Pair left: p1 right: p2).\r\thasFailed:=false.\r\t\r\tUnifiedTerm:=Pair left:nil right:nil."not sure if needed"\r\t\r\t"And we try to unify it instantly"\r\tself unifyThis.\r',			#stamp : 'pm 10/25/2018 07:58',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'initialize:Predicate2:',			#protocol : #initialization,			#sourceCode : 'initialize: p1 Predicate2: p2\r\t"initialized with two predicates, that we\'ll try to unify."\r\t\r\t"init two different pair to be sure that we have the initial\r\tone to unify at the end."\r\tinitialPair:=(Pair left: (p1 veryDeepCopy) right: (p2 veryDeepCopy)).\r\tsetOfPairs:=MinimalOrderedSet new.\r\tsetOfPairs add:(Pair left: p1 right: p2).\r\thasFailed:=false.\r\t\r\tUnifiedTerm:=Pair left:nil right:nil."not sure if needed"\r\t\r\t"And we try to unify it instantly"\r\tself unifyThis.\r',			#stamp : 'pm 11/11/2018 09:44',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-11-11T09:51:28.792217+01:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testUnboundExistReplacedByConsts,			#protocol : #basic,			#sourceCode : 'testUnboundExistReplacedByConsts\r\t| p res expected |\r\tself halt.\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTerms: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 11/5/2018 19:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Skolemn_test,				#isMetaSide : false			},			#name : #testUnboundExistReplacedByConsts,			#protocol : #basic,			#sourceCode : 'testUnboundExistReplacedByConsts\r\t| p res expected |\r\r\tp:=Not new:\r\t\t(Imply new: \r\t\t\t(ForAll new: \'x\' Property:\r\t\t\t\t(Or new:  \r\t\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\t\t rightProp:\r\t\t\t\t\t(Predicate new: \'Q\' variable:(Term new:\'x\'))))\r\t\t\t rightProp:\r\t\t\t(Or new: \r\t\t\t\t(Predicate new: \'P\' variable:(Term new:\'x\'))\r\t\t\t\trightProp:(Predicate new: \'Q\' variable:(Term new:\'x\')))).\r\tres:=p StartSkolemnisation.\r\r\t"terms1:=LinkedList new add:(ConstTerm new:(Term new:\'x\')); add:(ConstTerm new:(Term new:\'x\'));yourself."\r\texpected:=Not new:(Imply new:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(LinkedTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(LinkedTerm new:(Term new:\'x\'))))\r\t\t\t\trightProp:\r\t\t\t\t\t(Or new: (Predicate new: \'P\' variable:(ConstTerm new:(Term new:\'x\')))\r\t\t\t\t\trightProp: (Predicate new: \'Q\' variable:(ConstTerm new:(Term new:\'x\'))))).\r\r\t\r\tself assert:(res isSameForTesting: expected).\r\tself assert:((((res operand) left) left) isSameTerms: (((res operand) right) right))\r\t"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"',			#stamp : 'pm 11/11/2018 09:51',			#package : #_resolution_1erOrdre		}	}}