OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T14:46:04.485512+01:00' ],		#prior : OmReference [ 'Pharo.2169bfn22ldpnh5mzp8yeoc0z', '144' ],		#self : OmReference [ '1' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFuncTerm)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:["Decompose is possible"\r\t\t\t\tself decompose:aPair. \r\t\t\t\tmodified:=true.\r\t\t\t\t]\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tself swap:aPair.\r\t\t\tmodified:=true.\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tself eliminate:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\tleft=right\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\tmodified:=true\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 14:44',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFuncTerm)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:["Decompose is possible"\r\t\t\t\tself decompose:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t]\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tself swap:aPair.\r\t\t\tmodified:=true.\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tself eliminate:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\tleft=right\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\tmodified:=true\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 14:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T14:46:21.919253+01:00' ],		#prior : OmReference [ '1' ],		#self : OmReference [ '2' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFuncTerm)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:["Decompose is possible"\r\t\t\t\tself decompose:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t]\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tself swap:aPair.\r\t\t\tmodified:=true.\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tself eliminate:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\tleft=right\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\tmodified:=true\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 14:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFuncTerm)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:["Decompose is possible"\r\t\t\t\tself decompose:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t]\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tself swap:aPair.\r\t\t\tmodified:=true.\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tself eliminate:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\tleft=right\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\tmodified:=true\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\tnotPossible:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 14:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T14:46:39.502444+01:00' ],		#prior : OmReference [ '2' ],		#self : OmReference [ '3' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFuncTerm)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:["Decompose is possible"\r\t\t\t\tself decompose:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t]\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tself swap:aPair.\r\t\t\tmodified:=true.\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tself eliminate:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\tleft=right\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\tmodified:=true\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\tnotPossible:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 14:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFuncTerm)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:["Decompose is possible"\r\t\t\t\tself decompose:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t]\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tself swap:aPair.\r\t\t\tmodified:=true.\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tself eliminate:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\tleft=right\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\tnotPossible:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 14:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T14:51:01.830752+01:00' ],		#prior : OmReference [ '3' ],		#self : OmReference [ '4' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFuncTerm)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:["Decompose is possible"\r\t\t\t\tself decompose:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t]\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tself swap:aPair.\r\t\t\tmodified:=true.\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tself eliminate:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\tleft=right\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\tnotPossible:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 14:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFuncTerm)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:["Decompose is possible"\r\t\t\t\tself decompose:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t]\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tself swap:aPair.\r\t\t\tmodified:=true.\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\tleft=right\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\tnotPossible:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 14:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T14:51:07.131008+01:00' ],		#prior : OmReference [ '4' ],		#self : OmReference [ '5' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFuncTerm)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:["Decompose is possible"\r\t\t\t\tself decompose:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t]\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tself swap:aPair.\r\t\t\tmodified:=true.\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\tleft=right\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\tnotPossible:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 14:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFuncTerm)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:["Decompose is possible"\r\t\t\t\tself decompose:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t]\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tself swap:aPair.\r\t\t\tmodified:=true.\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\tleft=right\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\tnotPossible:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 14:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T15:12:56.186966+01:00' ],		#prior : OmReference [ '5' ],		#self : OmReference [ '6' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFuncTerm)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:["Decompose is possible"\r\t\t\t\tself decompose:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t]\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tself swap:aPair.\r\t\t\tmodified:=true.\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\tleft=right\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\tnotPossible:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 14:51',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFuncTerm)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:["Decompose is possible"\r\t\t\t\tself decompose:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t]\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tself swap:aPair.\r\t\t\tmodified:=true.\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\t"notPossible:=self check:aPair."\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\t"notPossible:=self check:aPair"\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\tleft=right\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\tnotPossible:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 15:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T15:14:20.783227+01:00' ],		#prior : OmReference [ '6' ],		#self : OmReference [ '7' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'check:',			#protocol : #unification,			#sourceCode : 'check: aPair\r\t"Not active yet"\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'check\';cr.].\r\t\r\t^((aPair right) contains: aPair left).',			#stamp : 'pm 10/19/2018 17:41',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'check:',			#protocol : #unification,			#sourceCode : 'check: aPair\r\t"Not active yet"\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'check\';cr.].\r\t\r\t^aPair right term contains: aPair left',			#stamp : 'pm 12/14/2018 15:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T15:14:46.133114+01:00' ],		#prior : OmReference [ '7' ],		#self : OmReference [ '8' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFuncTerm)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:["Decompose is possible"\r\t\t\t\tself decompose:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t]\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tself swap:aPair.\r\t\t\tmodified:=true.\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\t"notPossible:=self check:aPair."\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\t"notPossible:=self check:aPair"\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\tleft=right\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\tnotPossible:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 15:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFuncTerm)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:["Decompose is possible"\r\t\t\t\tself decompose:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t]\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tself swap:aPair.\r\t\t\tmodified:=true.\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\tleft=right\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\tnotPossible:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 15:14',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T15:15:09.446277+01:00' ],		#prior : OmReference [ '8' ],		#self : OmReference [ '9' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'check:',			#protocol : #unification,			#sourceCode : 'check: aPair\r\t"Not active yet"\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'check\';cr.].\r\t\r\t^aPair right term contains: aPair left',			#stamp : 'pm 12/14/2018 15:14',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'check:',			#protocol : #unification,			#sourceCode : 'check: aPair\r\t"Not active yet"\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'check\';cr.].\r\t\r\t^aPair right contains: aPair left term',			#stamp : 'pm 12/14/2018 15:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T15:26:49.318387+01:00' ],		#prior : OmReference [ '9' ],		#self : OmReference [ '10' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnFunc,			#protocol : #tests,			#sourceCode : 'testConstOnFunc\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aLinkedTerm"\r\r\t"since they can\'t be equal. As proven by this assertion. (obviously)"\r\tself deny:(ConstTerm new: ( Term new: \'a\'))=(LinkedTerm new: ( Term new: \'a\'))."S"\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 15:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T15:31:32.005056+01:00' ],		#prior : OmReference [ '10' ],		#self : OmReference [ '11' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnFunc,			#protocol : #tests,			#sourceCode : 'testConstOnFunc\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aLinkedTerm"\r\r\t"since they can\'t be equal. As proven by this assertion. (obviously)"\r\tself deny:(ConstTerm new: ( Term new: \'a\'))=(LinkedTerm new: ( Term new: \'a\'))."S"\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 15:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnFunc,			#protocol : #tests,			#sourceCode : 'testConstOnFunc\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aFuncTerm"\r\t\r\t"check fail"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair :=nil.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 15:31',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T15:32:44.519251+01:00' ],		#prior : OmReference [ '11' ],		#self : OmReference [ '12' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnFunc,			#protocol : #tests,			#sourceCode : 'testConstOnFunc\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aFuncTerm"\r\t\r\t"check fail"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair :=nil.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 15:31',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnFunc,			#protocol : #tests,			#sourceCode : 'testConstOnFunc\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aFuncTerm"\r\t\r\t"check fail"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair :=nil.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"left:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t"',			#stamp : 'pm 12/14/2018 15:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T15:35:38.121746+01:00' ],		#prior : OmReference [ '12' ],		#self : OmReference [ '13' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnFunc,			#protocol : #tests,			#sourceCode : 'testConstOnFunc\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aFuncTerm"\r\t\r\t"check fail"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair :=nil.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"left:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t"',			#stamp : 'pm 12/14/2018 15:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnFunc,			#protocol : #tests,			#sourceCode : 'testConstOnFunc\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aFuncTerm"\r\t\r\t"check fail"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair :=nil.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"check ok"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 15:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T15:39:51.275844+01:00' ],		#prior : OmReference [ '13' ],		#self : OmReference [ '14' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnFunc,			#protocol : #tests,			#sourceCode : 'testConstOnFunc\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aFuncTerm"\r\t\r\t"check fail"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair :=nil.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"check ok"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 15:35',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnFunc,			#protocol : #tests,			#sourceCode : 'testConstOnFunc\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aFuncTerm"\r\t\r\t"check fail"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair :=nil.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"check ok"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 15:39',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T15:40:35.929612+01:00' ],		#prior : OmReference [ '14' ],		#self : OmReference [ '15' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both test for aConstTerm = anotherConstTerm"\r\t\r\t"conflict rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"The resulting pair is the same as the input, since the unification was unnecessary"\r\texpectedResultPair:=(Pair left:left right:right).\r\t"the delete let us an empty set"\r\texpectedResultSetOfPair:=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 12:07',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both test for aConstTerm = anotherConstTerm"\r\t\r\t"conflict rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"The resulting pair is the same as the input, since the unification was unnecessary"\r\texpectedResultPair:=(Pair left:left right:right).\r\t"the delete let us an empty set"\r\texpectedResultSetOfPair:=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 15:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T15:40:42.04855+01:00' ],		#prior : OmReference [ '15' ],		#self : OmReference [ '16' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both test for aConstTerm = anotherConstTerm"\r\t\r\t"conflict rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"The resulting pair is the same as the input, since the unification was unnecessary"\r\texpectedResultPair:=(Pair left:left right:right).\r\t"the delete let us an empty set"\r\texpectedResultSetOfPair:=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 15:40',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnConst,			#protocol : #tests,			#sourceCode : 'testConstOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both test for aConstTerm = anotherConstTerm"\r\t\r\t"conflict rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"this first test should just fail, with everything being nil"\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:nil.\r\tself assert:unifier setOfPairs equals: nil.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"The resulting pair is the same as the input, since the unification was unnecessary"\r\texpectedResultPair:=(Pair left:left right:right).\r\t"the delete let us an empty set"\r\texpectedResultSetOfPair:=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert: unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 15:40',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T15:43:10.652694+01:00' ],		#prior : OmReference [ '16' ],		#self : OmReference [ '17' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnFunc,			#protocol : #tests,			#sourceCode : 'testConstOnFunc\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aFuncTerm"\r\t\r\t"check fail"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair :=nil.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"check ok"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 15:39',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnFunc,			#protocol : #tests,			#sourceCode : 'testConstOnFunc\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aFuncTerm"\r\t\r\t"check fail"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair :=nil.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"check ok"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 15:43',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T15:48:59.02262+01:00' ],		#prior : OmReference [ '17' ],		#self : OmReference [ '18' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherFuncTerm\r\t"Comparaison Operator."\r\t| res |\r\tself assert:(self class=anotherFuncTerm class)."checking the input"\r\tres:=self isSameSymb: anotherFuncTerm."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherFuncTerm]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherFuncTerm).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 11/5/2018 09:09',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #FuncTerm,				#isMetaSide : false			},			#name : #'=',			#protocol : #comparing,			#sourceCode : '=anotherFuncTerm\r\t"Comparaison Operator."\r\t| res |\r\tres:=(self class=anotherFuncTerm class)."checking the input"\r\tres:=res and:[self isSameSymb: anotherFuncTerm]."comparing the function symbol"\r\tres:=res and:[self isSameArity: anotherFuncTerm]."comparing arity"\r\tres:=res and:[(self isSameTerms: anotherFuncTerm).]."we let the superclass LinkedList check for the correct terms"\r\t^res.',			#stamp : 'pm 12/14/2018 15:48',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T16:22:59.307346+01:00' ],		#prior : OmReference [ '18' ],		#self : OmReference [ '19' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #methodeDeResolution,			#sourceCode : 'resolvante: aClause1 with: aClause2\r\t"This method gets all the resolvantes between aClause1 and aClause2, modulo a subtitution of two terms.\r\tself is an Unifier\r\taClause1 and aClause2 are the clauses we want to get the resolvant off.\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\t\r\t[ i<=(aClause1 size). ]\r\twhileTrue:[\r\t\ta1:=aClause1 at:i.\r\t\t\r\t\tj:=1.\r\t\t[ j<=(aClause2 size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause2 at:j.\r\r\t\t\t(a1 isOppositePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t(sub1=sub2)\r\t\t\t\tifTrue:[\r\t\t\t\t\t"newClause:=Clause new.we create a new clause with everything but the Atomes used"\r\t\t\t\t\tnewClause:=(aClause1 without:i).\r\t\t\t\t\tnewClause addFromList: (aClause2 without:j).\r\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/27/2018 22:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #methodeDeResolution,			#sourceCode : 'resolvante: aClause1 with: aClause2\r\t"This method gets all the resolvantes between aClause1 and aClause2, modulo a subtitution of two terms.\r\tself is an Unifier\r\taClause1 and aClause2 are the clauses we want to get the resolvant off.\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\t\r\t[ i<=(aClause1 size). ]\r\twhileTrue:[\r\t\ta1:=aClause1 at:i.\r\t\t\r\t\tj:=1.\r\t\t[ j<=(aClause2 size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause2 at:j.\r\r\t\t\t(a1 isOppositePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:["if the unified pair isNil, then the unification failed"\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t\t(sub1=sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new.we create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause1 without:i).\r\t\t\t\t\t\tnewClause addFromList: (aClause2 without:j).\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 16:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T16:27:07.352138+01:00' ],		#prior : OmReference [ '19' ],		#self : OmReference [ '20' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t"This method factorise positively AND negatively at the same time.\r\tself is an Unifier\r\taClause is the clause we want to factorise\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t(sub1=sub2)\r\t\t\t\tifTrue:[\r\t\t\t\t\t"newClause:=Clause new. We create a new clause with everything but the Atomes used"\r\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 10/27/2018 22:13',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t"This method factorise positively AND negatively at the same time.\r\tself is an Unifier\r\taClause is the clause we want to factorise\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:[\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t"\t\t\t(sub1=sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new. We create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 16:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T16:28:17.55655+01:00' ],		#prior : OmReference [ '20' ],		#self : OmReference [ '21' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnFunc,			#protocol : #tests,			#sourceCode : 'testConstOnFunc\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aFuncTerm"\r\t\r\t"check fail"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair :=nil.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"check ok"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))) right:(ConstTerm new:(Term new:\'a\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 15:43',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testConstOnFunc,			#protocol : #tests,			#sourceCode : 'testConstOnFunc\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Only test for aConstTerm=aFuncTerm"\r\t\r\t"check fail"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=nil.\r\texpectedResultSetOfPair :=nil.\r\r\tself assert:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"check ok"\r\tleft:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tright:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'a\')) right:(FuncTerm new: \'f\' Variable:(ConstTerm new:(Term new:\'x\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 16:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T16:54:41.836224+01:00' ],		#prior : OmReference [ '21' ],		#self : OmReference [ '22' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'check:',			#protocol : #unification,			#sourceCode : 'check: aPair\r\t"Not active yet"\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'check\';cr.].\r\t\r\t^aPair right contains: aPair left term',			#stamp : 'pm 12/14/2018 15:15',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'check:',			#protocol : #unification,			#sourceCode : 'check: aPair\r\r\t(Prop debugUnification)\r\tifTrue:[Transcript show:\'check\';cr.].\r\t\r\t^aPair right contains: aPair left term',			#stamp : 'pm 12/14/2018 16:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T16:54:44.158474+01:00' ],		#prior : OmReference [ '22' ],		#self : OmReference [ '23' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\t"eliminate rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'y\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 16:54',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T17:13:29.364834+01:00' ],		#prior : OmReference [ '23' ],		#self : OmReference [ '24' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"Both tests for aLinkedTerm=anotherLinkedTerm"\r\t\r\t"eliminate rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'y\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(LinkedTerm new:(Term new:\'y\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 16:54',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\t\r\t"swap rule. We don\'t use the same term to not trigger a check afterwards"\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new:(LinkedTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: right right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new:(LinkedTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 17:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T17:15:13.439119+01:00' ],		#prior : OmReference [ '24' ],		#self : OmReference [ '25' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\t\r\t"swap rule. We don\'t use the same term to not trigger a check afterwards"\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new:(LinkedTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: right right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new:(LinkedTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 17:13',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\t\r\t"swap rule. We don\'t use the same term to not trigger a check afterwards"\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new:(ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: right right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new:(ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 17:15',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T17:18:18.791505+01:00' ],		#prior : OmReference [ '25' ],		#self : OmReference [ '26' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\t\r\t"swap rule. We don\'t use the same term to not trigger a check afterwards"\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new:(ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: right right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new:(ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 17:15',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\t\r\t"swap rule. We don\'t use the same term to not trigger a check afterwards"\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: right right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 17:18',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T17:19:03.967381+01:00' ],		#prior : OmReference [ '26' ],		#self : OmReference [ '27' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\t\r\t"swap rule. We don\'t use the same term to not trigger a check afterwards"\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: right right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 17:18',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\t\r\t"swap rule. We don\'t use the same term to not trigger a check afterwards"\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: right right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))) right:(ConstTerm new:(Term new:\'x\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 17:19',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T17:20:39.869089+01:00' ],		#prior : OmReference [ '27' ],		#self : OmReference [ '28' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\t\r\t"swap rule. We don\'t use the same term to not trigger a check afterwards"\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: right right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))) right:(ConstTerm new:(Term new:\'x\')));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 17:19',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\t\r\t"swap rule. We don\'t use the same term to not trigger a check afterwards"\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: right right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 17:20',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T17:21:33.113933+01:00' ],		#prior : OmReference [ '28' ],		#self : OmReference [ '29' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\t\r\t"swap rule. We don\'t use the same term to not trigger a check afterwards"\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: right right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 17:20',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\t\r\t"swap rule. We don\'t use the same term to not trigger a check afterwards"\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 17:21',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T17:21:46.057376+01:00' ],		#prior : OmReference [ '29' ],		#self : OmReference [ '30' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\t\r\t"swap rule. We don\'t use the same term to not trigger a check afterwards"\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 17:21',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\t\r\t"swap rule. We don\'t use the same term to not trigger a check afterwards"\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself halt.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 17:21',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T17:23:14.438551+01:00' ],		#prior : OmReference [ '30' ],		#self : OmReference [ '31' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\t\r\t"swap rule. We don\'t use the same term to not trigger a check afterwards"\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself halt.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 17:21',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\t\r\t"swap rule. We don\'t use the same term to not trigger a check afterwards"\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 17:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T17:23:57.605551+01:00' ],		#prior : OmReference [ '31' ],		#self : OmReference [ '32' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\t\r\t"swap rule. We don\'t use the same term to not trigger a check afterwards"\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 17:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\t\r\t"swap rule. We don\'t use the same term to not trigger a check afterwards"\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\tself halt.\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 17:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T17:27:39.667812+01:00' ],		#prior : OmReference [ '32' ],		#self : OmReference [ '33' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\t\r\t"swap rule. We don\'t use the same term to not trigger a check afterwards"\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\tself halt.\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 17:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\t\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\tself halt.\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 17:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T17:27:47.164195+01:00' ],		#prior : OmReference [ '33' ],		#self : OmReference [ '34' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\t\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: right. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\tself halt.\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 17:27',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\t\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: right right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\tself halt.\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 17:27',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T17:28:10.668877+01:00' ],		#prior : OmReference [ '34' ],		#self : OmReference [ '35' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\t\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: right right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\tself halt.\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r\t"delete rule"\r\tleft:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since they already are the same"\r\texpectedResultPair:=Pair left: left right: right. \r\t"the delete let us with an empty set"\r\texpectedResultSetOfPair :=MinimalOrderedSet new.\r\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t\r',			#stamp : 'pm 12/14/2018 17:27',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\t\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: right right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\tself halt.\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 17:28',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T17:29:07.42153+01:00' ],		#prior : OmReference [ '35' ],		#self : OmReference [ '36' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\t\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: right right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\tself halt.\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 17:28',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\tTranscript clear.\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 17:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T17:29:12.464977+01:00' ],		#prior : OmReference [ '36' ],		#self : OmReference [ '37' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\tTranscript clear.\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 17:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 17:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T17:29:35.199024+01:00' ],		#prior : OmReference [ '37' ],		#self : OmReference [ '38' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 17:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 17:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T17:29:57.167739+01:00' ],		#prior : OmReference [ '38' ],		#self : OmReference [ '39' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnLinked,			#protocol : #tests,			#sourceCode : 'testFuncOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\t\t\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 17:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T17:30:12.329086+01:00' ],		#prior : OmReference [ '39' ],		#self : OmReference [ '40' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 17:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\t\t\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 17:30',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T17:31:28.574726+01:00' ],		#prior : OmReference [ '40' ],		#self : OmReference [ '41' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnLinked,			#protocol : #tests,			#sourceCode : 'testFuncOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\t\t\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 17:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnLinked,			#protocol : #tests,			#sourceCode : 'testFuncOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"Will swap before eliminate and succeed"\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\t\t\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 17:31',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T17:32:20.890641+01:00' ],		#prior : OmReference [ '41' ],		#self : OmReference [ '42' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"No changes expected since "\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\t\t\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 17:30',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=aConstTerm"\r\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"Will swap before eliminate and succeed"\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\t\t\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 17:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T17:32:25.485963+01:00' ],		#prior : OmReference [ '42' ],		#self : OmReference [ '43' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnLinked,			#protocol : #tests,			#sourceCode : 'testFuncOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=anotherLinkedTerm"\r\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"Will swap before eliminate and succeed"\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\t\t\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 17:31',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnLinked,			#protocol : #tests,			#sourceCode : 'testFuncOnLinked\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=aLinkedTerm"\r\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\t\r\t"Will swap before eliminate and succeed"\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\t\t\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 17:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T17:33:17.485999+01:00' ],		#prior : OmReference [ '43' ],		#self : OmReference [ '44' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=aConstTerm"\r\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"Will swap before eliminate and succeed"\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (LinkedTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))));\r\t\tyourself.\r\t\t\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 17:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=aConstTerm"\r\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"Will swap before eliminate and succeed"\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'x\'))));\r\t\tyourself.\r\t\t\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 17:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T17:46:59.198381+01:00' ],		#prior : OmReference [ '44' ],		#self : OmReference [ '45' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFuncTerm)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:["Decompose is possible"\r\t\t\t\tself decompose:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t]\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tself swap:aPair.\r\t\t\tmodified:=true.\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\tleft=right\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\tnotPossible:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 15:14',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #'tryOperations:',			#protocol : #unification,			#sourceCode : 'tryOperations: aPair\r\t| modified notPossible left right |\r\tleft:=aPair left."syntaxic sugar"\r\tright:=aPair right.\r\r\tnotPossible:=false.\r\tmodified:=false.\r\r\t(left isPredicateOrFuncTerm)\r\tifTrue:[\r\t\t(right isPredicateOrFuncTerm)\r\t\tifTrue:[\r\t\t\t((left isSameSymb: right) and:[(left arity=right arity)])\r\t\t\tifTrue:["Decompose is possible"\r\t\t\t\tself decompose:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t]\r\t\t\tifFalse:["Isn\'t the sameSymbol, conflict"\r\t\t\t\tself conflict:aPair.\r\t\t\t\tnotPossible:=true.\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["it\'s either a ConstTerm or a LinkedTerm. Same behavior"\r\t\t\tleft isConst\r\t\t\tifTrue:[\r\t\t\t\tself swap:aPair.\r\t\t\t\tmodified:=true.\r\t\t\t\t]\r\t\t\t]\r\t\t]\r\tifFalse:[\r\t\t(left isLinkedTerm)\r\t\tifTrue:[\r\t\t\tright isPredicateOrFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair.\r\t\t\t\t]\r\t\t\tifFalse:["else right is either Linked or Const term, behavior is factorisable"\r\t\t\t\tleft=right\r\t\t\t\tifTrue:["then they both are LinkedTerms"\r\t\t\t\t\tself delete:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:[\r\t\t\t\t\tmodified:=self eliminate:aPair.\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\tifFalse:["left is a ConstTerm"\r\t\t\tright isFuncTerm\r\t\t\tifTrue:[\r\t\t\t\tnotPossible:=self check:aPair\r\t\t\t\t]\r\t\t\tifFalse:[\r\t\t\t\tright isLinkedTerm\r\t\t\t\tifTrue:[\r\t\t\t\t\tself swap:aPair.\r\t\t\t\t\tmodified:=true.\r\t\t\t\t\t]\r\t\t\t\tifFalse:["right is a ConstTerm"\r\t\t\t\t\tleft=right\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\tself delete:aPair.\r\t\t\t\t\t\tmodified:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself conflict:aPair.\r\t\t\t\t\t\tnotPossible:=true.\r\t\t\t\t\t\t]\r\t\t\t\t\t]\r\t\t\t\t]\r\t\t\t]\r\t\t].\r\r\t^Pair left: modified right: notPossible. ',			#stamp : 'pm 12/14/2018 17:46',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T17:52:21.826228+01:00' ],		#prior : OmReference [ '45' ],		#self : OmReference [ '46' ]	},	#content : EpMethodRemoval {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testFuncOnConst,			#protocol : #tests,			#sourceCode : 'testFuncOnConst\r\t| left right unifier expectedResultPair expectedResultSetOfPair |\r\t"the only test for aFuncTerm=aConstTerm"\r\r\t"swap rule."\r\tleft:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'y\'))).\r\tright:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'x\')).\r\t\r\tunifier:=Unifier new: left Predicate2:right.\r\r\t"Will swap before eliminate and succeed"\r\texpectedResultPair:=Pair left: left right: left. \r\texpectedResultSetOfPair :=MinimalOrderedSet new\r\t\tadd: (Pair left: (ConstTerm new:(Term new:\'x\')) right:(FuncTerm new: \'f\' Variable: (ConstTerm new:(Term new:\'x\'))));\r\t\tyourself.\r\t\t\r\tself deny:unifier hasFailed.\r\tself assert:unifier unifiedPair equals:expectedResultPair.\r\tself assert:unifier setOfPairs equals: expectedResultSetOfPair.\r\t',			#stamp : 'pm 12/14/2018 17:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T17:52:45.943323+01:00' ],		#prior : OmReference [ '46' ],		#self : OmReference [ '47' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines"\r\t"Binary"\r\t|t l r|\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl unificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t\r\t"should replace x by y at the end of the unification"\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:( LinkedTerm new:(Term new:\'x\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 12/13/2018 19:08',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #TestUnification,				#isMetaSide : false			},			#name : #testingUnification,			#protocol : #testing,			#sourceCode : 'testingUnification\r \t"everything is tested in those few lines, with textual output. Not automated"\r\t|t l r|\r\t\r\tTranscript show: \'Testing Unification related stuff\';cr.\r\t\r\tTranscript show:\'Basics\';cr.\r\t\r\tTranscript show:\'decompositions\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'b\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'delete\';cr.\r\tl:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\t\r\tTranscript show:\'conflict\';cr.\r\tl:=Predicate new: \'Q\' variable: (ConstTerm new:(Term new:\'a\')).\r\tr:=Predicate new: \'P\' variable: (ConstTerm new:(Term new:\'a\')).\r\tl unificationUnitTest:r.\r\r\tTranscript show:\'swap\';cr.\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variable: (ConstTerm new: (Term new: \'a\'))).\r\tr:=Predicate new: \'P\' variable: (LinkedTerm new:(Term new:\'x\')).\r\tl unificationUnitTest:r.\r\r\t"G{f(x,g(x))=f(a,g(a))}"\r\tTranscript show:\'Exemple\tdavid #2\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (LinkedTerm new:(Term new:\'x\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'a\')) ;add:(FuncTerm new:\'g\' Variable:(ConstTerm new:(Term new:\'a\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t"G{f(x,g(a))=f(b,g(y))}"\r\tTranscript show:\'Exemple david #1\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(FuncTerm new:\'g\' Variable: (ConstTerm new:(Term new:\'a\'))).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add:(ConstTerm new:(Term new:\'b\')) ;add:(FuncTerm new:\'g\' Variable:(LinkedTerm new:(Term new:\'y\'))).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\t\r\t"should replace x by y at the end of the unification"\r\tTranscript show:\'x alias y\';cr.\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'y\'));add:( LinkedTerm new:(Term new:\'x\'));add:(ConstTerm new:(Term new:\'a\')).\r\tl:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tt:=LinkedList new.\r\tt add: (LinkedTerm new:(Term new:\'x\'));add:(LinkedTerm new:(Term new:\'y\'));add:(LinkedTerm new:(Term new:\'x\')).\r\tr:=Predicate new: \'P\' variable: (FuncTerm new: \'f\' Variables:t).\r\tl unificationUnitTest:r.\r\t\r\r\t\r\tTranscript show: \'Done with the testing, did it work? :3\' ; cr; cr.',			#stamp : 'pm 12/14/2018 17:52',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T17:59:32.889098+01:00' ],		#prior : OmReference [ '47' ],		#self : OmReference [ '48' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tclausificationTrace:=false.\r\tskolemnTrace:=false.\r\tdebugUnification:=true.\r\tresolutionTrace:=false.\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/13/2018 19:14',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tclausificationTrace:=false.\r\tskolemnTrace:=false.\r\tdebugUnification:=false.\r\tresolutionTrace:=false.\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/14/2018 17:59',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T18:12:22.930065+01:00' ],		#prior : OmReference [ '48' ],		#self : OmReference [ '49' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #debugUnification,			#protocol : #'as yet unclassified',			#sourceCode : 'debugUnification\r\t^debugUnification',			#stamp : 'pm 12/13/2018 19:10',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #debugUnification,			#protocol : #accessing,			#sourceCode : 'debugUnification\r\t^debugUnification',			#stamp : 'pm 12/13/2018 19:10',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T18:12:30.353107+01:00' ],		#prior : OmReference [ '49' ],		#self : OmReference [ '50' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tclausificationTrace:=false.\r\tskolemnTrace:=false.\r\tdebugUnification:=false.\r\tresolutionTrace:=false.\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/14/2018 17:59',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tclausificationTrace:=true.\r\tskolemnTrace:=false.\r\tdebugUnification:=false.\r\tresolutionTrace:=false.\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/14/2018 18:12',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T18:13:58.263723+01:00' ],		#prior : OmReference [ '50' ],		#self : OmReference [ '51' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tclausificationTrace:=true.\r\tskolemnTrace:=false.\r\tdebugUnification:=false.\r\tresolutionTrace:=false.\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/14/2018 18:12',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tclausificationTrace:=false.\r\tskolemnTrace:=false.\r\tdebugUnification:=false.\r\tresolutionTrace:=true.\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/14/2018 18:13',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T18:21:06.283737+01:00' ],		#prior : OmReference [ '51' ],		#self : OmReference [ '52' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #methodeDeResolution,			#sourceCode : 'resolvante: aClause1 with: aClause2\r\t"This method gets all the resolvantes between aClause1 and aClause2, modulo a subtitution of two terms.\r\tself is an Unifier\r\taClause1 and aClause2 are the clauses we want to get the resolvant off.\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\t\r\t[ i<=(aClause1 size). ]\r\twhileTrue:[\r\t\ta1:=aClause1 at:i.\r\t\t\r\t\tj:=1.\r\t\t[ j<=(aClause2 size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause2 at:j.\r\r\t\t\t(a1 isOppositePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:["if the unified pair isNil, then the unification failed"\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t\t(sub1=sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new.we create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause1 without:i).\r\t\t\t\t\t\tnewClause addFromList: (aClause2 without:j).\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 16:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #methodeDeResolution,			#sourceCode : 'resolvante: aClause1 with: aClause2\r\t"This method gets all the resolvantes between aClause1 and aClause2, modulo a subtitution of two terms.\r\tself is an Unifier\r\taClause1 and aClause2 are the clauses we want to get the resolvant off.\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\t\r\t[ i<=(aClause1 size). ]\r\twhileTrue:[\r\t\ta1:=aClause1 at:i.\r\t\t\r\t\tj:=1.\r\t\t[ j<=(aClause2 size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause2 at:j.\r\r\t\t\t(a1 isOppositePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:["if the unified pair isNil, then the unification failed"\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t\t(sub1=sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new.we create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause1 without:i).\r\t\t\t\t\t\tnewClause addFromList: (aClause2 without:j).\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself halt.\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 18:21',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T18:22:13.495907+01:00' ],		#prior : OmReference [ '52' ],		#self : OmReference [ '53' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #methodeDeResolution,			#sourceCode : 'resolvante: aClause1 with: aClause2\r\t"This method gets all the resolvantes between aClause1 and aClause2, modulo a subtitution of two terms.\r\tself is an Unifier\r\taClause1 and aClause2 are the clauses we want to get the resolvant off.\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\t\r\t[ i<=(aClause1 size). ]\r\twhileTrue:[\r\t\ta1:=aClause1 at:i.\r\t\t\r\t\tj:=1.\r\t\t[ j<=(aClause2 size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause2 at:j.\r\r\t\t\t(a1 isOppositePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:["if the unified pair isNil, then the unification failed"\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t\t(sub1=sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new.we create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause1 without:i).\r\t\t\t\t\t\tnewClause addFromList: (aClause2 without:j).\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself halt.\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 18:21',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #methodeDeResolution,			#sourceCode : 'resolvante: aClause1 with: aClause2\r\t"This method gets all the resolvantes between aClause1 and aClause2, modulo a subtitution of two terms.\r\tself is an Unifier\r\taClause1 and aClause2 are the clauses we want to get the resolvant off.\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\t\r\t[ i<=(aClause1 size). ]\r\twhileTrue:[\r\t\ta1:=aClause1 at:i.\r\t\t\r\t\tj:=1.\r\t\t[ j<=(aClause2 size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause2 at:j.\r\r\t\t\t(a1 isOppositePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:["if the unified pair isNil, then the unification failed"\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t\t(sub1 isOpposite: sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new.we create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause1 without:i).\r\t\t\t\t\t\tnewClause addFromList: (aClause2 without:j).\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself halt.\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 18:22',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T18:23:29.362+01:00' ],		#prior : OmReference [ '53' ],		#self : OmReference [ '54' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #methodeDeResolution,			#sourceCode : 'resolvante: aClause1 with: aClause2\r\t"This method gets all the resolvantes between aClause1 and aClause2, modulo a subtitution of two terms.\r\tself is an Unifier\r\taClause1 and aClause2 are the clauses we want to get the resolvant off.\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\t\r\t[ i<=(aClause1 size). ]\r\twhileTrue:[\r\t\ta1:=aClause1 at:i.\r\t\t\r\t\tj:=1.\r\t\t[ j<=(aClause2 size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause2 at:j.\r\r\t\t\t(a1 isOppositePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:["if the unified pair isNil, then the unification failed"\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t\t(sub1 isOpposite: sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new.we create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause1 without:i).\r\t\t\t\t\t\tnewClause addFromList: (aClause2 without:j).\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\tself halt.\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 18:22',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #methodeDeResolution,			#sourceCode : 'resolvante: aClause1 with: aClause2\r\t"This method gets all the resolvantes between aClause1 and aClause2, modulo a subtitution of two terms.\r\tself is an Unifier\r\taClause1 and aClause2 are the clauses we want to get the resolvant off.\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\t\r\t[ i<=(aClause1 size). ]\r\twhileTrue:[\r\t\ta1:=aClause1 at:i.\r\t\t\r\t\tj:=1.\r\t\t[ j<=(aClause2 size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause2 at:j.\r\r\t\t\t(a1 isOppositePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:["if the unified pair isNil, then the unification failed"\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t\t(sub1 isOpposite: sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new.we create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause1 without:i).\r\t\t\t\t\t\tnewClause addFromList: (aClause2 without:j).\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 18:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T18:26:18.521149+01:00' ],		#prior : OmReference [ '54' ],		#self : OmReference [ '55' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t"This method factorise positively AND negatively at the same time.\r\tself is an Unifier\r\taClause is the clause we want to factorise\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:[\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t"\t\t\t(sub1=sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new. We create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t].\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 16:27',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t"This method factorise positively AND negatively at the same time.\r\tself is an Unifier\r\taClause is the clause we want to factorise\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:[\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t"\t\t\t(sub1=sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new. We create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t\tself halt.\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 18:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T18:26:29.088631+01:00' ],		#prior : OmReference [ '55' ],		#self : OmReference [ '56' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t"This method factorise positively AND negatively at the same time.\r\tself is an Unifier\r\taClause is the clause we want to factorise\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:[\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t"\t\t\t(sub1=sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new. We create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\tifFalse:[\r\t\t\t\t\t\t\tself halt.\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 18:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t"This method factorise positively AND negatively at the same time.\r\tself is an Unifier\r\taClause is the clause we want to factorise\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:[\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t"\t\t\t(sub1=sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new. We create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 18:26',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T18:31:44.510215+01:00' ],		#prior : OmReference [ '56' ],		#self : OmReference [ '57' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t"This method factorise positively AND negatively at the same time.\r\tself is an Unifier\r\taClause is the clause we want to factorise\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:[\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t"\t\t\t(sub1=sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new. We create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 18:26',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t"This method factorise positively AND negatively at the same time.\r\tself is an Unifier\r\taClause is the clause we want to factorise\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:[\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t"\t\t\t(sub1=sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new. We create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\t\tself halt.\r\t\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 18:31',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T18:32:52.205928+01:00' ],		#prior : OmReference [ '57' ],		#self : OmReference [ '58' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t"This method factorise positively AND negatively at the same time.\r\tself is an Unifier\r\taClause is the clause we want to factorise\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:[\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t"\t\t\t(sub1=sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new. We create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\t\tself halt.\r\t\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 18:31',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t"This method factorise positively AND negatively at the same time.\r\tself is an Unifier\r\taClause is the clause we want to factorise\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:[\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t"\t\t\t(sub1=sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new. We create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 18:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T18:33:05.752176+01:00' ],		#prior : OmReference [ '58' ],		#self : OmReference [ '59' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #methodeDeResolution,			#sourceCode : 'resolvante: aClause1 with: aClause2\r\t"This method gets all the resolvantes between aClause1 and aClause2, modulo a subtitution of two terms.\r\tself is an Unifier\r\taClause1 and aClause2 are the clauses we want to get the resolvant off.\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\t\r\t[ i<=(aClause1 size). ]\r\twhileTrue:[\r\t\ta1:=aClause1 at:i.\r\t\t\r\t\tj:=1.\r\t\t[ j<=(aClause2 size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause2 at:j.\r\r\t\t\t(a1 isOppositePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:["if the unified pair isNil, then the unification failed"\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t\t(sub1 isOpposite: sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new.we create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause1 without:i).\r\t\t\t\t\t\tnewClause addFromList: (aClause2 without:j).\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 18:23',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #methodeDeResolution,			#sourceCode : 'resolvante: aClause1 with: aClause2\r\t"This method gets all the resolvantes between aClause1 and aClause2, modulo a subtitution of two terms.\r\tself is an Unifier\r\taClause1 and aClause2 are the clauses we want to get the resolvant off.\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\t\r\t[ i<=(aClause1 size). ]\r\twhileTrue:[\r\t\ta1:=aClause1 at:i.\r\t\t\r\t\tj:=1.\r\t\t[ j<=(aClause2 size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause2 at:j.\r\r\t\t\t(a1 isOppositePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:["if the unified pair isNil, then the unification failed"\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t\t(sub1 isOpposite: sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new.we create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause1 without:i).\r\t\t\t\t\t\tnewClause addFromList: (aClause2 without:j).\r\t\t\t\t\t\tself halt.\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 18:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T18:35:26.753451+01:00' ],		#prior : OmReference [ '59' ],		#self : OmReference [ '60' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #methodeDeResolution,			#sourceCode : 'resolvante: aClause1 with: aClause2\r\t"This method gets all the resolvantes between aClause1 and aClause2, modulo a subtitution of two terms.\r\tself is an Unifier\r\taClause1 and aClause2 are the clauses we want to get the resolvant off.\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\t\r\t[ i<=(aClause1 size). ]\r\twhileTrue:[\r\t\ta1:=aClause1 at:i.\r\t\t\r\t\tj:=1.\r\t\t[ j<=(aClause2 size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause2 at:j.\r\r\t\t\t(a1 isOppositePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:["if the unified pair isNil, then the unification failed"\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t\t(sub1 isOpposite: sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new.we create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause1 without:i).\r\t\t\t\t\t\tnewClause addFromList: (aClause2 without:j).\r\t\t\t\t\t\tself halt.\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 18:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #resolutionMethod,			#sourceCode : 'resolvante: aClause1 with: aClause2\r\t"This method gets all the resolvantes between aClause1 and aClause2, modulo a subtitution of two terms.\r\tself is an Unifier\r\taClause1 and aClause2 are the clauses we want to get the resolvant off.\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\t\r\t[ i<=(aClause1 size). ]\r\twhileTrue:[\r\t\ta1:=aClause1 at:i.\r\t\t\r\t\tj:=1.\r\t\t[ j<=(aClause2 size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause2 at:j.\r\r\t\t\t(a1 isOppositePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:["if the unified pair isNil, then the unification failed"\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t\t(sub1 isOpposite: sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new.we create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause1 without:i).\r\t\t\t\t\t\tnewClause addFromList: (aClause2 without:j).\r\t\t\t\t\t\tself halt.\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 18:33',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T18:35:26.761343+01:00' ],		#prior : OmReference [ '60' ],		#self : OmReference [ '61' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #methodeDeResolution,			#sourceCode : 'factorisation: aClause\r\t"This method factorise positively AND negatively at the same time.\r\tself is an Unifier\r\taClause is the clause we want to factorise\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:[\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t"\t\t\t(sub1=sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new. We create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 18:32',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'factorisation:',			#protocol : #resolutionMethod,			#sourceCode : 'factorisation: aClause\r\t"This method factorise positively AND negatively at the same time.\r\tself is an Unifier\r\taClause is the clause we want to factorise\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\r\t"Transcript show:aClause;cr."\r\t\r\t[ i<=(aClause size). ]\r\twhileTrue:[\r\t\ta1:=aClause at:i.\r\t\t\r\t\tj:=i+1.\r\t\t[ j<=(aClause size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause at:j.\r\r\t\t\t(a1 isSamePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\t\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:[\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t\t"\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t\t"\t\t\t(sub1=sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new. We create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause without:i nor:j).\r\t\t\t\t\t\tnewClause add:sub1. "sub1=sub2, so we only add one of them"\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 18:32',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T18:35:36.093533+01:00' ],		#prior : OmReference [ '61' ],		#self : OmReference [ '62' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #resolutionMethod,			#sourceCode : 'resolvante: aClause1 with: aClause2\r\t"This method gets all the resolvantes between aClause1 and aClause2, modulo a subtitution of two terms.\r\tself is an Unifier\r\taClause1 and aClause2 are the clauses we want to get the resolvant off.\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\t\r\t[ i<=(aClause1 size). ]\r\twhileTrue:[\r\t\ta1:=aClause1 at:i.\r\t\t\r\t\tj:=1.\r\t\t[ j<=(aClause2 size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause2 at:j.\r\r\t\t\t(a1 isOppositePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:["if the unified pair isNil, then the unification failed"\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t\t(sub1 isOpposite: sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new.we create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause1 without:i).\r\t\t\t\t\t\tnewClause addFromList: (aClause2 without:j).\r\t\t\t\t\t\tself halt.\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 18:33',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'resolvante:with:',			#protocol : #resolutionMethod,			#sourceCode : 'resolvante: aClause1 with: aClause2\r\t"This method gets all the resolvantes between aClause1 and aClause2, modulo a subtitution of two terms.\r\tself is an Unifier\r\taClause1 and aClause2 are the clauses we want to get the resolvant off.\r\tresultant clauses are stocked in self."\r\r\t| i j a1 a2 sub1 sub2 u newClause |\r\t"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.\r\tWe don\'t need that much variable, it\'s for clarity"\r\ti:=1.\r\t\t\r\t[ i<=(aClause1 size). ]\r\twhileTrue:[\r\t\ta1:=aClause1 at:i.\r\t\t\r\t\tj:=1.\r\t\t[ j<=(aClause2 size) ]\r\t\twhileTrue:[\r\t\t\ta2:=aClause2 at:j.\r\r\t\t\t(a1 isOppositePolarity: a2)\r\t\t\tifTrue:[\r\t\t\t\tu:=Unifier new: a1 Predicate2: a2.\r\t\t\t\tu hasFailed\r\t\t\t\tifFalse:["if the unified pair isNil, then the unification failed"\r\t\t\t\t\tsub1:=u firstPredicate.\r\t\t\t\t\tsub2:=u secondPredicate.\r\t"\t\t\t\tTranscript show:\'sub1: \';show:sub1;cr.\r\t\t\t\t\tTranscript show:\'sub2: \';show:sub2;cr.\r\t"\t\t\t\t(sub1 isOpposite: sub2)\r\t\t\t\t\tifTrue:[\r\t\t\t\t\t\t"newClause:=Clause new.we create a new clause with everything but the Atomes used"\r\t\t\t\t\t\tnewClause:=(aClause1 without:i).\r\t\t\t\t\t\tnewClause addFromList: (aClause2 without:j).\r\t\t\t\t\t\tself add:newClause. "we finally add the resolvante."\r\t\t\t\t\t\t]\r\t\t\t\t\t].\r\t\t\t\t].\r\t\t\tj:=j+1.\r\t\t\t].\r\t\ti:=i+1.\r\t\t].',			#stamp : 'pm 12/14/2018 18:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T18:51:16.050831+01:00' ],		#prior : OmReference [ '62' ],		#self : OmReference [ '63' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Resolvante,				#isMetaSide : false			},			#name : #'ApplyUnifier:onClause:',			#protocol : #resolutionMethod,			#sourceCode : 'ApplyUnifier: u onClause:aClause',			#stamp : 'pm 12/14/2018 18:51',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T19:23:54.501911+01:00' ],		#prior : OmReference [ '63' ],		#self : OmReference [ '64' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tclausificationTrace:=false.\r\tskolemnTrace:=false.\r\tdebugUnification:=false.\r\tresolutionTrace:=true.\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/14/2018 18:13',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #initialize,			#protocol : #initialization,			#sourceCode : 'initialize\r\tclausificationTrace:=false.\r\tskolemnTrace:=false.\r\tdebugUnification:=true.\r\tresolutionTrace:=true.\r\ttestNumber:=0.\r\t',			#stamp : 'pm 12/14/2018 19:23',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T19:29:15.57047+01:00' ],		#prior : OmReference [ '64' ],		#self : OmReference [ '65' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\t[ modified ]\r\twhileTrue:[\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification ifTrue: [ Transcript show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right"=not possible"\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\t"Transcript show: \'Unification impossible\'; cr."\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\thasFailed:=true.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t\r\t\t]. ',			#stamp : 'pm 12/14/2018 09:46',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\t[ modified ]\r\twhileTrue:[\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification ifTrue: [ Transcript cr;show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right"=not possible"\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\t"Transcript show: \'Unification impossible\'; cr."\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\thasFailed:=true.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t\r\t\t]. ',			#stamp : 'pm 12/14/2018 19:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T19:29:17.507921+01:00' ],		#prior : OmReference [ '65' ],		#self : OmReference [ '66' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\t[ modified ]\r\twhileTrue:[\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification ifTrue: [ Transcript cr;show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right"=not possible"\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\t"Transcript show: \'Unification impossible\'; cr."\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\thasFailed:=true.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t\r\t\t]. ',			#stamp : 'pm 12/14/2018 19:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #Unifier,				#isMetaSide : false			},			#name : #unifyMe,			#protocol : #unification,			#sourceCode : 'unifyMe\r\t| modified operationAnswer i |\r\tmodified := true.\r\t[ modified ]\r\twhileTrue:[\r\t\tmodified := false.\r\t\ti := 1.\r\t\t[(modified not) and:[(i <= (setOfPairs size))]]\r\t\twhileTrue: [ \r\t\t\tProp debugUnification ifTrue: [ Transcript cr;cr;show: self;cr ].\r\t\t\toperationAnswer := self tryOperations: (setOfPairs at: i).\r\t\t\toperationAnswer right"=not possible"\r\t\t\tifTrue: [ "On a conflict or a fail check"\r\t\t\t\t"Transcript show: \'Unification impossible\'; cr."\r\t\t\t\tsetOfPairs := nil.\r\t\t\t\thasFailed:=true.\r\t\t\t\t^nil "return value doesn\'t matter, we just want to break out" \r\t\t\t\t].\t"NotPossible to unify?"\r\t\t\t"else we go on till we didn\'t do anything more"\r\t\t\tmodified := modified or: [ operationAnswer left ].\t"isModified was put arbitrily in left"\r\t\t\ti:=i + 1 .\r\t\t\t].\t\r\t\t]. ',			#stamp : 'pm 12/14/2018 19:29',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T19:34:50.422688+01:00' ],		#prior : OmReference [ '66' ],		#self : OmReference [ '67' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t"application of the resolution method on self. Course algorithm"\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tTranscript show:self;cr.\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r\t   ((c isTautology) or:[sat anySatisfy:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 12/13/2018 18:29',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t"application of the resolution method on self. Course algorithm"\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tProp resolutionTrace ifTrue:[ Transcript show:self;cr].\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r\t   ((c isTautology) or:[sat anySatisfy:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 12/14/2018 19:34',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T19:35:36.522836+01:00' ],		#prior : OmReference [ '67' ],		#self : OmReference [ '68' ]	},	#content : EpMethodAddition {		#method : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #'Prop class',				#isMetaSide : true			},			#name : #resolutionTrace,			#protocol : #'as yet unclassified',			#sourceCode : 'resolutionTrace\r\t^resolutionTrace',			#stamp : 'pm 12/14/2018 19:35',			#package : #_resolution_1erOrdre		}	}}OmEntry {	#tags : {		#author : 'pm',		#time : DateAndTime [ '2018-12-14T19:42:15.343456+01:00' ],		#prior : OmReference [ '68' ],		#self : OmReference [ '69' ]	},	#content : EpMethodModification {		#oldMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t"application of the resolution method on self. Course algorithm"\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tProp resolutionTrace ifTrue:[ Transcript show:self;cr].\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[^true.]."Insatisfiable"\r\t   ((c isTautology) or:[sat anySatisfy:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 12/14/2018 19:34',			#package : #_resolution_1erOrdre		},		#newMethod : RGMethodDefinition {			#annotations : IdentityDictionary {				#className : #ClausalForm,				#isMetaSide : false			},			#name : #resolutionMethod,			#protocol : #resolution,			#sourceCode : 'resolutionMethod\r\t"application of the resolution method on self. Course algorithm"\r\t| sat c r |\r\tsat:=MinimalOrderedSet new.\r\t[self isEmpty]\r\twhileFalse:[\r\t\tProp resolutionTrace ifTrue:[ Transcript show:self;cr].\r\t\tc:=self removeFirst.\r\t\tc isEmptyClause\r\t\tifTrue:[Transcript show:\'POUET\'.^true.]."Insatisfiable"\r\t   ((c isTautology) or:[sat anySatisfy:[:each|each=c.]])"ifTrue:[skip]"\r\t\t\tifFalse:[\r\t\t\t\tr:=Resolvante new.\r\t\t\t\tr factorisation:c.\r\t\t\t\tsat do:[:c1|\r\t\t\t\t\tr resolvante: c1 with: c.\r\t\t\t\t\t].\r\t\t\t\tself addFromList:r.\r\t\t\t\tsat addLast:c.\r\t\t\t].\t\r\t\t].\r\t^false."satisfiable"',			#stamp : 'pm 12/14/2018 19:42',			#package : #_resolution_1erOrdre		}	}}