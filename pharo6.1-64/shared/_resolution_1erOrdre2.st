Object subclass: #Clause	instanceVariableNames: 'atomes'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Clause methodsFor: 'printing' stamp: 'pm 10/3/2018 13:08'!prettyPrint	|t|	t:='{'.		atomes do: [  :each | t:=t,(each prettyPrint),','. ].	t:=t,'}'.	^t.! !!Clause methodsFor: 'accessing' stamp: 'pm 10/3/2018 13:00'!add: var	(var isKindOf: Atome)		ifTrue:[			(self atomes) add:var.			^self."able chaining operation"			]		ifFalse:[				Transcript show: 'wrong type'.				"should add an error."			].! !!Clause methodsFor: 'accessing' stamp: 'pm 10/2/2018 17:33'!initialize: OrProp	atomes:=LinkedList new.	self addAll:OrProp.! !!Clause methodsFor: 'accessing' stamp: 'pm 10/1/2018 20:18'!atomes	^atomes.! !!Clause methodsFor: 'accessing' stamp: 'pm 10/3/2018 15:37'!addAll: OrProp	(OrProp isKindOf: Atome)	ifTrue:[self add:OrProp.]	ifFalse:[		((OrProp) isKindOf: Not)		ifTrue:[			(OrProp operand isKindOf:Atome)				ifTrue:["Transcript show:(OrProp operand) getSymb ;cr."						self add:(NotVar new:((OrProp operand) getSymb))]				ifFalse:["switch to Error new:"					Transcript show: 'Error, shouldn''t be any more not ( binaryOp )'					].			]		ifFalse:[			((OrProp) isKindOf: Or)			ifTrue:[				self addAll: (OrProp left).				self addAll: (OrProp right).				]			ifFalse:["switch to Error new:"				Transcript show:'Error, shouldn''t be any other kind of prop here.'.				].			].		].! !!Clause methodsFor: 'accessing' stamp: 'pm 10/2/2018 17:03'!initialize	atomes:=LinkedList new.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Clause class	instanceVariableNames: ''!!Clause class methodsFor: 'instance creation' stamp: 'pm 10/2/2018 17:31'!new: OrProp	^self basicNew initialize:OrProp.! !!Clause class methodsFor: 'instance creation' stamp: 'pm 10/2/2018 17:06'!new	^self basicNew initialize.! !Object subclass: #FormeClausale	instanceVariableNames: 'clauses'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!FormeClausale methodsFor: 'initialization' stamp: 'pm 10/3/2018 13:01'!add: clause	(clause isKindOf: Clause)	ifTrue: [ self clauses add: clause ]	ifFalse:[Transcript show: 'Tried to add a non clause object to a clausaleForm'].! !!FormeClausale methodsFor: 'initialization' stamp: 'pm 10/2/2018 19:52'!initialize: ClausifiedFormula	clauses:=LinkedList new.	self addAll: ClausifiedFormula.! !!FormeClausale methodsFor: 'initialization' stamp: 'pm 10/2/2018 21:34'!addAll: clausifiedProp		(clausifiedProp  isKindOf: Or) | (clausifiedProp isKindOf: Atome) "If i'm in a or, there's only or(s) under him."		ifTrue:[self clauses add: (Clause new:clausifiedProp)]		ifFalse:[			(clausifiedProp isKindOf: And)			ifTrue:[				self addAll: (clausifiedProp left).				self addAll: (clausifiedProp right).				]			ifFalse:[			Transcript show: 'Tried to add a non clause object to a clausaleForm'  ].		].! !!FormeClausale methodsFor: 'initialization' stamp: 'pm 10/2/2018 19:49'!initialize	clauses:=LinkedList new.	! !!FormeClausale methodsFor: 'initialization' stamp: 'pm 10/3/2018 15:38'!prettyPrint	|t|	t:='{'.		clauses do: [  :each | t:=t,(each prettyPrint),','. ].	t:=t,'}'.	^t.! !!FormeClausale methodsFor: 'accessing' stamp: 'pm 10/1/2018 20:17'!clauses	^clauses.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FormeClausale class	instanceVariableNames: ''!!FormeClausale class methodsFor: 'instance creation' stamp: 'pm 10/3/2018 12:49'!new: ClausaleProposition	^self basicNew initialize:ClausaleProposition.! !!FormeClausale class methodsFor: 'instance creation' stamp: 'pm 10/3/2018 12:50'!new	^self basicNew initialize.! !Object subclass: #Prop	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Prop methodsFor: 'testing' stamp: 'pm 9/30/2018 20:12'!clausificationUnitTest	|t|	Transcript show: self prettyPrint; show: '  ' ;show: self isClause; cr.	t:=self fullClausification.	Transcript show: t prettyPrint; show: '  ' ;show: t isClause; cr;cr.! !!Prop methodsFor: 'testing' stamp: 'pm 9/30/2018 19:07'!propUnitTest	Transcript show: self prettyPrint; show: '  ' ;show: self isClause; cr; cr.! !!Prop methodsFor: 'testing' stamp: 'pm 9/30/2018 12:34'!matchingUnitTest: prop	"self will be considered as a pattern"	Transcript cr;		show: 'prop : ' ; 		show: (prop prettyPrint);		cr;		show: 'pattern : ';		show: (self prettyPrint);		cr.		(self matchPatternWith: prop)			ifTrue:[ Transcript show: 'matched!!';cr.]			ifFalse:[ Transcript show: 'didn''t match!!';cr]	! !!Prop methodsFor: 'clausification' stamp: 'pm 9/29/2018 08:21'!isClause	^SubclassResponsibility ! !!Prop methodsFor: 'clausification' stamp: 'pm 9/30/2018 20:06'!clausification	"Only one iteration over the full formula."	"Basic empty comportement for atomes mostly. (only?)"! !!Prop methodsFor: 'clausification' stamp: 'pm 10/1/2018 10:58'!fullClausification	| t |	t:=self clausification.	[t isClause] whileFalse:[			(Prop debug) ifTrue:[Transcript show: t prettyPrint; show: t isClause;cr.].		t:=t clausification.].	^t! !!Prop methodsFor: 'matching' stamp: 'pm 9/30/2018 10:16'!compareSymbol: otherProp	^(self getSymb = otherProp getSymb) ! !!Prop methodsFor: 'matching' stamp: 'pm 9/30/2018 09:09'!matchPatternWith: prop	"Match self and prop. to end a branch of the pattern	use a random variable	var == whatever	anythingElse == anythingElse only :  !!n => T == !!(A /\ B)=> T for example	"	^SubclassResponsibility.! !!Prop methodsFor: 'printing' stamp: 'pm 9/28/2018 22:41'!prettyPrint	^SubclassResponsibility ! !!Prop methodsFor: 'accessing' stamp: 'pm 9/28/2018 22:42'!getSymb	^SubclassResponsibility. ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Prop class	instanceVariableNames: 'debug'!!Prop class methodsFor: 'initialization' stamp: 'pm 10/1/2018 10:56'!initialize	debug:=false.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/5/2018 16:54'!testingMatch	|pattern prop|   "Transcript clear."	Transcript show: 'Testing matching related stuff'.		pattern:= Imply new: (True_Const new) rightProp: (Predicate new: 'P' variable: 'a').	prop:= Imply new: (True_Const new) rightProp: (Not new:(Predicate new: 'P' variable: 'a')).	pattern matchingUnitTest: prop.		pattern:= Imply new: (True_Const new) rightProp: (False_Const  new).	prop:= Imply new: (True_Const new) rightProp: (Not new:(Predicate new: 'P' variable: 'a')).	pattern matchingUnitTest: prop.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/4/2018 23:43'!initEverything	"classic logic"	Prop initialize.	Atome initialize.	Constant initialize.	False_Const initialize.	True_Const initialize.	Var initialize.	NotVar initialize.	Operator initialize.	Binary initialize.	And initialize.	Equal initialize.	Imply initialize.	Or initialize.	Unary initialize.	Not initialize.		"Predicate"	Quantifier initialize.	Exists initialize.	ForAll initialize.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/5/2018 00:09'!testingClausification 	"everything is tested in those few lines"	"Binary"	| p |	"	Transcript clear."	Transcript show: 'Testing clausification related stuff';cr.		p:=And new: (Var new: 'a') rightProp: (False_Const new).	p clausificationUnitTest.	p:=Or new: (Var new: 'a') rightProp: (False_Const new).	p clausificationUnitTest.	p:=Equal new: (Var new: 'a') rightProp: (True_Const new).	p clausificationUnitTest.		p:=Imply new: (Var new: 'a') rightProp: (True_Const new).	p clausificationUnitTest.	"unary"	p:=Not new: (Var new: 'a').	p clausificationUnitTest.		Transcript show: 'Bit more complicated stuff!!';cr.		p:=Imply new: (Equal new: (Not new: (Var new: 'a')) rightProp: (Var new: 'b')) rightProp: (False_Const new).	p clausificationUnitTest.			Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/1/2018 10:58'!debug	^debug! !!Prop class methodsFor: 'testing' stamp: 'pm 10/5/2018 00:11'!testEverything	Transcript clear.	Prop initEverything.	Prop testingProp.	Prop testingMatch.	Prop testingClausification.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/5/2018 16:33'!testingPropClassic 	"everything is tested in those few lines"	"Binary"	| p l r|		"Transcript clear."	Transcript show: 'Testing prop related stuff';cr.		Transcript show: 'testing every constructor in a simple way, and if they are clauses:';cr.		p:=And new: (Var new: 'a') rightProp: (False_Const new).	p propUnitTest.	p:=Or new: (Var new: 'a') rightProp: (False_Const new).	p propUnitTest.	p:=Equal new: (Var new: 'a') rightProp: (True_Const new).	p propUnitTest.		p:=Imply new: (Var new: 'a') rightProp: (True_Const new).	p propUnitTest.	"unary"	p:=Not new: (Var new: 'a').	p propUnitTest.		Transcript show: 'Bit more complicated stuff!!';cr.		p:=Imply new: (Equal new: (Not new: (Var new: 'a')) rightProp: (Var new: 'b')) rightProp: (False_Const new).	p propUnitTest.		Transcript show: 'Testing Comparisons on Vars:'; cr.		l:=Var new: 'a'.	r:=Var new: 'b'.	Transcript show: 'is var a = b ? ';			show: (l isSameVar: r); cr.	r:=Var new: 'a'.	Transcript show: 'is var a = a ? ';		show: (l isSameVar: r); cr.		Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/5/2018 17:09'!testingProp 	"everything is tested in those few lines"	"Binary"	| p l r|		"Transcript clear."	Transcript show: 'Testing prop related stuff';cr.		Transcript show: 'testing every constructor in a simple way, and if they are clauses:';cr.		p:=Exists new: 'a' Property: (And new: (Predicate new: 'D' variable:  'a') rightProp: (False_Const new)).	p propUnitTest.	p:=Exists new: 'a' Property:(Or new: (Predicate new: 'C' variable:  'a') rightProp: (False_Const new)).	p propUnitTest.	p:=ForAll new: 'x' Property: (Equal new: (Predicate new: 'A' variable:  'a') rightProp: (True_Const new)).	p propUnitTest.		p:=ForAll new: 'x' Property: (Imply new: (Predicate new: 'B' variable:  'a') rightProp: (True_Const new)).	p propUnitTest.	"unary"	p:=Not new: (Predicate new: 'Q' variable:  'a').	p propUnitTest.		Transcript show: 'Bit more complicated stuff!!';cr.		p:=Imply new: (Equal new: (Not new: (Predicate new: 'P' variable:  'a')) rightProp: (Predicate new: 'P' variable: 'b')) rightProp: (False_Const new).	p propUnitTest.		Transcript show: 'Testing Comparisons on Vars:'; cr.		l:=Predicate new: 'P' variable:  'a'.	r:=Predicate new: 'P' variable:  'b'.	Transcript show: 'is P(a) = P(b) ? ';			show: (l isTheSame: r); cr.	r:=Predicate new: 'Q' variable:  'a'.	Transcript show: 'is var P(a) = Q(a) ? ';		show: (l isTheSame: r); cr.	r:=Predicate new: 'P' variable:  'a'.	Transcript show: 'is P(a) = P(a) ? ';		show: (l isTheSame: r); cr.		Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !Prop subclass: #Atome	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Atome methodsFor: 'printing' stamp: 'pm 9/28/2018 20:26'!prettyPrint	^self getSymb! !!Atome methodsFor: 'clausification' stamp: 'pm 9/29/2018 08:25'!isClause	^true! !Atome subclass: #Constant	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Constant methodsFor: 'printing' stamp: 'pm 9/28/2018 22:30'!getSymb	^(self class symb)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Constant class	instanceVariableNames: 'symb'!Constant subclass: #False_Const	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!False_Const methodsFor: 'matching' stamp: 'pm 9/30/2018 09:45'!matchPatternWith: prop	"see Prop comment for usage."	^prop isKindOf: False_Const! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!False_Const class	instanceVariableNames: ''!!False_Const class methodsFor: 'accessing' stamp: 'pm 9/28/2018 21:18'!symb	^symb! !!False_Const class methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!initialize	symb:='F'.! !Prop subclass: #Operator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Operator methodsFor: 'print' stamp: 'pm 9/28/2018 20:26'!getSymb	^(self class symb)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Operator class	instanceVariableNames: 'symb'!!Operator class methodsFor: 'accessing' stamp: 'pm 10/4/2018 23:44'!symb	^symb.! !Operator subclass: #Binary	instanceVariableNames: 'left right'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Binary methodsFor: 'clausification' stamp: 'pm 9/29/2018 08:39'!isClause	"false unless it's a or/and"	^false! !!Binary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:27'!right: replacement	right:=replacement.	^right! !!Binary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:27'!left: replacement	left:=replacement.	^left! !!Binary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:27'!right	^right! !!Binary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:26'!left	^left! !!Binary methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!initialize: leftProp rightProp: rp	left:=leftProp.	right:=rp.	! !!Binary methodsFor: 'matching' stamp: 'pm 9/30/2018 12:00'!matchPatternWith: prop	(self compareSymbol: prop)		ifTrue:[			^(left matchPatternWith: (prop left))			& (right matchPatternWith: (prop right))			]		ifFalse:[^false].! !!Binary methodsFor: 'printing' stamp: 'pm 9/30/2018 12:15'!prettyPrint	^((left isKindOf: Atome) ifTrue:[' '] ifFalse:[' (']) ,		left prettyPrint,		((left isKindOf: Atome) ifTrue:[' '] ifFalse:[') ']) ,		self getSymb,		((right isKindOf: Atome) ifTrue:[' '] ifFalse:[' (']) ,		right prettyPrint,		((right isKindOf: Atome) ifTrue:[' '] ifFalse:[') ']).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Binary class	instanceVariableNames: ''!!Binary class methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!new: leftProp rightProp: rp	^self basicNew initialize: leftProp rightProp: rp.! !Binary subclass: #And	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!And methodsFor: 'clausification' stamp: 'pm 9/29/2018 08:40'!isClause	^(left isClause & right isClause)! !!And methodsFor: 'clausification' stamp: 'pm 10/1/2018 11:09'!clausification	| t |	t:=nil. 	((And patternFalse) matchPatternWith: self)	ifTrue:[t:=right]	ifFalse:[		((And patternFalseSym) matchPatternWith: self)		ifTrue:[t:=left]		ifFalse:[			((And patternTrue) matchPatternWith: self)			ifTrue:[t:=left]			ifFalse:[				((And patternTrueSym) matchPatternWith: self)				ifTrue:[t:=right]				ifFalse:["					((And patternOr) matchPatternWith: self)					ifTrue:[t:=Or new: (And new: ((self left) left) rightProp: (self right)) 								  rightProp: (And new:((self left) right) rightProp: (self right))]					ifFalse:[						((And patternOrSym) matchPatternWith: self)						ifTrue:[t:=Or new:(And new: (self left) rightProp: ((self right) left)) 									  rightProp: (And new: (self left) rightProp: ((self right) right))].						]					"]				]			]		].		(t isNil) ifTrue:[ (Prop debug) ifTrue:[Transcript show:'in And';show: self prettyPrint;cr.].			self left:(left clausification).								self right:(right clausification).								^self]					 ifFalse:[(Prop debug) ifTrue:[Transcript show:'in And2';show: t prettyPrint;cr.].						^t "clausification"]. ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!And class	instanceVariableNames: 'patternOr patternOrSym patternTrue patternTrueSym patternFalse patternFalseSym'!!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternFalse	^patternFalse! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternTrueSym	^patternTrueSym! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternOrSym	^patternOrSym! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternTrue	^patternTrue! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternFalseSym	^patternFalseSym! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternOr	^patternOr! !!And class methodsFor: 'initialize' stamp: 'pm 10/3/2018 20:06'!initialize	symb:='/\'.	patternOr:=And new: (Or new: (Var new: 'a') rightProp: (Var new:('a')))  rightProp: (Var new: 'a').	patternOrSym:=And new: (Var new: 'a') rightProp: (Or new: (Var new: 'a') rightProp: (Var new:('a'))).	patternTrue:=And new: (Var new: 'a') rightProp: (True_Const new).	patternTrueSym:=And new: (True_Const new) rightProp:(Var new:'a').	patternFalse:=And new: (Var new: 'a') rightProp: (False_Const new).	patternFalseSym:=And new: (False_Const new) rightProp:(Var new:'a').! !Binary subclass: #Equal	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Equal methodsFor: 'clausification' stamp: 'pm 10/1/2018 11:09'!clausification	| t |	t:=Or new: (And new: (self left) rightProp: (self right))		 rightProp: (And new:(Not new: (self left)) rightProp:(Not new: (self right))).	(Prop debug) ifTrue:[Transcript show:'in equal';show: t prettyPrint;cr.].	^t "clausification".! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Equal class	instanceVariableNames: ''!!Equal class methodsFor: 'initialize' stamp: 'pm 9/30/2018 17:36'!initialize	symb:='<->'.! !Binary subclass: #Imply	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Imply methodsFor: 'clausification' stamp: 'pm 10/1/2018 11:09'!clausification	|t|	t:=Or new: (Not new:left)  rightProp: right.	(Prop debug) ifTrue:[Transcript show:'in Imply';show: t prettyPrint;cr.].	^t "clausification".! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Imply class	instanceVariableNames: ''!!Imply class methodsFor: 'initialize' stamp: 'pm 9/30/2018 17:35'!initialize	symb:='->'.! !Binary subclass: #Or	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Or methodsFor: 'clausification' stamp: 'pm 9/29/2018 08:41'!isClause	^(left isClause & right isClause)! !!Or methodsFor: 'clausification' stamp: 'pm 10/1/2018 11:09'!clausification	| t |	t:=nil. 	((Or patternFalse) matchPatternWith: self)	ifTrue:[t:=left]	ifFalse:[		((Or patternFalseSym) matchPatternWith: self)		ifTrue:[t:=right]		ifFalse:[			((Or patternTrue) matchPatternWith: self)			ifTrue:[t:=right]			ifFalse:[				((Or patternTrueSym) matchPatternWith: self)				ifTrue:[t:=left]				ifFalse:[					((Or patternAnd) matchPatternWith: self)					ifTrue:[t:=And new: (Or new: ((self left) left) rightProp: (self right)) 								  rightProp: (Or new:((self left) right) rightProp: (self right))]					ifFalse:[						((Or patternAndSym) matchPatternWith: self)						ifTrue:[t:=And new:(Or new: (self left) rightProp: ((self right) left)) 									  rightProp: (Or new: (self left) rightProp: ((self right) right))].						]					]				]			]		].		(t isNil) ifTrue:[(Prop debug) ifTrue:[Transcript show:'in Or';show: self prettyPrint;cr.].								self left:(left clausification).								self right:(right clausification).								^self]					 ifFalse:[(Prop debug) ifTrue:[Transcript show:'in Or2';show: t prettyPrint;cr.].						^t "clausification" ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Or class	instanceVariableNames: 'patternAnd patternAndSym patternTrue patternTrueSym patternFalse patternFalseSym'!!Or class methodsFor: 'initialize' stamp: 'pm 10/4/2018 08:07'!initialize	symb:='\/'. 	patternAnd:=Or new: (And new: (Var new: 'a') rightProp: (Var new:('a')))  rightProp: (Var new: 'a').	patternAndSym:=Or new: (Var new: 'a') rightProp: (And new: (Var new: 'a') rightProp: (Var new:('a'))).	patternTrue:=Or new: (Var new: 'a') rightProp: (True_Const new).	patternTrueSym:=Or new: (True_Const new) rightProp:(Var new:'a').	patternFalse:=Or new: (Var new: 'a') rightProp: (False_Const new).	patternFalseSym:=Or new: (False_Const new) rightProp:(Var new:'a').! !!Or class methodsFor: 'initialize' stamp: 'pm 9/30/2018 16:11'!patternAnd	^patternAnd! !!Or class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:13'!patternFalse	^patternFalse! !!Or class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:12'!patternTrueSym	^patternTrueSym! !!Or class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:12'!patternAndSym	^patternAndSym! !!Or class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:13'!patternFalseSym	^patternFalseSym! !!Or class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:12'!patternTrue	^patternTrue! !Atome subclass: #Predicate	instanceVariableNames: 'symb vars'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Predicate methodsFor: 'accessing' stamp: 'pm 10/5/2018 18:58'!vars	^vars! !!Predicate methodsFor: 'accessing' stamp: 'pm 10/5/2018 15:50'!getSymb	^symb.! !!Predicate methodsFor: 'printing' stamp: 'pm 10/5/2018 20:03'!prettyPrint 	|p|	p:=	(self getSymb) ,'('.	Transcript show:p.	vars do:[:each| p:=p,each,','.].	p:=p,')'.! !!Predicate methodsFor: 'initialization' stamp: 'pm 10/5/2018 20:01'!initialize: symbl Variables: aLinkedList	symb:=symbl.	vars:=aLinkedList.! !!Predicate methodsFor: 'initialization' stamp: 'pm 10/5/2018 19:42'!initialize: symbl Variable: aVar	symb:=symbl.	vars:=LinkedList new.	vars add:aVar.! !!Predicate methodsFor: 'matching' stamp: 'pm 10/5/2018 16:06'!matchPatternWith: prop	"see Prop comment for usage."	^true! !!Predicate methodsFor: 'testing' stamp: 'pm 10/5/2018 17:11'!isClause	^true.! !!Predicate methodsFor: 'testing' stamp: 'pm 10/5/2018 16:13'!isTheSame: predicate	^(self isSamePredicate:predicate) &	(self isSameVar:predicate).! !!Predicate methodsFor: 'testing' stamp: 'pm 10/5/2018 19:05'!isSameVar: predicate	"add comparaison of all things, in order"	^(self var)=(predicate var)! !!Predicate methodsFor: 'testing' stamp: 'pm 10/5/2018 16:47'!isSamePredicate: predicate	^(self getSymb)=(predicate getSymb)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Predicate class	instanceVariableNames: ''!!Predicate class methodsFor: 'instance creation' stamp: 'pm 10/5/2018 20:00'!new: symb variable: aVar	^self basicNew initialize: symb Variable:aVar.! !!Predicate class methodsFor: 'instance creation' stamp: 'pm 10/5/2018 20:00'!new: symb fromList: aList	^self basicNew initialize: symb Variables: aList.! !Constant subclass: #True_Const	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!True_Const methodsFor: 'matching' stamp: 'pm 9/30/2018 09:48'!matchPatternWith: prop	"see Prop comment for usage."	^prop isKindOf: True_Const! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!True_Const class	instanceVariableNames: ''!!True_Const class methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!initialize	symb:='T'.! !!True_Const class methodsFor: 'accessing' stamp: 'pm 9/28/2018 21:08'!symb	^symb! !Operator subclass: #Unary	instanceVariableNames: 'operand'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Unary methodsFor: 'Matching' stamp: 'pm 9/30/2018 10:39'!matchPatternWith: prop	(self compareSymbol: prop)		ifTrue:[^operand matchPatternWith: (prop operand)]		ifFalse:[^false].! !!Unary methodsFor: 'printing' stamp: 'pm 9/30/2018 19:21'!prettyPrint	^self getSymb,		((operand isKindOf: Atome) ifTrue:[' '] ifFalse:[' (']) ,		operand prettyPrint,		((operand isKindOf: Atome) ifTrue:[' '] ifFalse:[') ']).! !!Unary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:28'!operand	^operand! !!Unary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:28'!operand: replacement	operand:=replacement.	^operand! !!Unary methodsFor: 'Initialize' stamp: 'pm 9/28/2018 22:38'!initialize: prop	operand:=prop.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Unary class	instanceVariableNames: ''!!Unary class methodsFor: 'Initialize' stamp: 'pm 9/28/2018 22:31'!new: prop	^self basicNew initialize: prop.! !Unary subclass: #Not	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Not methodsFor: 'clausification' stamp: 'pm 9/30/2018 20:33'!isClause	" (!! a) is a clause, but !! (a \/ b) isn't"	^(operand isKindOf: Atome)! !!Not methodsFor: 'clausification' stamp: 'pm 10/1/2018 11:09'!clausification	"Only one clausification operation at time"	"/!!\ since we're in an unary operator, the pattern doesn't start at self, but at operand"	| t |	t:=nil.	((Not patternNot) matchPatternWith: operand)	ifTrue:[t:=operand operand.]	ifFalse:[			((Not patternTrue) matchPatternWith: operand)			ifTrue:[t:=False_Const new]			ifFalse:[				((Not patternFalse) matchPatternWith: operand)				ifTrue:[t:=True_Const new]				ifFalse:[					((Not patternOr) matchPatternWith: operand)					ifTrue:[t:=And new: (Not new:(operand left)) rightProp:(Not new:(operand right))]					ifFalse:[						((Not patternAnd) matchPatternWith: operand)						ifTrue:[t:=Or new: (Not new:(operand left)) rightProp:(Not new:(operand right))].						]					]				 ]			].		(t isNil) ifTrue:[(Prop debug) ifTrue:[Transcript show:'in Not';show: self prettyPrint;cr.].			 self operand:(operand clausification).								^self]					 ifFalse:[(Prop debug) ifTrue:[Transcript show:'in Not2';show: t prettyPrint;cr.].						^t "clausification" ].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Not class	instanceVariableNames: 'patternNot patternTrue patternFalse patternOr patternAnd'!!Not class methodsFor: 'Initialize' stamp: 'pm 9/30/2018 18:50'!initialize	symb:='!!'.	patternNot:=Not new:(Var new: 'a').	patternTrue:=True_Const new.	patternFalse:=False_Const new.	patternOr:=Or new:(Var new: 'a') rightProp: (Var new: 'a').	patternAnd:=And new:(Var new: 'a') rightProp: (Var new: 'a').! !!Not class methodsFor: 'accessing' stamp: 'pm 9/30/2018 14:14'!patternFalse	^patternFalse.! !!Not class methodsFor: 'accessing' stamp: 'pm 9/30/2018 14:15'!patternAnd	^patternAnd.! !!Not class methodsFor: 'accessing' stamp: 'pm 9/30/2018 14:15'!patternNot	^patternNot.! !!Not class methodsFor: 'accessing' stamp: 'pm 9/30/2018 14:15'!patternTrue	^patternTrue.! !!Not class methodsFor: 'accessing' stamp: 'pm 9/30/2018 14:14'!patternOr	^patternOr.! !Unary subclass: #Quantifier	instanceVariableNames: 'var'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Quantifier methodsFor: 'accessing' stamp: 'pm 10/4/2018 13:31'!var	^var.! !!Quantifier methodsFor: 'initialization' stamp: 'pm 10/4/2018 23:48'!initialize: arg Property: prop	super initialize: prop.	var:=arg.! !!Quantifier methodsFor: 'testing' stamp: 'pm 10/5/2018 17:21'!isClause	"very unsure here"	^false! !!Quantifier methodsFor: 'printing' stamp: 'pm 10/5/2018 15:34'!prettyPrint	^(self class symb),' ', (self var), '.(',	operand prettyPrint,	')'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Quantifier class	instanceVariableNames: ''!!Quantifier class methodsFor: 'initialization' stamp: 'pm 10/4/2018 23:48'!new:arg Property:prop	^self basicNew initialize:arg Property:prop.! !Quantifier subclass: #Exists	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Exists class	instanceVariableNames: ''!!Exists class methodsFor: 'initialization' stamp: 'pm 10/4/2018 13:36'!initialize	symb:='Exist'.! !Quantifier subclass: #ForAll	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ForAll class	instanceVariableNames: ''!!ForAll class methodsFor: 'initialization' stamp: 'pm 10/4/2018 23:52'!initialize	symb:='Forall'.! !Atome subclass: #Var	instanceVariableNames: 'symb'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Var methodsFor: 'matching' stamp: 'pm 9/30/2018 09:59'!matchPatternWith: prop	"see Prop comment for usage."	^true! !!Var methodsFor: 'comparison' stamp: 'pm 9/29/2018 09:19'!isSameVar: other	^self getSymb = other getSymb.! !!Var methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!initialize: varName	symb:=varName.! !!Var methodsFor: 'printing' stamp: 'pm 10/3/2018 13:11'!prettyPrint	^(self getSymb).! !!Var methodsFor: 'accessing' stamp: 'pm 9/28/2018 22:25'!getSymb	^symb! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Var class	instanceVariableNames: ''!!Var class methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!new: varName	^self basicNew initialize: varName.! !Var subclass: #NotVar	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!NotVar methodsFor: 'printing' stamp: 'pm 10/3/2018 15:23'!prettyPrint	^(Not symb),(self getSymb).! !Prop initialize!False_Const initialize!And initialize!Equal initialize!Imply initialize!Or initialize!True_Const initialize!Not initialize!Exists initialize!ForAll initialize!