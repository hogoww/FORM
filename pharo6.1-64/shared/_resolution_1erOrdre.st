Object subclass: #Prop	instanceVariableNames: ''	classVariableNames: 'clausificationTrace debugUnification resolutionTrace skolemnTrace testNumber unifDone'	poolDictionaries: ''	category: '_resolution_1erOrdre-Propositions'!!Prop commentStamp: 'pm 10/9/2018 10:52' prior: 0!Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.I allow a proposition to be clausified.I allow propositions of First order to be skolemnise, then clausifiedPublic API:- FullClausification -> return a Clausified version of  a Proposition- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)- PrettyPrint -> returns a string representing my  internal state.!!Prop methodsFor: 'comparing' stamp: 'pm 12/7/2018 13:04'!isSameForTesting:prop2	"comparaison operator for automated testing"	^SubclassResponsibility ! !!Prop methodsFor: 'accessing' stamp: 'pm 12/7/2018 13:26'!getSymb	"All the classes should have a symbol to represent them graphically"	^SubclassResponsibility. ! !!Prop methodsFor: 'testing' stamp: 'pm 10/26/2018 18:38'!factorisationUnitTest	|r fc|	Prop testInc.	self assert:[self isClause.].		Transcript show: 'test #'; show:(Prop testNumber);cr.	Transcript show: 'Trying to factorise ';show: self;cr.		fc:=ClausalForm new:self.	r:=Resolvante new.	r factorisation: (fc at:1).			Transcript show:r;cr;cr;cr.! !!Prop methodsFor: 'testing' stamp: 'pm 9/30/2018 12:34'!matchingUnitTest: prop	"self will be considered as a pattern"	Transcript cr;		show: 'prop : ' ; 		show: (prop prettyPrint);		cr;		show: 'pattern : ';		show: (self prettyPrint);		cr.		(self matchPatternWith: prop)			ifTrue:[ Transcript show: 'matched!!';cr.]			ifFalse:[ Transcript show: 'didn''t match!!';cr]	! !!Prop methodsFor: 'testing' stamp: 'pm 12/14/2018 13:22'!isPredicateOrFuncTerm	"Class tester"	"Necessary because we don't distinguish them in the unification process"	^false! !!Prop methodsFor: 'testing' stamp: 'pm 10/25/2018 08:37'!unificationUnitTest: otherPredicate	|t newPair|	Prop testInc.	Transcript show: 'test #'; show:(Prop testNumber);cr.	Transcript show: 'Trying to Unify ';show: self; show:' and ';show: otherPredicate;cr.	t:=Unifier new: self Predicate2: otherPredicate.	newPair:=t unifiedPair.	(t hasFailed)	ifFalse:[		Transcript show:newPair;cr;cr.	]	ifTrue:[		Transcript show: 'Unification failed.';cr;cr.		].	^t! !!Prop methodsFor: 'testing' stamp: 'pm 10/26/2018 22:12'!SkolemnisationTest	|t|	Prop testInc.		Transcript show: 'test #'; show:(Prop testNumber);cr.	Transcript show: 'initial: '; show: self prettyPrint; cr.	t:=self StartSkolemnisation.	Transcript show: 'Skolemn: ';show: t prettyPrint;cr.	t:=t fullClausification.	Transcript show: 'Clausified:';show: t prettyPrint ;cr.	t:=ClausalForm new:t.	Transcript show: 'ClausalForm:';show: t prettyPrint ;cr.	t:=t resolutionMethod.	Transcript show:'Resolution method:' ;show:t;cr;cr;cr.	^t ! !!Prop methodsFor: 'testing' stamp: 'pm 10/26/2018 18:35'!resolvanteUnitTest: anotherClause	"We expect self and anotherClause to be clauses, or at minimal a clausal form."	|r fc1 fc2|	self assert: [ self isClause ].	anotherClause assert:[ self isClause ].		Prop testInc.	Transcript show: 'test #'; show:(Prop testNumber);cr.	fc1:=ClausalForm new:self.	fc2:=ClausalForm new:anotherClause.	Transcript show: 'Trying to resolve ';show: fc1 ; show:' with ';show: fc2; cr.	r:=Resolvante new.		r resolvante: (fc1 at:1) with: (fc2 at:1).	Transcript show:r;cr;cr;cr.! !!Prop methodsFor: 'testing' stamp: 'pm 10/9/2018 13:33'!clausificationUnitTest	|t|	Transcript show: self prettyPrint; show: '  ' ;show: self isClause; cr.	t:=self fullClausification.	Transcript show: t prettyPrint; show: '  ' ;show: t isClause; cr;cr.	^t.! !!Prop methodsFor: 'testing' stamp: 'pm 10/9/2018 12:25'!propUnitTest	Transcript show: self prettyPrint; show: '  ' ;show: self isClause; cr; cr.	^self! !!Prop methodsFor: 'matching' stamp: 'pm 11/28/2018 01:09'!compareSymbol: otherProp	"comparaison operator for proposition, which all have symbols"	^(self getSymb = otherProp getSymb) ! !!Prop methodsFor: 'matching' stamp: 'pm 12/7/2018 13:05'!matchPatternWith: prop	"Match self and prop. to end a branch of the pattern	use a random variable	var == whatever	anythingElse == anythingElse only :  !!n => T == !!(A /\ B)=> T for example	"	^SubclassResponsibility.! !!Prop methodsFor: 'clausification' stamp: 'pm 12/7/2018 13:26'!isClause	^SubclassResponsibility ! !!Prop methodsFor: 'clausification' stamp: 'pm 12/12/2018 10:46'!constituteOfOr	"Part of the isClause method. Used to check if a prop's tree is constitute of Or's"	^self subclassResponsibility.! !!Prop methodsFor: 'clausification' stamp: 'pm 9/30/2018 20:06'!clausification	"Only one iteration over the full formula."	"Basic empty comportement for atomes mostly. (only?)"! !!Prop methodsFor: 'clausification' stamp: 'pm 12/12/2018 15:56'!fullClausification	| t |	t:=self clausification.	[t isClause] whileFalse:[			clausificationTrace ifTrue:[Transcript show: t prettyPrint; show: t isClause;cr.].		t:=t clausification.].	^t! !!Prop methodsFor: 'testing-properties' stamp: 'pm 11/27/2018 07:51'!isAtome	"Class tester"	^false.! !!Prop methodsFor: 'testing-properties' stamp: 'pm 11/27/2018 11:08'!isTrueConst	"Class tester"	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 11/27/2018 07:52'!isVar	"Class tester"	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 11/27/2018 07:52'!isQuantifier	"Class tester"	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 11/27/2018 07:51'!isExists	"Class tester"	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 11/27/2018 07:51'!isConstant	"Class tester"	^false.! !!Prop methodsFor: 'testing-properties' stamp: 'pm 11/27/2018 07:51'!isEqual	"Class tester"	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 11/27/2018 07:51'!isConst	"Class tester"	^false.! !!Prop methodsFor: 'testing-properties' stamp: 'pm 11/27/2018 07:51'!isNotPredicate	"Class tester"	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 11/27/2018 07:51'!isOperator	"Class tester"	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 11/27/2018 07:51'!isImply	"Class tester"	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 11/27/2018 07:51'!isNot	"Class tester"	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 11/27/2018 07:51'!isAnd	"Class tester"	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 11/27/2018 11:08'!isFalseConst	"Class tester"	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 11/27/2018 07:51'!isBinaryOperator	"Class tester"	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 11/27/2018 07:51'!isPredicate	"Class tester"	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 11/27/2018 07:51'!isNotVar	"Class tester"	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 11/27/2018 07:52'!isProp	"Class tester"	^true.! !!Prop methodsFor: 'testing-properties' stamp: 'pm 11/27/2018 07:51'!isOr	"Class tester"	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 11/27/2018 07:51'!isForAll	"Class tester"	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 11/27/2018 07:51'!isPositivePredicate	"Class tester"	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 11/27/2018 07:52'!isUnaryOperator	"Class tester"	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 11/27/2018 07:51'!isNegativePredicate	"Class tester"	^false! !!Prop methodsFor: 'resolution' stamp: 'pm 12/12/2018 16:09'!amIValid	|t treatedProp|	Prop testInc.		Transcript show:'Is ';show: self; show:' valid?';cr.		treatedProp:=Not new:self.		resolutionTrace ifTrue:[Transcript show: 'initial: '; show: treatedProp ; cr.].	t:=treatedProp StartSkolemnisation.	resolutionTrace ifTrue:[Transcript show: 'Skolemn: ';show: t ;cr.].	t:=t fullClausification.	resolutionTrace ifTrue:[Transcript show: 'Clausified:';show: t ;cr.].	t:=ClausalForm new:t.	resolutionTrace ifTrue:[Transcript show: 'ClausalForm:';show: t ;cr.].	t:=t resolutionMethod.	Transcript show:'Resolution method:' ; show:t ; cr; cr; cr.	^t ! !!Prop methodsFor: 'Skoleminsation' stamp: 'pm 11/27/2018 11:40'!HerbranSkolemDocu	^Error new:'documentation of Skolemnisation'.	"return the proposition skolemnised"		"Herbrandise: setOfLinkedVar CorrespondingValue: aMap"	"setOfLinkedVar is a set of linked var (incredible, i know)	It's used to know if a variable was linked in that branch, following the rules of Skolemn/Herbran		CorrespondingValue: aMap 	Map containing the correspondance between a variable, and the associated object term that we stored along the way. This will be used in Predicate::UpdateTerms.		The rules were taken from the course of David Delahaye, professor, science faculty, university of montpellier			(Not sure the credit is enought)	"! !!Prop methodsFor: 'Skoleminsation' stamp: 'pm 10/7/2018 19:40'!StartSkolemnisation	| set aMap |	set:=MinimalOrderedSet new.	aMap:=Dictionary new.	^self Skolemnise: set CorrespondingValue: aMap! !!Prop methodsFor: 'Skoleminsation' stamp: 'pm 12/7/2018 13:06'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	"cf Prop::HerbranSkolemDocu"	^SubclassResponsibility.! !!Prop methodsFor: 'Skoleminsation' stamp: 'pm 11/26/2018 20:10'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	"cf Prop::HerbranSkolemDocu"	^SubclassResponsibility.! !!Prop methodsFor: 'printing' stamp: 'pm 10/18/2018 15:46'!printOn: aStream	aStream nextPutAll: (self prettyPrint).! !!Prop methodsFor: 'printing' stamp: 'pm 12/7/2018 14:15'!prettyPrint	"return the internal representation of a Proposition"	^SubclassResponsibility ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Prop class	instanceVariableNames: ''!!Prop class methodsFor: 'initialization' stamp: 'pm 12/14/2018 18:13'!initialize	clausificationTrace:=false.	skolemnTrace:=false.	debugUnification:=false.	resolutionTrace:=true.	testNumber:=0.	! !!Prop class methodsFor: 'accessing' stamp: 'pm 10/11/2018 16:25'!testNumber	^testNumber! !!Prop class methodsFor: 'accessing' stamp: 'pm 12/13/2018 19:10'!debugUnification	^debugUnification! !!Prop class methodsFor: 'tests' stamp: 'pm 10/11/2018 16:25'!testInc	testNumber:=testNumber+1.! !!Prop class methodsFor: 'instance creation' stamp: 'pm 12/12/2018 10:49'!new	"abstract class, not meant to be instanciated"	^self error: 'Prop is abstract and shouldn''t be implemented'! !!Prop class methodsFor: 'testing' stamp: 'pm 10/26/2018 20:50'!testingResolvante 	"everything is tested in those few lines"	"Binary"	|l r|		Transcript show: 'Testing resolvante related stuff';cr.		Transcript show:'Basics';cr.	Transcript show:'Class exemple.';cr.	l:=Or new: (Predicate new: 'P' variable: (LinkedTerm new:(Term new:'x')))	 rightProp: (Predicate new: 'Q' variable: (LinkedTerm new:(Term new:'x'))).	r:=Or new: (Not new: (Predicate new: 'P' variable: (ConstTerm new:(Term new:'a'))))	 rightProp: (Not new: (Predicate new: 'Q' variable: (ConstTerm new:(Term new:'a')))).		l resolvanteUnitTest:r.	Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/27/2018 08:27'!testEverything	Transcript clear.	Prop initEverything.	"Prop testingProp."	"Prop testingMatch."	"Prop testingClausification."	Prop testingFactorisation.	Prop testingResolvante.	Prop testingUnification.	Prop testingSkolemn.	Prop testingResolutionMethod.! !!Prop class methodsFor: 'testing' stamp: 'pm 12/7/2018 13:48'!testingMatch	|pattern prop|   "Transcript clear."	Transcript show: 'Testing matching related stuff'.		pattern:= Imply new: (True_Const new) rightProp: (Predicate new: 'P' variable: (Term new:'a')).	prop:= Imply new: (True_Const new) rightProp: (Not new:(Predicate new: 'P' variable: (Term new:'a'))).	pattern matchingUnitTest: prop.		pattern:= Imply new: (True_Const new) rightProp: (False_Const  new).	prop:= Imply new: (True_Const new) rightProp: (Not new:(Predicate new: 'P' variable: (Term new: 'a'))).	pattern matchingUnitTest: prop.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/5/2018 00:09'!testingClausification 	"everything is tested in those few lines"	"Binary"	| p |	"	Transcript clear."	Transcript show: 'Testing clausification related stuff';cr.		p:=And new: (Var new: 'a') rightProp: (False_Const new).	p clausificationUnitTest.	p:=Or new: (Var new: 'a') rightProp: (False_Const new).	p clausificationUnitTest.	p:=Equal new: (Var new: 'a') rightProp: (True_Const new).	p clausificationUnitTest.		p:=Imply new: (Var new: 'a') rightProp: (True_Const new).	p clausificationUnitTest.	"unary"	p:=Not new: (Var new: 'a').	p clausificationUnitTest.		Transcript show: 'Bit more complicated stuff!!';cr.		p:=Imply new: (Equal new: (Not new: (Var new: 'a')) rightProp: (Var new: 'b')) rightProp: (False_Const new).	p clausificationUnitTest.			Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !!Prop class methodsFor: 'testing' stamp: 'pm 12/13/2018 20:59'!testingUnification 	"everything is tested in those few lines"	"Binary"	|t l r|		Prop initialize.	Transcript clear.		Transcript show: 'Testing Unification related stuff';cr.		Transcript show:'Basics';cr.		Transcript show:'decompositions';cr.	l:=Predicate new: 'P' variable: (ConstTerm new:(Term new:'a')).	r:=Predicate new: 'P' variable: (ConstTerm new:(Term new:'b')).	l unificationUnitTest:r.	Transcript show:'delete';cr.	l:=Predicate new: 'P' variable: (ConstTerm new:(Term new:'a')).	r:=Predicate new: 'P' variable: (ConstTerm new:(Term new:'a')).	l unificationUnitTest:r.		Transcript show:'conflict';cr.	l:=Predicate new: 'Q' variable: (ConstTerm new:(Term new:'a')).	r:=Predicate new: 'P' variable: (ConstTerm new:(Term new:'a')).	l unificationUnitTest:r.	Transcript show:'swap';cr.	l:=Predicate new: 'P' variable: (FuncTerm new: 'f' Variable: (ConstTerm new: (Term new: 'a'))).	r:=Predicate new: 'P' variable: (LinkedTerm new:(Term new:'x')).	l unificationUnitTest:r.	"G{f(x,g(x))=f(a,g(a))}"	Transcript show:'Exemple	david #2';cr.	t:=LinkedList new.	t add: (LinkedTerm new:(Term new:'x'));add:(FuncTerm new:'g' Variable: (LinkedTerm new:(Term new:'x'))).	l:=Predicate new: 'P' variable: (FuncTerm new: 'f' Variables:t).	t:=LinkedList new.	t add:(ConstTerm new:(Term new:'a')) ;add:(FuncTerm new:'g' Variable:(ConstTerm new:(Term new:'a'))).	r:=Predicate new: 'P' variable: (FuncTerm new: 'f' Variables:t).	l unificationUnitTest:r.		"G{f(x,g(a))=f(b,g(y))}"	Transcript show:'Exemple david #1';cr.	t:=LinkedList new.	t add: (LinkedTerm new:(Term new:'x'));add:(FuncTerm new:'g' Variable: (ConstTerm new:(Term new:'a'))).	l:=Predicate new: 'P' variable: (FuncTerm new: 'f' Variables:t).	t:=LinkedList new.	t add:(ConstTerm new:(Term new:'b')) ;add:(FuncTerm new:'g' Variable:(LinkedTerm new:(Term new:'y'))).	r:=Predicate new: 'P' variable: (FuncTerm new: 'f' Variables:t).	l unificationUnitTest:r.			"should replace x by y at the end of the unification"	Transcript show:'x alias y';cr.	t:=LinkedList new.	t add: (LinkedTerm new:(Term new:'y'));add:( LinkedTerm new:(Term new:'x'));add:(ConstTerm new:(Term new:'a')).	l:=Predicate new: 'P' variable: (FuncTerm new: 'f' Variables:t).	t:=LinkedList new.	t add: (LinkedTerm new:(Term new:'x'));add:(LinkedTerm new:(Term new:'y'));add:(LinkedTerm new:(Term new:'x')).	r:=Predicate new: 'P' variable: (FuncTerm new: 'f' Variables:t).	l unificationUnitTest:r.			Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/27/2018 09:13'!testingResolutionMethod 	"everything is tested in those few lines"	"Binary"	|p|		Transcript show: 'Testing Unification related stuff';cr.		Transcript show:'Course proposition';cr.		Transcript show:'#1';cr.	p:=Exists new: 'x' Property: (		Imply new:			(Predicate new: 'P' variable: (Term new:'x'))		rightProp:			(And new: (Predicate new: 'P' variable: (Term new:'a'))			rightProp:(Predicate new:'P' variable: (Term new:'b')))).	p amIValid.	Transcript show:'#2';cr.	p:=ForAll new: 'x' Property: (		Imply new:			(Predicate new: 'P' variable: (Term new:'x'))		rightProp:			(Exists new: 'y' Property: 			(And new: (Predicate new: 'P' variable: (Term new:'y'))			rightProp:(Predicate new:'P' variable: (Term new:'y'))))).	p amIValid.	Transcript show:'#3';cr.	p:=Imply new:			(Exists new: 'x' Property:				(Or new: (Predicate new: 'P' variable: (Term new:'x'))				rightProp: (Predicate new: 'Q' variable: (Term new:'x'))))		rightProp: 				(Or new:					(Exists new: 'x' Property:						 (Predicate new: 'P' variable: (Term new:'x')))				rightProp:					(Exists new: 'x' Property:						 (Predicate new: 'Q' variable: (Term new:'x')))).	p amIValid.	Transcript show:'#4';cr.	p:=Imply new:			(ForAll new: 'x' Property:				(And new: (Predicate new: 'P' variable: (Term new:'x'))				rightProp: (Predicate new: 'Q' variable: (Term new:'x'))))		rightProp: 			(ForAll new: 'x' Property:				(And new: (Predicate new: 'P' variable: (Term new:'x'))				rightProp: (Predicate new: 'Q' variable: (Term new:'x')))).	p amIValid.		Transcript show:'#5';cr.	p:=Imply new:			(ForAll new: 'x' Property:				(And new: (Predicate new: 'P' variable: (Term new:'x'))				rightProp: (Predicate new: 'Q' variable: (Term new:'x'))))		rightProp: 				(And new:					(ForAll new: 'x' Property:						 (Predicate new: 'P' variable: (Term new:'x')))				rightProp:					(ForAll new: 'x' Property:						 (Predicate new: 'Q' variable: (Term new:'x')))).	p amIValid.		Transcript show:'#6';cr.	p:=Imply new: 			(ForAll new: 'x' Property:				(Not new:					(Predicate new: 'P' variable:(Term new:'x'))))		rightProp: 			(Not new:				(Exists new: 'x' Property:					(Predicate new: 'P' variable:(Term new:'x')))).	p amIValid.		Transcript show:'#7';cr.	p:=Imply new:			(Not new: 				(ForAll new: 'x' Property:					(Predicate new: 'P' variable:(Term new:'x'))))		rightProp: 			(Exists new: 'x' Property:				(Not new:					(Predicate new: 'P' variable:(Term new:'x')))).	p amIValid.		Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/26/2018 22:43'!testingSkolemn 	"everything is tested in those few lines"	"Binary"	| p terms terms2 |		"Transcript clear."	Transcript show: 'Testing Skolemnisation related stuff';cr.		Transcript show: 'basic one #1'.	terms:=LinkedList new.	terms add:(Term new:'x');add:(Term new:'y');add:(Term new:'z').		p:=ForAll new: 'x' Property: (Exists new: 'y' Property: (ForAll new: 'z' Property: (Predicate new: 'P' fromList: terms ))).	p SkolemnisationTest.	Transcript show: 'basic one #2'.	terms:=LinkedList new.	terms add:(Term new:'x');add:(Term new:'z').		p:=Or new: (ForAll new: 'x' Property: (ForAll new: 'z' Property: (Predicate new: 'P' fromList: terms )))	 rightProp: (ForAll new: 'x' Property: (ForAll new: 'z' Property: (Predicate new: 'P' fromList: terms ))).	p SkolemnisationTest.	Transcript show: 'with imply and nested forall.'.	p:=Not new: 		(Imply new: 			(ForAll new: 'x' Property:				(Or new:  					(Predicate new: 'P' variable:(Term new:'x'))					 rightProp:					(Predicate new: 'Q' variable:(Term new:'x'))))			 rightProp:			(Or new: 				(Predicate new: 'P' variable:(Term new:'a'))				rightProp:(Predicate new: 'Q' variable:(Term new:'a')))).	p SkolemnisationTest.				Transcript show: 'same as previous one, but with x representing a variable in one, and a const in the other.'.	p:=Not new:		(Imply new: 			(ForAll new: 'x' Property:				(Or new:  					(Predicate new: 'P' variable:(Term new:'x'))					 rightProp:					(Predicate new: 'Q' variable:(Term new:'x'))))			 rightProp:			(Or new: 				(Predicate new: 'P' variable:(Term new:'x'))				rightProp:(Predicate new: 'Q' variable:(Term new:'x')))).	p SkolemnisationTest.				Transcript show: 'same as previous one, check Unbound Exists is replaced by consts'.	p:=Not new:		(Imply new: 			(Exists new: 'x' Property:				(Or new:  					(Predicate new: 'P' variable:(Term new:'x'))					 rightProp:					(Predicate new: 'Q' variable:(Term new:'x'))))			 rightProp:			(Or new: 				(Predicate new: 'P' variable:(Term new:'x'))				rightProp:(Predicate new: 'Q' variable:(Term new:'x')))).	p SkolemnisationTest.			Transcript show: 'Teacher''s stress test#1' .	p:=Not new:(        ForAll new: 'x' Property:         (Imply new: (ForAll new: 'y' Property: (Predicate new: 'P' variable: (Term new:'y')))         rightProp: (Predicate new:'Q' variable: (Term new:'x')))).        	p SkolemnisationTest.			Transcript show: 'Teacher''s stress test#2'	.	terms:=LinkedList new.    terms add:(Term new: 'x') ; add:(Term new:'z').    terms2:=LinkedList new.    terms2 add:(Term new:'y') ; add: (Term new:'t').    p:=Not new:            (ForAll new: 'x' Property:                (ForAll new: 'y' Property:                    (Exists new: 'z' Property:                         (ForAll new: 't' Property:                             (Imply new:                                 (Predicate new: 'P' fromList: terms)                             rightProp:                                 (Predicate new: 'Q' fromList: terms2)))))).	p SkolemnisationTest.				Transcript show: 'Test functionnal term in initial Predicate '.	terms:=LinkedList new.   terms add:(Term new: 'x') ; add:(FuncTerm new: 'f' Variable: (Term new:'z')).   p:=Not new:            (ForAll new: 'x' Property:                  (Predicate new: 'P' fromList: terms)).	p SkolemnisationTest .		Transcript show: 'Test functionnal term in initial Predicate  with needed inner replacement'.	terms:=LinkedList new.   terms add:(Term new: 'x') ; add:(FuncTerm new: 'f' Variable: (Term new:'y')).   p:=ForAll new: 'x' Property:					(Exists new: 'y' Property:                  (Predicate new: 'P' fromList: terms)).	p SkolemnisationTest.		Transcript show:'Class exemple.';cr.	p:=Imply new: (And new: (Predicate new: 'P' variable:(Term new: 'a'))							rightProp: (Predicate new:'Q' variable:(Term new:'b')))	 rightProp: (Predicate new: 'P' variable:(Term new: 'a')).	p SkolemnisationTest.	Transcript show: 'Done with the testing, did it work? :3' ; cr; cr. ! !!Prop class methodsFor: 'testing' stamp: 'pm 11/27/2018 11:45'!testingProp 	"everything is tested in those few lines"	"Binary"	| p l r|		"Transcript clear."	Transcript show: 'Testing prop related stuff';cr.		Transcript show: 'testing every constructor in a simple way, and if they are clauses:';cr.		p:=Exists new: 'a' Property: (And new: (Predicate new: 'D' variable: (Term new: 'a')) rightProp: (False_Const new)).	p propUnitTest.	p:=Exists new: 'a' Property:(Or new: (Predicate new: 'C' variable:  (Term new: 'a')) rightProp: (False_Const new)).	p propUnitTest.	p:=ForAll new: 'x' Property: (Equal new: (Predicate new: 'A' variable:  (Term new: 'a')) rightProp: (True_Const new)).	p propUnitTest.		p:=ForAll new: 'x' Property: (Imply new: (Predicate new: 'B' variable:  (Term new: 'a')) rightProp: (True_Const new)).	p propUnitTest.	"unary"	p:=Not new: (Predicate new: 'Q' variable: (Term new: 'a')).	p propUnitTest.		Transcript show: 'Bit more complicated stuff!!';cr.		p:=Imply new: (Equal new: (Not new: (Predicate new: 'P' variable:  (Term new: 'a'))) rightProp: (Predicate new: 'P' variable:(Term new: 'b'))) rightProp: (False_Const new).	p propUnitTest.		Transcript show: 'Testing Comparisons on Vars:'; cr.		l:=Predicate new: 'P' variable:  'a'.	r:=Predicate new: 'P' variable:  'b'.	Transcript show: 'is P(a) = P(b) ? ';			show: (l = r); cr.	r:=Predicate new: 'Q' variable:  'a'.	Transcript show: 'is var P(a) = Q(a) ? ';		show: (l = r); cr.	r:=Predicate new: 'P' variable:  'a'.	Transcript show: 'is P(a) = P(a) ? ';		show: (l = r); cr.		Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/8/2018 17:11'!initEverything	"classic logic"	Prop initialize.	Atome initialize.	Constant initialize.	False_Const initialize.	True_Const initialize.	Var initialize.	NotVar initialize.	Operator initialize.	Binary initialize.	And initialize.	Equal initialize.	Imply initialize.	Or initialize.	Unary initialize.	Not initialize.		"Predicate"	Quantifier initialize.	Exists initialize.	ForAll initialize.		"terms"	Term initialize.	ConstTerm initialize.	FuncTerm initialize.	LinkedTerm initialize.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/5/2018 16:33'!testingPropClassic 	"everything is tested in those few lines"	"Binary"	| p l r|		"Transcript clear."	Transcript show: 'Testing prop related stuff';cr.		Transcript show: 'testing every constructor in a simple way, and if they are clauses:';cr.		p:=And new: (Var new: 'a') rightProp: (False_Const new).	p propUnitTest.	p:=Or new: (Var new: 'a') rightProp: (False_Const new).	p propUnitTest.	p:=Equal new: (Var new: 'a') rightProp: (True_Const new).	p propUnitTest.		p:=Imply new: (Var new: 'a') rightProp: (True_Const new).	p propUnitTest.	"unary"	p:=Not new: (Var new: 'a').	p propUnitTest.		Transcript show: 'Bit more complicated stuff!!';cr.		p:=Imply new: (Equal new: (Not new: (Var new: 'a')) rightProp: (Var new: 'b')) rightProp: (False_Const new).	p propUnitTest.		Transcript show: 'Testing Comparisons on Vars:'; cr.		l:=Var new: 'a'.	r:=Var new: 'b'.	Transcript show: 'is var a = b ? ';			show: (l isSameVar: r); cr.	r:=Var new: 'a'.	Transcript show: 'is var a = a ? ';		show: (l isSameVar: r); cr.		Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/26/2018 16:37'!testingFactorisation 	"everything is tested in those few lines"	"Binary"	|c|		Transcript show: 'Testing factorisation related stuff';cr.		Transcript show:'Basics';cr.	Transcript show:'Unifiable positive const & linked predicate';cr.	c:=Or new: (Predicate new: 'P' variable: (ConstTerm new:(Term new:'a')))	 rightProp: (Predicate new: 'P' variable: (LinkedTerm new:(Term new:'x'))).	c factorisationUnitTest.	Transcript show:'Unifiable negative const & linked predicate';cr.	c:=Or new:(Not new: (Predicate new: 'P' variable: (ConstTerm new:(Term new:'a'))))	 rightProp:(Not new: (Predicate new: 'P' variable: (LinkedTerm new:(Term new:'x')))).	c factorisationUnitTest.	Transcript show:'same predicate, different polarity';cr.	c:=Or new: (Predicate new: 'P' variable: (ConstTerm new:(Term new:'a')))	 rightProp: 	(Not new:(Predicate new: 'P' variable: (LinkedTerm new:(Term new:'a')))).	c factorisationUnitTest.	Transcript show:'same predicate, different polarity';cr.	c:=Or new: (Predicate new: 'P' variable: (ConstTerm new:(Term new:'a')))	 rightProp: 	(Not new:(Predicate new: 'P' variable: (LinkedTerm new:(Term new:'a')))).	c factorisationUnitTest.	"add multiple possible resolutions clauses next"	Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !Prop subclass: #Atome	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Propositions'!!Atome commentStamp: 'pm 10/9/2018 11:03' prior: 0!I represent an Abstract atome in a Proposition.I factorise some proprieties.!!Atome methodsFor: 'testing' stamp: 'pm 11/27/2018 07:51'!isAtome	"Class tester"	^true! !!Atome methodsFor: 'clausification' stamp: 'pm 12/11/2018 20:53'!isClause	"An atome is a clause, whatever it is."	^true! !!Atome methodsFor: 'clausification' stamp: 'pm 12/12/2018 10:52'!constituteOfOr	"Used to check if there's only Or's in this prop tree, during the clausification process"	"In an atome, it's always true. They aren't considered during the clausification process"	^true! !!Atome methodsFor: 'comparing' stamp: 'pm 11/28/2018 01:04'!isSameForTesting:prop2	"comparaison operator for automated testing"	^self=prop2! !!Atome methodsFor: 'printing' stamp: 'pm 11/26/2018 21:24'!prettyPrint		"toString"	^self getSymb! !Atome subclass: #Constant	instanceVariableNames: ''	classVariableNames: 'symb'	poolDictionaries: ''	category: '_resolution_1erOrdre-Propositions'!!Constant commentStamp: 'pm 10/9/2018 11:07' prior: 0!True and False constants, to represent them in Propositions!!Constant methodsFor: 'comparing' stamp: 'pm 12/7/2018 20:17'!= anotherAtome	^self class = anotherAtome class.! !!Constant methodsFor: 'accessors' stamp: 'pm 11/27/2018 07:46'!getSymb	"accessor"	^(self class symb)! !!Constant methodsFor: 'Skoleminsation' stamp: 'pm 12/12/2018 16:33'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	"cf Prop::HerbranSkolemDocu"	skolemnTrace ifTrue:[Transcript show:'Herbran' ; space ; show:self class name ;space ; show:self ;cr].	^self.! !!Constant methodsFor: 'Skoleminsation' stamp: 'pm 12/12/2018 16:33'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	"cf Prop::HerbranSkolemDocu"	skolemnTrace ifTrue:[Transcript show:'Skolem' ; space ; show:self class name ;space ; show:self ;cr].	^self.! !!Constant methodsFor: 'testing' stamp: 'pm 11/27/2018 07:51'!isConstant	"Class tester"	^true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Constant class	instanceVariableNames: ''!!Constant class methodsFor: 'instance creation' stamp: 'pm 12/7/2018 17:19'!new	^self basicNew.! !!Constant class methodsFor: 'accessing' stamp: 'pm 11/28/2018 01:13'!symb	^symb! !Constant subclass: #False_Const	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Propositions'!!False_Const commentStamp: '<historical>' prior: 0!False const!!False_Const methodsFor: 'matching' stamp: 'pm 12/14/2018 09:22'!matchPatternWith: prop	"see Prop comment for usage."	^prop isFalseConst! !!False_Const methodsFor: 'testing' stamp: 'pm 11/27/2018 07:50'!isFalseConst	"Class tester"	^true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!False_Const class	instanceVariableNames: ''!!False_Const class methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!initialize	symb:='F'.! !Prop subclass: #Operator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Propositions'!!Operator commentStamp: 'pm 10/9/2018 10:48' prior: 0!I represent an operator whith an unknown number of argument.I only factorise a method for now, but I allow possible future evolutions.!!Operator methodsFor: 'comparing' stamp: 'pm 12/7/2018 18:16'!= anotherOperator	^self getSymb = anotherOperator getSymb! !!Operator methodsFor: 'clausification' stamp: 'pm 12/12/2018 10:52'!constituteOfOr	"Used to check if there's only Or's in this prop tree, during the clausification process"	"This is basically the same as isClause, except for the And class."	^self isClause! !!Operator methodsFor: 'print' stamp: 'pm 11/28/2018 00:08'!getSymb	"general accessor"	^(self class symb)! !!Operator methodsFor: 'testing' stamp: 'pm 11/27/2018 08:00'!isOperator	"Class tester"	^true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Operator class	instanceVariableNames: 'symb'!!Operator class methodsFor: 'accessing' stamp: 'pm 11/28/2018 01:10'!symb	"accessor"	^symb.! !Operator subclass: #Binary	instanceVariableNames: 'left right'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Propositions'!!Binary commentStamp: 'pm 10/9/2018 10:55' prior: 0!I represent a Abstract binary operatorI factorise some of the attributes part of future operators.Public API and Key Messages- left & right -> accessors.- new: rightProp: -> create a binary operatorexample of initialization.BinaryOpClass new: (aPropClass newOperator) 			    rightProp: (aPropClass newOperator).			!!Binary methodsFor: 'initialize' stamp: 'pm 11/28/2018 00:06'!initialize: leftProp rightProp: rightProp	"Standart initialization for Unary Operators"	"leftProp & rightProp should be subclass of the abstract class Prop"	left:=leftProp.	right:=rightProp.	! !!Binary methodsFor: 'testing' stamp: 'pm 11/27/2018 08:00'!isBinaryOperator  	"Class tester"	^true! !!Binary methodsFor: 'accessing' stamp: 'pm 11/27/2018 07:43'!right: replacement	"accessor"	right:=replacement.	^right! !!Binary methodsFor: 'accessing' stamp: 'pm 11/27/2018 07:44'!left: replacement	"accessor"	left:=replacement.	^left! !!Binary methodsFor: 'accessing' stamp: 'pm 11/27/2018 07:44'!left	"accessor"	^left! !!Binary methodsFor: 'accessing' stamp: 'pm 11/27/2018 07:44'!right	"accessor"	^right! !!Binary methodsFor: 'matching' stamp: 'pm 9/30/2018 12:00'!matchPatternWith: prop	(self compareSymbol: prop)		ifTrue:[			^(left matchPatternWith: (prop left))			& (right matchPatternWith: (prop right))			]		ifFalse:[^false].! !!Binary methodsFor: 'printing' stamp: 'pm 12/13/2018 18:30'!prettyPrint	"toString"	^((left isAtome) ifTrue:[' '] ifFalse:[' (']) ,		left prettyPrint,		((left isAtome) ifTrue:[' '] ifFalse:[') ']) ,		self getSymb,		((right isAtome) ifTrue:[' '] ifFalse:[' (']) ,		right prettyPrint,		((right isAtome) ifTrue:[' '] ifFalse:[') ']).! !!Binary methodsFor: 'comparing' stamp: 'pm 12/7/2018 17:59'!= anotherBinaryOperator	^ super = anotherBinaryOperator 		and:[self left = anotherBinaryOperator left			and:[self right = anotherBinaryOperator right]			]! !!Binary methodsFor: 'comparing' stamp: 'pm 11/27/2018 11:41'!isSameForTesting:prop2	"Comparaison operator for automated testing"	^(self class = prop2 class) and:[((self left) isSameForTesting: (prop2 left)) and:[(self right)isSameForTesting: (prop2 right).]].! !!Binary methodsFor: 'clausification' stamp: 'pm 9/29/2018 08:39'!isClause	"false unless it's a or/and"	^false! !!Binary methodsFor: 'Skoleminsation' stamp: 'pm 12/12/2018 17:03'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	"factorisation for Or and And binaryOperator"	"cf Prop::HerbranSkolemDocu"	skolemnTrace ifTrue:[Transcript show:'Herbran' ; space ; show:self ;cr].		^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) 			rightProp: (self right Herbrandise: setOfLinkedVar CorrespondingValue: aMap ).		"We pass veryDeepCopys to the leftProp, so each branch has it's own collections"! !!Binary methodsFor: 'Skoleminsation' stamp: 'pm 12/12/2018 17:03'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	"factorisation for Or and And binaryOperator"	"cf Prop::HerbranSkolemDocu"	skolemnTrace ifTrue:[Transcript show:'Skolem' ; space ; show:self ;cr].		^(self class) new: (self left Skolemnise: (setOfLinkedVar veryDeepCopy)  CorrespondingValue: (aMap veryDeepCopy)) 			rightProp: (self right Skolemnise: setOfLinkedVar CorrespondingValue: aMap).			"Works for Or & And."				"We pass veryDeepCopys to the leftProp, so each branch has it's own collections"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Binary class	instanceVariableNames: ''!!Binary class methodsFor: 'initialize' stamp: 'pm 11/28/2018 00:04'!new: leftProp rightProp: rightProp	"Standart new for Unary Operators"	"leftProp & rightProp should be subclass of the abstract class Prop"		^self basicNew initialize: leftProp rightProp: rightProp.! !Binary subclass: #And	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Propositions'!!And commentStamp: 'pm 10/9/2018 11:29' prior: 0!I represent an And proposition!!And methodsFor: 'clausification' stamp: 'pm 12/12/2018 10:41'!constituteOfOr	"Used to check if there's only Or's in this prop tree, during the clausification process"	"Since we're in an And, we're not in a or, so, false !!"	^false! !!And methodsFor: 'clausification' stamp: 'pm 12/12/2018 10:53'!isClause	"a And is a clause only if the rest is constitute of Ors !!"	^((left isAnd ifTrue:[left isClause]ifFalse:[left constituteOfOr])		and:[(right isAnd ifTrue:[right isClause]ifFalse:[right constituteOfOr])])! !!And methodsFor: 'clausification' stamp: 'pm 12/12/2018 14:05'!clausification	"does an iteration of clausification the current proposition"		"For this one, we have some different possible pattern."		| t |	t:=nil. 	((And patternFalse) matchPatternWith: self)	ifTrue:[t:=right]	ifFalse:[		((And patternFalseSym) matchPatternWith: self)		ifTrue:[t:=left]		ifFalse:[			((And patternTrue) matchPatternWith: self)			ifTrue:[t:=left]			ifFalse:[				((And patternTrueSym) matchPatternWith: self)				ifTrue:[t:=right]				ifFalse:[]				]			]		].		(t isNil) ifTrue:[ clausificationTrace ifTrue:[Transcript show:'in And';show: self prettyPrint;cr.].			self left:(left clausification).								self right:(right clausification).								^self]					 ifFalse:[clausificationTrace  ifTrue:[Transcript show:'in And2';show: t prettyPrint;cr.].						^t]. ! !!And methodsFor: 'testing' stamp: 'pm 11/27/2018 08:00'!isAnd	"Class tester"	^true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!And class	instanceVariableNames: 'patternTrue patternTrueSym patternFalse patternFalseSym'!!And class methodsFor: 'initialize' stamp: 'pm 12/7/2018 21:12'!initialize	"Choosing the graphical symbol"	symb:='/\'.			"patterns used for clausification.	Since we're in a binary operator, we have represent it, to fit in one variable."	patternTrue:=And new: (Var new: 'a') rightProp: (True_Const new).	patternTrueSym:=And new: (True_Const new) rightProp:(Var new:'a').	patternFalse:=And new: (Var new: 'a') rightProp: (False_Const new).	patternFalseSym:=And new: (False_Const new) rightProp:(Var new:'a').! !!And class methodsFor: 'accessing' stamp: 'pm 11/27/2018 18:03'!patternFalse		"accessor"	^patternFalse! !!And class methodsFor: 'accessing' stamp: 'pm 11/27/2018 18:03'!patternTrueSym		"accessor"	^patternTrueSym! !!And class methodsFor: 'accessing' stamp: 'pm 11/27/2018 18:03'!patternFalseSym		"accessor"	^patternFalseSym! !!And class methodsFor: 'accessing' stamp: 'pm 11/27/2018 18:03'!patternTrue		"accessor"	^patternTrue! !Binary subclass: #Equal	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Propositions'!!Equal commentStamp: 'pm 10/9/2018 11:29' prior: 0!I represent an Equal proposition!!Equal methodsFor: 'clausification' stamp: 'pm 12/12/2018 14:08'!clausification	"does an iteration of clausification the current proposition"	| t |	t:=And new: (Or new: (self left) rightProp: (self right))		 rightProp: (Or new:(Not new: (self left)) rightProp:(Not new: (self right))).	clausificationTrace ifTrue:[Transcript show:'in equal';show: t prettyPrint;cr.].	^t.! !!Equal methodsFor: 'testing' stamp: 'pm 11/27/2018 08:00'!isEqual	"Class tester"	^true! !!Equal methodsFor: 'Skoleminsation' stamp: 'pm 12/12/2018 16:28'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	"cf Prop::HerbranSkolemDocu"		skolemnTrace ifTrue:[Transcript show:'Herbran' ; space ; show:self ;cr].		^(And new: (Imply new: (self left) rightProp: (self right))	 rightProp: (Imply new: (self right) rightProp: (self left))) Herbrandise: setOfLinkedVar CorrespondingValue:aMap.! !!Equal methodsFor: 'Skoleminsation' stamp: 'pm 12/12/2018 16:28'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	"cf Prop::HerbranSkolemDocu"	skolemnTrace ifTrue:[Transcript show:'Skolem' ; space ; show:self ;cr].		^(And new: (Imply new: (self left) rightProp: (self right))	 rightProp: (Imply new: (self right) rightProp: (self left))) Skolemnise:setOfLinkedVar CorrespondingValue:aMap.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Equal class	instanceVariableNames: ''!!Equal class methodsFor: 'initialize' stamp: 'pm 11/27/2018 12:25'!initialize	"Choosing the graphical symbol"	symb:='<->'.! !Binary subclass: #Imply	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Propositions'!!Imply commentStamp: 'pm 10/9/2018 11:29' prior: 0!I represent an Imply  proposition!!Imply methodsFor: 'Skoleminsation' stamp: 'pm 12/12/2018 16:29'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	"cf Prop::HerbranSkolemDocu"	skolemnTrace ifTrue:[Transcript show:'Herbran' ; space ; show:self ;cr].		^(self class) new: (self left Skolemnise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) 			rightProp: (self right Herbrandise: setOfLinkedVar CorrespondingValue: aMap).				"We pass veryDeepCopys to the leftProp, so each branch has it's own collections"! !!Imply methodsFor: 'Skoleminsation' stamp: 'pm 12/12/2018 16:28'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	"cf Prop::HerbranSkolemDocu"	skolemnTrace ifTrue:[Transcript show:'Skolem' ; space ; show:self ;cr].		^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) 			rightProp: (self right Skolemnise: setOfLinkedVar CorrespondingValue: aMap).	"We pass veryDeepCopys to the leftProp, so each branch has it's own collections"! !!Imply methodsFor: 'clausification' stamp: 'pm 12/12/2018 14:08'!clausification	"does an iteration of clausification the current proposition"	|t|	t:=Or new: (Not new:left)  rightProp: right.	clausificationTrace ifTrue:[Transcript show:'in Imply';show: t prettyPrint;cr.].	^t.! !!Imply methodsFor: 'testing' stamp: 'pm 11/27/2018 08:00'!isImply	"Class tester"	^true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Imply class	instanceVariableNames: ''!!Imply class methodsFor: 'initialize' stamp: 'pm 11/27/2018 12:25'!initialize	"Choosing the graphical symbol"	symb:='->'.! !Binary subclass: #Or	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Propositions'!!Or commentStamp: 'pm 10/9/2018 11:29' prior: 0!I represent an Or proposition!!Or methodsFor: 'testing' stamp: 'pm 11/27/2018 07:59'!isOr	"Class tester"	^true! !!Or methodsFor: 'clausification' stamp: 'pm 12/12/2018 10:53'!isClause	"tester"	^(left constituteOfOr & right constituteOfOr)! !!Or methodsFor: 'clausification' stamp: 'pm 12/12/2018 14:14'!clausification	"does an iteration of clausification the current proposition"		"For this one, we have some different possible pattern."	| t |	t:=nil. 	((Or patternFalse) matchPatternWith: self)	ifTrue:[t:=left]	ifFalse:[		((Or patternFalseSym) matchPatternWith: self)		ifTrue:[t:=right]		ifFalse:[			((Or patternTrue) matchPatternWith: self)			ifTrue:[t:=right]			ifFalse:[				((Or patternTrueSym) matchPatternWith: self)				ifTrue:[t:=left]				ifFalse:[					((Or patternAnd) matchPatternWith: self)					ifTrue:[t:=And new: (Or new: ((self left) left) rightProp: (self right)) 								  rightProp: (Or new:((self left) right) rightProp: (self right))]					ifFalse:[						((Or patternAndSym) matchPatternWith: self)						ifTrue:[t:=And new:(Or new: (self left) rightProp: ((self right) left)) 									  rightProp: (Or new: (self left) rightProp: ((self right) right))].						]					]				]			]		].		(t isNil) ifTrue:[clausificationTrace ifTrue:[Transcript show:'in Or';show: self prettyPrint;cr.].								self left:(left clausification).								self right:(right clausification).								^self]					 ifFalse:[clausificationTrace ifTrue:[Transcript show:'in Or2';show: t prettyPrint;cr.].						^t "clausification" ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Or class	instanceVariableNames: 'patternAnd patternAndSym patternTrue patternTrueSym patternFalse patternFalseSym'!!Or class methodsFor: 'accessing' stamp: 'pm 11/27/2018 18:03'!patternFalse		"accessor"	^patternFalse! !!Or class methodsFor: 'accessing' stamp: 'pm 11/27/2018 18:03'!patternTrueSym	"accessor"	^patternTrueSym! !!Or class methodsFor: 'accessing' stamp: 'pm 11/27/2018 18:03'!patternAndSym		"accessor"	^patternAndSym! !!Or class methodsFor: 'accessing' stamp: 'pm 11/27/2018 18:03'!patternFalseSym		"accessor"	^patternFalseSym! !!Or class methodsFor: 'accessing' stamp: 'pm 11/27/2018 18:03'!patternTrue		"accessor"	^patternTrue! !!Or class methodsFor: 'initialize' stamp: 'pm 11/27/2018 12:24'!initialize	"Choosing the graphical symbol"	symb:='\/'. 		"patterns used for clausification.	Since we're in a binary operator, we have represent it, to fit in one variable."	patternAnd:=Or new: (And new: (Var new: 'a') rightProp: (Var new:('a')))  rightProp: (Var new: 'a').	patternAndSym:=Or new: (Var new: 'a') rightProp: (And new: (Var new: 'a') rightProp: (Var new:('a'))).	patternTrue:=Or new: (Var new: 'a') rightProp: (True_Const new).	patternTrueSym:=Or new: (True_Const new) rightProp:(Var new:'a').	patternFalse:=Or new: (Var new: 'a') rightProp: (False_Const new).	patternFalseSym:=Or new: (False_Const new) rightProp:(Var new:'a').! !!Or class methodsFor: 'initialize' stamp: 'pm 11/27/2018 18:03'!patternAnd		"accessor"	^patternAnd! !Atome subclass: #Predicate	instanceVariableNames: 'symb terms'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Propositions'!!Predicate commentStamp: 'pm 11/28/2018 00:25' prior: 0!I represent a Predicate with a list of terms,Also in ClausaleForm we'll be representing a Positive predicate.Can be created two ways :-new: PredicateName-new: PredicateName Variable:aTerm-new: PredicateName Variables: aListOfTermIf it's a pre skolemnisation you should give a Term, Otherwise you should give a specialisation of abstract term(functerm/constterm/linkedterm) depending on what you need (of course)!!Predicate methodsFor: 'matching' stamp: 'pm 10/7/2018 17:13'!matchPatternWith: prop	"see Prop's comment for usage."	^true! !!Predicate methodsFor: 'comparing' stamp: 'pm 11/27/2018 11:42'!isSameSymb:AnotherPredicate	"Part of comparaison operator for automated testing"	^(self getSymb)=(AnotherPredicate getSymb).! !!Predicate methodsFor: 'comparing' stamp: 'pm 11/27/2018 11:42'!isSamePolarity: anotherPredicate	"Part of comparaison operator for automated testing"	^((anotherPredicate isPredicate) and:[self class = anotherPredicate class])."checking the input"! !!Predicate methodsFor: 'comparing' stamp: 'pm 11/28/2018 00:30'!isOpposite: anotherPredicate	"Check if this predicate is the equal to anotherPredicate, but is the opposite polarity"	| res |	res:=self isOppositePolarity: anotherPredicate."checking if they are opposite polarity"	res:=res and:[(self isSameSymb: anotherPredicate)]."comparing the function symbol"	res:=res and:[self isSameArity: anotherPredicate]."comparing arity"	res:=res and:[(self isSameTerms: anotherPredicate).]."we let the superclass LinkedList check for the correct terms"	^res.! !!Predicate methodsFor: 'comparing' stamp: 'pm 11/28/2018 00:32'!isOppositePolarity: anotherPredicate	"check if it's the opposite polarity"	^ anotherPredicate isPredicate	and: [ anotherPredicate class ~= self class ]! !!Predicate methodsFor: 'comparing' stamp: 'pm 11/28/2018 00:33'!isSameForTesting: anotherPredicate	"Comparaison Operator, without carring for anonymous const/functerm."	| res |	self assert:(anotherPredicate class=self class)."checking the input"	res:=self isSameSymb: anotherPredicate."comparing the function symbol"	res:=res and:[self isSameArity: anotherPredicate]."comparing arity"	res:=res and:[(self isSameTermsForTesting: anotherPredicate).].	^res.! !!Predicate methodsFor: 'comparing' stamp: 'pm 12/7/2018 18:27'!=anotherPredicate	| res |	"comparaison operator"		res:=anotherPredicate isKindOf: self class."checking the input"	res:=res and:[self isSameSymb: anotherPredicate]."comparing the function symbol"	res:=res and:[self isSameArity: anotherPredicate]."comparing arity"	res:=res and:[self isSameTerms: anotherPredicate]."we let the superclass LinkedList check for the correct terms"	^res.! !!Predicate methodsFor: 'comparing' stamp: 'pm 11/27/2018 11:42'!isSameTerms: anotherPredicate	"Part of comparaison operator for automated testing"	^(self terms) = (anotherPredicate terms).! !!Predicate methodsFor: 'comparing' stamp: 'pm 11/27/2018 11:42'!isSameTermsForTesting: anotherPredicate	"Part of comparaison operator for automated testing"	| selfTerms anotherPredicateTerms |	selfTerms:=self terms.	anotherPredicateTerms:=anotherPredicate terms.	1 to: (terms size) do:[:i|		((selfTerms at:i) isSameForTesting: (anotherPredicateTerms at:i))		ifFalse:[			^false			]		].	^true! !!Predicate methodsFor: 'adding' stamp: 'pm 11/28/2018 00:45'!replace:x by:t	| i |	i:=1.	[i<=(self arity)]	whileTrue:[		((terms at:i) isKindOf: FuncTerm)		ifTrue: [			(terms at:i) replace:x by:t.			]		ifFalse:[			((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."			ifTrue:[				terms at:i put:t.				].			].			i:=i+1.		].	^self! !!Predicate methodsFor: 'initialization' stamp: 'pm 11/28/2018 01:11'!initialize: symbl Variables: aLinkedListOfTerm	"Standart initialization for variadic predicate"	"symbl is the name of the predicate, as a string"	"aLinkedListOfTerm has to be a LinkedList of kind of Abstract term, depending on when you want to use it for"	"if it's pre skolemnisation, you should give Terms, otherwise a specialisation of a Abstract Terms	(functerm/constterm/linkedterm)"		symb:=symbl.	aLinkedListOfTerm do:[:each| 		(each isKindOf: AbstractTerm)		ifFalse:[Error new:'Predicates needs terms as arguments.'].		].	terms:=aLinkedListOfTerm.! !!Predicate methodsFor: 'initialization' stamp: 'pm 11/28/2018 00:19'!initialize: symbl Variable: aTerm	"Standart initialization for unary predicate"	"symbl is the name of the predicate, as a string"	"aTerm has to be a kind of Abstract term, depending on when you want to use it for"	"if it's pre skolemnisation, you should give a Term, otherwise a specialisation of a Abstract Term	(functerm/constterm/linkedterm)"	(aTerm isKindOf: AbstractTerm)	ifFalse:[Error new:'Predicates needs terms as arguments.'].	symb:=symbl.	terms:=LinkedListFix new.	terms add:aTerm.! !!Predicate methodsFor: 'initialization' stamp: 'pm 11/28/2018 00:13'!initialize: symbl	"Standart initialization for empty predicate"	"symbl is the name of the predicate, as a string"	symb:=symbl.	terms:=LinkedListFix new.! !!Predicate methodsFor: 'Skoleminsation' stamp: 'pm 12/12/2018 16:32'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	"cf Prop::HerbranSkolemDocu"	skolemnTrace ifTrue:[Transcript show:'Herbran'  ;space ; show:self ;cr].		^self updateTerms: setOfLinkedVar CorrespondingValue: aMap.! !!Predicate methodsFor: 'Skoleminsation' stamp: 'pm 12/12/2018 16:32'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	"cf Prop::HerbranSkolemDocu"	skolemnTrace ifTrue:[Transcript show:'Skolem' ;space ; show:self ;cr].		^self updateTerms: setOfLinkedVar CorrespondingValue: aMap.! !!Predicate methodsFor: 'Skoleminsation' stamp: 'pm 11/27/2018 21:22'!updateTerms: setOfLinkedVar CorrespondingValue: aMap	| res |	res := LinkedList new.	terms do:[ :term | res add: (term WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].	^Predicate new: (self getSymb) fromList:res.! !!Predicate methodsFor: 'printing' stamp: 'pm 11/26/2018 21:24'!prettyPrint	"toString"	|t|	t:=(self getSymb),'('.	terms do:[:each| t:=t,each prettyPrint. ] separatedBy:[t:=t,','].	t:=t,')'.	^t.! !!Predicate methodsFor: 'testing' stamp: 'pm 10/7/2018 17:13'!isSameVar: predicate	"= defined on SequenceableCollection, LinkedList's superclass."	^(self terms)=(predicate terms).! !!Predicate methodsFor: 'testing' stamp: 'pm 11/28/2018 00:11'!contains: aTerm	"check if that predicate contains aTerm"	^ terms anySatisfy: [ :each | each contains: aTerm ]! !!Predicate methodsFor: 'testing' stamp: 'pm 12/14/2018 13:21'!isPredicateOrFuncTerm	"Class tester"	"Necessary because we don't distinguish them in the unification process"	^true! !!Predicate methodsFor: 'testing' stamp: 'pm 11/27/2018 07:50'!isPositivePredicate	"Class tester"	^true! !!Predicate methodsFor: 'testing' stamp: 'pm 11/28/2018 00:32'!isSameArity:anotherPredicate	"check if the two predicate have the same arity"	^(self arity)=(anotherPredicate arity).! !!Predicate methodsFor: 'testing' stamp: 'pm 11/27/2018 07:50'!isPredicate	"Class tester"	^true! !!Predicate methodsFor: 'testing' stamp: 'pm 12/13/2018 18:27'!isConst	"check if every term in the list of terms is const"	^ terms allSatisfy: [ :each | each isConst ]! !!Predicate methodsFor: 'accessing' stamp: 'pm 11/27/2018 07:46'!at: index 	"accessor for underlying attribute"	^ (self terms) at:index.! !!Predicate methodsFor: 'accessing' stamp: 'pm 11/28/2018 00:09'!arity	"arity of underlying attribute"	^terms size.! !!Predicate methodsFor: 'accessing' stamp: 'pm 11/27/2018 07:45'!terms	"accessor"	^terms.! !!Predicate methodsFor: 'accessing' stamp: 'pm 11/27/2018 07:46'!getSymb	"accessor"	^symb.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Predicate class	instanceVariableNames: ''!!Predicate class methodsFor: 'instance creation' stamp: 'pm 11/28/2018 01:11'!new: symb fromList: aList	"Standart new for unary predicate"	"symbl is the name of the predicate, as a string"	"aTerm has to be a kind of Abstract term, depending on when you want to use it for"	"if it's pre skolemnisation, you should give a Term, otherwise a specialisation of a Abstract Term	(functerm/constterm/linkedterm)"	^self basicNew initialize: symb Variables: aList.! !!Predicate class methodsFor: 'instance creation' stamp: 'pm 12/7/2018 10:42'!new: symb variable: aVar	"Standart new for variadic predicate"	"symbl is the name of the predicate, as a string"	"aLinkedListOfTerm has to be a LinkedList of kind of Abstract term, depending on when you want to use it for"	"if it's pre skolemnisation, you should give Terms, otherwise a specialisation of a Abstract Terms	(functerm/constterm/linkedterm)"		^self basicNew initialize: symb Variable:aVar.! !!Predicate class methodsFor: 'instance creation' stamp: 'pm 11/28/2018 01:10'!new: symb	"Standart new for empty predicate"	"symbl is the name of the predicate, as a string"	^self basicNew initialize: symb.! !Predicate subclass: #NotPredicate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Propositions'!!NotPredicate commentStamp: 'pm 10/9/2018 11:24' prior: 0!I represent a negative Predicate, only in ClausalForm!!NotPredicate methodsFor: 'printing' stamp: 'pm 11/26/2018 21:24'!prettyPrint 	"toString"	^(Not symb),(super prettyPrint)! !!NotPredicate methodsFor: 'testing' stamp: 'pm 11/27/2018 08:01'!isPositivePredicate	"Class tester"	^false! !!NotPredicate methodsFor: 'testing' stamp: 'pm 11/27/2018 08:00'!isNotPredicate	"Class tester"	^true! !!NotPredicate methodsFor: 'testing' stamp: 'pm 11/27/2018 08:01'!isNegativePredicate	"Class tester"	^true! !Constant subclass: #True_Const	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Propositions'!!True_Const commentStamp: '<historical>' prior: 0!True Const!!True_Const methodsFor: 'testing' stamp: 'pm 11/27/2018 07:50'!isTrueConst	"Class tester"	^true! !!True_Const methodsFor: 'matching' stamp: 'pm 12/14/2018 09:22'!matchPatternWith: prop	"see Prop comment for usage."	^prop isTrueConst! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!True_Const class	instanceVariableNames: ''!!True_Const class methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!initialize	symb:='T'.! !Operator subclass: #Unary	instanceVariableNames: 'operand'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Propositions'!!Unary commentStamp: 'pm 11/26/2018 20:01' prior: 0!I represent a Abstract unary operatorI factorise some of the attributes part of future operators.Public API and Key Messages- operand -> accessor.- new: -> create a unary operatorexample of initialization.UnaryOpClass new: (aPropClass newOperator) .!!Unary methodsFor: 'comparing' stamp: 'pm 12/7/2018 18:00'!= anotherUnaryOperator	^ super = anotherUnaryOperator 		and:[self operand = anotherUnaryOperator operand]! !!Unary methodsFor: 'comparing' stamp: 'pm 11/27/2018 11:41'!isSameForTesting:prop2	"Comparaison operator for automated testing"	^self class = prop2 class and:[(self operand) isSameForTesting: (prop2 operand)].! !!Unary methodsFor: 'Matching' stamp: 'pm 11/27/2018 11:21'!matchPatternWith: prop	(self compareSymbol: prop)	ifTrue:[^operand matchPatternWith: (prop operand)]	ifFalse:[^false].! !!Unary methodsFor: 'accessing' stamp: 'pm 11/27/2018 07:43'!operand	"accessor"	^operand! !!Unary methodsFor: 'accessing' stamp: 'pm 11/27/2018 07:43'!operand: replacement	"accessor"	operand:=replacement.	^operand! !!Unary methodsFor: 'Initialize' stamp: 'pm 11/27/2018 11:15'!initialize: aProp		"Standart initialization for Unary Operators"	"aProp should be subclass of the abstract class Prop"	operand:=aProp.! !!Unary methodsFor: 'printing' stamp: 'pm 11/26/2018 21:24'!prettyPrint	"toString"	^self getSymb,		((operand isKindOf: Atome) ifTrue:[' '] ifFalse:[' (']),		operand prettyPrint,		((operand isKindOf: Atome) ifTrue:[' '] ifFalse:[') ']).! !!Unary methodsFor: 'testing' stamp: 'pm 11/27/2018 07:59'!isUnaryOperator 	"Class tester"	^true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Unary class	instanceVariableNames: ''!!Unary class methodsFor: 'Initialize' stamp: 'pm 11/27/2018 11:16'!new: aProp		"Standart initialization for Unary Operators"	"aProp should be subclass of the abstract class Prop"	^self basicNew initialize: aProp.! !Unary subclass: #Not	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Propositions'!!Not commentStamp: 'pm 11/27/2018 07:42' prior: 0!I represent a Not  operatorMy creation is available in the Unary class!!Not methodsFor: 'testing' stamp: 'pm 11/27/2018 07:59'!isNot	"Class tester"	^true! !!Not methodsFor: 'Skoleminsation' stamp: 'pm 12/12/2018 16:25'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	"cf Prop::HerbranSkolemDocu"	skolemnTrace ifTrue:[Transcript show:'Herbran' ; space ; show:self ;cr].		^(self class) new: (self operand Skolemnise: setOfLinkedVar CorrespondingValue: aMap).! !!Not methodsFor: 'Skoleminsation' stamp: 'pm 12/12/2018 16:25'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	"cf Prop::HerbranSkolemDocu"	skolemnTrace ifTrue:[Transcript show:'Skolem' ; space ; show:self ;cr].		^(self class) new: (self operand Herbrandise: setOfLinkedVar CorrespondingValue: aMap).! !!Not methodsFor: 'clausification' stamp: 'pm 12/13/2018 18:29'!isClause	"tester"	" (!! a) is a clause, but (!! (a \/ b)) isn't"	" (!! (!! a)) has to be flush during the clausification process too."	^(operand isAtome)! !!Not methodsFor: 'clausification' stamp: 'pm 12/12/2018 15:49'!clausification	"does an iteration of clausification the current proposition"		"For this one, we have some different possible pattern."	"/!!\ since we're in an unary operator, the pattern doesn't start at self, but at operand"	| t |	t:=nil.	((Not patternNot) matchPatternWith: operand)	ifTrue:[t:=operand operand.]	ifFalse:[			((Not patternTrue) matchPatternWith: operand)			ifTrue:[t:=False_Const new]			ifFalse:[				((Not patternFalse) matchPatternWith: operand)				ifTrue:[t:=True_Const new]				ifFalse:[					((Not patternOr) matchPatternWith: operand)					ifTrue:[t:=And new: (Not new:(operand left)) rightProp:(Not new:(operand right))]					ifFalse:[						((Not patternAnd) matchPatternWith: operand)						ifTrue:[t:=Or new: (Not new:(operand left)) rightProp:(Not new:(operand right))].						]					]				 ]			].		(t isNil) ifTrue:[clausificationTrace  ifTrue:[Transcript show:'in Not';show: self prettyPrint;cr.].			 self operand:(operand clausification).								^self]					 ifFalse:[clausificationTrace ifTrue:[Transcript show:'in Not2';show: t prettyPrint;cr.].						^t].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Not class	instanceVariableNames: 'patternNot patternTrue patternFalse patternOr patternAnd'!!Not class methodsFor: 'accessing' stamp: 'pm 11/27/2018 07:42'!patternFalse	"accessor"	^patternFalse.! !!Not class methodsFor: 'accessing' stamp: 'pm 11/27/2018 07:42'!patternAnd	"accessor"	^patternAnd.! !!Not class methodsFor: 'accessing' stamp: 'pm 11/27/2018 07:42'!patternNot	"accessor"	^patternNot.! !!Not class methodsFor: 'accessing' stamp: 'pm 11/27/2018 07:42'!patternTrue	"accessor"	^patternTrue.! !!Not class methodsFor: 'accessing' stamp: 'pm 11/27/2018 07:42'!patternOr	"accessor"	^patternOr.! !!Not class methodsFor: 'Initialize' stamp: 'pm 11/27/2018 12:23'!initialize	"Choosing the graphical symbol"	symb:='~'.		"patterns used for clausification.	Since we're in a unary operator, we choose to not represent it, and just compare those pattern with the operand"	patternNot:=Not new:(Var new: 'a').	patternTrue:=True_Const new.	patternFalse:=False_Const new.	patternOr:=Or new:(Var new: 'a') rightProp: (Var new: 'a').	patternAnd:=And new:(Var new: 'a') rightProp: (Var new: 'a').! !Unary subclass: #Quantifier	instanceVariableNames: 'var'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Propositions'!!Quantifier commentStamp: 'pm 11/26/2018 21:31' prior: 0!I represent a QuantifierI'm created this way:new: VariableIQuantifieAsChar Property: aPropex:Forall x P(x)Forall new: 'x'  Property: Predicate new:  (...)I don't support variadic Forall ( Forall x,y (...))!!Quantifier methodsFor: 'printing' stamp: 'pm 11/26/2018 21:23'!prettyPrint	"toString"	^(self class symb),' ', (self var), '.(',	operand prettyPrint,	')'.! !!Quantifier methodsFor: 'testing' stamp: 'pm 11/27/2018 07:08'!isClause	"tester. The skolemnisation process flush quantifiers out, so the program flow shouldn't get here."	^self error:'Quantifiers shouldn''t be there anymore in a clause. Did you skolemnise first?'.! !!Quantifier methodsFor: 'testing' stamp: 'pm 12/12/2018 12:04'!Clausification	"does an iteration of clausification the current proposition"		"shouldn't exist anymore"	^self error:'Quantifiers shouldn''t be there anymore, they can''t be clausified. Did you skolemnise first?'.! !!Quantifier methodsFor: 'testing' stamp: 'pm 11/27/2018 07:59'!isQuantifier 	"Class tester"	^true! !!Quantifier methodsFor: 'accessing' stamp: 'pm 11/26/2018 21:27'!var	"accessor"	^var.! !!Quantifier methodsFor: 'comparing' stamp: 'pm 11/26/2018 21:02'!=prop2	"comparaison operator"	^self getSymb = prop2 getSymb and:[self var=prop2 var and:[self operand=prop2 operand]].! !!Quantifier methodsFor: 'comparing' stamp: 'pm 11/27/2018 07:09'!isSameForTesting:anotherProp	"Comparaison operator for automated testing"	^self class = anotherProp class 		and:[self var=anotherProp var 			and:[(self operand) isSameForTesting: (anotherProp operand)]			]		.! !!Quantifier methodsFor: 'initialization' stamp: 'pm 11/26/2018 21:18'!initialize: aName Property: prop	"Standart initialization for Quantifier objects"	"aName should be a char or a string"	"aProp should be subclass of the abstract class Prop"	self initialize: prop.	var:=aName.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Quantifier class	instanceVariableNames: ''!!Quantifier class methodsFor: 'initialization' stamp: 'pm 11/26/2018 21:28'!new: aName Property:aProp	"Standart creation for Quantifier objects"	"aName should be a char or a string"	"aProp should be subclass of the abstract class Prop"	^self basicNew initialize: aName Property:aProp.! !Quantifier subclass: #Exists	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Propositions'!!Exists commentStamp: 'pm 10/9/2018 11:26' prior: 0!I represent an Exists quantifier!!Exists methodsFor: 'Skoleminsation' stamp: 'pm 12/12/2018 16:26'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	"cf Prop::HerbranSkolemDocu"	skolemnTrace ifTrue:[Transcript show:'Herbran' ; space ; show:self ;cr].		setOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).	^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.	"We don't keep the Quantifiers in the formula"! !!Exists methodsFor: 'Skoleminsation' stamp: 'pm 12/12/2018 16:26'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	"cf Prop::HerbranSkolemDocu"	| t |	skolemnTrace ifTrue:[Transcript show:'Skolem' ; space ; show:self ;cr].		t := setOfLinkedVar isEmpty		ifTrue: [ ConstTerm new ]"then it's a generated constant, same as an Exists"		ifFalse: [ FuncTerm newFuncWithVars:  setOfLinkedVar ].		"then it's a skolem function"	aMap add: (Association key: var value: t).	^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.		"We don't keep the Quantifiers in the formula"! !!Exists methodsFor: 'testing' stamp: 'pm 11/27/2018 07:59'!isExists		"Class tester"	^true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Exists class	instanceVariableNames: ''!!Exists class methodsFor: 'initialization' stamp: 'pm 11/26/2018 21:26'!initialize	"Choosing a symbol for this class"	symb:='Exist'.! !Quantifier subclass: #ForAll	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Propositions'!!ForAll commentStamp: 'pm 10/9/2018 11:26' prior: 0!I represent a ForallQuantifier!!ForAll methodsFor: 'Skoleminsation' stamp: 'pm 12/12/2018 16:27'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	"cf Prop::HerbranSkolemDocu"	| t |	skolemnTrace ifTrue:[Transcript show:'Herbran' ; space ; show:self ;cr].		t := setOfLinkedVar isEmpty		ifTrue: [ ConstTerm new ]"then it's a generated constant, same as an Exists"		ifFalse: [ FuncTerm newFuncWithVars: setOfLinkedVar ].		"then it's a skolem function"	aMap add: (Association key: var value: t).	^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.	"(self class) new: ("	")"	"We don't keep the Quantifiers in the formula"! !!ForAll methodsFor: 'Skoleminsation' stamp: 'pm 12/12/2018 16:27'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	"cf Prop::HerbranSkolemDocu"	skolemnTrace ifTrue:[Transcript show:'Skolem' ; space ; show:self ;cr].	setOfLinkedVar add: (LinkedTerm new:(Term new:(self var))).	^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.	 	"We don't keep the Quantifiers in the formula"! !!ForAll methodsFor: 'testing' stamp: 'pm 11/27/2018 07:59'!isForAll 	"Class tester"	^true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ForAll class	instanceVariableNames: ''!!ForAll class methodsFor: 'initialization' stamp: 'pm 11/26/2018 21:25'!initialize	"Choosing forall symbol"	symb:='Forall'.! !Atome subclass: #Var	instanceVariableNames: 'symb'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Propositions'!!Var commentStamp: 'pm 10/9/2018 11:23' prior: 0!I represent a variable in a Propositional logic.-new:VarName !!Var methodsFor: 'accessing' stamp: 'pm 11/27/2018 07:45'!getSymb	"accessor"	^symb! !!Var methodsFor: 'comparison' stamp: 'pm 9/29/2018 09:19'!isSameVar: other	^self getSymb = other getSymb.! !!Var methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!initialize: varName	symb:=varName.! !!Var methodsFor: 'matching' stamp: 'pm 9/30/2018 09:59'!matchPatternWith: prop	"see Prop comment for usage."	^true! !!Var methodsFor: 'testing' stamp: 'pm 11/27/2018 08:00'!isVar 	"Class tester"	^true! !!Var methodsFor: 'printing' stamp: 'pm 11/26/2018 21:24'!prettyPrint		"toString"	^(self getSymb).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Var class	instanceVariableNames: ''!!Var class methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!new: varName	^self basicNew initialize: varName.! !Var subclass: #NotVar	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Propositions'!!NotVar commentStamp: 'pm 10/9/2018 11:24' prior: 0!I represent a negative variable, only in ClausalForm!!NotVar methodsFor: 'testing' stamp: 'pm 11/27/2018 08:00'!isNotVar 	"Class tester"	^true! !!NotVar methodsFor: 'printing' stamp: 'pm 11/26/2018 21:24'!prettyPrint	"toString"	^(Not symb),(self getSymb).! !Prop initialize!False_Const initialize!And initialize!Equal initialize!Imply initialize!Or initialize!True_Const initialize!Not initialize!Exists initialize!ForAll initialize!TestCase subclass: #TestClausification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Testing class'!!TestClausification commentStamp: 'pm 12/13/2018 17:34' prior: 0!Automatiic Clausification testsWhat's in the predicates isn't relevant, since they aren't touched through this process.That mean that even though we're after the skolemnisation, and there should only be specific terms in there (const/linked/func), they don't matter. We therefore are able to use the propGeneration tool to create new tests at will.!!TestClausification methodsFor: 'clausification-Or' stamp: 'pm 12/12/2018 09:32'!testClausificationOrDistributivity	| prop res |	"Or's distributivity"	prop:=Or new:     (Predicate new:'P' fromList:               (LinkedList new                     yourself)     )	rightProp:     (And new:          (Predicate new:'Q' fromList:                    (LinkedList new                          yourself)          )     rightProp:          (Predicate new:'R' fromList:                    (LinkedList new                          yourself)          )     ).	res:=And new:     (Or new:          (Predicate new:'P' fromList:                    (LinkedList new                          yourself)          )     rightProp:          (Predicate new:'Q' fromList:                    (LinkedList new                          yourself)          )     )	rightProp:     (Or new:          (Predicate new:'P' fromList:                    (LinkedList new                          yourself)          )     rightProp:          (Predicate new:'R' fromList:                    (LinkedList new                          yourself)          )     ).	self assert: prop fullClausification equals: res.! !!TestClausification methodsFor: 'clausification-Or' stamp: 'pm 12/12/2018 09:32'!testClausificationOrOnAtomes	| prop res |	"P() \/ T -> T"	prop := Or new: (Predicate new: 'P')				  rightProp: (True_Const new).					res:=	True_Const new.		self assert: prop fullClausification equals: res.		"P() \/ F -> P()"			prop := Or new: (Predicate new: 'P')				  rightProp: (False_Const new).					res:=	Predicate new: 'P'.		self assert: prop fullClausification equals: res.	"T \/ P()-> T"	prop := Or new: (True_Const new)				  rightProp: (Predicate new: 'P').					res:=	True_Const new.		self assert: prop fullClausification equals: res.		"F \/ P() -> P()"			prop := Or new: (False_Const new)				  rightProp: (Predicate new: 'P').					res:=	Predicate new: 'P'.		self assert: prop fullClausification equals: res.	! !!TestClausification methodsFor: 'clausification-Or' stamp: 'pm 12/12/2018 09:32'!testClausificationOrStability	| prop res |		"stability of a clausified or"	prop := Or new: (Predicate new: 'P') 	  			  rightProp: (Predicate new: 'Q').		res := Or new: (Predicate new: 'P')	 			 rightProp: (Predicate new: 'Q').						self assert: prop fullClausification equals: res.	! !!TestClausification methodsFor: 'clausification-Or' stamp: 'pm 12/12/2018 09:32'!testClausificationOrDistributivitySymetric	| prop res |	"And the symetric. "	prop :=Or new:     (And new:          (Predicate new:'Q' fromList:                    (LinkedList new                          yourself)          )     rightProp:          (Predicate new:'R' fromList:                    (LinkedList new                          yourself)          )     )	rightProp:     (Predicate new:'P' fromList:               (LinkedList new                     yourself)     ).	res:=And new:     (Or new:          (Predicate new:'Q' fromList:                    (LinkedList new                          yourself)          )     rightProp:          (Predicate new:'P' fromList:                    (LinkedList new                          yourself)          )     )	rightProp:     (Or new:          (Predicate new:'R' fromList:                    (LinkedList new                          yourself)          )     rightProp:          (Predicate new:'P' fromList:                    (LinkedList new                          yourself)          )     ).	self assert: prop fullClausification equals: res.! !!TestClausification methodsFor: 'clausification-general' stamp: 'pm 12/12/2018 11:38'!testClausificationEquals	| prop res |	"basic test for equal's clausification"	prop := Equal new: (Predicate new:'P')					rightProp: (Predicate new:'Q').		res := And new:(Or new:	    		      			(Predicate new:'P')						    rightProp:					         (Predicate new:'Q'))				rightProp:(Or new:          			(Not new: (Predicate new:'P'))				     rightProp:			          (Not new:(Predicate new:'Q'))).							self assert: prop fullClausification equals: res.! !!TestClausification methodsFor: 'clausification-general' stamp: 'pm 12/12/2018 09:32'!testClausificationPredicate	| prop res |	"basic, should be  unafected by clausification"		"for empty predicates"	prop := (Predicate new:'P').	res := (Predicate new:'P').							self assert: prop fullClausification equals: res.			"for unary predicates"	prop := (Predicate new:'P' variable: (Term new: 'a')).	res := (Predicate new:'P' variable: (Term new: 'a')).	self assert: prop fullClausification equals: res.	"for variadic predicates"	prop := Predicate new:'P' fromList:          (LinkedList new                add:(Term new:'a');               add:(Term new:'b');               add:(Term new:'c');               add:(Term new:'d');               yourself).	res := Predicate new:'P' fromList:          (LinkedList new                add:(Term new:'a');               add:(Term new:'b');               add:(Term new:'c');               add:(Term new:'d');               yourself).	"for variadic predicates"	self assert: prop fullClausification equals: res.! !!TestClausification methodsFor: 'clausification-general' stamp: 'pm 12/12/2018 09:32'!testClausificationImply	| prop res |		"basic test for imply's clausification"	prop := Imply		new: (Predicate new: 'P')		rightProp: (Predicate new: 'Q').	res := Or		new: (Not new: (Predicate new: 'P'))		rightProp: (Predicate new: 'Q').	self assert: prop fullClausification equals: res! !!TestClausification methodsFor: 'clausification-general' stamp: 'pm 12/12/2018 12:09'!testClausificationQuantifier	| input |		"should fail, because the quantifier should be flushed before clausification, through skolemnisation."	"exists"	input:=Exists new:'x' Property:     (Predicate new:'P' fromList:               (LinkedList new                     add:(Term new:'x');                    yourself)     ).	self should:[input isClause] raise:Error.	"forall"	input:=ForAll new:'x' Property:     (Predicate new:'P' fromList:               (LinkedList new                     add:(Term new:'x');                    yourself)     ).	self should:[input isClause] raise:Error.! !!TestClausification methodsFor: 'clausification-Not' stamp: 'pm 12/12/2018 09:32'!testClausificationNotDistributedOnAnd	"Not on an And"	| prop res |	prop := Not new:     (And new:          (Predicate new:'P' fromList:                    (LinkedList new                          yourself)          )     rightProp:          (Predicate new:'Q' fromList:                    (LinkedList new                          yourself)          )     ).	res:= Or new:     (Not new:          (Predicate new:'P' fromList:                    (LinkedList new                          yourself)          )     )	rightProp:     (Not new:          (Predicate new:'Q' fromList:                    (LinkedList new                          yourself)          )     ).	self assert: prop fullClausification equals: res.! !!TestClausification methodsFor: 'clausification-Not' stamp: 'pm 12/12/2018 09:32'!testClausificationNotDistributedOnOr	| prop res |	"Not on an Or"	prop:=Not new:     (Or new:          (Predicate new:'P' fromList:                    (LinkedList new                          yourself)          )     rightProp:          (Predicate new:'Q' fromList:                    (LinkedList new                          yourself)          )     ).	res:= And new:     (Not new:          (Predicate new:'P' fromList:                    (LinkedList new                          yourself)          )     )	rightProp:     (Not new:          (Predicate new:'Q' fromList:                    (LinkedList new                          yourself)          )     ).	self assert: prop fullClausification equals: res.! !!TestClausification methodsFor: 'clausification-Not' stamp: 'pm 12/12/2018 09:32'!testClausificationNotOnAtomes	| prop res |	"Complete test for the Not clausifications"		"Polarity inversion"	prop := Not new: False_Const new.	res := True_Const new.	self assert: prop fullClausification equals: res.	"Polarity inversion #2"		prop := Not new: True_Const new.	res := False_Const new.	self assert: prop fullClausification equals: res.	"cancel Not"	prop := Not new: (Not new: (Predicate new:'P')).	res := (Predicate new:'P').	self assert: prop fullClausification equals: res.		! !!TestClausification methodsFor: 'clausification-And' stamp: 'pm 12/12/2018 09:32'!testClausificationAndOnAtomes	| prop res |		"P() /\ T -> P()"		prop := And new: (Predicate new: 'P')				   rightProp: (True_Const new).					res:=	Predicate new: 'P'.			self assert: prop fullClausification equals: res.		"P() /\ F -> F"		prop := And new: (Predicate new: 'P')				   rightProp: (False_Const new).					res:=	False_Const new.			self assert: prop fullClausification equals: res.	"T /\ P() -> P()"		prop := And new: (True_Const new)				   rightProp: (Predicate new: 'P').					res:=	Predicate new: 'P'.			self assert: prop fullClausification equals: res.		"F /\ P() -> F"		prop := And new: (False_Const new)				   rightProp: (Predicate new: 'P').					res:=	False_Const new.			self assert: prop fullClausification equals: res.! !!TestClausification methodsFor: 'clausification-And' stamp: 'pm 12/12/2018 09:32'!testClausificationAndStability	| prop res |		"stability of a clausified and"	prop := And new: (Predicate new:'P')					rightProp: (Predicate new:'Q').		res := And new: (Predicate new:'P')					rightProp: (Predicate new:'Q').							self assert: prop fullClausification equals: res.! !!TestClausification methodsFor: 'isClause' stamp: 'pm 12/12/2018 13:33'!testIsClauseLongOr	| input |	"an Equal isn't a clause!!"	input:=Or new:          (Or new:               (Or new:                    (Or new:                         (Or new:                              (Predicate new:'P' fromList:                                        (LinkedList new                                              yourself)                              )                         rightProp:                              (Predicate new:'P' fromList:                                        (LinkedList new                                              yourself)                              )                         )                    rightProp:                         (Predicate new:'P' fromList:                                   (LinkedList new                                         yourself)                         )                    )               rightProp:                    (Predicate new:'P' fromList:                              (LinkedList new                                    yourself)                    )               )          rightProp:               (Predicate new:'P' fromList:                         (LinkedList new                               yourself)               )          )     rightProp:          (Predicate new:'P' fromList:                    (LinkedList new                          yourself)          ).	self assert: input isClause.! !!TestClausification methodsFor: 'isClause' stamp: 'pm 12/12/2018 13:34'!testIsClauseLongAnd	| input |	"an Equal isn't a clause!!"	input:=And new:          (And new:               (And new:                    (And new:                         (And new:                              (Predicate new:'P' fromList:                                        (LinkedList new                                              yourself)                              )                         rightProp:                              (Predicate new:'P' fromList:                                        (LinkedList new                                              yourself)                              )                         )                    rightProp:                         (Predicate new:'P' fromList:                                   (LinkedList new                                         yourself)                         )                    )               rightProp:                    (Predicate new:'P' fromList:                              (LinkedList new                                    yourself)                    )               )          rightProp:               (Predicate new:'P' fromList:                         (LinkedList new                               yourself)               )          )     rightProp:          (Predicate new:'P' fromList:                    (LinkedList new                          yourself)          ).	self assert: input isClause.! !!TestClausification methodsFor: 'isClause' stamp: 'pm 12/12/2018 09:39'!testIsClauseDoubleNotWithOnlyAtomes	| input |	input:=Not new:     (Not new:          (Predicate new:'P' fromList:                    (LinkedList new                          yourself)          )     ).	"should fail, because the double Not can and should be removed through clausification"	self deny: input isClause.! !!TestClausification methodsFor: 'isClause' stamp: 'pm 12/12/2018 09:39'!testIsClauseSimpleNotWithOnlyAtomes	| input |	input:=Not new:          (Predicate new:'P' fromList:                    (LinkedList new                          yourself)          ).	self assert: input isClause.! !!TestClausification methodsFor: 'isClause' stamp: 'pm 12/12/2018 10:04'!testIsClauseQuantifier	| input |		"should fail, because the Not can and should be removed through clausification	Test on every binary operator for the principle of it, but the result should be the same every time"	"Equal"	input:=Exists new:'x' Property:     (Predicate new:'P' fromList:               (LinkedList new                     add:(Term new:'x');                    yourself)     ).	self should:[input isClause] raise:Error.	input:=ForAll new:'x' Property:     (Predicate new:'P' fromList:               (LinkedList new                     add:(Term new:'x');                    yourself)     ).	self should:[input isClause] raise:Error.! !!TestClausification methodsFor: 'isClause' stamp: 'pm 12/12/2018 10:59'!testIsClauseOrOnAnd	| input |	"test that (or (and (stuff) stuff)) isn't a clause"	input :=Or new:     (And new:          (Predicate new:'P' fromList:                    (LinkedList new                          yourself)          )     rightProp:          (Predicate new:'Q' fromList:                    (LinkedList new                          yourself)          )     )	rightProp:     (Predicate new:'P' fromList:               (LinkedList new                     yourself)     ).	self deny: input isClause.	input:=Or new:     (Predicate new:'P' fromList:               (LinkedList new                     yourself)     )	rightProp:     (And new:          (Predicate new:'P' fromList:                    (LinkedList new                          yourself)          )     rightProp:          (Predicate new:'Q' fromList:                    (LinkedList new                          yourself)          )     ).	self deny: input isClause.! !!TestClausification methodsFor: 'isClause' stamp: 'pm 12/12/2018 09:50'!testIsClauseNotOnOperator	| input |		"should fail, because the Not can and should be removed through clausification	Test on every binary operator for the principle of it, but the result should be the same every time"	"Equal"	input:=Not new:		(Equal new:           (Predicate new:'P' fromList:                    (LinkedList new                          yourself)          )		rightProp: 			(Predicate new:'P' fromList:                    (LinkedList new                          yourself)          )     ).	self deny: input isClause.		"Imply"	input:=Not new:		(Imply new:           (Predicate new:'P' fromList:                    (LinkedList new                          yourself)          )		rightProp: 			(Predicate new:'P' fromList:                    (LinkedList new                          yourself)          )     ).	self deny: input isClause.	"Or"	input:=Not new:		(Or new:           (Predicate new:'P' fromList:                    (LinkedList new                          yourself)          )		rightProp: 			(Predicate new:'P' fromList:                    (LinkedList new                          yourself)          )     ).	self deny: input isClause.	"And"	input:=Not new:		(And new:           (Predicate new:'P' fromList:                    (LinkedList new                          yourself)          )		rightProp: 			(Predicate new:'P' fromList:                    (LinkedList new                          yourself)          )     ).	self deny: input isClause.! !!TestClausification methodsFor: 'isClause' stamp: 'pm 12/12/2018 13:23'!testIsClauseEqual	| input |	"Equal isn't a clause!!"	input:=Equal new:          (Predicate new:'P' fromList:                    (LinkedList new                          yourself)          )     rightProp:          (Predicate new:'P' fromList:                    (LinkedList new                          yourself)          ).	self deny: input isClause.! !!TestClausification methodsFor: 'isClause' stamp: 'pm 12/12/2018 13:48'!testIsClauseAndOnOr	| input |	"test that (And (Or (stuff) stuff)) is a clause"	input :=And new:          (Or new:               (Predicate new:'P' fromList:                         (LinkedList new                               yourself)               )          rightProp:               (Predicate new:'Q' fromList:                         (LinkedList new                               yourself)               )          )     rightProp:          (Or new:               (Predicate new:'Q' fromList:                         (LinkedList new                               yourself)               )          rightProp:               (Predicate new:'P' fromList:                         (LinkedList new                               yourself)               )          ).	self assert: input isClause.! !!TestClausification methodsFor: 'isClause' stamp: 'pm 12/12/2018 13:23'!testIsClauseImply	| input |	"Imply isn't a clause!!"	input:=Imply new:          (Predicate new:'P' fromList:                    (LinkedList new                          yourself)          )     rightProp:          (Predicate new:'P' fromList:                    (LinkedList new                          yourself)          ).	self deny: input isClause.! !TestCase subclass: #TestSkolemnisation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Testing class'!!TestSkolemnisation commentStamp: 'pm 12/13/2018 17:48' prior: 0!Automatic Skolemnisation testsFirst step of the Resolution Method process.-> We therefor have to use only Terms in predicates. Those terms are being specialized through this processThis imply that  we can generate the inputs from the propGeneration tool, but NOT the expected results.!!TestSkolemnisation methodsFor: 'tests' stamp: 'pm 12/12/2018 17:53'!testBasicOnlyPredicate	| p res expected terms terms2 |	terms:=LinkedList new add:(Term new:'x');add:(Term new:'y');add:(Term new:'z');yourself.		p:=ForAll new: 'x' Property: (Exists new: 'y' Property: (ForAll new: 'z' Property: (Predicate new: 'P' fromList: terms ))).	res:=p StartSkolemnisation.			terms2:=LinkedList new add:(LinkedTerm new:(Term new:'x'));add:(FuncTerm newFunc: ((LinkedTerm new:(Term new:'x'))));add:(LinkedTerm new:(Term new:'z'));yourself.	expected:=Predicate new: 'P' fromList: terms2.		self assert:(res isSameForTesting: expected).! !!TestSkolemnisation methodsFor: 'tests' stamp: 'pm 12/12/2018 17:22'!testImplyAndNestedForAllWithSameNameForConstAndLinkedVar	| p res expected |	p:=Not new:		(Imply new: 			(ForAll new: 'x' Property:				(Or new:  					(Predicate new: 'P' variable:(Term new:'x'))					 rightProp:					(Predicate new: 'Q' variable:(Term new:'x'))))			 rightProp:			(Or new: 				(Predicate new: 'P' variable:(Term new:'x'))				rightProp:(Predicate new: 'Q' variable:(Term new:'x')))).	res:=p StartSkolemnisation.	"terms1:=LinkedList new add:(ConstTerm new:(Term new:'x')); add:(ConstTerm new:(Term new:'x'));yourself."	expected:=Not new:(Imply new:					(Or new: (Predicate new: 'P' variable:(LinkedTerm new:(Term new:'x')))					rightProp: (Predicate new: 'Q' variable:(LinkedTerm new:(Term new:'x'))))				rightProp:					(Or new: (Predicate new: 'P' variable:(ConstTerm new:(Term new:'x')))					rightProp: (Predicate new: 'Q' variable:(ConstTerm new:(Term new:'x'))))).		self assert:(res isSameForTesting: expected).	self assert:((((res operand) left) left) isSameTermsForTesting: (((res operand) right) right))	"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"! !!TestSkolemnisation methodsFor: 'tests' stamp: 'pm 12/12/2018 17:54'!testImplyAndNestedForAll	| p res expected |	p:=Not new: 		(Imply new: 			(ForAll new: 'x' Property:				(Or new:  					(Predicate new: 'P' variable:(Term new:'x'))					 rightProp:					(Predicate new: 'Q' variable:(Term new:'x'))))			 rightProp:			(Or new: 				(Predicate new: 'P' variable:(Term new:'a'))				rightProp:(Predicate new: 'Q' variable:(Term new:'a')))).	res:=p StartSkolemnisation.	"terms1:=LinkedList new add:(ConstTerm new:(Term new:'x')); add:(ConstTerm new:(Term new:'x'));yourself."	expected:=Not new:(Imply new:(					Or new: (Predicate new: 'P' variable:(ConstTerm new:(Term new:'x')))					rightProp: (Predicate new: 'Q' variable:(ConstTerm new:(Term new:'x'))))				rightProp:(					Or new: (Predicate new: 'P' variable:(ConstTerm new:(Term new:'a')))					rightProp: (Predicate new: 'Q' variable:(ConstTerm new:(Term new:'a'))))).		self assert:(res isSameForTesting: expected).! !!TestSkolemnisation methodsFor: 'tests' stamp: 'pm 12/12/2018 17:22'!testUnboundExistReplacedByConsts	| p res expected |	p:=Not new:		(Imply new: 			(ForAll new: 'x' Property:				(Or new:  					(Predicate new: 'P' variable:(Term new:'x'))					 rightProp:					(Predicate new: 'Q' variable:(Term new:'x'))))			 rightProp:			(Or new: 				(Predicate new: 'P' variable:(Term new:'x'))				rightProp:(Predicate new: 'Q' variable:(Term new:'x')))).	res:=p StartSkolemnisation.	"terms1:=LinkedList new add:(ConstTerm new:(Term new:'x')); add:(ConstTerm new:(Term new:'x'));yourself."	expected:=Not new:(Imply new:					(Or new: (Predicate new: 'P' variable:(LinkedTerm new:(Term new:'x')))					rightProp: (Predicate new: 'Q' variable:(LinkedTerm new:(Term new:'x'))))				rightProp:					(Or new: (Predicate new: 'P' variable:(ConstTerm new:(Term new:'x')))					rightProp: (Predicate new: 'Q' variable:(ConstTerm new:(Term new:'x'))))).		self assert:(res isSameForTesting: expected).	self assert:((((res operand) left) left) isSameTermsForTesting: (((res operand) right) right))	"we also test that the anonymousTerms generated from the initial ConstTerm are different from the generated ConstTerm from inital LinkedTerm, even they seem equals"! !!TestSkolemnisation methodsFor: 'tests' stamp: 'pm 12/12/2018 17:53'!testBasicForAll	| p res expected terms |	terms:=LinkedList new add:(Term new:'x');add:(Term new:'z');yourself.	p:=Or new: (ForAll new: 'x' Property: (ForAll new: 'z' Property: (Predicate new: 'P' fromList: terms )))	 rightProp: (ForAll new: 'x' Property: (ForAll new: 'z' Property: (Predicate new: 'P' fromList: terms ))).	res:=p StartSkolemnisation.		terms:=LinkedList new add:(LinkedTerm new:(Term new:'x')); add:(LinkedTerm new:(Term new:'z'));yourself.	expected:=Or new: (Predicate new: 'P' fromList: terms)					rightProp: (Predicate new: 'P' fromList: terms).			self assert:(res isSameForTesting: expected).! !TestCase subclass: #TestUnification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Testing class'!!TestUnification commentStamp: 'pm 12/14/2018 12:33' prior: 0!Unification test. For reference, the table of possible operations used is:             =         |     const      |   Linked    |     Func/Pred             Const    |  Conflict     |  Swap       |    Check                        |  Delete        |                    |                        |                       |                     |      Linked     | Eliminate  |  Delete     |    Check                        |                       |                     | Func/Pred  | Swap          |  Swap        |   Decompose                        |                       |                      |   Conflict                        |                       |                      | !!TestUnification methodsFor: 'testing' stamp: 'pm 12/14/2018 17:52'!testingUnification 	"everything is tested in those few lines, with textual output. Not automated"	|t l r|		Transcript show: 'Testing Unification related stuff';cr.		Transcript show:'Basics';cr.		Transcript show:'decompositions';cr.	l:=Predicate new: 'P' variable: (ConstTerm new:(Term new:'a')).	r:=Predicate new: 'P' variable: (ConstTerm new:(Term new:'b')).	l unificationUnitTest:r.	Transcript show:'delete';cr.	l:=Predicate new: 'P' variable: (ConstTerm new:(Term new:'a')).	r:=Predicate new: 'P' variable: (ConstTerm new:(Term new:'a')).	l unificationUnitTest:r.		Transcript show:'conflict';cr.	l:=Predicate new: 'Q' variable: (ConstTerm new:(Term new:'a')).	r:=Predicate new: 'P' variable: (ConstTerm new:(Term new:'a')).	l unificationUnitTest:r.	Transcript show:'swap';cr.	l:=Predicate new: 'P' variable: (FuncTerm new: 'f' Variable: (ConstTerm new: (Term new: 'a'))).	r:=Predicate new: 'P' variable: (LinkedTerm new:(Term new:'x')).	l unificationUnitTest:r.	"G{f(x,g(x))=f(a,g(a))}"	Transcript show:'Exemple	david #2';cr.	t:=LinkedList new.	t add: (LinkedTerm new:(Term new:'x'));add:(FuncTerm new:'g' Variable: (LinkedTerm new:(Term new:'x'))).	l:=Predicate new: 'P' variable: (FuncTerm new: 'f' Variables:t).	t:=LinkedList new.	t add:(ConstTerm new:(Term new:'a')) ;add:(FuncTerm new:'g' Variable:(ConstTerm new:(Term new:'a'))).	r:=Predicate new: 'P' variable: (FuncTerm new: 'f' Variables:t).	l unificationUnitTest:r.		"G{f(x,g(a))=f(b,g(y))}"	Transcript show:'Exemple david #1';cr.	t:=LinkedList new.	t add: (LinkedTerm new:(Term new:'x'));add:(FuncTerm new:'g' Variable: (ConstTerm new:(Term new:'a'))).	l:=Predicate new: 'P' variable: (FuncTerm new: 'f' Variables:t).	t:=LinkedList new.	t add:(ConstTerm new:(Term new:'b')) ;add:(FuncTerm new:'g' Variable:(LinkedTerm new:(Term new:'y'))).	r:=Predicate new: 'P' variable: (FuncTerm new: 'f' Variables:t).	l unificationUnitTest:r.			"should replace x by y at the end of the unification"	Transcript show:'x alias y';cr.	t:=LinkedList new.	t add: (LinkedTerm new:(Term new:'y'));add:( LinkedTerm new:(Term new:'x'));add:(ConstTerm new:(Term new:'a')).	l:=Predicate new: 'P' variable: (FuncTerm new: 'f' Variables:t).	t:=LinkedList new.	t add: (LinkedTerm new:(Term new:'x'));add:(LinkedTerm new:(Term new:'y'));add:(LinkedTerm new:(Term new:'x')).	r:=Predicate new: 'P' variable: (FuncTerm new: 'f' Variables:t).	l unificationUnitTest:r.			Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !!TestUnification methodsFor: 'tests' stamp: 'pm 12/14/2018 16:28'!testConstOnFunc	| left right unifier expectedResultPair expectedResultSetOfPair |	"Only test for aConstTerm=aFuncTerm"		"check fail"	left:=Predicate new: 'P' variable: (ConstTerm new:(Term new:'a')).	right:=Predicate new: 'P' variable: (FuncTerm new: 'f' Variable:(ConstTerm new:(Term new:'a'))).		unifier:=Unifier new: left Predicate2:right.		expectedResultPair:=nil.	expectedResultSetOfPair :=nil.	self assert:unifier hasFailed.	self assert:unifier unifiedPair equals:expectedResultPair.	self assert:unifier setOfPairs equals: expectedResultSetOfPair.		"check ok"	left:=Predicate new: 'P' variable: (ConstTerm new:(Term new:'a')).	right:=Predicate new: 'P' variable: (FuncTerm new: 'f' Variable:(ConstTerm new:(Term new:'x'))).		unifier:=Unifier new: left Predicate2:right.		expectedResultPair:=Pair left: left right: right. 	expectedResultSetOfPair :=MinimalOrderedSet new		add: (Pair left: (ConstTerm new:(Term new:'a')) right:(FuncTerm new: 'f' Variable:(ConstTerm new:(Term new:'x'))));		yourself.	self deny:unifier hasFailed.	self assert:unifier unifiedPair equals:expectedResultPair.	self assert:unifier setOfPairs equals: expectedResultSetOfPair.	! !!TestUnification methodsFor: 'tests' stamp: 'pm 12/14/2018 17:32'!testFuncOnLinked	| left right unifier expectedResultPair expectedResultSetOfPair |	"the only test for aFuncTerm=aLinkedTerm"	"swap rule."	left:=Predicate new: 'P' variable: (FuncTerm new: 'f' Variable: (ConstTerm new:(Term new:'y'))).	right:=Predicate new: 'P' variable: (LinkedTerm new:(Term new:'x')).		unifier:=Unifier new: left Predicate2:right.		"Will swap before eliminate and succeed"	expectedResultPair:=Pair left: left right: left. 	expectedResultSetOfPair :=MinimalOrderedSet new		add: (Pair left: (LinkedTerm new:(Term new:'x')) right:(FuncTerm new: 'f' Variable: (ConstTerm new:(Term new:'y'))));		yourself.			self deny:unifier hasFailed.	self assert:unifier unifiedPair equals:expectedResultPair.	self assert:unifier setOfPairs equals: expectedResultSetOfPair.	! !!TestUnification methodsFor: 'tests' stamp: 'pm 12/14/2018 15:40'!testConstOnConst	| left right unifier expectedResultPair expectedResultSetOfPair |	"Both test for aConstTerm = anotherConstTerm"		"conflict rule"	left:=Predicate new: 'P' variable: (ConstTerm new:(Term new:'a')).	right:=Predicate new: 'P' variable: (ConstTerm new:(Term new:'b')).		unifier:=Unifier new: left Predicate2:right.	"this first test should just fail, with everything being nil"	self assert:unifier hasFailed.	self assert:unifier unifiedPair equals:nil.	self assert:unifier setOfPairs equals: nil.		"delete rule"	left:=Predicate new: 'P' variable: (ConstTerm new:(Term new:'a')).	right:=Predicate new: 'P' variable: (ConstTerm new:(Term new:'a')).		unifier:=Unifier new: left Predicate2:right.	"The resulting pair is the same as the input, since the unification was unnecessary"	expectedResultPair:=(Pair left:left right:right).	"the delete let us an empty set"	expectedResultSetOfPair:=MinimalOrderedSet new.	self deny:unifier hasFailed.	self assert: unifier unifiedPair equals:expectedResultPair.	self assert:unifier setOfPairs equals: expectedResultSetOfPair.	! !!TestUnification methodsFor: 'tests' stamp: 'pm 12/14/2018 11:34'!testConstOnLinked	| left right unifier expectedResultPair expectedResultSetOfPair |	"Only test for aConstTerm=aLinkedTerm"	"since they can't be equal. As proven by this assertion. (obviously)"	self deny:(ConstTerm new: ( Term new: 'a'))=(LinkedTerm new: ( Term new: 'a'))."S"		left:=Predicate new: 'P' variable: (ConstTerm new:(Term new:'a')).	right:=Predicate new: 'P' variable: (LinkedTerm new:(Term new:'x')).		unifier:=Unifier new: left Predicate2:right.		expectedResultPair:=Pair left: left right: left. 	expectedResultSetOfPair :=MinimalOrderedSet new		add: (Pair left: (LinkedTerm new:(Term new:'x')) right:(ConstTerm new:(Term new:'a')));		yourself.	self deny:unifier hasFailed.	self assert:unifier unifiedPair equals:expectedResultPair.	self assert:unifier setOfPairs equals: expectedResultSetOfPair.	! !!TestUnification methodsFor: 'tests' stamp: 'pm 12/14/2018 11:57'!testLinkedOnLinked	| left right unifier expectedResultPair expectedResultSetOfPair |	"Both tests for aLinkedTerm=anotherLinkedTerm"		"eliminate rule"	left:=Predicate new: 'P' variable: (LinkedTerm new:(Term new:'x')).	right:=Predicate new: 'P' variable: (LinkedTerm new:(Term new:'y')).		unifier:=Unifier new: left Predicate2:right.		"No changes expected since "	expectedResultPair:=Pair left: left right: right. 	expectedResultSetOfPair :=MinimalOrderedSet new		add: (Pair left: (LinkedTerm new:(Term new:'x')) right:(LinkedTerm new:(Term new:'y')));		yourself.	self deny:unifier hasFailed.	self assert:unifier unifiedPair equals:expectedResultPair.	self assert:unifier setOfPairs equals: expectedResultSetOfPair.		"delete rule"	left:=Predicate new: 'P' variable: (LinkedTerm new:(Term new:'x')).	right:=Predicate new: 'P' variable: (LinkedTerm new:(Term new:'x')).		unifier:=Unifier new: left Predicate2:right.		"No changes expected since they already are the same"	expectedResultPair:=Pair left: left right: right. 	"the delete let us with an empty set"	expectedResultSetOfPair :=MinimalOrderedSet new.	self deny:unifier hasFailed.	self assert:unifier unifiedPair equals:expectedResultPair.	self assert:unifier setOfPairs equals: expectedResultSetOfPair.	! !!TestUnification methodsFor: 'tests' stamp: 'pm 12/14/2018 12:25'!testEmptyPredicate	| left right unifier expectedResultPair expectedResultSetOfPair |	"tests for empty predicates"		"Decomposition rule"	left:=Predicate new: 'P'.	right:=Predicate new: 'P'.		unifier:=Unifier new: left Predicate2:right.	expectedResultPair :=Pair left: left right: right.	expectedResultSetOfPair:=MinimalOrderedSet new. 		"this first test should just fail, with everything being nil"	self deny:unifier hasFailed.	self assert:unifier unifiedPair equals: expectedResultPair.	self assert:unifier setOfPairs equals: expectedResultSetOfPair.		"Conflict rule on Symbols"	left:=Predicate new: 'P'.	right:=Predicate new: 'Q'.		unifier:=Unifier new: left Predicate2:right.		"testing will fai, so everything will be nill"	expectedResultPair:=nil.	expectedResultSetOfPair:=nil. 		"this first test should just fail, with everything being nil"	self assert:unifier hasFailed.	self assert:unifier unifiedPair equals: expectedResultPair.	self assert:unifier setOfPairs equals: expectedResultSetOfPair.	! !Object subclass: #AbstractTerm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Terms'!!AbstractTerm commentStamp: 'pm 10/22/2018 19:40' prior: 0!Abstract factorisation needed.Documentation available in Term.!!AbstractTerm methodsFor: 'printing' stamp: 'pm 10/28/2018 14:26'!printOn: stream	"Override of basic printOn, for use in transcripts.	Shows the current object"	stream nextPutAll: (self prettyPrint).! !!AbstractTerm methodsFor: 'printing' stamp: 'pm 10/28/2018 14:25'!prettyPrint	"Does a pretty print of the current object"	^SubclassResponsibility.! !!AbstractTerm methodsFor: 'testing' stamp: 'pm 12/14/2018 12:39'!isConstTerm	^false! !!AbstractTerm methodsFor: 'testing' stamp: 'pm 12/14/2018 12:38'!isTerm	^false! !!AbstractTerm methodsFor: 'testing' stamp: 'pm 12/14/2018 13:22'!isPredicateOrFuncTerm	"Class tester"	"Necessary because we don't distinguish them in the unification process"	^false! !!AbstractTerm methodsFor: 'testing' stamp: 'pm 12/14/2018 12:38'!isUnaryTerm	^false! !!AbstractTerm methodsFor: 'testing' stamp: 'pm 12/14/2018 12:38'!isFuncTerm	^false! !!AbstractTerm methodsFor: 'testing' stamp: 'pm 12/14/2018 12:39'!isLinkedTerm	^false! !!AbstractTerm methodsFor: 'testing' stamp: 'pm 12/14/2018 12:38'!isAbstractTerm	^true! !!AbstractTerm methodsFor: 'testing' stamp: 'pm 12/14/2018 12:52'!isPredicate	"that tester is necessary because of the similitudes between FuncTerm and Predicate"	^false.! !!AbstractTerm methodsFor: 'testing' stamp: 'pm 10/15/2018 16:39'!isConst	"Used to check if a term, or more often a funcTerm is const, while trying to unify a term with a funcTerm."	^false.! !!AbstractTerm methodsFor: 'Skoleminsation' stamp: 'pm 11/27/2018 21:26'!WhatAmI:setOfLinkedVar CorrespondingValue: aMap	"Part of the skolemnisation process.	Step which determines what kind of term each term in each predicate is (func/const/linked)"	"For argument, see documentation in Prop::SkolemnisationDocu."	| elem |	(setOfLinkedVar haveYouSeenThisObject:(LinkedTerm new:self))	ifTrue:[^LinkedTerm new:self.]	ifFalse:[		elem:=aMap at:(self prettyPrint) ifAbsent:[(ConstTerm new: self)].		^elem.].! !AbstractTerm subclass: #FuncTerm	instanceVariableNames: 'symb terms anonymous'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Terms'!!FuncTerm commentStamp: 'pm 10/9/2018 10:43' prior: 0!I represent a Func term, for a predicate.I should only be instanciated by the skolemnisation.I exists if my variable was bound by an Exists, with a forall binding the said Exists beforehand.Public API and Key Messages-prettyPrint >> return the term as a String, with a standart name 'f' for the function, and a list of terms.!!FuncTerm methodsFor: 'adding' stamp: 'pm 10/28/2018 14:41'!replace:x by:t	"replace every occurence of the term 'x' with the term 't'"	| i |	i:=1.	[i<=(self arity)]	whileTrue:[		((terms at:i) isKindOf: FuncTerm)		ifTrue:[ 			(terms at:i) replace:x by:t.			]		ifFalse:[			((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."			ifTrue:[				"Transcript cr;cr;show:'pouet';cr;cr."				terms at:i put:t.				].			].			i:=i+1.		].	^self! !!FuncTerm methodsFor: 'adding' stamp: 'pm 10/28/2018 14:29'!addTerm: aTerm	"add aTerm to the list of this predicate or function's list."	self assert:(aTerm isKindOf: AbstractTerm).	terms add:aTerm.! !!FuncTerm methodsFor: 'comparing' stamp: 'pm 11/5/2018 09:19'!isSameSymb:anotherFuncTerm	"Do both funcTerm have the same symbol"	^(self getSymb)=(anotherFuncTerm getSymb).! !!FuncTerm methodsFor: 'comparing' stamp: 'pm 11/5/2018 09:34'!isSameSymbForTesting:anotherFuncTerm	"Do both funcTerm have the same symbol, forgeting the anonymous ones"	^self anonymous 			ifTrue:[anotherFuncTerm anonymous]			ifFalse:[				(self getSymb)=(anotherFuncTerm getSymb).				].! !!FuncTerm methodsFor: 'comparing' stamp: 'pm 11/5/2018 09:33'!isSameForTesting: anotherFuncTerm	"Comparaison Operator."	| res |	self assert:(anotherFuncTerm class=self class)."checking the input"	res:=self isSameSymbForTesting: anotherFuncTerm."comparing the function symbol"	res:=res and:[self isSameArity: anotherFuncTerm]."comparing arity"	res:=res and:[(self isSameTermsForTesting: anotherFuncTerm).]."we let the superclass LinkedList check for the correct terms"	^res.! !!FuncTerm methodsFor: 'comparing' stamp: 'pm 10/28/2018 14:39'!isSameArity:anotherFuncTerm	"check if 2 FuncTerm have the same number of arguments"	^(self arity)=(anotherFuncTerm arity).! !!FuncTerm methodsFor: 'comparing' stamp: 'pm 12/14/2018 15:48'!=anotherFuncTerm	"Comparaison Operator."	| res |	res:=(self class=anotherFuncTerm class)."checking the input"	res:=res and:[self isSameSymb: anotherFuncTerm]."comparing the function symbol"	res:=res and:[self isSameArity: anotherFuncTerm]."comparing arity"	res:=res and:[(self isSameTerms: anotherFuncTerm).]."we let the superclass LinkedList check for the correct terms"	^res.! !!FuncTerm methodsFor: 'comparing' stamp: 'pm 11/5/2018 09:33'!isSameTerms: anotherFuncTerm	"check if every terms are equal in both FuncTerms."	^(self terms) = (anotherFuncTerm terms).! !!FuncTerm methodsFor: 'Skoleminsation' stamp: 'pm 10/28/2018 14:28'!WhatAmI:setOfLinkedVar CorrespondingValue: aMap	"CF AbstractTerm"	| newVars t|	newVars:=LinkedList new.	terms do: [ :each | newVars add: (each WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].	t:=(FuncTerm new: (self getSymb) Variables:newVars).	^t.! !!FuncTerm methodsFor: 'initialization' stamp: 'pm 11/8/2018 13:32'!initialize: symbo Variables: listOfLinkedVar	"variadic initialization of a funcTerm.	listOfLinkedVar can actually be any kind of enumerable object."	symb:=symbo.	terms:=LinkedListFix new.	listOfLinkedVar  do: [:each | terms add: each.].! !!FuncTerm methodsFor: 'initialization' stamp: 'pm 10/28/2018 14:37'!initialize: symbo Variable: aTerm	"initialization with only one term of a funcTerm"	symb:=symbo.	terms:=LinkedListFix new.	terms add: aTerm.! !!FuncTerm methodsFor: 'initialization' stamp: 'pm 10/28/2018 14:36'!initialize: symbo	"initialization, for an empty functerm"	symb:=symbo.	terms:=LinkedListFix new.! !!FuncTerm methodsFor: 'testing' stamp: 'pm 12/14/2018 12:40'!isFuncTerm	^true! !!FuncTerm methodsFor: 'testing' stamp: 'pm 12/14/2018 13:23'!isPredicateOrFuncTerm	"Class tester"	"Necessary because we don't distinguish them in the unification process"	^true! !!FuncTerm methodsFor: 'testing' stamp: 'pm 12/13/2018 18:27'!isConst 	"is const if every terms of his is const"	^ terms allSatisfy: [ :each | each isConst ]! !!FuncTerm methodsFor: 'testing' stamp: 'pm 11/5/2018 09:44'!isSameTermsForTesting:anotherFuncTerm	| selfTerms anotherFuncTerms |	selfTerms:=self terms.	anotherFuncTerms:=anotherFuncTerm terms.	1 to: (terms size) do:[:i|		((selfTerms at:i) isSameForTesting: (anotherFuncTerms at:i))		ifFalse:[			^false			]		].	^true! !!FuncTerm methodsFor: 'accessing' stamp: 'pm 11/11/2018 09:08'!anonymous	"Accessors	This knoledge is needed for automated testing"	^anonymous! !!FuncTerm methodsFor: 'accessing' stamp: 'pm 10/28/2018 14:42'!terms	"accessor"	^terms! !!FuncTerm methodsFor: 'accessing' stamp: 'pm 10/28/2018 14:35'!getSymb	"accessor"	^symb! !!FuncTerm methodsFor: 'accessing' stamp: 'pm 11/11/2018 09:09'!anonymous:aBool	"Accessors	This knoledge is needed for automated testing"	anonymous:=aBool! !!FuncTerm methodsFor: 'accessing' stamp: 'pm 10/28/2018 14:33'!at: index 	"Transmit the at:index message to the terms attribute	returns the term at the index index."	^ (self terms) at:index.! !!FuncTerm methodsFor: 'accessing' stamp: 'pm 10/28/2018 14:30'!arity	"Return the arity of this FuncTerm"	^terms size.	! !!FuncTerm methodsFor: 'printing' stamp: 'pm 10/28/2018 14:34'!contains: aTerm	"Check if the term has at least one occurence in the current functerm"	^ terms anySatisfy: [ :each | each contains: aTerm ]! !!FuncTerm methodsFor: 'printing' stamp: 'pm 10/28/2018 14:41'!prettyPrint	"prettyprint of the current FuncTerm"	|t|	t:=(self getSymb),'('.	terms do: [:each| t:=t,each prettyPrint. ] separatedBy:[t:=t,','].	t:=t,')'.	^t.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FuncTerm class	instanceVariableNames: 'currentFuncNumber anonymousFuncSymb'!!FuncTerm class methodsFor: 'instance creation' stamp: 'pm 11/5/2018 09:13'!newFuncWithVars: varList	"creation of a new anonymous variadic funcTerm"	^self basicNew initialize: (self getNewFuncName) Variables:varList						;anonymous:true						;yourself.! !!FuncTerm class methodsFor: 'instance creation' stamp: 'pm 11/8/2018 13:15'!new: symbo Variables: aListOfTerms	"creation of a new named variadic funcTerm"	^self basicNew initialize:symbo Variables: aListOfTerms						;anonymous:false						;yourself.! !!FuncTerm class methodsFor: 'instance creation' stamp: 'pm 10/28/2018 14:44'!getNewFuncName	"Generator of anonymous function names. Used during skolemnisation"	currentFuncNumber :=currentFuncNumber +1.	^anonymousFuncSymb,(currentFuncNumber asString).! !!FuncTerm class methodsFor: 'instance creation' stamp: 'pm 11/5/2018 09:13'!newFunc: variable	"creation of a new anonymous funcTerm, with a variable"	^self basicNew initialize: (self getNewFuncName) Variable:variable						;anonymous:true						;yourself.! !!FuncTerm class methodsFor: 'instance creation' stamp: 'pm 11/5/2018 09:14'!new	"creation of a new empty, anonymous funcTerm"	^(self basicNew) initialize: (self getNewFuncName)							;anonymous:true						;yourself.! !!FuncTerm class methodsFor: 'instance creation' stamp: 'pm 11/5/2018 09:15'!new: symbo Variable: aVar	"creation of a new named funcTerm, with a term 'f(x)'"	^self basicNew initialize:symbo Variable: aVar						;anonymous:false						;yourself.! !!FuncTerm class methodsFor: 'instance creation' stamp: 'pm 11/5/2018 09:15'!new: symbo	"creation of a new named empty funcTerm "	^self basicNew initialize:symbo						;anonymous:false						;yourself.! !!FuncTerm class methodsFor: 'initialization' stamp: 'pm 10/28/2018 14:45'!initialize	"Initialization of the class."	currentFuncNumber:=0."we start anonymous functions number at 0."	anonymousFuncSymb:='f'."mutable anonymous function name."! !AbstractTerm subclass: #Term	instanceVariableNames: 'symb'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Terms'!!Term commentStamp: 'pm 10/9/2018 10:36' prior: 0!I represent a Predicate's Term.My type will be specialized in ConstTerm, FuncTerm, LinkedVar when the propostion my predicate's in goes through skolemnisation.I look a lot like a proposition, but i'm conceptually different, hence the new object defined types.Public API and Key Messages-prettyPrint -> print the term as a string.-new: aChar -> new instance, with a char as a term. !!Term methodsFor: 'testing' stamp: 'pm 12/14/2018 12:40'!isTerm	^true! !!Term methodsFor: 'testing' stamp: 'pm 11/5/2018 09:44'!isSameForTesting: anotherTerm	^self=anotherTerm.! !!Term methodsFor: 'printing' stamp: 'pm 10/28/2018 15:00'!prettyPrint 	"return current term as string"	^self getSymb.! !!Term methodsFor: 'comparing' stamp: 'pm 10/21/2018 13:10'!=anotherTerm	"default comparing for terms."	^(self getSymb)=(anotherTerm getSymb).! !!Term methodsFor: 'accessing' stamp: 'pm 10/28/2018 14:48'!initialize: aName	"initialization of a named term"	symb:=aName.! !!Term methodsFor: 'accessing' stamp: 'pm 10/28/2018 14:48'!getSymb	"accessor"	^symb! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Term class	instanceVariableNames: ''!!Term class methodsFor: 'instance creation' stamp: 'pm 10/28/2018 14:47'!new: aName	"Creation of a term, which are represented by a name"	^(self basicNew) initialize:aName.! !AbstractTerm subclass: #UnaryTerm	instanceVariableNames: 'term'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Terms'!!UnaryTerm commentStamp: 'pm 10/28/2018 15:12' prior: 0!Abstract factorisation for LinkedTerm & ConstTerm!!UnaryTerm methodsFor: 'accessing' stamp: 'pm 10/28/2018 15:03'!term	"accessor"	^term.! !!UnaryTerm methodsFor: 'initialize' stamp: 'pm 10/28/2018 15:01'!initialize:aTerm	"initialize an UnaryTerm with a term as argument"	(aTerm isKindOf: Term)	ifFalse:[^self error:'Takes only Terms as parameters. This is a', (aTerm class). ]	ifTrue:[term:=aTerm].! !!UnaryTerm methodsFor: 'comparing' stamp: 'pm 11/5/2018 09:45'!=anotherTerm	"comparaison operator"	^((anotherTerm class) = (self class)) and:[(self term)=(anotherTerm term).].			! !!UnaryTerm methodsFor: 'adding' stamp: 'pm 10/28/2018 15:02'!replace:x by:t	"This message is only for predicate & funterms. They both deal with unary terms to be able to modify the type of the terms."	^self error:'shouldn''t be able to get here'.! !!UnaryTerm methodsFor: 'testing' stamp: 'pm 12/14/2018 12:40'!isUnaryTerm	^true! !!UnaryTerm methodsFor: 'testing' stamp: 'pm 10/28/2018 15:01'!contains: aTerm	"Check if the contained term is the same as the argument"	^term = aTerm.! !!UnaryTerm methodsFor: 'testing' stamp: 'pm 11/5/2018 09:45'!isSameForTesting: anotherTerm	^self term = anotherTerm term.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnaryTerm class	instanceVariableNames: ''!!UnaryTerm class methodsFor: 'instance creation' stamp: 'pm 11/28/2018 01:21'!new: aTerm	"Creation of a specialized term, with a symbol"	^(self basicNew) initialize:aTerm.! !UnaryTerm subclass: #ConstTerm	instanceVariableNames: 'anonymous'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Terms'!!ConstTerm commentStamp: 'pm 10/9/2018 10:44' prior: 0!I represent a Const term, for a predicate.I should only be instanciated by the skolemnisation.I exists if my variable wasn't bound by anything OR if i'm bound by an exists which isn't bound by a previous forall.Public API and Key Messages-prettyPrint >> return the term as a String, with the character 'c' as a start. To differenciate it from the rest visually.!!ConstTerm methodsFor: 'printing' stamp: 'pm 10/28/2018 15:05'!prettyPrint	"print current object as string."	"we add a c in front of it to be able to differenciate a const term from a linked term while reading."	^'c', (term prettyPrint).! !!ConstTerm methodsFor: 'initialization' stamp: 'pm 10/28/2018 15:04'!initialize	"Initialization of an anonymous ConstTerm. Done during the skolemnisation"	term:=Term new:(self class) getNum.! !!ConstTerm methodsFor: 'accessing' stamp: 'pm 11/5/2018 09:20'!anonymous	^anonymous! !!ConstTerm methodsFor: 'accessing' stamp: 'pm 11/5/2018 09:20'!anonymous:aBool	anonymous:=aBool! !!ConstTerm methodsFor: 'testing' stamp: 'pm 11/5/2018 09:24'!isSameForTesting: anotherTerm		^self anonymous 		ifTrue:[			anotherTerm anonymous			]		ifFalse:[			self term = anotherTerm term.			].! !!ConstTerm methodsFor: 'testing' stamp: 'pm 12/14/2018 12:40'!isConstTerm	^true! !!ConstTerm methodsFor: 'testing' stamp: 'pm 10/28/2018 15:04'!isConst	"a const term is const. obvious, right?"	^true.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ConstTerm class	instanceVariableNames: 'factoryVar factoryNum'!!ConstTerm class methodsFor: 'initialization' stamp: 'pm 11/5/2018 09:22'!nextConst	"Used as a anonymous const term name factory"	^factoryVar,(self getNum).! !!ConstTerm class methodsFor: 'initialization' stamp: 'pm 10/28/2018 15:06'!factoryNum	"Number of the next anonymous const term"	"accessor"	^factoryNum.! !!ConstTerm class methodsFor: 'initialization' stamp: 'pm 10/28/2018 15:07'!getNum	"The number of the next anonymous object as string."	factoryNum:=factoryNum+1.	^factoryNum asString! !!ConstTerm class methodsFor: 'initialization' stamp: 'pm 11/5/2018 09:21'!new 	"new anonymous const term"	^self basicNew initialize;			anonymous:true;			yourself.! !!ConstTerm class methodsFor: 'initialization' stamp: 'pm 11/5/2018 09:23'!initialize	"initlize of the class, which is the chosen name for an anonymous const terms and the number of the first anonymous const term"	factoryVar:='c'.	factoryNum:=0.! !!ConstTerm class methodsFor: 'initialization' stamp: 'pm 11/5/2018 09:21'!new:Const_Value	"new named const Object"	^self basicNew initialize:Const_Value;			anonymous:false;			yourself.! !UnaryTerm subclass: #LinkedTerm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Terms'!!LinkedTerm commentStamp: 'pm 10/28/2018 15:13' prior: 0!I represent a Linked Term, for a Predicate or a FuncTermMost of my logic is factorised in UnaryTerm and AbstractTermI should only be instanciated by the skolemnisation.I exists if my variable is bound by a forall earlier in the proposition.Public API and Key Messages-prettyPrint >> return the term as a String!!LinkedTerm methodsFor: 'testing' stamp: 'pm 12/14/2018 12:41'!isLinkedTerm	^true! !!LinkedTerm methodsFor: 'printing' stamp: 'pm 10/28/2018 15:10'!prettyPrint 	"return a representation of the current object as string"	^term prettyPrint.! !FuncTerm initialize!ConstTerm initialize!MinimalOrderedSet subclass: #ClausalForm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Clausal Form'!!ClausalForm commentStamp: 'pm 10/28/2018 15:21' prior: 0!I represent a clausal form, which means i'm a long 'and' statement with 'or' as my propositions(Clauses).I inherit from a set, because i only want to have one of each clause object inside me.I'm conceived to be instanciated by  the method "amIValid, of propositions"I know my clauses (which are represented by the class Clause)My responsability is to use the resolution method on myselfPublic API and Key Messages- resolutionMethod : I'm using the resolutionMethod on myselfI can be created empty or with a Prop object as input.ClausalForm new: aFullProp. !!ClausalForm methodsFor: 'resolution' stamp: 'pm 12/13/2018 18:29'!resolutionMethod	"application of the resolution method on self. Course algorithm"	| sat c r |	sat:=MinimalOrderedSet new.	[self isEmpty]	whileFalse:[		Transcript show:self;cr.		c:=self removeFirst.		c isEmptyClause		ifTrue:[^true.]."Insatisfiable"	   ((c isTautology) or:[sat anySatisfy:[:each|each=c.]])"ifTrue:[skip]"			ifFalse:[				r:=Resolvante new.				r factorisation:c.				sat do:[:c1|					r resolvante: c1 with: c.					].				self addFromList:r.				sat addLast:c.			].			].	^false."satisfiable"! !!ClausalForm methodsFor: 'initialization' stamp: 'pm 10/28/2018 15:27'!initialize: clausifiedFormula	"initialize a clausal form from a clausified Prop object"	self addAll: clausifiedFormula.! !!ClausalForm methodsFor: 'initialization' stamp: 'pm 10/28/2018 15:27'!prettyPrint	"toString"	|t|	t:='{'.		self do: [  :each | t:=t,(each prettyPrint). ] separatedBy: [t:=t,','].	t:=t,'}'.	^t.! !!ClausalForm methodsFor: 'adding' stamp: 'pm 10/28/2018 15:25'!addFromList: aLinkedList	"add a list of clauses"	aLinkedList do:[:each|		self add: each.		].! !!ClausalForm methodsFor: 'adding' stamp: 'pm 10/28/2018 15:19'!addAll: clausifiedProp	"badly designed, NEEDS a refactor."						((clausifiedProp  isOr) | (clausifiedProp isAtome))"If i'm in a or, there's only or(s) under him."	ifTrue:[self add: (Clause new:clausifiedProp)]	ifFalse:[		(clausifiedProp isNot)		ifTrue:[			((clausifiedProp operand) isAtome)			ifTrue:[^self add:(Clause new:clausifiedProp).]			ifFalse:[^Error new:'A not isn''t englobing an atome.'.].			]		ifFalse:[			(clausifiedProp isAnd)			ifTrue:[				self addAll: (clausifiedProp left).				self addAll: (clausifiedProp right).				]		ifFalse:[			Error new: 'Tried to add a non clause object to a clausaleForm.'.].			].		].! !!ClausalForm methodsFor: 'adding' stamp: 'pm 10/28/2018 15:21'!add: aClause	"add a new clause in self."	(aClause isKindOf: Clause)	ifTrue: [ super add: aClause ]	ifFalse:[Error new: 'Tried to add a non clause object to a clausaleForm'].	^self "enable chaining operation"! !!ClausalForm methodsFor: 'printing' stamp: 'pm 10/28/2018 15:27'!printOn: stream	"override to be shown on transcripts"	stream nextPutAll: (self prettyPrint).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClausalForm class	instanceVariableNames: ''!!ClausalForm class methodsFor: 'instance creation' stamp: 'pm 10/28/2018 15:18'!new: ClausaleProposition	"Creation of a clausal form, and add everything in a Clausified Prop."	^self basicNew initialize:ClausaleProposition.! !!ClausalForm class methodsFor: 'instance creation' stamp: 'pm 10/28/2018 15:17'!new	"Object creation of an empty Clausal Form"	^self basicNew initialize.! !MinimalOrderedSet subclass: #Clause	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Clausal Form'!!Clause commentStamp: 'pm 10/28/2018 15:21' prior: 0!I represent a clause, which is a set of predicate (positive or negative)  related by a variadic Or operator.Build on top of a Set, to avoid redundancy.I should be instanciated by ClausalForm only.!!Clause methodsFor: 'adding' stamp: 'pm 11/11/2018 09:19'!add: anAtome	"Add an atomic predicate to self. Either a const or a predicate"	(anAtome isAtome)	ifTrue:[		super add:anAtome.		^self."able chaining operation"		]	ifFalse:[			^self error: 'Trying to add a wrong type in a clause'.		].! !!Clause methodsFor: 'adding' stamp: 'pm 11/11/2018 09:20'!addAll: orProp	"BADLY DESIGNED, NEEDS REFACTOR"		(orProp isAtome)	ifTrue:[self add:orProp.]	ifFalse:[		((orProp) isNot)		ifTrue:["we're in a not"			(orProp operand isAtome)				ifTrue:["we're in an atom"					((orProp operand) isPredicate)					ifTrue:[self add:(NotPredicate new: (orProp operand) getSymb fromList: (orProp operand) terms).]					ifFalse:[						((orProp operand) isVar)						ifTrue:[self add:(NotVar new:((orProp operand) getSymb)).]						ifFalse: [ Error new: 'shouldn''t be any True or false here' ]].						]				ifFalse:[					Error new:'Error, shouldn''t be any more not ( binaryOp )'				].			]		ifFalse:[			(orProp isOr)			ifTrue:[				self addAll: (orProp left).				self addAll: (orProp right).				]			ifFalse:["switch to Error new:"				Error new:'Error, shouldn''t be any other kind of prop here.'.				].			].		].! !!Clause methodsFor: 'adding' stamp: 'pm 11/11/2018 09:35'!without:index1 nor:index2	"return self without the object at an index1 nor index2"	|i resClause|	resClause:=Clause new.	i:=1.		[i<=self size]	whileTrue:[		(i~=index1 and:[i~=index2])		ifTrue:[			resClause add:(self at:i).			].		i:=i+1.		].	^resClause ! !!Clause methodsFor: 'adding' stamp: 'pm 11/11/2018 09:33'!without:index	"return self without the object at an index"	|i resClause|	resClause:=Clause new.	i:=1.		[i<=self size]	whileTrue:[		(i~=index)		ifTrue:[			resClause add:(self at:i).			].		i:=i+1.		].	^resClause ! !!Clause methodsFor: 'adding' stamp: 'pm 11/11/2018 09:23'!addFromList: aLinkedList	"Add every atomes in the linked list to self"	aLinkedList do:[:each|		self add: each.		].! !!Clause methodsFor: 'printing' stamp: 'pm 11/11/2018 09:29'!printOn: stream	"Override to print the to string on transcript	"	stream nextPutAll: (self prettyPrint).! !!Clause methodsFor: 'printing' stamp: 'pm 11/11/2018 09:28'!prettyPrint	"tostring"	|t|	t:='{'.	self do:[  :each | t:=t,(each prettyPrint). ] separatedBy:[t:=t,','].	t:=t,'}'.	^t.! !!Clause methodsFor: 'initialize' stamp: 'pm 12/9/2018 14:13'!initialize: orProp	"initialization using an orProp. Should only contain predicates/const"	self addAll:orProp.! !!Clause methodsFor: 'testing' stamp: 'pm 11/11/2018 09:25'!isEmptyClause	"Check if we don't have any terms in self. Used in resolution method."	^self isEmpty.! !!Clause methodsFor: 'testing' stamp: 'pm 11/11/2018 09:27'!isTautology	"Check if self contains a tautology"	self do:[ :p1 |		self do:[ :p2 | 			(p1 isOpposite: p2)			ifTrue:[^true].			].		].	^false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Clause class	instanceVariableNames: ''!!Clause class methodsFor: 'instance creation' stamp: 'pm 12/13/2018 18:34'!new: orProp	"creation of a new clause of a OrProp"	^self basicNew initialize:orProp.! !MinimalOrderedSet subclass: #Resolvante	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Clausal Form'!!Resolvante commentStamp: 'pm 10/27/2018 22:04' prior: 0!Utility class for ClausalForm::ResolutionMethod.!!Resolvante methodsFor: 'methodeDeResolution' stamp: 'pm 12/14/2018 18:23'!resolvante: aClause1 with: aClause2	"This method gets all the resolvantes between aClause1 and aClause2, modulo a subtitution of two terms.	self is an Unifier	aClause1 and aClause2 are the clauses we want to get the resolvant off.	resultant clauses are stocked in self."	| i j a1 a2 sub1 sub2 u newClause |	"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.	We don't need that much variable, it's for clarity"	i:=1.			[ i<=(aClause1 size). ]	whileTrue:[		a1:=aClause1 at:i.				j:=1.		[ j<=(aClause2 size) ]		whileTrue:[			a2:=aClause2 at:j.			(a1 isOppositePolarity: a2)			ifTrue:[				u:=Unifier new: a1 Predicate2: a2.				u hasFailed				ifFalse:["if the unified pair isNil, then the unification failed"					sub1:=u firstPredicate.					sub2:=u secondPredicate.	"				Transcript show:'sub1: ';show:sub1;cr.					Transcript show:'sub2: ';show:sub2;cr.	"				(sub1 isOpposite: sub2)					ifTrue:[						"newClause:=Clause new.we create a new clause with everything but the Atomes used"						newClause:=(aClause1 without:i).						newClause addFromList: (aClause2 without:j).						self add:newClause. "we finally add the resolvante."						]					].				].			j:=j+1.			].		i:=i+1.		].! !!Resolvante methodsFor: 'methodeDeResolution' stamp: 'pm 12/14/2018 16:27'!factorisation: aClause	"This method factorise positively AND negatively at the same time.	self is an Unifier	aClause is the clause we want to factorise	resultant clauses are stocked in self."	| i j a1 a2 sub1 sub2 u newClause |	"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.	We don't need that much variable, it's for clarity"	i:=1.		"Transcript show:aClause;cr."		[ i<=(aClause size). ]	whileTrue:[		a1:=aClause at:i.				j:=i+1.		[ j<=(aClause size) ]		whileTrue:[			a2:=aClause at:j.			(a1 isSamePolarity: a2)			ifTrue:[				u:=Unifier new: a1 Predicate2: a2.					u hasFailed				ifFalse:[					sub1:=u firstPredicate.					sub2:=u secondPredicate.		"			Transcript show:'sub1: ';show:sub1;cr.					Transcript show:'sub2: ';show:sub2;cr.		"			(sub1=sub2)					ifTrue:[						"newClause:=Clause new. We create a new clause with everything but the Atomes used"						newClause:=(aClause without:i nor:j).						newClause add:sub1. "sub1=sub2, so we only add one of them"						self add:newClause. "we finally add the resolvante."						].					].				].			j:=j+1.			].		i:=i+1.		].! !Object subclass: #Unifier	instanceVariableNames: 'setOfPairs hasFailed initialPair unifiedPair'	classVariableNames: 'UnifiedTerm'	poolDictionaries: ''	category: '_resolution_1erOrdre-Clausal Form'!!Unifier commentStamp: 'pm 10/27/2018 22:13' prior: 0!I represent an Unifier object.My purpose is to unify two predicate.Public API and Key Messages-Unifier new: Predicate2:- UnifyThisp1:=Predicate new:(..)p2:=Predicate new:(...)Unifier new: p1 Predicate2:p2 Instance Variables	hasFailed:	Boolean to see if the unification failed.!!Unifier methodsFor: 'printing' stamp: 'pm 10/20/2018 08:21'!printOn: aStream	aStream nextPutAll: (self prettyPrint).! !!Unifier methodsFor: 'printing' stamp: 'pm 10/20/2018 08:40'!prettyPrint	| t |	t:='{'.	(setOfPairs isNil)	ifFalse:[		setOfPairs do: [:each| t:=t,each prettyPrintUnifier.] separatedBy: [ t:=t,','.].		].	t:=t,'}'.	^t! !!Unifier methodsFor: 'add/remove' stamp: 'pm 10/15/2018 19:14'!add: value1 Value2: value2	setOfPairs add:(Pair left: value1 right: value2).! !!Unifier methodsFor: 'add/remove' stamp: 'pm 10/15/2018 16:40'!addUnifier: anotherUnifier	setOfPairs merge: (anotherUnifier setOfPairs ).	^self! !!Unifier methodsFor: 'add/remove' stamp: 'pm 10/15/2018 16:40'!add: aPair	setOfPairs add: aPair.	^self! !!Unifier methodsFor: 'accessing' stamp: 'pm 10/20/2018 08:53'!hasFailed	^hasFailed! !!Unifier methodsFor: 'initialization' stamp: 'pm 12/14/2018 09:49'!initialize: p1 Predicate2: p2	"initialized with two predicates, that we'll try to unify."		"init two different pair to be sure that we have the initial	one to unify at the end."	initialPair:=(Pair left: (p1 veryDeepCopy) right: (p2 veryDeepCopy)).	setOfPairs:=MinimalOrderedSet new.	setOfPairs add:(Pair left: p1 right: p2).	hasFailed:=false.		unifiedPair:=Pair left:nil right:nil."not sure if needed"		"And we try to unify it instantly"	self unifyThis.! !!Unifier methodsFor: 'initialization' stamp: 'pm 10/25/2018 08:07'!firstPredicate	^unifiedPair left.! !!Unifier methodsFor: 'initialization' stamp: 'pm 10/25/2018 08:07'!secondPredicate	^unifiedPair right.! !!Unifier methodsFor: 'accessors' stamp: 'pm 10/15/2018 16:29'!setOfPairs: anotherSet	setOfPairs:=anotherSet.	^self.! !!Unifier methodsFor: 'accessors' stamp: 'pm 10/15/2018 16:29'!setOfPairs	^setOfPairs! !!Unifier methodsFor: 'unification' stamp: 'pm 12/14/2018 17:46'!tryOperations: aPair	| modified notPossible left right |	left:=aPair left."syntaxic sugar"	right:=aPair right.	notPossible:=false.	modified:=false.	(left isPredicateOrFuncTerm)	ifTrue:[		(right isPredicateOrFuncTerm)		ifTrue:[			((left isSameSymb: right) and:[(left arity=right arity)])			ifTrue:["Decompose is possible"				self decompose:aPair.				modified:=true.				]			ifFalse:["Isn't the sameSymbol, conflict"				self conflict:aPair.				notPossible:=true.				]			]		ifFalse:["it's either a ConstTerm or a LinkedTerm. Same behavior"			left isConst			ifTrue:[				self swap:aPair.				modified:=true.				]			]		]	ifFalse:[		(left isLinkedTerm)		ifTrue:[			right isPredicateOrFuncTerm			ifTrue:[				notPossible:=self check:aPair.				]			ifFalse:["else right is either Linked or Const term, behavior is factorisable"				left=right				ifTrue:["then they both are LinkedTerms"					self delete:aPair.					modified:=true.					]				ifFalse:[					modified:=self eliminate:aPair.					]				]			]		ifFalse:["left is a ConstTerm"			right isFuncTerm			ifTrue:[				notPossible:=self check:aPair				]			ifFalse:[				right isLinkedTerm				ifTrue:[					self swap:aPair.					modified:=true.					]				ifFalse:["right is a ConstTerm"					left=right					ifTrue:[						self delete:aPair.						modified:=true.						]					ifFalse:[						self conflict:aPair.						notPossible:=true.						]					]				]			]		].	^Pair left: modified right: notPossible. ! !!Unifier methodsFor: 'unification' stamp: 'pm 12/13/2018 20:54'!swap: aPair	|left right|	(Prop debugUnification)	ifTrue:[Transcript show:'swaping : '; show:aPair ;cr.].		left:=aPair left.	right:=aPair right.	setOfPairs remove:aPair.	self add: (Pair left: right right: left).	! !!Unifier methodsFor: 'unification' stamp: 'pm 12/13/2018 20:58'!eliminate: aPair	|left right previousSet newSet |		(Prop debugUnification)	ifTrue:[Transcript show:'eliminate with '; show:aPair ;cr.].		left:=aPair left.	right:=aPair right.	newSet:=MinimalOrderedSet new.		previousSet:=setOfPairs veryDeepCopy."we need to work on a copy, to avoid having another iteration"	previousSet remove:aPair.		previousSet do:[:each |		"tempVar:=each veryDeepCopy.""since we modify the underlying data, we work on a copy"		newSet add: (self replacementPair:each replaced:left by:right).		].	(previousSet = newSet)	ifTrue:[		^false "Nothing changed"		]	ifFalse:[		newSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"		setOfPairs:=newSet."replace with new set"		^true. "modifications were mades"		].	 ! !!Unifier methodsFor: 'unification' stamp: 'pm 10/21/2018 09:15'!replacementPair:aPair replaced:x by:t	^Pair left:(self replacement: (aPair left) replaced:x by:t)		  right:(self replacement: (aPair right) replaced:x by:t).! !!Unifier methodsFor: 'unification' stamp: 'pm 10/25/2018 08:36'!unifiedPair	^unifiedPair. ! !!Unifier methodsFor: 'unification' stamp: 'pm 12/13/2018 20:57'!delete:aPair	(Prop debugUnification)	ifTrue:[Transcript show:'delete'; show:aPair ;cr.].	setOfPairs remove:aPair.! !!Unifier methodsFor: 'unification' stamp: 'pm 12/13/2018 20:50'!conflict: aPair	(Prop debugUnification) 	ifTrue:[Transcript show:'[Unification] conflict between : '; show:aPair ; cr.].! !!Unifier methodsFor: 'unification' stamp: 'pm 12/14/2018 14:43'!tryOperationsOld: aPair	| modified notPossible left right |	left:=aPair left."syntaxic sugar"	right:=aPair right.	notPossible:=false.	modified:=false.		((left isConstTerm) and:[right isConstTerm])	ifTrue:[		(left = right) "check underlying symbols, and that"		ifTrue:[self delete:aPair. modified:=true.]"delete"		ifFalse:[					self conflict:aPair.				notPossible:=true.				].]	ifFalse:[		(((left isFuncTerm) and:[right isFuncTerm])		or:[(left isPredicate) and:[right isPredicate]])		ifTrue:["try a decompose or conflict "			((left isSameSymb: right) and:[(left arity=right arity)])			ifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"			ifFalse:["Isn't the sameSymbol, conflict"				self conflict:aPair.				notPossible:=true.				].			]		ifFalse:[			(((left isConst) and:[right isLinkedTerm.])			or:[left isFuncTerm])			ifTrue:[ "swap"				self swap:aPair.				modified:=true.				 ]			ifFalse:[  				((left isLinkedTerm) 				and:[(right isLinkedTerm) or:[right isConst]])"eliminate if x=t or x=f(t) [...]"				ifTrue:[					modified:=self eliminate:aPair.					]				ifFalse:["check, not implemented for now"					((left isLinkedTerm) and:[right isFuncTerm])					ifTrue:[						notPossible:=self check:aPair.						].					].				].			].		].		^Pair left: modified right: notPossible. ! !!Unifier methodsFor: 'unification' stamp: 'pm 12/14/2018 09:46'!unifyMe	| modified operationAnswer i |	modified := true.	[ modified ]	whileTrue:[		modified := false.		i := 1.		[(modified not) and:[(i <= (setOfPairs size))]]		whileTrue: [ 			Prop debugUnification ifTrue: [ Transcript show: self;cr ].			operationAnswer := self tryOperations: (setOfPairs at: i).			operationAnswer right"=not possible"			ifTrue: [ "On a conflict or a fail check"				"Transcript show: 'Unification impossible'; cr."				setOfPairs := nil.				hasFailed:=true.				^nil "return value doesn't matter, we just want to break out" 				].	"NotPossible to unify?"			"else we go on till we didn't do anything more"			modified := modified or: [ operationAnswer left ].	"isModified was put arbitrily in left"			i:=i + 1 .			].			]. ! !!Unifier methodsFor: 'unification' stamp: 'pm 12/14/2018 09:52'!unifyThis	self unifyMe."Now setOfPairs contains my unifier"		(hasFailed)	ifTrue:[		unifiedPair := nil."Failed to unify thing"		^nil."return value doesn't matter, we just want to breakout."		].	unifiedPair := initialPair veryDeepCopy.	(setOfPairs isNil)	ifFalse:[		setOfPairs do:[ :each | 			((((each left) isConst) not) and:[(each right) isConst])				ifTrue:["They both should be predicates, so they can use replace: by:"					(unifiedPair left) replace: (each left) by: (each right).					(unifiedPair right) replace: (each left) by: (each right).					].				].			].	"else it was already the same  predicate"! !!Unifier methodsFor: 'unification' stamp: 'pm 12/14/2018 16:54'!check: aPair	(Prop debugUnification)	ifTrue:[Transcript show:'check';cr.].		^aPair right contains: aPair left term! !!Unifier methodsFor: 'unification' stamp: 'pm 12/13/2018 20:56'!decompose: aPair	|left right i|	(Prop debugUnification)	ifTrue:[Transcript show:'decompose '; show:aPair ;cr.].		left:=aPair left.	right:=aPair right.	i:=1.	setOfPairs remove: aPair.	[i<=(left arity)]"arity is the same, as we tested in the caller."	whileTrue:[		self add: (Pair left: (left at: i) right: (right at: i)).		i:=i+1.		].	! !!Unifier methodsFor: 'unification' stamp: 'pm 10/21/2018 09:16'!replacement:aTerm replaced:x by:t	((aTerm isKindOf: FuncTerm)or:[aTerm isKindOf: Predicate])	ifTrue:[		^aTerm replace:x by:t.		]"if it's something else than a functerm, "	ifFalse:[		(aTerm=x)		ifTrue:[^t]		ifFalse:[^aTerm].		]. ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Unifier class	instanceVariableNames: ''!!Unifier class methodsFor: 'instance creation' stamp: 'pm 11/11/2018 09:43'!new: p1 Predicate2: p2	"takes two predicate as initialization arguments"	^(self basicNew) initialize: p1 Predicate2:p2.! !LinkedList subclass: #LinkedListFix	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Data structures'!!LinkedListFix commentStamp: 'pm 10/22/2018 10:04' prior: 0!Only exists because the basic LinkedList implementation of at:put: is weird, and create a infinite loop if you add twice the same object.That override fixes that.!!LinkedListFix methodsFor: 'accessing' stamp: 'pm 11/11/2018 09:14'!at:index put: anObject	"Override since the basic one seems to rather do a infinite loop for no good reason."	| currentLink i |	currentLink:=self firstLink.	i:=1. 	[(index=(i)) and:[(currentLink isNil) not]]	whileFalse:[		i:=i+1.		currentLink:=currentLink nextLink.		].		(currentLink isNil)	ifTrue:[^self error:'index out of bound']	ifFalse:[currentLink value: anObject ].! !LinkedListFix subclass: #MinimalOrderedSet	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Data structures'!!MinimalOrderedSet commentStamp: 'pm 10/9/2018 10:08' prior: 0!I'm a ordered set, using a LinkedList. I'm a linked list which only override the method 'add' so i can be considered as a set.I also give access to a way to find an object via haveYouSeenThisObject.cf LinkedList.Public API and Key Messages- add: anObject (add an object IF it's not in the set)- haveYouSeenThisObject: anObject (search for an element in the set- To create instances , cf LinkedListp:=MinimalOrderSet new.p add: 1 >> "p contains { 1 }" p add : 1 >> "p contains { 1 }"p haveYouSeenThisObject: 1 >> "true"p haveYouSeenThisObject: 2 >> "false"!!MinimalOrderedSet methodsFor: 'search' stamp: 'pm 12/13/2018 18:28'!haveYouSeenThisObject: anObject 	"search for the object"	^ self anySatisfy: [ :each | each = anObject ]! !!MinimalOrderedSet methodsFor: 'adding' stamp: 'pm 10/28/2018 15:16'!merge: anotherMinimalOrderedSet	"Merge of two MinimalOrderedSet"	anotherMinimalOrderedSet do:[:each | self add:each.].	^self.! !!MinimalOrderedSet methodsFor: 'adding' stamp: 'pm 11/11/2018 09:16'!add: anObject	"Override to add the set component on a LinkedList"		self do: [ :each | 		(each=anObject) 		ifTrue:[^self]"Object's already in, we're done"		].	 super add: anObject."we let LinkedList add the object"	^self."to be chainable"! !Object subclass: #Pair	instanceVariableNames: 'left right'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre-Data structures'!!Pair commentStamp: '<historical>' prior: 0!Basic implementation of the Pair data-structure!!Pair methodsFor: 'printing' stamp: 'pm 11/11/2018 09:39'!printOn: aStream	"tostring for transcript"	aStream nextPutAll: (self prettyPrint)! !!Pair methodsFor: 'printing' stamp: 'pm 11/11/2018 09:38'!prettyPrint	"tostring"	^'(',(self left prettyPrint),',',(self right prettyPrint),')'.! !!Pair methodsFor: 'printing' stamp: 'pm 11/11/2018 09:39'!prettyPrintUnifier	"prettyPrint in the context of the unifier. Better visualisation of it's state."	^'(',(self left prettyPrint),'=',(self right prettyPrint),')'.! !!Pair methodsFor: 'initialize-release' stamp: 'pm 11/11/2018 09:38'!left:l right:r	"initializer/accessor"	left:=l.	right:=r.! !!Pair methodsFor: 'comparing' stamp: 'pm 11/11/2018 09:37'!= anotherPair	"comparator"	self assert: ((anotherPair class)=(self class)).	^(self left)=(anotherPair left) and:[(self right)=(anotherPair right)].! !!Pair methodsFor: 'accessing' stamp: 'pm 11/11/2018 09:39'!right	"accessor"	^right! !!Pair methodsFor: 'accessing' stamp: 'pm 11/11/2018 09:37'!left: anObject	"accessor"	left:=anObject.	^left! !!Pair methodsFor: 'accessing' stamp: 'pm 11/11/2018 09:40'!right: anObject	"accessor"	right:=anObject.	^right! !!Pair methodsFor: 'accessing' stamp: 'pm 11/11/2018 09:37'!left	"accessor"	^left! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Pair class	instanceVariableNames: ''!!Pair class methodsFor: 'initialize-release' stamp: 'pm 11/28/2018 01:23'!left:l right:r	"Basic new for a pair"	^(self basicNew) left:l right:r.! !