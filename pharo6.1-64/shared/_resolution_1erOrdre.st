Object subclass: #AbstractTerm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!AbstractTerm commentStamp: 'pm 10/22/2018 19:40' prior: 0!Abstract factorisation needed.Documentation available in Term.!!AbstractTerm methodsFor: 'printing' stamp: 'pm 10/28/2018 14:26'!printOn: stream	"Override of basic printOn, for use in transcripts.	Shows the current object"	stream nextPutAll: (self prettyPrint).! !!AbstractTerm methodsFor: 'printing' stamp: 'pm 10/28/2018 14:25'!prettyPrint	"Does a pretty print of the current object"	^SubclassResponsibility.! !!AbstractTerm methodsFor: 'testing' stamp: 'pm 10/15/2018 16:39'!isConst	"Used to check if a term, or more often a funcTerm is const, while trying to unify a term with a funcTerm."	^false.! !!AbstractTerm methodsFor: 'Skoleminsation' stamp: 'pm 10/28/2018 14:25'!WhatAmI:setOfLinkedVar CorrespondingValue: aMap	"Part of the skolemnisation process.	Step which determines what kind of term each term in each predicate is (func/const/Linked"	"For argument, see documentation in Prop::SkolemnisationDocu."	| elem |	(setOfLinkedVar haveYouSeenThisObject:self)	ifTrue:[^LinkedTerm new:self.]	ifFalse:[		elem:=aMap at:(self prettyPrint) ifAbsent:[(ConstTerm new: self)].		^elem.].! !AbstractTerm subclass: #FuncTerm	instanceVariableNames: 'symb terms'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!FuncTerm commentStamp: 'pm 10/9/2018 10:43' prior: 0!I represent a Func term, for a predicate.I should only be instanciated by the skolemnisation.I exists if my variable was bound by an Exists, with a forall binding the said Exists beforehand.Public API and Key Messages-prettyPrint >> return the term as a String, with a standart name 'f' for the function, and a list of terms.!!FuncTerm methodsFor: 'adding' stamp: 'pm 10/28/2018 14:41'!replace:x by:t	"replace every occurence of the term 'x' with the term 't'"	| i |	i:=1.	[i<=(self arity)]	whileTrue:[		((terms at:i) isKindOf: FuncTerm)		ifTrue:[ 			(terms at:i) replace:x by:t.			]		ifFalse:[			((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."			ifTrue:[				"Transcript cr;cr;show:'pouet';cr;cr."				terms at:i put:t.				].			].			i:=i+1.		].	^self! !!FuncTerm methodsFor: 'adding' stamp: 'pm 10/28/2018 14:29'!addTerm: aTerm	"add aTerm to the list of this predicate or function's list."	self assert:(aTerm isKindOf: AbstractTerm).	terms add:aTerm.! !!FuncTerm methodsFor: 'comparing' stamp: 'pm 10/28/2018 14:30'!=anotherFuncTerm	"Comparaison Operator."	| res |	self assert:(anotherFuncTerm isKindOf: FuncTerm)."checking the input"	res:=self isSameSymb: anotherFuncTerm."comparing the function symbol"	res:=res and:[self isSameArity: anotherFuncTerm]."comparing arity"	res:=res and:[(self isSameTerms: anotherFuncTerm).]."we let the superclass LinkedList check for the correct terms"	^res.! !!FuncTerm methodsFor: 'comparing' stamp: 'pm 10/28/2018 14:41'!isSameTerms: anotherFuncTerm	"check if every terms are in both FuncTerms."	^(self terms) = (anotherFuncTerm terms).! !!FuncTerm methodsFor: 'comparing' stamp: 'pm 10/28/2018 14:39'!isSameArity:anotherFuncTerm	"check if 2 FuncTerm have the same number of arguments"	^(self arity)=(anotherFuncTerm arity).! !!FuncTerm methodsFor: 'comparing' stamp: 'pm 10/28/2018 14:40'!isSameSymb:anotherFuncTerm	"Do both funcTerm have the same symbol"	^(self getSymb)=(anotherFuncTerm getSymb).! !!FuncTerm methodsFor: 'Skoleminsation' stamp: 'pm 10/28/2018 14:28'!WhatAmI:setOfLinkedVar CorrespondingValue: aMap	"CF AbstractTerm"	| newVars t|	newVars:=LinkedList new.	terms do: [ :each | newVars add: (each WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].	t:=(FuncTerm new: (self getSymb) Variables:newVars).	^t.! !!FuncTerm methodsFor: 'initialization' stamp: 'pm 10/28/2018 14:38'!initialize: symbo Variables: listOfLinkedVar	"variadic initialization of a funcTerm.	listOfLinkedVar can actually be any kind of enumerable object."	symb:=symbo.	terms:=LinkedListFix new.	listOfLinkedVar  do: [:each | terms add: each.].! !!FuncTerm methodsFor: 'initialization' stamp: 'pm 10/28/2018 14:37'!initialize: symbo Variable: aTerm	"initialization with only one term of a funcTerm"	symb:=symbo.	terms:=LinkedListFix new.	terms add: aTerm.! !!FuncTerm methodsFor: 'initialization' stamp: 'pm 10/28/2018 14:36'!initialize: symbo	"initialization, for an empty functerm"	symb:=symbo.	terms:=LinkedListFix new.! !!FuncTerm methodsFor: 'testing' stamp: 'pm 10/28/2018 14:39'!isConst 	"is const if every terms of his is const"	terms do:[:each | (each isConst)ifFalse:[^false]].	^true! !!FuncTerm methodsFor: 'accessing' stamp: 'pm 10/28/2018 14:33'!at: index 	"Transmit the at:index message to the terms attribute	returns the term at the index index."	^ (self terms) at:index.! !!FuncTerm methodsFor: 'accessing' stamp: 'pm 10/28/2018 14:30'!arity	"Return the arity of this FuncTerm"	^terms size.	! !!FuncTerm methodsFor: 'accessing' stamp: 'pm 10/28/2018 14:42'!terms	"accessor"	^terms! !!FuncTerm methodsFor: 'accessing' stamp: 'pm 10/28/2018 14:35'!getSymb	"accessor"	^symb! !!FuncTerm methodsFor: 'printing' stamp: 'pm 10/28/2018 14:34'!contains: aTerm	"Check if the term has at least one occurence in the current functerm"	^ terms anySatisfy: [ :each | each contains: aTerm ]! !!FuncTerm methodsFor: 'printing' stamp: 'pm 10/28/2018 14:41'!prettyPrint	"prettyprint of the current FuncTerm"	|t|	t:=(self getSymb),'('.	terms do: [:each| t:=t,each prettyPrint. ] separatedBy:[t:=t,','].	t:=t,')'.	^t.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FuncTerm class	instanceVariableNames: 'currentFuncNumber anonymousFuncSymb'!!FuncTerm class methodsFor: 'instance creation' stamp: 'pm 10/28/2018 14:47'!newFuncWithVars: varList	"creation of a new anonymous variadic funcTerm"	^self basicNew initialize: (self getNewFuncName) Variables:varList.! !!FuncTerm class methodsFor: 'instance creation' stamp: 'pm 10/28/2018 14:46'!new: symbo Variables: setOfLinkedVar	"creation of a new named variadic funcTerm"	^self basicNew initialize:symbo Variables: setOfLinkedVar.! !!FuncTerm class methodsFor: 'instance creation' stamp: 'pm 10/28/2018 14:44'!getNewFuncName	"Generator of anonymous function names. Used during skolemnisation"	currentFuncNumber :=currentFuncNumber +1.	^anonymousFuncSymb,(currentFuncNumber asString).! !!FuncTerm class methodsFor: 'instance creation' stamp: 'pm 10/28/2018 14:45'!new	"creation of a new anonymous funcTerm"	^(self basicNew) initialize: (self getNewFuncName).! !!FuncTerm class methodsFor: 'instance creation' stamp: 'pm 10/28/2018 14:46'!new: symbo Variable: aVar	"creation of a new named funcTerm, with a term 'f(x)'"	^self basicNew initialize:symbo Variable: aVar.! !!FuncTerm class methodsFor: 'instance creation' stamp: 'pm 10/28/2018 14:47'!newFunc: variable	"creation of a new anonymous funcTerm, with a variable"	^self basicNew initialize: (self getNewFuncName) Variable:variable.! !!FuncTerm class methodsFor: 'instance creation' stamp: 'pm 10/28/2018 14:46'!new: symbo	"creation of a new named empty funcTerm "	^self basicNew initialize:symbo.! !!FuncTerm class methodsFor: 'initialization' stamp: 'pm 10/28/2018 14:45'!initialize	"Initialization of the class."	currentFuncNumber:=0."we start anonymous functions number at 0."	anonymousFuncSymb:='f'."mutable anonymous function name."! !LinkedList subclass: #LinkedListFix	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!LinkedListFix commentStamp: 'pm 10/22/2018 10:04' prior: 0!Only exists because the basic LinkedList implementation of at:put: is weird, and create a infinite loop if you add twice the same object.That override fixes that.!!LinkedListFix methodsFor: 'accessing' stamp: 'pm 10/22/2018 09:43'!at:index put: anObject	"Override since the basic one seems to rather do a infinite loop for no reason."	| currentLink i |	currentLink:=self firstLink.	i:=1. 	[(index=(i)) and:[(currentLink isNil) not]]	whileFalse:[		i:=i+1.		currentLink:=currentLink nextLink.		].		(currentLink isNil)	ifTrue:[^self error:'index out of bound']	ifFalse:[currentLink value: anObject ].! !LinkedListFix subclass: #MinimalOrderedSet	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!MinimalOrderedSet commentStamp: 'pm 10/9/2018 10:08' prior: 0!I'm a ordered set, using a LinkedList. I'm a linked list which only override the method 'add' so i can be considered as a set.I also give access to a way to find an object via haveYouSeenThisObject.cf LinkedList.Public API and Key Messages- add: anObject (add an object IF it's not in the set)- haveYouSeenThisObject: anObject (search for an element in the set- To create instances , cf LinkedListp:=MinimalOrderSet new.p add: 1 >> "p contains { 1 }" p add : 1 >> "p contains { 1 }"p haveYouSeenThisObject: 1 >> "true"p haveYouSeenThisObject: 2 >> "false"!!MinimalOrderedSet methodsFor: 'search' stamp: 'pm 10/11/2018 13:02'!haveYouSeenThisObject: anObject 	"search for the object"	self do: [ :each | 		(each=anObject) 		ifTrue:["Transcript cr;show:each prettyPrint;cr".			^true.]		].	^false.! !!MinimalOrderedSet methodsFor: 'adding' stamp: 'pm 10/28/2018 15:16'!merge: anotherMinimalOrderedSet	"Merge of two MinimalOrderedSet"	anotherMinimalOrderedSet do:[:each | self add:each.].	^self.! !!MinimalOrderedSet methodsFor: 'adding' stamp: 'pm 10/28/2018 15:15'!add: anObject	"Override to add the set component on a LinkedList"	self do: [ :each | 		(each=anObject) 		ifTrue:[^self]"Object's already in, we're done"		].	 super add: anObject."we let LinkedList add the object"	^self."to be chainable"! !MinimalOrderedSet subclass: #ClausalForm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!ClausalForm commentStamp: 'pm 10/28/2018 15:21' prior: 0!I represent a clausal form, which means i'm a long 'and' statement with 'or' as my propositions(Clauses).I inherit from a set, because i only want to have one of each clause object inside me.I'm conceived to be instanciated by  the method "amIValid, of propositions"I know my clauses (which are represented by the class Clause)My responsability is to use the resolution method on myselfPublic API and Key Messages- resolutionMethod : I'm using the resolutionMethod on myselfI can be created empty or with a Prop object as input.ClausalForm new: aFullProp. !!ClausalForm methodsFor: 'resolution' stamp: 'pm 10/26/2018 22:45'!resolutionMethod	| sat c r |	sat:=MinimalOrderedSet new.	[self isEmpty]	whileFalse:[		Transcript show:self;cr.		c:=self removeFirst.		c isEmptyClause		ifTrue:[^true.]."Insatisfiable""TODO"   ((c isTautology) or:[sat contains:[:each|each=c.]])"ifTrue:[skip]"			ifFalse:[				r:=Resolvante new.				r factorisation:c.				sat do:[:c1|					r resolvante: c1 with: c.					].				self addFromList:r.				sat addLast:c.			].			].	^false."satisfiable"! !!ClausalForm methodsFor: 'initialization' stamp: 'pm 10/28/2018 15:27'!initialize: clausifiedFormula	"initialize a clausal form from a clausified Prop object"	self addAll: clausifiedFormula.! !!ClausalForm methodsFor: 'initialization' stamp: 'pm 10/28/2018 15:27'!prettyPrint	"toString"	|t|	t:='{'.		self do: [  :each | t:=t,(each prettyPrint). ] separatedBy: [t:=t,','].	t:=t,'}'.	^t.! !!ClausalForm methodsFor: 'adding' stamp: 'pm 10/28/2018 15:25'!addFromList: aLinkedList	"add a list of clauses"	aLinkedList do:[:each|		self add: each.		].! !!ClausalForm methodsFor: 'adding' stamp: 'pm 10/28/2018 15:19'!addAll: clausifiedProp	"badly designed, NEEDS a refactor."						((clausifiedProp  isOr) | (clausifiedProp isAtome))"If i'm in a or, there's only or(s) under him."	ifTrue:[self add: (Clause new:clausifiedProp)]	ifFalse:[		(clausifiedProp isNot)		ifTrue:[			((clausifiedProp operand) isAtome)			ifTrue:[^self add:(Clause new:clausifiedProp).]			ifFalse:[^Error new:'A not isn''t englobing an atome.'.].			]		ifFalse:[			(clausifiedProp isAnd)			ifTrue:[				self addAll: (clausifiedProp left).				self addAll: (clausifiedProp right).				]		ifFalse:[			Error new: 'Tried to add a non clause object to a clausaleForm.'.].			].		].! !!ClausalForm methodsFor: 'adding' stamp: 'pm 10/28/2018 15:21'!add: aClause	"add a new clause in self."	(aClause isKindOf: Clause)	ifTrue: [ super add: aClause ]	ifFalse:[Error new: 'Tried to add a non clause object to a clausaleForm'].	^self "enable chaining operation"! !!ClausalForm methodsFor: 'printing' stamp: 'pm 10/28/2018 15:27'!printOn: stream	"override to be shown on transcripts"	stream nextPutAll: (self prettyPrint).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClausalForm class	instanceVariableNames: ''!!ClausalForm class methodsFor: 'instance creation' stamp: 'pm 10/28/2018 15:18'!new: ClausaleProposition	"Creation of a clausal form, and add everything in a Clausified Prop."	^self basicNew initialize:ClausaleProposition.! !!ClausalForm class methodsFor: 'instance creation' stamp: 'pm 10/28/2018 15:17'!new	"Object creation of an empty Clausal Form"	^self basicNew initialize.! !MinimalOrderedSet subclass: #Clause	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Clause commentStamp: 'pm 10/28/2018 15:21' prior: 0!I represent a clause, which is a set of predicate (positive or negative)  related by a variadic Or operator.Build on top of a Set, to avoid redundancy.I should be instanciated by ClausalForm only.!!Clause methodsFor: 'adding' stamp: 'pm 10/28/2018 15:28'!add: var	(var isAtome)	ifTrue:[		super add:var.		^self."able chaining operation"		]	ifFalse:[			^self error: 'Trying to add a wrong type in a clause'.		].! !!Clause methodsFor: 'adding' stamp: 'pm 10/25/2018 08:44'!addAll: orProp	(orProp isAtome)	ifTrue:[self add:orProp.]	ifFalse:[		((orProp) isNot)		ifTrue:["we're in a not"			(orProp operand isAtome)				ifTrue:["we're in an atom"					((orProp operand) isPredicate)					ifTrue:[self add:(NotPredicate new: (orProp operand) getSymb fromList: (orProp operand) terms).]					ifFalse:[						((orProp operand) isVar)						ifTrue:[self add:(NotVar new:((orProp operand) getSymb)).]						ifFalse: [ Error new: 'shouldn''t be any True or false here' ]].						]				ifFalse:[					Error new:'Error, shouldn''t be any more not ( binaryOp )'				].			]		ifFalse:[			(orProp isOr)			ifTrue:[				self addAll: (orProp left).				self addAll: (orProp right).				]			ifFalse:["switch to Error new:"				Error new:'Error, shouldn''t be any other kind of prop here.'.				].			].		].! !!Clause methodsFor: 'adding' stamp: 'pm 10/26/2018 16:52'!without:index1 nor:index2	|i resClause|	resClause:=Clause new.	i:=1.		[i<=self size]	whileTrue:[		(i~=index1 and:[i~=index2])		ifTrue:[			resClause add:(self at:i).			].		i:=i+1.		].	^resClause ! !!Clause methodsFor: 'adding' stamp: 'pm 10/26/2018 16:52'!without:index	|i resClause|	resClause:=Clause new.	i:=1.		[i<=self size]	whileTrue:[		(i~=index)		ifTrue:[			resClause add:(self at:i).			].		i:=i+1.		].	^resClause ! !!Clause methodsFor: 'adding' stamp: 'pm 10/26/2018 21:46'!addFromList: aLinkedList	aLinkedList do:[:each|		self add: each.		].! !!Clause methodsFor: 'printing' stamp: 'pm 10/25/2018 18:40'!printOn: stream	stream nextPutAll: (self prettyPrint).! !!Clause methodsFor: 'printing' stamp: 'pm 10/25/2018 18:41'!prettyPrint	|t|	t:='{'.	self do:[  :each | t:=t,(each prettyPrint). ] separatedBy:[t:=t,','].	t:=t,'}'.	^t.! !!Clause methodsFor: 'initialize' stamp: 'pm 10/25/2018 18:41'!initialize: OrProp	self addAll:OrProp.! !!Clause methodsFor: 'testing' stamp: 'pm 10/26/2018 21:15'!isEmptyClause	^self isEmpty.! !!Clause methodsFor: 'testing' stamp: 'pm 10/25/2018 18:41'!isTautology	self do:[ :p1 |		self do:[ :p2 | 			(p1 isOpposite: p2)			ifTrue:[^true].			].		].	^false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Clause class	instanceVariableNames: ''!!Clause class methodsFor: 'instance creation' stamp: 'pm 10/28/2018 15:18'!new: OrProp	"creation of a new clause of a OrProp"	^self basicNew initialize:OrProp.! !Object subclass: #Pair	instanceVariableNames: 'left right'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Pair commentStamp: '<historical>' prior: 0!Basic implementation of the Pair data-structure!!Pair methodsFor: 'printing' stamp: 'pm 10/18/2018 16:29'!printOn: aStream	aStream nextPutAll: (self prettyPrint)! !!Pair methodsFor: 'printing' stamp: 'pm 10/15/2018 16:47'!prettyPrint	^'(',(self left prettyPrint),',',(self right prettyPrint),')'.! !!Pair methodsFor: 'printing' stamp: 'pm 10/18/2018 15:27'!prettyPrintUnifier	^'(',(self left prettyPrint),'=',(self right prettyPrint),')'.! !!Pair methodsFor: 'initialize-release' stamp: 'pm 10/15/2018 16:26'!left:l right:r	left:=l.	right:=r.! !!Pair methodsFor: 'comparing' stamp: 'pm 10/18/2018 16:31'!= anotherPair	^(self left)=(anotherPair left) and:[(self right)=(anotherPair right)].! !!Pair methodsFor: 'accessing' stamp: 'pm 10/15/2018 16:23'!right: anObject	right:=anObject.	^right! !!Pair methodsFor: 'accessing' stamp: 'pm 10/15/2018 16:22'!left: anObject	left:=anObject.	^left! !!Pair methodsFor: 'accessing' stamp: 'pm 10/15/2018 16:23'!right	^right! !!Pair methodsFor: 'accessing' stamp: 'pm 10/15/2018 16:22'!left	^left! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Pair class	instanceVariableNames: ''!!Pair class methodsFor: 'initialize-release' stamp: 'pm 10/15/2018 16:25'!left:l right:r	^(self basicNew) left:l right:r.! !Object subclass: #Prop	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Prop commentStamp: 'pm 10/9/2018 10:52' prior: 0!Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.I allow a proposition to be clausified.I allow propositions of First order to be skolemnise, then clausifiedPublic API:- FullClausification -> return a Clausified version of  a Proposition- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)- PrettyPrint -> returns a string representing my  internal state.!!Prop methodsFor: 'testing' stamp: 'pm 10/26/2018 18:38'!factorisationUnitTest	|r fc|	Prop testInc.	self assert:[self isClause.].		Transcript show: 'test #'; show:(Prop testNumber);cr.	Transcript show: 'Trying to factorise ';show: self;cr.		fc:=ClausalForm new:self.	r:=Resolvante new.	r factorisation: (fc at:1).			Transcript show:r;cr;cr;cr.! !!Prop methodsFor: 'testing' stamp: 'pm 9/30/2018 12:34'!matchingUnitTest: prop	"self will be considered as a pattern"	Transcript cr;		show: 'prop : ' ; 		show: (prop prettyPrint);		cr;		show: 'pattern : ';		show: (self prettyPrint);		cr.		(self matchPatternWith: prop)			ifTrue:[ Transcript show: 'matched!!';cr.]			ifFalse:[ Transcript show: 'didn''t match!!';cr]	! !!Prop methodsFor: 'testing' stamp: 'pm 10/25/2018 08:37'!unificationUnitTest: otherPredicate	|t newPair|	Prop testInc.	Transcript show: 'test #'; show:(Prop testNumber);cr.	Transcript show: 'Trying to Unify ';show: self; show:' and ';show: otherPredicate;cr.	t:=Unifier new: self Predicate2: otherPredicate.	newPair:=t unifiedPair.	(t hasFailed)	ifFalse:[		Transcript show:newPair;cr;cr.	]	ifTrue:[		Transcript show: 'Unification failed.';cr;cr.		].	^t! !!Prop methodsFor: 'testing' stamp: 'pm 10/26/2018 22:12'!SkolemnisationTest	|t|	Prop testInc.		Transcript show: 'test #'; show:(Prop testNumber);cr.	Transcript show: 'initial: '; show: self prettyPrint; cr.	t:=self StartSkolemnisation.	Transcript show: 'Skolemn: ';show: t prettyPrint;cr.	t:=t fullClausification.	Transcript show: 'Clausified:';show: t prettyPrint ;cr.	t:=ClausalForm new:t.	Transcript show: 'ClausalForm:';show: t prettyPrint ;cr.	t:=t resolutionMethod.	Transcript show:'Resolution method:' ;show:t;cr;cr;cr.	^t ! !!Prop methodsFor: 'testing' stamp: 'pm 10/26/2018 18:35'!resolvanteUnitTest: anotherClause	"We expect self and anotherClause to be clauses, or at minimal a clausal form."	|r fc1 fc2|	self assert: [ self isClause ].	anotherClause assert:[ self isClause ].		Prop testInc.	Transcript show: 'test #'; show:(Prop testNumber);cr.	fc1:=ClausalForm new:self.	fc2:=ClausalForm new:anotherClause.	Transcript show: 'Trying to resolve ';show: fc1 ; show:' with ';show: fc2; cr.	r:=Resolvante new.		r resolvante: (fc1 at:1) with: (fc2 at:1).	Transcript show:r;cr;cr;cr.! !!Prop methodsFor: 'testing' stamp: 'pm 10/9/2018 13:33'!clausificationUnitTest	|t|	Transcript show: self prettyPrint; show: '  ' ;show: self isClause; cr.	t:=self fullClausification.	Transcript show: t prettyPrint; show: '  ' ;show: t isClause; cr;cr.	^t.! !!Prop methodsFor: 'testing' stamp: 'pm 10/9/2018 12:25'!propUnitTest	Transcript show: self prettyPrint; show: '  ' ;show: self isClause; cr; cr.	^self! !!Prop methodsFor: 'resolution' stamp: 'pm 10/27/2018 08:33'!amIValid	|t treatedProp|	Prop testInc.		Transcript show:'Is ';show: self; show:' valid?';cr.		treatedProp:=Not new:self.		(Prop resolutionTrace)ifTrue:[Transcript show: 'initial: '; show: self prettyPrint; cr.].	t:=treatedProp StartSkolemnisation.	(Prop resolutionTrace)ifTrue:[Transcript show: 'Skolemn: ';show: t prettyPrint;cr.].	t:=t fullClausification.	(Prop resolutionTrace)ifTrue:[Transcript show: 'Clausified:';show: t prettyPrint ;cr.].	t:=ClausalForm new:t.	(Prop resolutionTrace)ifTrue:[Transcript show: 'ClausalForm:';show: t prettyPrint ;cr.].	t:=t resolutionMethod.	Transcript show:'Resolution method:' ;show:t;cr;cr;cr.	^t ! !!Prop methodsFor: 'matching' stamp: 'pm 9/30/2018 10:16'!compareSymbol: otherProp	^(self getSymb = otherProp getSymb) ! !!Prop methodsFor: 'matching' stamp: 'pm 9/30/2018 09:09'!matchPatternWith: prop	"Match self and prop. to end a branch of the pattern	use a random variable	var == whatever	anythingElse == anythingElse only :  !!n => T == !!(A /\ B)=> T for example	"	^SubclassResponsibility.! !!Prop methodsFor: 'testing-properties' stamp: 'pm 10/23/2018 07:28'!isAtome	^false.! !!Prop methodsFor: 'testing-properties' stamp: 'pm 10/23/2018 07:29'!isFalse_Const	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 10/23/2018 07:29'!isVar	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 10/23/2018 07:31'!isQuantifier	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 10/23/2018 07:31'!isExists	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 10/23/2018 07:29'!isNotPredicate	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 10/23/2018 07:31'!isConstant	^false.! !!Prop methodsFor: 'testing-properties' stamp: 'pm 10/23/2018 07:30'!isEqual	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 10/23/2018 07:30'!isOperator	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 10/23/2018 07:28'!isConst	^false.! !!Prop methodsFor: 'testing-properties' stamp: 'pm 10/23/2018 07:30'!isImply	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 10/23/2018 07:30'!isNot	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 10/23/2018 07:30'!isAnd	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 10/23/2018 07:30'!isBinaryOperator	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 10/23/2018 07:29'!isPredicate	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 10/23/2018 07:29'!isNotVar	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 10/23/2018 07:28'!isProp	^true.! !!Prop methodsFor: 'testing-properties' stamp: 'pm 10/23/2018 07:30'!isOr	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 10/23/2018 07:29'!isPositivePredicate	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 10/23/2018 07:31'!isForAll	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 10/23/2018 07:29'!isTrue_Const	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 10/23/2018 07:29'!isNegativePredicate	^false! !!Prop methodsFor: 'testing-properties' stamp: 'pm 10/23/2018 07:30'!isUnaryOperator	^false! !!Prop methodsFor: 'Skoleminsation' stamp: 'pm 10/7/2018 11:25'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	^SubclassResponsibility.! !!Prop methodsFor: 'Skoleminsation' stamp: 'pm 10/7/2018 11:31'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	^SubclassResponsibility.! !!Prop methodsFor: 'Skoleminsation' stamp: 'pm 10/6/2018 18:09'!HerbranSkolemDocu	^Error new:'documentation of Skolemnisation'.	"return that prop skolemnised"! !!Prop methodsFor: 'Skoleminsation' stamp: 'pm 10/7/2018 19:40'!StartSkolemnisation	| set aMap |	set:=MinimalOrderedSet new.	aMap:=Dictionary new.	^self Skolemnise: set CorrespondingValue: aMap! !!Prop methodsFor: 'clausification' stamp: 'pm 9/29/2018 08:21'!isClause	^SubclassResponsibility ! !!Prop methodsFor: 'clausification' stamp: 'pm 9/30/2018 20:06'!clausification	"Only one iteration over the full formula."	"Basic empty comportement for atomes mostly. (only?)"! !!Prop methodsFor: 'clausification' stamp: 'pm 10/1/2018 10:58'!fullClausification	| t |	t:=self clausification.	[t isClause] whileFalse:[			(Prop debug) ifTrue:[Transcript show: t prettyPrint; show: t isClause;cr.].		t:=t clausification.].	^t! !!Prop methodsFor: 'accessing' stamp: 'pm 9/28/2018 22:42'!getSymb	^SubclassResponsibility. ! !!Prop methodsFor: 'printing' stamp: 'pm 10/18/2018 15:46'!printOn: aStream	aStream nextPutAll: (self prettyPrint).! !!Prop methodsFor: 'printing' stamp: 'pm 10/9/2018 11:31'!prettyPrint	"return the internal representation of Proposition"	^SubclassResponsibility ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Prop class	instanceVariableNames: 'debug debugUnification testNumber unifDone resolutionTrace'!!Prop class methodsFor: 'initialization' stamp: 'pm 10/27/2018 08:05'!initialize	debug:=false.	debugUnification:=false.	resolutionTrace:=true.	testNumber:=0.! !!Prop class methodsFor: 'accessing' stamp: 'pm 10/27/2018 08:05'!resolutionTrace	^resolutionTrace! !!Prop class methodsFor: 'accessing' stamp: 'pm 10/11/2018 16:25'!testNumber	^testNumber! !!Prop class methodsFor: 'accessing' stamp: 'pm 10/18/2018 18:16'!debugUnification	^debugUnification! !!Prop class methodsFor: 'tests' stamp: 'pm 10/11/2018 16:25'!testInc	testNumber:=testNumber+1.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/26/2018 20:50'!testingResolvante 	"everything is tested in those few lines"	"Binary"	|l r|		Transcript show: 'Testing resolvante related stuff';cr.		Transcript show:'Basics';cr.	Transcript show:'Class exemple.';cr.	l:=Or new: (Predicate new: 'P' variable: (LinkedTerm new:(Term new:'x')))	 rightProp: (Predicate new: 'Q' variable: (LinkedTerm new:(Term new:'x'))).	r:=Or new: (Not new: (Predicate new: 'P' variable: (ConstTerm new:(Term new:'a'))))	 rightProp: (Not new: (Predicate new: 'Q' variable: (ConstTerm new:(Term new:'a')))).		l resolvanteUnitTest:r.	Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/5/2018 16:54'!testingMatch	|pattern prop|   "Transcript clear."	Transcript show: 'Testing matching related stuff'.		pattern:= Imply new: (True_Const new) rightProp: (Predicate new: 'P' variable: 'a').	prop:= Imply new: (True_Const new) rightProp: (Not new:(Predicate new: 'P' variable: 'a')).	pattern matchingUnitTest: prop.		pattern:= Imply new: (True_Const new) rightProp: (False_Const  new).	prop:= Imply new: (True_Const new) rightProp: (Not new:(Predicate new: 'P' variable: 'a')).	pattern matchingUnitTest: prop.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/27/2018 08:27'!testEverything	Transcript clear.	Prop initEverything.	"Prop testingProp."	"Prop testingMatch."	"Prop testingClausification."	Prop testingFactorisation.	Prop testingResolvante.	Prop testingUnification.	Prop testingSkolemn.	Prop testingResolutionMethod.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/5/2018 00:09'!testingClausification 	"everything is tested in those few lines"	"Binary"	| p |	"	Transcript clear."	Transcript show: 'Testing clausification related stuff';cr.		p:=And new: (Var new: 'a') rightProp: (False_Const new).	p clausificationUnitTest.	p:=Or new: (Var new: 'a') rightProp: (False_Const new).	p clausificationUnitTest.	p:=Equal new: (Var new: 'a') rightProp: (True_Const new).	p clausificationUnitTest.		p:=Imply new: (Var new: 'a') rightProp: (True_Const new).	p clausificationUnitTest.	"unary"	p:=Not new: (Var new: 'a').	p clausificationUnitTest.		Transcript show: 'Bit more complicated stuff!!';cr.		p:=Imply new: (Equal new: (Not new: (Var new: 'a')) rightProp: (Var new: 'b')) rightProp: (False_Const new).	p clausificationUnitTest.			Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/22/2018 10:05'!testingUnification 	"everything is tested in those few lines"	"Binary"	|t l r|		Transcript show: 'Testing Unification related stuff';cr.		Transcript show:'Basics';cr.		Transcript show:'decompositions';cr.	l:=Predicate new: 'P' variable: (ConstTerm new:(Term new:'a')).	r:=Predicate new: 'P' variable: (ConstTerm new:(Term new:'b')).	l unificationUnitTest:r.	Transcript show:'delete';cr.	l:=Predicate new: 'P' variable: (ConstTerm new:(Term new:'a')).	r:=Predicate new: 'P' variable: (ConstTerm new:(Term new:'a')).	l unificationUnitTest:r.		Transcript show:'conflict';cr.	l:=Predicate new: 'Q' variable: (ConstTerm new:(Term new:'a')).	r:=Predicate new: 'P' variable: (ConstTerm new:(Term new:'a')).	l unificationUnitTest:r.	Transcript show:'swap';cr.	l:=Predicate new: 'P' variable: (FuncTerm new: 'f' Variable: (ConstTerm new: (Term new: 'a'))).	r:=Predicate new: 'P' variable: (LinkedTerm new:(Term new:'x')).	l unificationUnitTest:r.	"G{f(x,g(x))=f(a,g(a))}"	Transcript show:'Exemple	david #2';cr.	t:=LinkedList new.	t add: (LinkedTerm new:(Term new:'x'));add:(FuncTerm new:'g' Variable: (LinkedTerm new:(Term new:'x'))).	l:=Predicate new: 'P' variable: (FuncTerm new: 'f' Variables:t).	t:=LinkedList new.	t add:(ConstTerm new:(Term new:'a')) ;add:(FuncTerm new:'g' Variable:(ConstTerm new:(Term new:'a'))).	r:=Predicate new: 'P' variable: (FuncTerm new: 'f' Variables:t).	l unificationUnitTest:r.		"G{f(x,g(a))=f(b,g(y))}"	Transcript show:'Exemple david #1';cr.	t:=LinkedList new.	t add: (LinkedTerm new:(Term new:'x'));add:(FuncTerm new:'g' Variable: (ConstTerm new:(Term new:'a'))).	l:=Predicate new: 'P' variable: (FuncTerm new: 'f' Variables:t).	t:=LinkedList new.	t add:(ConstTerm new:(Term new:'b')) ;add:(FuncTerm new:'g' Variable:(LinkedTerm new:(Term new:'y'))).	r:=Predicate new: 'P' variable: (FuncTerm new: 'f' Variables:t).	l unificationUnitTest:r.			"should replace x by y at the end of the unification"	Transcript show:'x alias y';cr.	t:=LinkedList new.	t add: (LinkedTerm new:(Term new:'y'));add:( LinkedTerm new:(Term new:'x'));add:(ConstTerm new:(Term new:'a')).	l:=Predicate new: 'P' variable: (FuncTerm new: 'f' Variables:t).	t:=LinkedList new.	t add: (LinkedTerm new:(Term new:'x'));add:(LinkedTerm new:(Term new:'y'));add:(LinkedTerm new:(Term new:'x')).	r:=Predicate new: 'P' variable: (FuncTerm new: 'f' Variables:t).	l unificationUnitTest:r.			Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/1/2018 10:58'!debug	^debug! !!Prop class methodsFor: 'testing' stamp: 'pm 10/27/2018 09:13'!testingResolutionMethod 	"everything is tested in those few lines"	"Binary"	|p|		Transcript show: 'Testing Unification related stuff';cr.		Transcript show:'Course proposition';cr.		Transcript show:'#1';cr.	p:=Exists new: 'x' Property: (		Imply new:			(Predicate new: 'P' variable: (Term new:'x'))		rightProp:			(And new: (Predicate new: 'P' variable: (Term new:'a'))			rightProp:(Predicate new:'P' variable: (Term new:'b')))).	p amIValid.	Transcript show:'#2';cr.	p:=ForAll new: 'x' Property: (		Imply new:			(Predicate new: 'P' variable: (Term new:'x'))		rightProp:			(Exists new: 'y' Property: 			(And new: (Predicate new: 'P' variable: (Term new:'y'))			rightProp:(Predicate new:'P' variable: (Term new:'y'))))).	p amIValid.	Transcript show:'#3';cr.	p:=Imply new:			(Exists new: 'x' Property:				(Or new: (Predicate new: 'P' variable: (Term new:'x'))				rightProp: (Predicate new: 'Q' variable: (Term new:'x'))))		rightProp: 				(Or new:					(Exists new: 'x' Property:						 (Predicate new: 'P' variable: (Term new:'x')))				rightProp:					(Exists new: 'x' Property:						 (Predicate new: 'Q' variable: (Term new:'x')))).	p amIValid.	Transcript show:'#4';cr.	p:=Imply new:			(ForAll new: 'x' Property:				(And new: (Predicate new: 'P' variable: (Term new:'x'))				rightProp: (Predicate new: 'Q' variable: (Term new:'x'))))		rightProp: 			(ForAll new: 'x' Property:				(And new: (Predicate new: 'P' variable: (Term new:'x'))				rightProp: (Predicate new: 'Q' variable: (Term new:'x')))).	p amIValid.		Transcript show:'#5';cr.	p:=Imply new:			(ForAll new: 'x' Property:				(And new: (Predicate new: 'P' variable: (Term new:'x'))				rightProp: (Predicate new: 'Q' variable: (Term new:'x'))))		rightProp: 				(And new:					(ForAll new: 'x' Property:						 (Predicate new: 'P' variable: (Term new:'x')))				rightProp:					(ForAll new: 'x' Property:						 (Predicate new: 'Q' variable: (Term new:'x')))).	p amIValid.		Transcript show:'#6';cr.	p:=Imply new: 			(ForAll new: 'x' Property:				(Not new:					(Predicate new: 'P' variable:(Term new:'x'))))		rightProp: 			(Not new:				(Exists new: 'x' Property:					(Predicate new: 'P' variable:(Term new:'x')))).	p amIValid.		Transcript show:'#7';cr.	p:=Imply new:			(Not new: 				(ForAll new: 'x' Property:					(Predicate new: 'P' variable:(Term new:'x'))))		rightProp: 			(Exists new: 'x' Property:				(Not new:					(Predicate new: 'P' variable:(Term new:'x')))).	p amIValid.		Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/26/2018 22:43'!testingSkolemn 	"everything is tested in those few lines"	"Binary"	| p terms terms2 |		"Transcript clear."	Transcript show: 'Testing Skolemnisation related stuff';cr.		Transcript show: 'basic one #1'.	terms:=LinkedList new.	terms add:(Term new:'x');add:(Term new:'y');add:(Term new:'z').		p:=ForAll new: 'x' Property: (Exists new: 'y' Property: (ForAll new: 'z' Property: (Predicate new: 'P' fromList: terms ))).	p SkolemnisationTest.	Transcript show: 'basic one #2'.	terms:=LinkedList new.	terms add:(Term new:'x');add:(Term new:'z').		p:=Or new: (ForAll new: 'x' Property: (ForAll new: 'z' Property: (Predicate new: 'P' fromList: terms )))	 rightProp: (ForAll new: 'x' Property: (ForAll new: 'z' Property: (Predicate new: 'P' fromList: terms ))).	p SkolemnisationTest.	Transcript show: 'with imply and nested forall.'.	p:=Not new: 		(Imply new: 			(ForAll new: 'x' Property:				(Or new:  					(Predicate new: 'P' variable:(Term new:'x'))					 rightProp:					(Predicate new: 'Q' variable:(Term new:'x'))))			 rightProp:			(Or new: 				(Predicate new: 'P' variable:(Term new:'a'))				rightProp:(Predicate new: 'Q' variable:(Term new:'a')))).	p SkolemnisationTest.				Transcript show: 'same as previous one, but with x representing a variable in one, and a const in the other.'.	p:=Not new:		(Imply new: 			(ForAll new: 'x' Property:				(Or new:  					(Predicate new: 'P' variable:(Term new:'x'))					 rightProp:					(Predicate new: 'Q' variable:(Term new:'x'))))			 rightProp:			(Or new: 				(Predicate new: 'P' variable:(Term new:'x'))				rightProp:(Predicate new: 'Q' variable:(Term new:'x')))).	p SkolemnisationTest.				Transcript show: 'same as previous one, check Unbound Exists is replaced by consts'.	p:=Not new:		(Imply new: 			(Exists new: 'x' Property:				(Or new:  					(Predicate new: 'P' variable:(Term new:'x'))					 rightProp:					(Predicate new: 'Q' variable:(Term new:'x'))))			 rightProp:			(Or new: 				(Predicate new: 'P' variable:(Term new:'x'))				rightProp:(Predicate new: 'Q' variable:(Term new:'x')))).	p SkolemnisationTest.			Transcript show: 'Teacher''s stress test#1' .	p:=Not new:(        ForAll new: 'x' Property:         (Imply new: (ForAll new: 'y' Property: (Predicate new: 'P' variable: (Term new:'y')))         rightProp: (Predicate new:'Q' variable: (Term new:'x')))).        	p SkolemnisationTest.			Transcript show: 'Teacher''s stress test#2'	.	terms:=LinkedList new.    terms add:(Term new: 'x') ; add:(Term new:'z').    terms2:=LinkedList new.    terms2 add:(Term new:'y') ; add: (Term new:'t').    p:=Not new:            (ForAll new: 'x' Property:                (ForAll new: 'y' Property:                    (Exists new: 'z' Property:                         (ForAll new: 't' Property:                             (Imply new:                                 (Predicate new: 'P' fromList: terms)                             rightProp:                                 (Predicate new: 'Q' fromList: terms2)))))).	p SkolemnisationTest.				Transcript show: 'Test functionnal term in initial Predicate '.	terms:=LinkedList new.   terms add:(Term new: 'x') ; add:(FuncTerm new: 'f' Variable: (Term new:'z')).   p:=Not new:            (ForAll new: 'x' Property:                  (Predicate new: 'P' fromList: terms)).	p SkolemnisationTest .		Transcript show: 'Test functionnal term in initial Predicate  with needed inner replacement'.	terms:=LinkedList new.   terms add:(Term new: 'x') ; add:(FuncTerm new: 'f' Variable: (Term new:'y')).   p:=ForAll new: 'x' Property:					(Exists new: 'y' Property:                  (Predicate new: 'P' fromList: terms)).	p SkolemnisationTest.		Transcript show:'Class exemple.';cr.	p:=Imply new: (And new: (Predicate new: 'P' variable:(Term new: 'a'))							rightProp: (Predicate new:'Q' variable:(Term new:'b')))	 rightProp: (Predicate new: 'P' variable:(Term new: 'a')).	p SkolemnisationTest.	Transcript show: 'Done with the testing, did it work? :3' ; cr; cr. ! !!Prop class methodsFor: 'testing' stamp: 'pm 10/8/2018 17:24'!testingProp 	"everything is tested in those few lines"	"Binary"	| p l r|		"Transcript clear."	Transcript show: 'Testing prop related stuff';cr.		Transcript show: 'testing every constructor in a simple way, and if they are clauses:';cr.		p:=Exists new: 'a' Property: (And new: (Predicate new: 'D' variable: (Term new: 'a')) rightProp: (False_Const new)).	p propUnitTest.	p:=Exists new: 'a' Property:(Or new: (Predicate new: 'C' variable:  (Term new: 'a')) rightProp: (False_Const new)).	p propUnitTest.	p:=ForAll new: 'x' Property: (Equal new: (Predicate new: 'A' variable:  (Term new: 'a')) rightProp: (True_Const new)).	p propUnitTest.		p:=ForAll new: 'x' Property: (Imply new: (Predicate new: 'B' variable:  (Term new: 'a')) rightProp: (True_Const new)).	p propUnitTest.	"unary"	p:=Not new: (Predicate new: 'Q' variable: (Term new: 'a')).	p propUnitTest.		Transcript show: 'Bit more complicated stuff!!';cr.		p:=Imply new: (Equal new: (Not new: (Predicate new: 'P' variable:  (Term new: 'a'))) rightProp: (Predicate new: 'P' variable:(Term new: 'b'))) rightProp: (False_Const new).	p propUnitTest.		Transcript show: 'Testing Comparisons on Vars:'; cr.		l:=Predicate new: 'P' variable:  'a'.	r:=Predicate new: 'P' variable:  'b'.	Transcript show: 'is P(a) = P(b) ? ';			show: (l isTheSame: r); cr.	r:=Predicate new: 'Q' variable:  'a'.	Transcript show: 'is var P(a) = Q(a) ? ';		show: (l isTheSame: r); cr.	r:=Predicate new: 'P' variable:  'a'.	Transcript show: 'is P(a) = P(a) ? ';		show: (l isTheSame: r); cr.		Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/8/2018 17:11'!initEverything	"classic logic"	Prop initialize.	Atome initialize.	Constant initialize.	False_Const initialize.	True_Const initialize.	Var initialize.	NotVar initialize.	Operator initialize.	Binary initialize.	And initialize.	Equal initialize.	Imply initialize.	Or initialize.	Unary initialize.	Not initialize.		"Predicate"	Quantifier initialize.	Exists initialize.	ForAll initialize.		"terms"	Term initialize.	ConstTerm initialize.	FuncTerm initialize.	LinkedTerm initialize.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/5/2018 16:33'!testingPropClassic 	"everything is tested in those few lines"	"Binary"	| p l r|		"Transcript clear."	Transcript show: 'Testing prop related stuff';cr.		Transcript show: 'testing every constructor in a simple way, and if they are clauses:';cr.		p:=And new: (Var new: 'a') rightProp: (False_Const new).	p propUnitTest.	p:=Or new: (Var new: 'a') rightProp: (False_Const new).	p propUnitTest.	p:=Equal new: (Var new: 'a') rightProp: (True_Const new).	p propUnitTest.		p:=Imply new: (Var new: 'a') rightProp: (True_Const new).	p propUnitTest.	"unary"	p:=Not new: (Var new: 'a').	p propUnitTest.		Transcript show: 'Bit more complicated stuff!!';cr.		p:=Imply new: (Equal new: (Not new: (Var new: 'a')) rightProp: (Var new: 'b')) rightProp: (False_Const new).	p propUnitTest.		Transcript show: 'Testing Comparisons on Vars:'; cr.		l:=Var new: 'a'.	r:=Var new: 'b'.	Transcript show: 'is var a = b ? ';			show: (l isSameVar: r); cr.	r:=Var new: 'a'.	Transcript show: 'is var a = a ? ';		show: (l isSameVar: r); cr.		Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/26/2018 16:37'!testingFactorisation 	"everything is tested in those few lines"	"Binary"	|c|		Transcript show: 'Testing factorisation related stuff';cr.		Transcript show:'Basics';cr.	Transcript show:'Unifiable positive const & linked predicate';cr.	c:=Or new: (Predicate new: 'P' variable: (ConstTerm new:(Term new:'a')))	 rightProp: (Predicate new: 'P' variable: (LinkedTerm new:(Term new:'x'))).	c factorisationUnitTest.	Transcript show:'Unifiable negative const & linked predicate';cr.	c:=Or new:(Not new: (Predicate new: 'P' variable: (ConstTerm new:(Term new:'a'))))	 rightProp:(Not new: (Predicate new: 'P' variable: (LinkedTerm new:(Term new:'x')))).	c factorisationUnitTest.	Transcript show:'same predicate, different polarity';cr.	c:=Or new: (Predicate new: 'P' variable: (ConstTerm new:(Term new:'a')))	 rightProp: 	(Not new:(Predicate new: 'P' variable: (LinkedTerm new:(Term new:'a')))).	c factorisationUnitTest.	Transcript show:'same predicate, different polarity';cr.	c:=Or new: (Predicate new: 'P' variable: (ConstTerm new:(Term new:'a')))	 rightProp: 	(Not new:(Predicate new: 'P' variable: (LinkedTerm new:(Term new:'a')))).	c factorisationUnitTest.	"add multiple possible resolutions clauses next"	Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !Prop subclass: #Atome	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Atome commentStamp: 'pm 10/9/2018 11:03' prior: 0!I represent an Abstract atome in a Proposition.I factorise some proprieties.!!Atome methodsFor: 'clausification' stamp: 'pm 9/29/2018 08:25'!isClause	^true! !!Atome methodsFor: 'printing' stamp: 'pm 9/28/2018 20:26'!prettyPrint	^self getSymb! !!Atome methodsFor: 'testing' stamp: 'pm 10/5/2018 23:12'!isSkolem	^true.! !!Atome methodsFor: 'testing' stamp: 'pm 10/23/2018 07:31'!isAtome	^true! !Atome subclass: #Constant	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Constant commentStamp: 'pm 10/9/2018 11:07' prior: 0!True and False constants, to represent them in Propositions!!Constant methodsFor: 'Skoleminsation' stamp: 'pm 10/7/2018 19:50'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	^self.! !!Constant methodsFor: 'Skoleminsation' stamp: 'pm 10/7/2018 19:50'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	^self.! !!Constant methodsFor: 'testing' stamp: 'pm 10/23/2018 07:32'!isConstant	^true! !!Constant methodsFor: 'accessors' stamp: 'pm 9/28/2018 22:30'!getSymb	^(self class symb)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Constant class	instanceVariableNames: 'symb'!Constant subclass: #False_Const	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!False_Const commentStamp: '<historical>' prior: 0!False const!!False_Const methodsFor: 'matching' stamp: 'pm 9/30/2018 09:45'!matchPatternWith: prop	"see Prop comment for usage."	^prop isKindOf: False_Const! !!False_Const methodsFor: 'testing' stamp: 'pm 10/23/2018 07:32'!isFalseConst	^true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!False_Const class	instanceVariableNames: ''!!False_Const class methodsFor: 'accessing' stamp: 'pm 9/28/2018 21:18'!symb	^symb! !!False_Const class methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!initialize	symb:='F'.! !Prop subclass: #Operator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Operator commentStamp: 'pm 10/9/2018 10:48' prior: 0!I represent an operator whith an unknown number of argument.I only factorise a method for now, but I allow possible future evolutions.!!Operator methodsFor: 'testing' stamp: 'pm 10/23/2018 07:34'!isOperator	^true! !!Operator methodsFor: 'print' stamp: 'pm 9/28/2018 20:26'!getSymb	^(self class symb)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Operator class	instanceVariableNames: 'symb'!!Operator class methodsFor: 'accessing' stamp: 'pm 10/4/2018 23:44'!symb	^symb.! !Operator subclass: #Binary	instanceVariableNames: 'left right'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Binary commentStamp: 'pm 10/9/2018 10:55' prior: 0!I represent a Abstract binary operatorI factorise some of the attributes part of future operators.Public API and Key Messages- left & right -> accessors.- new: rightProp: -> create a binary operatorexample of initialization.BinaryOpClass new: (aPropClass newOperator) 			    rightProp: (aPropClass newOperator).			!!Binary methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!initialize: leftProp rightProp: rp	left:=leftProp.	right:=rp.	! !!Binary methodsFor: 'testing' stamp: 'pm 10/23/2018 07:34'!isBinaryOperator  	^true! !!Binary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:27'!right: replacement	right:=replacement.	^right! !!Binary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:27'!left: replacement	left:=replacement.	^left! !!Binary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:26'!left	^left! !!Binary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:27'!right	^right! !!Binary methodsFor: 'matching' stamp: 'pm 9/30/2018 12:00'!matchPatternWith: prop	(self compareSymbol: prop)		ifTrue:[			^(left matchPatternWith: (prop left))			& (right matchPatternWith: (prop right))			]		ifFalse:[^false].! !!Binary methodsFor: 'printing' stamp: 'pm 9/30/2018 12:15'!prettyPrint	^((left isKindOf: Atome) ifTrue:[' '] ifFalse:[' (']) ,		left prettyPrint,		((left isKindOf: Atome) ifTrue:[' '] ifFalse:[') ']) ,		self getSymb,		((right isKindOf: Atome) ifTrue:[' '] ifFalse:[' (']) ,		right prettyPrint,		((right isKindOf: Atome) ifTrue:[' '] ifFalse:[') ']).! !!Binary methodsFor: 'clausification' stamp: 'pm 9/29/2018 08:39'!isClause	"false unless it's a or/and"	^false! !!Binary methodsFor: 'Skoleminsation' stamp: 'pm 10/9/2018 09:21'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) 			rightProp: (self right Herbrandise: setOfLinkedVar CorrespondingValue: aMap ).		"We pass veryDeepCopys to the leftProp, so each branch has it's own collections"! !!Binary methodsFor: 'Skoleminsation' stamp: 'pm 10/9/2018 09:21'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	^(self class) new: (self left Skolemnise: (setOfLinkedVar veryDeepCopy)  CorrespondingValue: (aMap veryDeepCopy)) 			rightProp: (self right Skolemnise: setOfLinkedVar CorrespondingValue: aMap).			"Works for at least Or & And. Maybe Equal?"				"We pass veryDeepCopys to the leftProp, so each branch has it's own collections"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Binary class	instanceVariableNames: ''!!Binary class methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!new: leftProp rightProp: rp	^self basicNew initialize: leftProp rightProp: rp.! !Binary subclass: #And	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!And commentStamp: 'pm 10/9/2018 11:29' prior: 0!I represent an And proposition!!And methodsFor: 'clausification' stamp: 'pm 9/29/2018 08:40'!isClause	^(left isClause & right isClause)! !!And methodsFor: 'clausification' stamp: 'pm 10/1/2018 11:09'!clausification	| t |	t:=nil. 	((And patternFalse) matchPatternWith: self)	ifTrue:[t:=right]	ifFalse:[		((And patternFalseSym) matchPatternWith: self)		ifTrue:[t:=left]		ifFalse:[			((And patternTrue) matchPatternWith: self)			ifTrue:[t:=left]			ifFalse:[				((And patternTrueSym) matchPatternWith: self)				ifTrue:[t:=right]				ifFalse:["					((And patternOr) matchPatternWith: self)					ifTrue:[t:=Or new: (And new: ((self left) left) rightProp: (self right)) 								  rightProp: (And new:((self left) right) rightProp: (self right))]					ifFalse:[						((And patternOrSym) matchPatternWith: self)						ifTrue:[t:=Or new:(And new: (self left) rightProp: ((self right) left)) 									  rightProp: (And new: (self left) rightProp: ((self right) right))].						]					"]				]			]		].		(t isNil) ifTrue:[ (Prop debug) ifTrue:[Transcript show:'in And';show: self prettyPrint;cr.].			self left:(left clausification).								self right:(right clausification).								^self]					 ifFalse:[(Prop debug) ifTrue:[Transcript show:'in And2';show: t prettyPrint;cr.].						^t "clausification"]. ! !!And methodsFor: 'testing' stamp: 'pm 10/23/2018 07:34'!isAnd	^true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!And class	instanceVariableNames: 'patternOr patternOrSym patternTrue patternTrueSym patternFalse patternFalseSym'!!And class methodsFor: 'initialize' stamp: 'pm 10/3/2018 20:06'!initialize	symb:='/\'.	patternOr:=And new: (Or new: (Var new: 'a') rightProp: (Var new:('a')))  rightProp: (Var new: 'a').	patternOrSym:=And new: (Var new: 'a') rightProp: (Or new: (Var new: 'a') rightProp: (Var new:('a'))).	patternTrue:=And new: (Var new: 'a') rightProp: (True_Const new).	patternTrueSym:=And new: (True_Const new) rightProp:(Var new:'a').	patternFalse:=And new: (Var new: 'a') rightProp: (False_Const new).	patternFalseSym:=And new: (False_Const new) rightProp:(Var new:'a').! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternFalse	^patternFalse! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternTrueSym	^patternTrueSym! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternOrSym	^patternOrSym! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternTrue	^patternTrue! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternFalseSym	^patternFalseSym! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternOr	^patternOr! !Binary subclass: #Equal	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Equal commentStamp: 'pm 10/9/2018 11:29' prior: 0!I represent an Equal proposition!!Equal methodsFor: 'clausification' stamp: 'pm 10/1/2018 11:09'!clausification	| t |	t:=Or new: (And new: (self left) rightProp: (self right))		 rightProp: (And new:(Not new: (self left)) rightProp:(Not new: (self right))).	(Prop debug) ifTrue:[Transcript show:'in equal';show: t prettyPrint;cr.].	^t "clausification".! !!Equal methodsFor: 'testing' stamp: 'pm 10/23/2018 07:34'!isEqual	^true! !!Equal methodsFor: 'Skoleminsation' stamp: 'pm 10/27/2018 17:08'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	^(And new: (Imply new: (self left) rightProp: (self right))	 rightProp: (Imply new: (self right) rightProp: (self left))) Herbrandise: setOfLinkedVar CorrespondingValue:aMap.! !!Equal methodsFor: 'Skoleminsation' stamp: 'pm 10/27/2018 17:08'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	^(And new: (Imply new: (self left) rightProp: (self right))	 rightProp: (Imply new: (self right) rightProp: (self left))) Skolemnise:setOfLinkedVar CorrespondingValue:aMap.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Equal class	instanceVariableNames: ''!!Equal class methodsFor: 'initialize' stamp: 'pm 9/30/2018 17:36'!initialize	symb:='<->'.! !Binary subclass: #Imply	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Imply commentStamp: 'pm 10/9/2018 11:29' prior: 0!I represent an Imply  proposition!!Imply methodsFor: 'Skoleminsation' stamp: 'pm 10/9/2018 09:21'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	^(self class) new: (self left Skolemnise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) 			rightProp: (self right Herbrandise: setOfLinkedVar CorrespondingValue: aMap).				"We pass veryDeepCopys to the leftProp, so each branch has it's own collections"! !!Imply methodsFor: 'Skoleminsation' stamp: 'pm 10/9/2018 09:21'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) 			rightProp: (self right Skolemnise: setOfLinkedVar CorrespondingValue: aMap).	"We pass veryDeepCopys to the leftProp, so each branch has it's own collections"! !!Imply methodsFor: 'clausification' stamp: 'pm 10/1/2018 11:09'!clausification	|t|	t:=Or new: (Not new:left)  rightProp: right.	(Prop debug) ifTrue:[Transcript show:'in Imply';show: t prettyPrint;cr.].	^t "clausification".! !!Imply methodsFor: 'testing' stamp: 'pm 10/23/2018 07:34'!isImply	^true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Imply class	instanceVariableNames: ''!!Imply class methodsFor: 'initialize' stamp: 'pm 9/30/2018 17:35'!initialize	symb:='->'.! !Binary subclass: #Or	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Or commentStamp: 'pm 10/9/2018 11:29' prior: 0!I represent an Or proposition!!Or methodsFor: 'testing' stamp: 'pm 10/23/2018 07:35'!isOr	^true! !!Or methodsFor: 'clausification' stamp: 'pm 9/29/2018 08:41'!isClause	^(left isClause & right isClause)! !!Or methodsFor: 'clausification' stamp: 'pm 10/1/2018 11:09'!clausification	| t |	t:=nil. 	((Or patternFalse) matchPatternWith: self)	ifTrue:[t:=left]	ifFalse:[		((Or patternFalseSym) matchPatternWith: self)		ifTrue:[t:=right]		ifFalse:[			((Or patternTrue) matchPatternWith: self)			ifTrue:[t:=right]			ifFalse:[				((Or patternTrueSym) matchPatternWith: self)				ifTrue:[t:=left]				ifFalse:[					((Or patternAnd) matchPatternWith: self)					ifTrue:[t:=And new: (Or new: ((self left) left) rightProp: (self right)) 								  rightProp: (Or new:((self left) right) rightProp: (self right))]					ifFalse:[						((Or patternAndSym) matchPatternWith: self)						ifTrue:[t:=And new:(Or new: (self left) rightProp: ((self right) left)) 									  rightProp: (Or new: (self left) rightProp: ((self right) right))].						]					]				]			]		].		(t isNil) ifTrue:[(Prop debug) ifTrue:[Transcript show:'in Or';show: self prettyPrint;cr.].								self left:(left clausification).								self right:(right clausification).								^self]					 ifFalse:[(Prop debug) ifTrue:[Transcript show:'in Or2';show: t prettyPrint;cr.].						^t "clausification" ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Or class	instanceVariableNames: 'patternAnd patternAndSym patternTrue patternTrueSym patternFalse patternFalseSym'!!Or class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:13'!patternFalse	^patternFalse! !!Or class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:12'!patternTrueSym	^patternTrueSym! !!Or class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:12'!patternAndSym	^patternAndSym! !!Or class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:13'!patternFalseSym	^patternFalseSym! !!Or class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:12'!patternTrue	^patternTrue! !!Or class methodsFor: 'initialize' stamp: 'pm 10/4/2018 08:07'!initialize	symb:='\/'. 	patternAnd:=Or new: (And new: (Var new: 'a') rightProp: (Var new:('a')))  rightProp: (Var new: 'a').	patternAndSym:=Or new: (Var new: 'a') rightProp: (And new: (Var new: 'a') rightProp: (Var new:('a'))).	patternTrue:=Or new: (Var new: 'a') rightProp: (True_Const new).	patternTrueSym:=Or new: (True_Const new) rightProp:(Var new:'a').	patternFalse:=Or new: (Var new: 'a') rightProp: (False_Const new).	patternFalseSym:=Or new: (False_Const new) rightProp:(Var new:'a').! !!Or class methodsFor: 'initialize' stamp: 'pm 9/30/2018 16:11'!patternAnd	^patternAnd! !Atome subclass: #Predicate	instanceVariableNames: 'symb terms'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Predicate commentStamp: 'pm 10/9/2018 11:29' prior: 0!I represent a Predicate with a list of terms,Also in ClausaleForm we'll be representing a Positive predicate.Public API and Key MessagesCan be created two ways :-new: PredicateName Variable:aTerm-new: PredicateName Variables: aListOfTerm!!Predicate methodsFor: 'matching' stamp: 'pm 10/7/2018 17:13'!matchPatternWith: prop	"see Prop's comment for usage."	^true! !!Predicate methodsFor: 'comparing' stamp: 'pm 10/17/2018 12:43'!isSameSymb:AnotherPredicate	^(self getSymb)=(AnotherPredicate getSymb).! !!Predicate methodsFor: 'comparing' stamp: 'pm 10/26/2018 15:49'!isSamePolarity: anotherPredicate	^((anotherPredicate isPredicate) and:[self class = anotherPredicate class])."checking the input"! !!Predicate methodsFor: 'comparing' stamp: 'pm 10/26/2018 16:38'!isOppositePolarity: anotherPredicate	^ anotherPredicate isPredicate	and: [ anotherPredicate class ~= self class ]! !!Predicate methodsFor: 'comparing' stamp: 'pm 10/24/2018 07:22'!=anotherPredicate	| res |	res:=anotherPredicate isKindOf: self class."checking the input"	res:=res and:[(self isSameSymb: anotherPredicate)]."comparing the function symbol"	res:=res and:[self isSameArity: anotherPredicate]."comparing arity"	res:=res and:[(self isSameTerms: anotherPredicate).]."we let the superclass LinkedList check for the correct terms"	^res.! !!Predicate methodsFor: 'comparing' stamp: 'pm 10/17/2018 12:43'!isSameTerms: AnotherPredicate	^(self terms) = (AnotherPredicate terms).! !!Predicate methodsFor: 'comparing' stamp: 'pm 10/24/2018 07:24'!isOpposite: anotherPredicate	| res |	res:=((anotherPredicate isPredicate) and:[(anotherPredicate isKindOf: self class) not])."checking the input"	res:=res and:[(self isSameSymb: anotherPredicate)]."comparing the function symbol"	res:=res and:[self isSameArity: anotherPredicate]."comparing arity"	res:=res and:[(self isSameTerms: anotherPredicate).]."we let the superclass LinkedList check for the correct terms"	^res.! !!Predicate methodsFor: 'adding' stamp: 'pm 10/24/2018 07:25'!replace:x by:t	| i |	i:=1.	[i<=(self arity)]	whileTrue:[		((terms at:i) isKindOf: FuncTerm)		ifTrue: [			"Transcript cr;cr;show:'pouet';cr;cr."			(terms at:i) replace:x by:t.			]		ifFalse:[			((terms at:i)=x)"x is either a ConstTerm or a LinkedTerm, so we need to replace them here rather than let them overview it."			ifTrue:[				terms at:i put:t.				].			].			i:=i+1.		].	^self! !!Predicate methodsFor: 'initialization' stamp: 'pm 10/18/2018 16:44'!initialize: symbl Variables: aLinkedListOfTerm	symb:=symbl.	aLinkedListOfTerm do:[:each| 		(each isKindOf: AbstractTerm)		ifFalse:[Error new:'Predicates needs terms as arguments.'].		].	terms:=aLinkedListOfTerm.! !!Predicate methodsFor: 'initialization' stamp: 'pm 10/22/2018 09:43'!initialize: symbl Variable: aTerm	(aTerm isKindOf: AbstractTerm)	ifFalse:[Error new:'Predicates needs terms as arguments.'].	symb:=symbl.	terms:=LinkedListFix new.	terms add:aTerm.! !!Predicate methodsFor: 'initialization' stamp: 'pm 10/22/2018 09:43'!initialize: symbl	symb:=symbl.	terms:=LinkedListFix new.! !!Predicate methodsFor: 'Skoleminsation' stamp: 'pm 10/8/2018 20:33'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	^self updateTerms: setOfLinkedVar CorrespondingValue: aMap.! !!Predicate methodsFor: 'Skoleminsation' stamp: 'pm 10/8/2018 20:33'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	^self updateTerms: setOfLinkedVar CorrespondingValue: aMap.! !!Predicate methodsFor: 'Skoleminsation' stamp: 'pm 10/8/2018 20:33'!updateTerms: setOfLinkedVar CorrespondingValue: aMap	| res |	res := LinkedList new.	terms do:[ :term | res add: (term WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].	^Predicate new: (self getSymb) fromList:res.! !!Predicate methodsFor: 'printing' stamp: 'pm 10/24/2018 07:27'!prettyPrint	|t|	t:=(self getSymb),'('.	terms do:[:each| t:=t,each prettyPrint. ] separatedBy:[t:=t,','].	t:=t,')'.	^t.! !!Predicate methodsFor: 'testing' stamp: 'pm 10/17/2018 12:32'!isTheSame: predicate	^(self isSameSymb:predicate) 	and:[(self isSameVar:predicate)].! !!Predicate methodsFor: 'testing' stamp: 'pm 10/7/2018 17:13'!isSameVar: predicate	"= defined on SequenceableCollection, LinkedList's superclass."	^(self terms)=(predicate terms).! !!Predicate methodsFor: 'testing' stamp: 'pm 10/18/2018 22:08'!contains: aTerm	^ terms anySatisfy: [ :each | each contains: aTerm ]! !!Predicate methodsFor: 'testing' stamp: 'pm 10/18/2018 16:03'!isSameArity:anotherPredicate	^(self arity)=(anotherPredicate arity).! !!Predicate methodsFor: 'testing' stamp: 'pm 10/23/2018 07:32'!isPositivePredicate	^true! !!Predicate methodsFor: 'testing' stamp: 'pm 10/20/2018 09:14'!isConst	terms do:[:each | (each isConst)ifFalse:[^false]].	^true! !!Predicate methodsFor: 'testing' stamp: 'pm 10/23/2018 07:32'!isPredicate	^true! !!Predicate methodsFor: 'testing' stamp: 'pm 10/5/2018 17:11'!isClause	^true.! !!Predicate methodsFor: 'accessing' stamp: 'pm 10/18/2018 09:23'!at: index 	^ (self terms) at:index.! !!Predicate methodsFor: 'accessing' stamp: 'pm 10/18/2018 15:56'!arity	^terms size.! !!Predicate methodsFor: 'accessing' stamp: 'pm 10/7/2018 17:12'!terms	^terms.! !!Predicate methodsFor: 'accessing' stamp: 'pm 10/5/2018 15:50'!getSymb	^symb.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Predicate class	instanceVariableNames: ''!!Predicate class methodsFor: 'instance creation' stamp: 'pm 10/8/2018 17:41'!new: symb fromList: aList	^self basicNew initialize: symb Variables: aList.! !!Predicate class methodsFor: 'instance creation' stamp: 'pm 10/5/2018 20:00'!new: symb variable: aVar	^self basicNew initialize: symb Variable:aVar.! !!Predicate class methodsFor: 'instance creation' stamp: 'pm 10/11/2018 14:59'!new: symb	^self basicNew initialize: symb.! !Predicate subclass: #NotPredicate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!NotPredicate commentStamp: 'pm 10/9/2018 11:24' prior: 0!I represent a negative Predicate, only in ClausalForm!!NotPredicate methodsFor: 'printing' stamp: 'pm 10/9/2018 17:30'!prettyPrint 	^(Not symb),(super prettyPrint)! !!NotPredicate methodsFor: 'testing' stamp: 'pm 10/23/2018 07:33'!isPositivePredicate	^false! !!NotPredicate methodsFor: 'testing' stamp: 'pm 10/23/2018 07:33'!isNegativePredicate	^true! !!NotPredicate methodsFor: 'testing' stamp: 'pm 10/23/2018 07:33'!isNotPredicate	^true! !MinimalOrderedSet subclass: #Resolvante	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Resolvante commentStamp: 'pm 10/27/2018 22:04' prior: 0!Utility class for ClausalForm::ResolutionMethod.!!Resolvante methodsFor: 'methodeDeResolution' stamp: 'pm 10/27/2018 22:12'!resolvante: aClause1 with: aClause2	"This method gets all the resolvantes between aClause1 and aClause2, modulo a subtitution of two terms.	self is an Unifier	aClause1 and aClause2 are the clauses we want to get the resolvant off.	resultant clauses are stocked in self."	| i j a1 a2 sub1 sub2 u newClause |	"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.	We don't need that much variable, it's for clarity"	i:=1.			[ i<=(aClause1 size). ]	whileTrue:[		a1:=aClause1 at:i.				j:=1.		[ j<=(aClause2 size) ]		whileTrue:[			a2:=aClause2 at:j.			(a1 isOppositePolarity: a2)			ifTrue:[				u:=Unifier new: a1 Predicate2: a2.					sub1:=u firstPredicate.				sub2:=u secondPredicate.	"			Transcript show:'sub1: ';show:sub1;cr.				Transcript show:'sub2: ';show:sub2;cr.	"			(sub1=sub2)				ifTrue:[					"newClause:=Clause new.we create a new clause with everything but the Atomes used"					newClause:=(aClause1 without:i).					newClause addFromList: (aClause2 without:j).					self add:newClause. "we finally add the resolvante."					].				].			j:=j+1.			].		i:=i+1.		].! !!Resolvante methodsFor: 'methodeDeResolution' stamp: 'pm 10/27/2018 22:13'!factorisation: aClause	"This method factorise positively AND negatively at the same time.	self is an Unifier	aClause is the clause we want to factorise	resultant clauses are stocked in self."	| i j a1 a2 sub1 sub2 u newClause |	"{i j}=iterator  {a1 a2} = atome (predicates) { sub1 sub2 }= Predicate substitution { u }=Unifier newClause = Each created new clause we add to the set.	We don't need that much variable, it's for clarity"	i:=1.		"Transcript show:aClause;cr."		[ i<=(aClause size). ]	whileTrue:[		a1:=aClause at:i.				j:=i+1.		[ j<=(aClause size) ]		whileTrue:[			a2:=aClause at:j.			(a1 isSamePolarity: a2)			ifTrue:[				u:=Unifier new: a1 Predicate2: a2.					sub1:=u firstPredicate.				sub2:=u secondPredicate.	"			Transcript show:'sub1: ';show:sub1;cr.				Transcript show:'sub2: ';show:sub2;cr.	"			(sub1=sub2)				ifTrue:[					"newClause:=Clause new. We create a new clause with everything but the Atomes used"					newClause:=(aClause without:i nor:j).					newClause add:sub1. "sub1=sub2, so we only add one of them"					self add:newClause. "we finally add the resolvante."					].				].			j:=j+1.			].		i:=i+1.		].! !AbstractTerm subclass: #Term	instanceVariableNames: 'symb'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Term commentStamp: 'pm 10/9/2018 10:36' prior: 0!I represent a Predicate's Term.My type will be specialized in ConstTerm, FuncTerm, LinkedVar when the propostion my predicate's in goes through skolemnisation.I look a lot like a proposition, but i'm conceptually different, hence the new object defined types.Public API and Key Messages-prettyPrint -> print the term as a string.-new: aChar -> new instance, with a char as a term. !!Term methodsFor: 'comparing' stamp: 'pm 10/21/2018 13:10'!=anotherTerm	"default comparing for terms."	^(self getSymb)=(anotherTerm getSymb).! !!Term methodsFor: 'printing' stamp: 'pm 10/28/2018 15:00'!prettyPrint 	"return current term as string"	^self getSymb.! !!Term methodsFor: 'accessing' stamp: 'pm 10/28/2018 14:48'!initialize: aName	"initialization of a named term"	symb:=aName.! !!Term methodsFor: 'accessing' stamp: 'pm 10/28/2018 14:48'!getSymb	"accessor"	^symb! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Term class	instanceVariableNames: ''!!Term class methodsFor: 'instance creation' stamp: 'pm 10/28/2018 14:47'!new: aName	"Creation of a term, which are represented by a name"	^(self basicNew) initialize:aName.! !Constant subclass: #True_Const	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!True_Const commentStamp: '<historical>' prior: 0!True Const!!True_Const methodsFor: 'testing' stamp: 'pm 10/23/2018 07:32'!isTrueConst	^true! !!True_Const methodsFor: 'matching' stamp: 'pm 9/30/2018 09:48'!matchPatternWith: prop	"see Prop comment for usage."	^prop isKindOf: True_Const! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!True_Const class	instanceVariableNames: ''!!True_Const class methodsFor: 'accessing' stamp: 'pm 9/28/2018 21:08'!symb	^symb! !!True_Const class methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!initialize	symb:='T'.! !Operator subclass: #Unary	instanceVariableNames: 'operand'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Unary commentStamp: 'pm 10/9/2018 10:56' prior: 0!I represent a Abstract binary operatorI factorise some of the attributes part of future operators.Public API and Key Messages- operand -> accessor.- new: -> create a binary operatorexample of initialization.UnaryOpClass new: (aPropClass newOperator) .!!Unary methodsFor: 'Matching' stamp: 'pm 9/30/2018 10:39'!matchPatternWith: prop	(self compareSymbol: prop)		ifTrue:[^operand matchPatternWith: (prop operand)]		ifFalse:[^false].! !!Unary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:28'!operand	^operand! !!Unary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:28'!operand: replacement	operand:=replacement.	^operand! !!Unary methodsFor: 'Initialize' stamp: 'pm 9/28/2018 22:38'!initialize: prop	operand:=prop.! !!Unary methodsFor: 'printing' stamp: 'pm 9/30/2018 19:21'!prettyPrint	^self getSymb,		((operand isKindOf: Atome) ifTrue:[' '] ifFalse:[' (']) ,		operand prettyPrint,		((operand isKindOf: Atome) ifTrue:[' '] ifFalse:[') ']).! !!Unary methodsFor: 'testing' stamp: 'pm 10/23/2018 07:35'!isUnaryOperator 	^true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Unary class	instanceVariableNames: ''!!Unary class methodsFor: 'Initialize' stamp: 'pm 9/28/2018 22:31'!new: prop	^self basicNew initialize: prop.! !Unary subclass: #Not	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Not commentStamp: '<historical>' prior: 0!I represent a Not  operator!!Not methodsFor: 'testing' stamp: 'pm 10/23/2018 07:35'!isNot	^true! !!Not methodsFor: 'Skoleminsation' stamp: 'pm 10/7/2018 11:35'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	^(self class) new: (self operand Skolemnise: setOfLinkedVar CorrespondingValue: aMap).! !!Not methodsFor: 'Skoleminsation' stamp: 'pm 10/7/2018 11:35'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	^(self class) new: (self operand Herbrandise: setOfLinkedVar CorrespondingValue: aMap).! !!Not methodsFor: 'clausification' stamp: 'pm 9/30/2018 20:33'!isClause	" (!! a) is a clause, but !! (a \/ b) isn't"	^(operand isKindOf: Atome)! !!Not methodsFor: 'clausification' stamp: 'pm 10/1/2018 11:09'!clausification	"Only one clausification operation at time"	"/!!\ since we're in an unary operator, the pattern doesn't start at self, but at operand"	| t |	t:=nil.	((Not patternNot) matchPatternWith: operand)	ifTrue:[t:=operand operand.]	ifFalse:[			((Not patternTrue) matchPatternWith: operand)			ifTrue:[t:=False_Const new]			ifFalse:[				((Not patternFalse) matchPatternWith: operand)				ifTrue:[t:=True_Const new]				ifFalse:[					((Not patternOr) matchPatternWith: operand)					ifTrue:[t:=And new: (Not new:(operand left)) rightProp:(Not new:(operand right))]					ifFalse:[						((Not patternAnd) matchPatternWith: operand)						ifTrue:[t:=Or new: (Not new:(operand left)) rightProp:(Not new:(operand right))].						]					]				 ]			].		(t isNil) ifTrue:[(Prop debug) ifTrue:[Transcript show:'in Not';show: self prettyPrint;cr.].			 self operand:(operand clausification).								^self]					 ifFalse:[(Prop debug) ifTrue:[Transcript show:'in Not2';show: t prettyPrint;cr.].						^t "clausification" ].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Not class	instanceVariableNames: 'patternNot patternTrue patternFalse patternOr patternAnd'!!Not class methodsFor: 'accessing' stamp: 'pm 9/30/2018 14:14'!patternFalse	^patternFalse.! !!Not class methodsFor: 'accessing' stamp: 'pm 9/30/2018 14:15'!patternAnd	^patternAnd.! !!Not class methodsFor: 'accessing' stamp: 'pm 9/30/2018 14:15'!patternNot	^patternNot.! !!Not class methodsFor: 'accessing' stamp: 'pm 9/30/2018 14:15'!patternTrue	^patternTrue.! !!Not class methodsFor: 'accessing' stamp: 'pm 9/30/2018 14:14'!patternOr	^patternOr.! !!Not class methodsFor: 'Initialize' stamp: 'pm 9/30/2018 18:50'!initialize	symb:='!!'.	patternNot:=Not new:(Var new: 'a').	patternTrue:=True_Const new.	patternFalse:=False_Const new.	patternOr:=Or new:(Var new: 'a') rightProp: (Var new: 'a').	patternAnd:=And new:(Var new: 'a') rightProp: (Var new: 'a').! !Unary subclass: #Quantifier	instanceVariableNames: 'var'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Quantifier commentStamp: 'pm 10/9/2018 11:28' prior: 0!I represent a QuantifierI'm created this way:new: VariableIQuantifieAsChar!!Quantifier methodsFor: 'testing' stamp: 'pm 10/5/2018 17:21'!isClause	"very unsure here"	^false! !!Quantifier methodsFor: 'testing' stamp: 'pm 10/23/2018 07:35'!isQuantifier 	^true! !!Quantifier methodsFor: 'accessing' stamp: 'pm 10/4/2018 13:31'!var	^var.! !!Quantifier methodsFor: 'printing' stamp: 'pm 10/5/2018 15:34'!prettyPrint	^(self class symb),' ', (self var), '.(',	operand prettyPrint,	')'.! !!Quantifier methodsFor: 'initialization' stamp: 'pm 10/4/2018 23:48'!initialize: arg Property: prop	super initialize: prop.	var:=arg.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Quantifier class	instanceVariableNames: ''!!Quantifier class methodsFor: 'initialization' stamp: 'pm 10/4/2018 23:48'!new:arg Property:prop	^self basicNew initialize:arg Property:prop.! !Quantifier subclass: #Exists	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Exists commentStamp: 'pm 10/9/2018 11:26' prior: 0!I represent an Exists quantifier!!Exists methodsFor: 'Skoleminsation' stamp: 'pm 10/11/2018 08:30'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	setOfLinkedVar add: (Term new:(self var)).	^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.	"We don't keep the Quantifiers in the formula"! !!Exists methodsFor: 'Skoleminsation' stamp: 'pm 10/11/2018 16:02'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	| t |	t := setOfLinkedVar isEmpty		ifTrue: [ ConstTerm new ]"then it's a generated constant, same as an Exists"		ifFalse: [ FuncTerm newFuncWithVars:  setOfLinkedVar ].		"then it's a skolem function"	aMap add: (Association key: var value: t).	^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.		"We don't keep the Quantifiers in the formula"! !!Exists methodsFor: 'testing' stamp: 'pm 10/23/2018 07:35'!isExists	^true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Exists class	instanceVariableNames: ''!!Exists class methodsFor: 'initialization' stamp: 'pm 10/4/2018 13:36'!initialize	symb:='Exist'.! !Quantifier subclass: #ForAll	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!ForAll commentStamp: 'pm 10/9/2018 11:26' prior: 0!I represent a ForallQuantifier!!ForAll methodsFor: 'Skoleminsation' stamp: 'pm 10/11/2018 16:17'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	| t |	t := setOfLinkedVar isEmpty		ifTrue: [ ConstTerm new ]"then it's a generated constant, same as an Exists"		ifFalse: [ FuncTerm newFuncWithVars: setOfLinkedVar ].		"then it's a skolem function"	aMap add: (Association key: var value: t).	^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.	"(self class) new: ("	")"	"We don't keep the Quantifiers in the formula"! !!ForAll methodsFor: 'Skoleminsation' stamp: 'pm 10/11/2018 08:29'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	setOfLinkedVar add: (Term new:(self var)).	^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.	 	"We don't keep the Quantifiers in the formula"! !!ForAll methodsFor: 'testing' stamp: 'pm 10/23/2018 07:35'!isForAll 	^true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ForAll class	instanceVariableNames: ''!!ForAll class methodsFor: 'initialization' stamp: 'pm 10/4/2018 23:52'!initialize	symb:='Forall'.! !AbstractTerm subclass: #UnaryTerm	instanceVariableNames: 'term'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!UnaryTerm commentStamp: 'pm 10/28/2018 15:12' prior: 0!Abstract factorisation for LinkedTerm & ConstTerm!!UnaryTerm methodsFor: 'accessing' stamp: 'pm 10/28/2018 15:03'!term	"accessor"	^term.! !!UnaryTerm methodsFor: 'initialize' stamp: 'pm 10/28/2018 15:01'!initialize:aTerm	"initialize an UnaryTerm with a term as argument"	(aTerm isKindOf: Term)	ifFalse:[^self error:'Takes only Terms as parameters. This is a', (aTerm class). ]	ifTrue:[term:=aTerm].! !!UnaryTerm methodsFor: 'comparing' stamp: 'pm 10/28/2018 15:00'!=anotherTerm	"comparaison operator"	^(anotherTerm isKindOf: (self class)) and:[(self term)=(anotherTerm term).].			! !!UnaryTerm methodsFor: 'adding' stamp: 'pm 10/28/2018 15:02'!replace:x by:t	"This message is only for predicate & funterms. They both deal with unary terms to be able to modify the type of the terms."	^self error:'shouldn''t be able to get here'.! !!UnaryTerm methodsFor: 'testing' stamp: 'pm 10/28/2018 15:01'!contains: aTerm	"Check if the contained term is the same as the argument"	^term = aTerm.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnaryTerm class	instanceVariableNames: ''!!UnaryTerm class methodsFor: 'instance creation' stamp: 'pm 10/28/2018 15:00'!new: aTerm	"Creation of a term, with a symbol"	^(self basicNew) initialize:aTerm.! !UnaryTerm subclass: #ConstTerm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!ConstTerm commentStamp: 'pm 10/9/2018 10:44' prior: 0!I represent a Const term, for a predicate.I should only be instanciated by the skolemnisation.I exists if my variable wasn't bound by anything OR if i'm bound by an exists which isn't bound by a previous forall.Public API and Key Messages-prettyPrint >> return the term as a String, with the character 'c' as a start. To differenciate it from the rest visually.!!ConstTerm methodsFor: 'initialization' stamp: 'pm 10/28/2018 15:04'!initialize	"Initialization of an anonymous ConstTerm. Done during the skolemnisation"	term:=Term new:(self class) getNum.! !!ConstTerm methodsFor: 'printing' stamp: 'pm 10/28/2018 15:05'!prettyPrint	"print current object as string."	"we add a c in front of it to be able to differenciate a const term from a linked term while reading."	^'c', (term prettyPrint).! !!ConstTerm methodsFor: 'testing' stamp: 'pm 10/28/2018 15:04'!isConst	"a const term is const. obvious, right?"	^true.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ConstTerm class	instanceVariableNames: 'factoryNum'!!ConstTerm class methodsFor: 'initialization' stamp: 'pm 10/28/2018 15:10'!nextConst	"Used as a anonymous const term name factory"	^'c',(self getNum).! !!ConstTerm class methodsFor: 'initialization' stamp: 'pm 10/28/2018 15:06'!factoryNum	"Number of the next anonymous const term"	"accessor"	^factoryNum.! !!ConstTerm class methodsFor: 'initialization' stamp: 'pm 10/28/2018 15:07'!getNum	"The number of the next anonymous object as string."	factoryNum:=factoryNum+1.	^factoryNum asString! !!ConstTerm class methodsFor: 'initialization' stamp: 'pm 10/28/2018 15:09'!new 	"new anonymous const term"	^self basicNew initialize.! !!ConstTerm class methodsFor: 'initialization' stamp: 'pm 10/28/2018 15:08'!initialize	"initlize of the class, which is only the number of the first anonymous const term"	factoryNum:=0.! !!ConstTerm class methodsFor: 'initialization' stamp: 'pm 10/28/2018 15:09'!new:Const_Value	"new named const Object"	^self basicNew initialize:Const_Value.! !UnaryTerm subclass: #LinkedTerm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!LinkedTerm commentStamp: 'pm 10/28/2018 15:13' prior: 0!I represent a Linked Term, for a Predicate or a FuncTermMost of my logic is factorised in UnaryTerm and AbstractTermI should only be instanciated by the skolemnisation.I exists if my variable is bound by a forall earlier in the proposition.Public API and Key Messages-prettyPrint >> return the term as a String!!LinkedTerm methodsFor: 'printing' stamp: 'pm 10/28/2018 15:10'!prettyPrint 	"return a representation of the current object as string"	^term prettyPrint.! !Object subclass: #Unifier	instanceVariableNames: 'setOfPairs hasFailed initialPair unifiedPair'	classVariableNames: 'UnifiedTerm'	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Unifier commentStamp: 'pm 10/27/2018 22:13' prior: 0!I represent an Unifier object.My purpose is to unify two predicate.Public API and Key Messages-Unifier new: Predicate2:- UnifyThisp1:=Predicate new:(..)p2:=Predicate new:(...)Unifier new: p1 Predicate2:p2 Instance Variables	hasFailed:	Boolean to see if the unification failed.!!Unifier methodsFor: 'printing' stamp: 'pm 10/20/2018 08:21'!printOn: aStream	aStream nextPutAll: (self prettyPrint).! !!Unifier methodsFor: 'printing' stamp: 'pm 10/20/2018 08:40'!prettyPrint	| t |	t:='{'.	(setOfPairs isNil)	ifFalse:[		setOfPairs do: [:each| t:=t,each prettyPrintUnifier.] separatedBy: [ t:=t,','.].		].	t:=t,'}'.	^t! !!Unifier methodsFor: 'add/remove' stamp: 'pm 10/15/2018 19:14'!add: value1 Value2: value2	setOfPairs add:(Pair left: value1 right: value2).! !!Unifier methodsFor: 'add/remove' stamp: 'pm 10/15/2018 16:40'!addUnifier: anotherUnifier	setOfPairs merge: (anotherUnifier setOfPairs ).	^self! !!Unifier methodsFor: 'add/remove' stamp: 'pm 10/15/2018 16:40'!add: aPair	setOfPairs add: aPair.	^self! !!Unifier methodsFor: 'accessing' stamp: 'pm 10/20/2018 08:53'!hasFailed	^hasFailed! !!Unifier methodsFor: 'initialization' stamp: 'pm 10/25/2018 07:58'!initialize: p1 Predicate2: p2	"initialized with two predicates, that we'll try to unify."	"init two different pair to be sure that we have the initial	one to unify at the end."	initialPair:=(Pair left: (p1 veryDeepCopy) right: (p2 veryDeepCopy)).	setOfPairs:=MinimalOrderedSet new.	setOfPairs add:(Pair left: p1 right: p2).	hasFailed:=false.		UnifiedTerm:=Pair left:nil right:nil."not sure if needed"		"And we try to unify it instantly"	self unifyThis.! !!Unifier methodsFor: 'initialization' stamp: 'pm 10/25/2018 08:07'!firstPredicate	^unifiedPair left.! !!Unifier methodsFor: 'initialization' stamp: 'pm 10/25/2018 08:07'!secondPredicate	^unifiedPair right.! !!Unifier methodsFor: 'accessors' stamp: 'pm 10/15/2018 16:29'!setOfPairs: anotherSet	setOfPairs:=anotherSet.	^self.! !!Unifier methodsFor: 'accessors' stamp: 'pm 10/15/2018 16:29'!setOfPairs	^setOfPairs! !!Unifier methodsFor: 'unification' stamp: 'pm 10/25/2018 08:33'!tryOperations: aPair	| modified notPossible left right |	left:=aPair left."syntaxic sugar"	right:=aPair right.	"Transcript cr;cr;show:'pouet';cr;cr."	notPossible:=false.	modified:=false.	((left isKindOf: ConstTerm) and:[right isKindOf: ConstTerm])	ifTrue:[		(left = right) "check underlying symbols, and that"		ifTrue:[self delete:aPair. modified:=true.].]"delete"	ifFalse:[		(((left isKindOf: FuncTerm) and:[right isKindOf: FuncTerm])		or:[(left isKindOf: Predicate) and:[right isKindOf: Predicate]])		ifTrue:["try a decompose or conflict "			((left isSameSymb: right) and:[(left arity=right arity)])			ifTrue:[self decompose:aPair. modified:=true.]"Decompose is possible"			ifFalse:["Isn't the sameSymbol, conflict ->"			(Prop debugUnification)			ifTrue:[Transcript show:'conflict';cr.].				notPossible:=true.				].			]		ifFalse:[			((left isConst) and:[right isKindOf: LinkedTerm.])			ifTrue:[ "swap"				self swap:aPair.				modified:=true.				 ]			ifFalse:[  				((left isKindOf: LinkedTerm) and:[(right isKindOf: LinkedTerm) or:[right isConst ]])"eliminate if x=t or x=f(t) [...]"				ifTrue:[					modified:=self eliminate:aPair.					]				ifFalse:["check, not implemented for now"					((left isKindOf:LinkedTerm) and:[right isKindOf: FuncTerm])					ifTrue:[						"notPossible:=self check:aPair"						].					].				].			].		].			^Pair left: modified right: notPossible. ! !!Unifier methodsFor: 'unification' stamp: 'pm 10/18/2018 18:20'!swap: aPair	|left right|	(Prop debugUnification)	ifTrue:[Transcript show:'swap';cr.].		left:=aPair left.	right:=aPair right.	setOfPairs remove:aPair.	self add: (Pair left: right right: left).	! !!Unifier methodsFor: 'unification' stamp: 'pm 10/20/2018 17:21'!eliminate: aPair	|left right previousSet newSet |		(Prop debugUnification)	ifTrue:[Transcript show:'eliminate with ';show: aPair;cr.].		left:=aPair left.	right:=aPair right.	newSet:=MinimalOrderedSet new.		previousSet:=setOfPairs veryDeepCopy."we need to work on a copy, to avoid having another iteration"	previousSet remove:aPair.		previousSet do:[:each |		"tempVar:=each veryDeepCopy.""since we modify the underlying data, we work on a copy"		newSet add: (self replacementPair:each replaced:left by:right).		].	(previousSet = newSet)	ifTrue:[		^false "Nothing changed"		]	ifFalse:[		newSet add:aPair."add back the argument. Corresponds to the union of G and the pair we do the elimination with"		setOfPairs:=newSet."replace with new set"		^true. "modifications were mades"		].	 ! !!Unifier methodsFor: 'unification' stamp: 'pm 10/21/2018 09:15'!replacementPair:aPair replaced:x by:t	^Pair left:(self replacement: (aPair left) replaced:x by:t)		  right:(self replacement: (aPair right) replaced:x by:t).! !!Unifier methodsFor: 'unification' stamp: 'pm 10/18/2018 18:27'!delete:aPair	(Prop debugUnification)	ifTrue:[Transcript show:'delete';cr.].	setOfPairs remove:aPair.! !!Unifier methodsFor: 'unification' stamp: 'pm 10/25/2018 08:36'!unifiedPair	^unifiedPair. ! !!Unifier methodsFor: 'unification' stamp: 'pm 10/26/2018 22:26'!unifyMe	| modified operationAnswer i |	modified := true.	[ modified ]	whileTrue:[		modified := false.		i := 1.		[(modified not) and:[(i <= (setOfPairs size))]]		whileTrue: [ 			Prop debugUnification			ifTrue: [ Transcript show: self;cr ].			operationAnswer := self tryOperations: (setOfPairs at: i).			operationAnswer right			ifTrue: [ "On a conflict or a fail check"				"Transcript show: 'Unification impossible'; cr."				setOfPairs := nil.				^nil "return value doesn't matter, we just want to break out" 				].	"NotPossible to unify?"			"else we go on till we didn't do anything more"			modified := modified or: [ operationAnswer left ].	"isModified was put arbitrily in left"			i:=i + 1 .			].			]. ! !!Unifier methodsFor: 'unification' stamp: 'pm 10/19/2018 17:41'!check: aPair	"Not active yet"	(Prop debugUnification)	ifTrue:[Transcript show:'check';cr.].		^((aPair right) contains: aPair left).! !!Unifier methodsFor: 'unification' stamp: 'pm 10/26/2018 22:27'!unifyThis	self unifyMe."Now setOfPairs contains my unifier"		(hasFailed)	ifTrue:[		unifiedPair := nil."Failed to unify thing"		].	unifiedPair := initialPair veryDeepCopy.	(setOfPairs isNil)	ifFalse:[		setOfPairs do:[ :each | 			((((each left) isConst) not) and:[(each right) isConst])				ifTrue:["They both should be predicates, so they can use replace: by:"					(unifiedPair left) replace: (each left) by: (each right).					(unifiedPair right) replace: (each left) by: (each right).					].				].			].	"else it was already the same  predicate"! !!Unifier methodsFor: 'unification' stamp: 'pm 10/18/2018 18:19'!decompose: aPair	|left right i|	(Prop debugUnification)	ifTrue:[Transcript show:'decompose';cr.].		left:=aPair left.	right:=aPair right.	i:=1.	setOfPairs remove: aPair.	[i<=(left arity)]"arity is the same, as we tested in the caller."	whileTrue:[		self add: (Pair left: (left at: i) right: (right at: i)).		i:=i+1.		].	! !!Unifier methodsFor: 'unification' stamp: 'pm 10/21/2018 09:16'!replacement:aTerm replaced:x by:t	((aTerm isKindOf: FuncTerm)or:[aTerm isKindOf: Predicate])	ifTrue:[		^aTerm replace:x by:t.		]"if it's something else than a functerm, "	ifFalse:[		(aTerm=x)		ifTrue:[^t]		ifFalse:[^aTerm].		]. ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Unifier class	instanceVariableNames: ''!!Unifier class methodsFor: 'instance creation' stamp: 'pm 10/15/2018 16:10'!new: p1 Predicate2: p2	^(self basicNew) initialize: p1 Predicate2:p2.! !Atome subclass: #Var	instanceVariableNames: 'symb'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Var commentStamp: 'pm 10/9/2018 11:23' prior: 0!I represent a variable in a Propositional logic.-new:VarName !!Var methodsFor: 'accessing' stamp: 'pm 9/28/2018 22:25'!getSymb	^symb! !!Var methodsFor: 'comparison' stamp: 'pm 9/29/2018 09:19'!isSameVar: other	^self getSymb = other getSymb.! !!Var methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!initialize: varName	symb:=varName.! !!Var methodsFor: 'matching' stamp: 'pm 9/30/2018 09:59'!matchPatternWith: prop	"see Prop comment for usage."	^true! !!Var methodsFor: 'testing' stamp: 'pm 10/23/2018 07:33'!isVar 	^true! !!Var methodsFor: 'printing' stamp: 'pm 10/3/2018 13:11'!prettyPrint	^(self getSymb).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Var class	instanceVariableNames: ''!!Var class methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!new: varName	^self basicNew initialize: varName.! !Var subclass: #NotVar	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!NotVar commentStamp: 'pm 10/9/2018 11:24' prior: 0!I represent a negative variable, only in ClausalForm!!NotVar methodsFor: 'testing' stamp: 'pm 10/23/2018 07:33'!isNotVar 	^true! !!NotVar methodsFor: 'printing' stamp: 'pm 10/3/2018 15:23'!prettyPrint	^(Not symb),(self getSymb).! !FuncTerm initialize!Prop initialize!False_Const initialize!And initialize!Equal initialize!Imply initialize!Or initialize!True_Const initialize!Not initialize!Exists initialize!ForAll initialize!ConstTerm initialize!