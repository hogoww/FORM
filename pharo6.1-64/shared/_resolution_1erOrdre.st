Object subclass: #AbstractTerm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!AbstractTerm methodsFor: 'printing' stamp: 'pm 10/14/2018 15:39'!printOn: stream	super printOn:stream.	stream nextPutAll: (self prettyPrint).! !!AbstractTerm methodsFor: 'printing' stamp: 'pm 10/11/2018 10:56'!prettyPrint	^SubclassResponsibility.! !!AbstractTerm methodsFor: 'testing' stamp: 'pm 10/15/2018 16:39'!isConst	"Used to check if a term, or more often a funcTerm is const, while trying to unify a term with a funcTerm."	^false.! !!AbstractTerm methodsFor: 'Skoleminsation' stamp: 'pm 10/11/2018 15:17'!WhatAmI:setOfLinkedVar CorrespondingValue: aMap	| elem |	(setOfLinkedVar haveYouSeenThisObject:self)	ifTrue:[^LinkedTerm new:self.]	ifFalse:[		elem:=aMap at:(self prettyPrint) ifAbsent:[(ConstTerm new: self)].		^elem.].! !Object subclass: #ClausalForm	instanceVariableNames: 'clauses'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!ClausalForm methodsFor: 'printing' stamp: 'pm 10/14/2018 15:39'!printOn: stream	super printOn:stream.	stream nextPutAll: (self prettyPrint).! !!ClausalForm methodsFor: 'initialization' stamp: 'pm 10/9/2018 13:35'!add: clause	(clause isKindOf: Clause)	ifTrue: [ self clauses add: clause ]	ifFalse:[Error new: 'Tried to add a non clause object to a clausaleForm'].! !!ClausalForm methodsFor: 'initialization' stamp: 'pm 10/15/2018 15:13'!initialize: ClausifiedFormula	clauses:=MinimalOrderedSet new.	self addAll: ClausifiedFormula.! !!ClausalForm methodsFor: 'initialization' stamp: 'pm 10/9/2018 13:59'!addAll: clausifiedProp	((clausifiedProp  isKindOf: Or) | (clausifiedProp isKindOf: Atome))	 "If i'm in a or, there's only or(s) under him."	ifTrue:[self clauses add: (Clause new:clausifiedProp)]	ifFalse:[		(clausifiedProp isKindOf: Not)		ifTrue:[			((clausifiedProp operand) isKindOf:Atome)			ifTrue:[^self clauses add:(Clause new:clausifiedProp).]			ifFalse:[^Error new:'a not isn''t englobing an atome'.].			]		ifFalse:[			(clausifiedProp isKindOf: And)			ifTrue:[				self addAll: (clausifiedProp left).				self addAll: (clausifiedProp right).				]		ifFalse:[		Error new: 'Tried to add a non clause object to a clausaleForm'.].	].	].! !!ClausalForm methodsFor: 'initialization' stamp: 'pm 10/9/2018 17:26'!prettyPrint	|t|	t:='{'.		clauses do: [  :each | t:=t,(each prettyPrint). ] separatedBy: [t:=t,','].	t:=t,'}'.	^t.! !!ClausalForm methodsFor: 'initialization' stamp: 'pm 10/15/2018 15:14'!initialize	clauses:=MinimalOrderedSet new.	! !!ClausalForm methodsFor: 'accessing' stamp: 'pm 10/1/2018 20:17'!clauses	^clauses.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClausalForm class	instanceVariableNames: ''!!ClausalForm class methodsFor: 'instance creation' stamp: 'pm 10/3/2018 12:49'!new: ClausaleProposition	^self basicNew initialize:ClausaleProposition.! !!ClausalForm class methodsFor: 'instance creation' stamp: 'pm 10/3/2018 12:50'!new	^self basicNew initialize.! !Object subclass: #Clause	instanceVariableNames: 'atomes'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Clause methodsFor: 'accessing' stamp: 'pm 10/1/2018 20:18'!atomes	^atomes.! !!Clause methodsFor: 'accessing' stamp: 'pm 10/9/2018 13:36'!addAll: orProp	(orProp isKindOf: Atome)	ifTrue:[self add:orProp.]	ifFalse:[		((orProp) isKindOf: Not)		ifTrue:["we're in a not"			(orProp operand isKindOf:Atome)				ifTrue:["we're in an atom"					((orProp operand) isKindOf: Predicate)					ifTrue:[self add:(NotPredicate new: (orProp operand) getSymb fromList: (orProp operand) terms).]					ifFalse:[						((orProp operand) isKindOf: Var)						ifTrue:[self add:(NotVar new:((orProp operand) getSymb)).]						ifFalse: [ Error new: 'shouldn''t be any True or false here' ]].						]				ifFalse:[					Error new:'Error, shouldn''t be any more not ( binaryOp )'				].			]		ifFalse:[			((orProp) isKindOf: Or)			ifTrue:[				self addAll: (orProp left).				self addAll: (orProp right).				]			ifFalse:["switch to Error new:"				Error new:'Error, shouldn''t be any other kind of prop here.'.				].			].		].! !!Clause methodsFor: 'accessing' stamp: 'pm 10/9/2018 13:35'!add: var	(var isKindOf: Atome)		ifTrue:[			(self atomes) add:var.			^self."able chaining operation"			]		ifFalse:[				Error new: 'wrong type in clause'.			].! !!Clause methodsFor: 'initialize' stamp: 'pm 10/15/2018 15:13'!initialize	atomes:=MinimalOrderedSet new.! !!Clause methodsFor: 'initialize' stamp: 'pm 10/15/2018 15:14'!initialize: OrProp	atomes:=MinimalOrderedSet new.	self addAll:OrProp.! !!Clause methodsFor: 'printing' stamp: 'pm 10/14/2018 15:39'!printOn: stream	super printOn:stream.	stream nextPutAll: (self prettyPrint).! !!Clause methodsFor: 'printing' stamp: 'pm 10/9/2018 17:25'!prettyPrint	|t|	t:='{'.		atomes do:[  :each | t:=t,(each prettyPrint). ] separatedBy:[t:=t,','].	t:=t,'}'.	^t.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Clause class	instanceVariableNames: ''!!Clause class methodsFor: 'instance creation' stamp: 'pm 10/2/2018 17:31'!new: OrProp	^self basicNew initialize:OrProp.! !!Clause class methodsFor: 'instance creation' stamp: 'pm 10/2/2018 17:06'!new	^self basicNew initialize.! !AbstractTerm subclass: #FuncTerm	instanceVariableNames: 'symb terms'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!FuncTerm commentStamp: 'pm 10/9/2018 10:43' prior: 0!I represent a Func term, for a predicate.I should only be instanciated by the skolemnisation.I exists if my variable was bound by an Exists, with a forall binding the said Exists beforehand.Public API and Key Messages-prettyPrint >> return the term as a String, with a standart name 'f' for the function, and a list of terms.!!FuncTerm methodsFor: 'initialization' stamp: 'pm 10/11/2018 11:05'!initialize: symbo Variables: setOfLinkedVar	symb:=symbo.	terms:=LinkedList new.	setOfLinkedVar  do: [ :each | terms add: each.].! !!FuncTerm methodsFor: 'initialization' stamp: 'pm 10/11/2018 12:13'!initialize: symbo Variable: aTerm	symb:=symbo.	terms:=LinkedList new.	terms add: aTerm.! !!FuncTerm methodsFor: 'initialization' stamp: 'pm 10/11/2018 15:01'!initialize: symbo	symb:=symbo.	terms:=LinkedList new.! !!FuncTerm methodsFor: 'Skoleminsation' stamp: 'pm 10/11/2018 16:17'!WhatAmI:setOfLinkedVar CorrespondingValue: aMap	| newVars t|	newVars:=LinkedList new.	terms do: [ :each | newVars add: (each WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].	t:=(FuncTerm new: (self getSymb) Variables:newVars).	^t.! !!FuncTerm methodsFor: 'printing' stamp: 'pm 10/11/2018 09:32'!prettyPrint	|t|	t:=(self getSymb),'('.	terms do: [:each| t:=t,each prettyPrint. ] separatedBy:[t:=t,','].	t:=t,')'.	^t.	! !!FuncTerm methodsFor: 'accessing' stamp: 'pm 10/15/2018 15:18'!arity	terms size.	! !!FuncTerm methodsFor: 'accessing' stamp: 'pm 10/6/2018 19:28'!terms	^terms! !!FuncTerm methodsFor: 'accessing' stamp: 'pm 10/11/2018 09:51'!getSymb	^symb! !!FuncTerm methodsFor: 'testing' stamp: 'pm 10/15/2018 16:38'!isConst	terms do:[:each | (each isConst)ifFalse:[^false]].	^true! !!FuncTerm methodsFor: 'comparing' stamp: 'pm 10/15/2018 15:42'!=anotherFuncTerm	| res |	res:=anotherFuncTerm isKindOf: FuncTerm."checking the input"	res:=res or: [(self getSymb)=(anotherFuncTerm getSymb).]."comparing the function symbol"	res:=res or:[(self arity)=(anotherFuncTerm arity).]."comparing aruty"	res:=res or:[(self terms) = (anotherFuncTerm terms).]."we let the superclass LinkedList check for the correct terms"	^res.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FuncTerm class	instanceVariableNames: 'currentFuncNumber anonymousFuncSymb'!!FuncTerm class methodsFor: 'initialization' stamp: 'pm 10/11/2018 15:11'!initialize	currentFuncNumber :=0.	anonymousFuncSymb:='f'.! !!FuncTerm class methodsFor: 'instance creation' stamp: 'pm 10/11/2018 15:06'!newFuncWithVars: varList	^self basicNew initialize: (self getNewFuncName) Variables:varList.! !!FuncTerm class methodsFor: 'instance creation' stamp: 'pm 10/7/2018 15:10'!new: symbo Variables: setOfLinkedVar	^self basicNew initialize:symbo Variables: setOfLinkedVar.! !!FuncTerm class methodsFor: 'instance creation' stamp: 'pm 10/11/2018 15:11'!getNewFuncName	currentFuncNumber :=currentFuncNumber +1.	^anonymousFuncSymb,(currentFuncNumber asString).! !!FuncTerm class methodsFor: 'instance creation' stamp: 'pm 10/10/2018 21:39'!new: symbo Variable: aVar	^self basicNew initialize:symbo Variable: aVar.! !!FuncTerm class methodsFor: 'instance creation' stamp: 'pm 10/11/2018 15:01'!new	^self basicNew initialize: (self getNewFuncName).! !!FuncTerm class methodsFor: 'instance creation' stamp: 'pm 10/11/2018 15:07'!newFunc: variable	^self basicNew initialize: (self getNewFuncName) Variable:variable.! !!FuncTerm class methodsFor: 'instance creation' stamp: 'pm 10/11/2018 15:01'!new: symbo	^self basicNew initialize:symbo.! !LinkedList subclass: #MinimalOrderedSet	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!MinimalOrderedSet commentStamp: 'pm 10/9/2018 10:08' prior: 0!I'm a ordered set, using a LinkedList. I'm a linked list which only override the method 'add' so i can be considered as a set.I also give access to a way to find an object via haveYouSeenThisObject.cf LinkedList.Public API and Key Messages- add: anObject (add an object IF it's not in the set)- haveYouSeenThisObject: anObject (search for an element in the set- To create instances , cf LinkedListp:=MinimalOrderSet new.p add: 1 >> "p contains { 1 }" p add : 1 >> "p contains { 1 }"p haveYouSeenThisObject: 1 >> "true"p haveYouSeenThisObject: 2 >> "false"!!MinimalOrderedSet methodsFor: 'adding' stamp: 'pm 10/15/2018 16:34'!merge: anotherMinimalOrderedSet	anotherMinimalOrderedSet do:[:each | self add:each.].	^self.! !!MinimalOrderedSet methodsFor: 'adding' stamp: 'pm 10/7/2018 12:25'!add: anObject 	self do: [ :each | 		(each=anObject) 		ifTrue:[^self]"Object's already in, we're done"		].	 super add: anObject."we let LinkedList add the object"	^self.! !!MinimalOrderedSet methodsFor: 'search' stamp: 'pm 10/11/2018 13:02'!haveYouSeenThisObject: anObject 	"search for the object"	self do: [ :each | 		(each=anObject) 		ifTrue:["Transcript cr;show:each prettyPrint;cr".			^true.]		].	^false.! !Object subclass: #Pair	instanceVariableNames: 'left right'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Pair methodsFor: 'printing' stamp: 'pm 10/15/2018 16:47'!prettyPrint	^'(',(self left prettyPrint),',',(self right prettyPrint),')'.! !!Pair methodsFor: 'accessing' stamp: 'pm 10/15/2018 16:23'!right: anObject	right:=anObject.	^right! !!Pair methodsFor: 'accessing' stamp: 'pm 10/15/2018 16:22'!left: anObject	left:=anObject.	^left! !!Pair methodsFor: 'accessing' stamp: 'pm 10/15/2018 16:22'!left	^left! !!Pair methodsFor: 'accessing' stamp: 'pm 10/15/2018 16:23'!right	^right! !!Pair methodsFor: 'comparing' stamp: 'pm 10/15/2018 16:42'!= anotherPair	^(self right)=(anotherPair left) and:[(self right)=(anotherPair right)].! !!Pair methodsFor: 'initialize-release' stamp: 'pm 10/15/2018 16:26'!left:l right:r	left:=l.	right:=r.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Pair class	instanceVariableNames: ''!!Pair class methodsFor: 'initialize-release' stamp: 'pm 10/15/2018 16:25'!left:l right:r	^(self basicNew) left:l right:r.! !Object subclass: #Prop	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Prop commentStamp: 'pm 10/9/2018 10:52' prior: 0!Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.I allow a proposition to be clausified.I allow propositions of First order to be skolemnise, then clausifiedPublic API:- FullClausification -> return a Clausified version of  a Proposition- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)- PrettyPrint -> returns a string representing my  internal state.!!Prop methodsFor: 'printing' stamp: 'pm 10/14/2018 15:39'!printOn: stream	super printOn:stream.	stream nextPutAll: (self prettyPrint).! !!Prop methodsFor: 'printing' stamp: 'pm 10/9/2018 11:31'!prettyPrint	"return the internal representation of Proposition"	^SubclassResponsibility ! !!Prop methodsFor: 'Skoleminsation' stamp: 'pm 10/7/2018 11:25'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	^SubclassResponsibility.! !!Prop methodsFor: 'Skoleminsation' stamp: 'pm 10/7/2018 11:31'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	^SubclassResponsibility.! !!Prop methodsFor: 'Skoleminsation' stamp: 'pm 10/6/2018 18:09'!HerbranSkolemDocu	^Error new:'documentation of Skolemnisation'.	"return that prop skolemnised"! !!Prop methodsFor: 'Skoleminsation' stamp: 'pm 10/7/2018 19:40'!StartSkolemnisation	| set aMap |	set:=MinimalOrderedSet new.	aMap:=Dictionary new.	^self Skolemnise: set CorrespondingValue: aMap! !!Prop methodsFor: 'matching' stamp: 'pm 9/30/2018 10:16'!compareSymbol: otherProp	^(self getSymb = otherProp getSymb) ! !!Prop methodsFor: 'matching' stamp: 'pm 9/30/2018 09:09'!matchPatternWith: prop	"Match self and prop. to end a branch of the pattern	use a random variable	var == whatever	anythingElse == anythingElse only :  !!n => T == !!(A /\ B)=> T for example	"	^SubclassResponsibility.! !!Prop methodsFor: 'accessing' stamp: 'pm 9/28/2018 22:42'!getSymb	^SubclassResponsibility. ! !!Prop methodsFor: 'clausification' stamp: 'pm 9/29/2018 08:21'!isClause	^SubclassResponsibility ! !!Prop methodsFor: 'clausification' stamp: 'pm 9/30/2018 20:06'!clausification	"Only one iteration over the full formula."	"Basic empty comportement for atomes mostly. (only?)"! !!Prop methodsFor: 'clausification' stamp: 'pm 10/1/2018 10:58'!fullClausification	| t |	t:=self clausification.	[t isClause] whileFalse:[			(Prop debug) ifTrue:[Transcript show: t prettyPrint; show: t isClause;cr.].		t:=t clausification.].	^t! !!Prop methodsFor: 'testing' stamp: 'pm 10/9/2018 13:33'!clausificationUnitTest	|t|	Transcript show: self prettyPrint; show: '  ' ;show: self isClause; cr.	t:=self fullClausification.	Transcript show: t prettyPrint; show: '  ' ;show: t isClause; cr;cr.	^t.! !!Prop methodsFor: 'testing' stamp: 'pm 10/9/2018 12:25'!propUnitTest	Transcript show: self prettyPrint; show: '  ' ;show: self isClause; cr; cr.	^self! !!Prop methodsFor: 'testing' stamp: 'pm 9/30/2018 12:34'!matchingUnitTest: prop	"self will be considered as a pattern"	Transcript cr;		show: 'prop : ' ; 		show: (prop prettyPrint);		cr;		show: 'pattern : ';		show: (self prettyPrint);		cr.		(self matchPatternWith: prop)			ifTrue:[ Transcript show: 'matched!!';cr.]			ifFalse:[ Transcript show: 'didn''t match!!';cr]	! !!Prop methodsFor: 'testing' stamp: 'pm 10/11/2018 16:42'!SkolemnisationTest	|t|	Prop testInc.		Transcript show: 'test #'; show:(Prop testNumber);cr.	Transcript show: 'initial: '; show: self prettyPrint; cr.	t:=self StartSkolemnisation.	Transcript show: 'Skolemn: ';show: t prettyPrint;cr.	t:=t fullClausification.	Transcript show: 'Clausified:';show: t prettyPrint ;cr.	t:=ClausalForm new:t.	Transcript show: 'ClausalForm:';show: t prettyPrint ;cr;cr;cr.	^t! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Prop class	instanceVariableNames: 'debug testNumber'!!Prop class methodsFor: 'testing' stamp: 'pm 10/5/2018 16:54'!testingMatch	|pattern prop|   "Transcript clear."	Transcript show: 'Testing matching related stuff'.		pattern:= Imply new: (True_Const new) rightProp: (Predicate new: 'P' variable: 'a').	prop:= Imply new: (True_Const new) rightProp: (Not new:(Predicate new: 'P' variable: 'a')).	pattern matchingUnitTest: prop.		pattern:= Imply new: (True_Const new) rightProp: (False_Const  new).	prop:= Imply new: (True_Const new) rightProp: (Not new:(Predicate new: 'P' variable: 'a')).	pattern matchingUnitTest: prop.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/8/2018 17:11'!initEverything	"classic logic"	Prop initialize.	Atome initialize.	Constant initialize.	False_Const initialize.	True_Const initialize.	Var initialize.	NotVar initialize.	Operator initialize.	Binary initialize.	And initialize.	Equal initialize.	Imply initialize.	Or initialize.	Unary initialize.	Not initialize.		"Predicate"	Quantifier initialize.	Exists initialize.	ForAll initialize.		"terms"	Term initialize.	ConstTerm initialize.	FuncTerm initialize.	LinkedTerm initialize.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/5/2018 00:09'!testingClausification 	"everything is tested in those few lines"	"Binary"	| p |	"	Transcript clear."	Transcript show: 'Testing clausification related stuff';cr.		p:=And new: (Var new: 'a') rightProp: (False_Const new).	p clausificationUnitTest.	p:=Or new: (Var new: 'a') rightProp: (False_Const new).	p clausificationUnitTest.	p:=Equal new: (Var new: 'a') rightProp: (True_Const new).	p clausificationUnitTest.		p:=Imply new: (Var new: 'a') rightProp: (True_Const new).	p clausificationUnitTest.	"unary"	p:=Not new: (Var new: 'a').	p clausificationUnitTest.		Transcript show: 'Bit more complicated stuff!!';cr.		p:=Imply new: (Equal new: (Not new: (Var new: 'a')) rightProp: (Var new: 'b')) rightProp: (False_Const new).	p clausificationUnitTest.			Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/15/2018 15:42'!testingSkolemn 	"everything is tested in those few lines"	"Binary"	| p terms terms2|		"Transcript clear."	Transcript show: 'Testing Skolemnisation related stuff';cr.		Transcript show: 'basic one #1'.	terms:=LinkedList new.	terms add:(Term new:'x');add:(Term new:'y');add:(Term new:'z').		p:=ForAll new: 'x' Property: (Exists new: 'y' Property: (ForAll new: 'z' Property: (Predicate new: 'P' fromList: terms ))).	p SkolemnisationTest.	Transcript show: 'basic one #2'.	terms:=LinkedList new.	terms add:(Term new:'x');add:(Term new:'z').		p:=Or new: (ForAll new: 'x' Property: (ForAll new: 'z' Property: (Predicate new: 'P' fromList: terms )))	 rightProp: (ForAll new: 'x' Property: (ForAll new: 'z' Property: (Predicate new: 'P' fromList: terms ))).	p SkolemnisationTest.	Transcript show: 'with imply and nested forall.'.	p:=Not new: 		(Imply new: 			(ForAll new: 'x' Property:				(Or new:  					(Predicate new: 'P' variable:(Term new:'x'))					 rightProp:					(Predicate new: 'Q' variable:(Term new:'x'))))			 rightProp:			(Or new: 				(Predicate new: 'P' variable:(Term new:'a'))				rightProp:(Predicate new: 'Q' variable:(Term new:'a')))).	p SkolemnisationTest.				Transcript show: 'same as previous one, but with x representing a variable in one, and a const in the other.'.	p:=Not new:		(Imply new: 			(ForAll new: 'x' Property:				(Or new:  					(Predicate new: 'P' variable:(Term new:'x'))					 rightProp:					(Predicate new: 'Q' variable:(Term new:'x'))))			 rightProp:			(Or new: 				(Predicate new: 'P' variable:(Term new:'x'))				rightProp:(Predicate new: 'Q' variable:(Term new:'x')))).	p SkolemnisationTest.				Transcript show: 'same as previous one, check Unbound Exists is replaced by consts'.	p:=Not new:		(Imply new: 			(Exists new: 'x' Property:				(Or new:  					(Predicate new: 'P' variable:(Term new:'x'))					 rightProp:					(Predicate new: 'Q' variable:(Term new:'x'))))			 rightProp:			(Or new: 				(Predicate new: 'P' variable:(Term new:'x'))				rightProp:(Predicate new: 'Q' variable:(Term new:'x')))).	p SkolemnisationTest.			Transcript show: 'Teacher''s stress test#1' .	p:=Not new:(        ForAll new: 'x' Property:         (Imply new: (ForAll new: 'y' Property: (Predicate new: 'P' variable: (Term new:'y')))         rightProp: (Predicate new:'Q' variable: (Term new:'x')))).        	p SkolemnisationTest.			Transcript show: 'Teacher''s stress test#2'	.	terms:=LinkedList new.    terms add:(Term new: 'x') ; add:(Term new:'z').    terms2:=LinkedList new.    terms2 add:(Term new:'y') ; add: (Term new:'t').    p:=Not new:            (ForAll new: 'x' Property:                (ForAll new: 'y' Property:                    (Exists new: 'z' Property:                         (ForAll new: 't' Property:                             (Imply new:                                 (Predicate new: 'P' fromList: terms)                             rightProp:                                 (Predicate new: 'Q' fromList: terms2)))))).	p SkolemnisationTest.				Transcript show: 'Test functionnal term in initial Predicate '.	terms:=LinkedList new.   terms add:(Term new: 'x') ; add:(FuncTerm new: 'f' Variable: (Term new:'z')).   p:=Not new:            (ForAll new: 'x' Property:                  (Predicate new: 'P' fromList: terms)).	p SkolemnisationTest .		Transcript show: 'Test functionnal term in initial Predicate  with needed inner replacement'.	terms:=LinkedList new.   terms add:(Term new: 'x') ; add:(FuncTerm new: 'f' Variable: (Term new:'y')).   p:=ForAll new: 'x' Property:					(Exists new: 'y' Property:                  (Predicate new: 'P' fromList: terms)).	p SkolemnisationTest.	Transcript show: 'Done with the testing, did it work? :3' ; cr; cr. ! !!Prop class methodsFor: 'testing' stamp: 'pm 10/1/2018 10:58'!debug	^debug! !!Prop class methodsFor: 'testing' stamp: 'pm 10/8/2018 17:24'!testingProp 	"everything is tested in those few lines"	"Binary"	| p l r|		"Transcript clear."	Transcript show: 'Testing prop related stuff';cr.		Transcript show: 'testing every constructor in a simple way, and if they are clauses:';cr.		p:=Exists new: 'a' Property: (And new: (Predicate new: 'D' variable: (Term new: 'a')) rightProp: (False_Const new)).	p propUnitTest.	p:=Exists new: 'a' Property:(Or new: (Predicate new: 'C' variable:  (Term new: 'a')) rightProp: (False_Const new)).	p propUnitTest.	p:=ForAll new: 'x' Property: (Equal new: (Predicate new: 'A' variable:  (Term new: 'a')) rightProp: (True_Const new)).	p propUnitTest.		p:=ForAll new: 'x' Property: (Imply new: (Predicate new: 'B' variable:  (Term new: 'a')) rightProp: (True_Const new)).	p propUnitTest.	"unary"	p:=Not new: (Predicate new: 'Q' variable: (Term new: 'a')).	p propUnitTest.		Transcript show: 'Bit more complicated stuff!!';cr.		p:=Imply new: (Equal new: (Not new: (Predicate new: 'P' variable:  (Term new: 'a'))) rightProp: (Predicate new: 'P' variable:(Term new: 'b'))) rightProp: (False_Const new).	p propUnitTest.		Transcript show: 'Testing Comparisons on Vars:'; cr.		l:=Predicate new: 'P' variable:  'a'.	r:=Predicate new: 'P' variable:  'b'.	Transcript show: 'is P(a) = P(b) ? ';			show: (l isTheSame: r); cr.	r:=Predicate new: 'Q' variable:  'a'.	Transcript show: 'is var P(a) = Q(a) ? ';		show: (l isTheSame: r); cr.	r:=Predicate new: 'P' variable:  'a'.	Transcript show: 'is P(a) = P(a) ? ';		show: (l isTheSame: r); cr.		Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/5/2018 16:33'!testingPropClassic 	"everything is tested in those few lines"	"Binary"	| p l r|		"Transcript clear."	Transcript show: 'Testing prop related stuff';cr.		Transcript show: 'testing every constructor in a simple way, and if they are clauses:';cr.		p:=And new: (Var new: 'a') rightProp: (False_Const new).	p propUnitTest.	p:=Or new: (Var new: 'a') rightProp: (False_Const new).	p propUnitTest.	p:=Equal new: (Var new: 'a') rightProp: (True_Const new).	p propUnitTest.		p:=Imply new: (Var new: 'a') rightProp: (True_Const new).	p propUnitTest.	"unary"	p:=Not new: (Var new: 'a').	p propUnitTest.		Transcript show: 'Bit more complicated stuff!!';cr.		p:=Imply new: (Equal new: (Not new: (Var new: 'a')) rightProp: (Var new: 'b')) rightProp: (False_Const new).	p propUnitTest.		Transcript show: 'Testing Comparisons on Vars:'; cr.		l:=Var new: 'a'.	r:=Var new: 'b'.	Transcript show: 'is var a = b ? ';			show: (l isSameVar: r); cr.	r:=Var new: 'a'.	Transcript show: 'is var a = a ? ';		show: (l isSameVar: r); cr.		Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/11/2018 09:02'!testEverything	Transcript clear.	Prop initEverything.	"Prop testingProp."	"Prop testingMatch."	"Prop testingClausification."	Prop testingSkolemn.! !!Prop class methodsFor: 'tests' stamp: 'pm 10/11/2018 16:25'!testInc	testNumber:=testNumber+1.! !!Prop class methodsFor: 'initialization' stamp: 'pm 10/11/2018 16:23'!initialize	debug:=false.	testNumber:=0.! !!Prop class methodsFor: 'accessing' stamp: 'pm 10/11/2018 16:25'!testNumber	^testNumber! !Prop subclass: #Atome	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Atome commentStamp: 'pm 10/9/2018 11:03' prior: 0!I represent an Abstract atome in a Proposition.I factorise some proprieties.!!Atome methodsFor: 'clausification' stamp: 'pm 9/29/2018 08:25'!isClause	^true! !!Atome methodsFor: 'printing' stamp: 'pm 9/28/2018 20:26'!prettyPrint	^self getSymb! !!Atome methodsFor: 'testing' stamp: 'pm 10/5/2018 23:12'!isSkolem	^true.! !Atome subclass: #Constant	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Constant commentStamp: 'pm 10/9/2018 11:07' prior: 0!True and False constants, to represent them in Propositions!!Constant methodsFor: 'Skoleminsation' stamp: 'pm 10/7/2018 19:50'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	^self.! !!Constant methodsFor: 'Skoleminsation' stamp: 'pm 10/7/2018 19:50'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	^self.! !!Constant methodsFor: 'accessors' stamp: 'pm 9/28/2018 22:30'!getSymb	^(self class symb)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Constant class	instanceVariableNames: 'symb'!Constant subclass: #False_Const	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!False_Const commentStamp: '<historical>' prior: 0!False const!!False_Const methodsFor: 'matching' stamp: 'pm 9/30/2018 09:45'!matchPatternWith: prop	"see Prop comment for usage."	^prop isKindOf: False_Const! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!False_Const class	instanceVariableNames: ''!!False_Const class methodsFor: 'accessing' stamp: 'pm 9/28/2018 21:18'!symb	^symb! !!False_Const class methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!initialize	symb:='F'.! !Prop subclass: #Operator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Operator commentStamp: 'pm 10/9/2018 10:48' prior: 0!I represent an operator whith an unknown number of argument.I only factorise a method for now, but I allow possible future evolutions.!!Operator methodsFor: 'print' stamp: 'pm 9/28/2018 20:26'!getSymb	^(self class symb)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Operator class	instanceVariableNames: 'symb'!!Operator class methodsFor: 'accessing' stamp: 'pm 10/4/2018 23:44'!symb	^symb.! !Operator subclass: #Binary	instanceVariableNames: 'left right'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Binary commentStamp: 'pm 10/9/2018 10:55' prior: 0!I represent a Abstract binary operatorI factorise some of the attributes part of future operators.Public API and Key Messages- left & right -> accessors.- new: rightProp: -> create a binary operatorexample of initialization.BinaryOpClass new: (aPropClass newOperator) 			    rightProp: (aPropClass newOperator).			!!Binary methodsFor: 'Skoleminsation' stamp: 'pm 10/9/2018 09:21'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) 			rightProp: (self right Herbrandise: setOfLinkedVar CorrespondingValue: aMap ).		"We pass veryDeepCopys to the leftProp, so each branch has it's own collections"! !!Binary methodsFor: 'Skoleminsation' stamp: 'pm 10/9/2018 09:21'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	^(self class) new: (self left Skolemnise: (setOfLinkedVar veryDeepCopy)  CorrespondingValue: (aMap veryDeepCopy)) 			rightProp: (self right Skolemnise: setOfLinkedVar CorrespondingValue: aMap).			"Works for at least Or & And. Maybe Equal?"				"We pass veryDeepCopys to the leftProp, so each branch has it's own collections"! !!Binary methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!initialize: leftProp rightProp: rp	left:=leftProp.	right:=rp.	! !!Binary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:27'!right: replacement	right:=replacement.	^right! !!Binary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:27'!left: replacement	left:=replacement.	^left! !!Binary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:27'!right	^right! !!Binary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:26'!left	^left! !!Binary methodsFor: 'clausification' stamp: 'pm 9/29/2018 08:39'!isClause	"false unless it's a or/and"	^false! !!Binary methodsFor: 'printing' stamp: 'pm 9/30/2018 12:15'!prettyPrint	^((left isKindOf: Atome) ifTrue:[' '] ifFalse:[' (']) ,		left prettyPrint,		((left isKindOf: Atome) ifTrue:[' '] ifFalse:[') ']) ,		self getSymb,		((right isKindOf: Atome) ifTrue:[' '] ifFalse:[' (']) ,		right prettyPrint,		((right isKindOf: Atome) ifTrue:[' '] ifFalse:[') ']).! !!Binary methodsFor: 'matching' stamp: 'pm 9/30/2018 12:00'!matchPatternWith: prop	(self compareSymbol: prop)		ifTrue:[			^(left matchPatternWith: (prop left))			& (right matchPatternWith: (prop right))			]		ifFalse:[^false].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Binary class	instanceVariableNames: ''!!Binary class methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!new: leftProp rightProp: rp	^self basicNew initialize: leftProp rightProp: rp.! !Binary subclass: #And	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!And commentStamp: 'pm 10/9/2018 11:29' prior: 0!I represent an And proposition!!And methodsFor: 'clausification' stamp: 'pm 9/29/2018 08:40'!isClause	^(left isClause & right isClause)! !!And methodsFor: 'clausification' stamp: 'pm 10/1/2018 11:09'!clausification	| t |	t:=nil. 	((And patternFalse) matchPatternWith: self)	ifTrue:[t:=right]	ifFalse:[		((And patternFalseSym) matchPatternWith: self)		ifTrue:[t:=left]		ifFalse:[			((And patternTrue) matchPatternWith: self)			ifTrue:[t:=left]			ifFalse:[				((And patternTrueSym) matchPatternWith: self)				ifTrue:[t:=right]				ifFalse:["					((And patternOr) matchPatternWith: self)					ifTrue:[t:=Or new: (And new: ((self left) left) rightProp: (self right)) 								  rightProp: (And new:((self left) right) rightProp: (self right))]					ifFalse:[						((And patternOrSym) matchPatternWith: self)						ifTrue:[t:=Or new:(And new: (self left) rightProp: ((self right) left)) 									  rightProp: (And new: (self left) rightProp: ((self right) right))].						]					"]				]			]		].		(t isNil) ifTrue:[ (Prop debug) ifTrue:[Transcript show:'in And';show: self prettyPrint;cr.].			self left:(left clausification).								self right:(right clausification).								^self]					 ifFalse:[(Prop debug) ifTrue:[Transcript show:'in And2';show: t prettyPrint;cr.].						^t "clausification"]. ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!And class	instanceVariableNames: 'patternOr patternOrSym patternTrue patternTrueSym patternFalse patternFalseSym'!!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternFalse	^patternFalse! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternTrueSym	^patternTrueSym! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternOrSym	^patternOrSym! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternTrue	^patternTrue! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternFalseSym	^patternFalseSym! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternOr	^patternOr! !!And class methodsFor: 'initialize' stamp: 'pm 10/3/2018 20:06'!initialize	symb:='/\'.	patternOr:=And new: (Or new: (Var new: 'a') rightProp: (Var new:('a')))  rightProp: (Var new: 'a').	patternOrSym:=And new: (Var new: 'a') rightProp: (Or new: (Var new: 'a') rightProp: (Var new:('a'))).	patternTrue:=And new: (Var new: 'a') rightProp: (True_Const new).	patternTrueSym:=And new: (True_Const new) rightProp:(Var new:'a').	patternFalse:=And new: (Var new: 'a') rightProp: (False_Const new).	patternFalseSym:=And new: (False_Const new) rightProp:(Var new:'a').! !Binary subclass: #Equal	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Equal commentStamp: 'pm 10/9/2018 11:29' prior: 0!I represent an Equal proposition!!Equal methodsFor: 'clausification' stamp: 'pm 10/1/2018 11:09'!clausification	| t |	t:=Or new: (And new: (self left) rightProp: (self right))		 rightProp: (And new:(Not new: (self left)) rightProp:(Not new: (self right))).	(Prop debug) ifTrue:[Transcript show:'in equal';show: t prettyPrint;cr.].	^t "clausification".! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Equal class	instanceVariableNames: ''!!Equal class methodsFor: 'initialize' stamp: 'pm 9/30/2018 17:36'!initialize	symb:='<->'.! !Binary subclass: #Imply	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Imply commentStamp: 'pm 10/9/2018 11:29' prior: 0!I represent an Imply  proposition!!Imply methodsFor: 'Skoleminsation' stamp: 'pm 10/9/2018 09:21'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	^(self class) new: (self left Skolemnise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) 			rightProp: (self right Herbrandise: setOfLinkedVar CorrespondingValue: aMap).				"We pass veryDeepCopys to the leftProp, so each branch has it's own collections"! !!Imply methodsFor: 'Skoleminsation' stamp: 'pm 10/9/2018 09:21'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) 			rightProp: (self right Skolemnise: setOfLinkedVar CorrespondingValue: aMap).	"We pass veryDeepCopys to the leftProp, so each branch has it's own collections"! !!Imply methodsFor: 'clausification' stamp: 'pm 10/1/2018 11:09'!clausification	|t|	t:=Or new: (Not new:left)  rightProp: right.	(Prop debug) ifTrue:[Transcript show:'in Imply';show: t prettyPrint;cr.].	^t "clausification".! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Imply class	instanceVariableNames: ''!!Imply class methodsFor: 'initialize' stamp: 'pm 9/30/2018 17:35'!initialize	symb:='->'.! !Binary subclass: #Or	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Or commentStamp: 'pm 10/9/2018 11:29' prior: 0!I represent an Or proposition!!Or methodsFor: 'clausification' stamp: 'pm 9/29/2018 08:41'!isClause	^(left isClause & right isClause)! !!Or methodsFor: 'clausification' stamp: 'pm 10/1/2018 11:09'!clausification	| t |	t:=nil. 	((Or patternFalse) matchPatternWith: self)	ifTrue:[t:=left]	ifFalse:[		((Or patternFalseSym) matchPatternWith: self)		ifTrue:[t:=right]		ifFalse:[			((Or patternTrue) matchPatternWith: self)			ifTrue:[t:=right]			ifFalse:[				((Or patternTrueSym) matchPatternWith: self)				ifTrue:[t:=left]				ifFalse:[					((Or patternAnd) matchPatternWith: self)					ifTrue:[t:=And new: (Or new: ((self left) left) rightProp: (self right)) 								  rightProp: (Or new:((self left) right) rightProp: (self right))]					ifFalse:[						((Or patternAndSym) matchPatternWith: self)						ifTrue:[t:=And new:(Or new: (self left) rightProp: ((self right) left)) 									  rightProp: (Or new: (self left) rightProp: ((self right) right))].						]					]				]			]		].		(t isNil) ifTrue:[(Prop debug) ifTrue:[Transcript show:'in Or';show: self prettyPrint;cr.].								self left:(left clausification).								self right:(right clausification).								^self]					 ifFalse:[(Prop debug) ifTrue:[Transcript show:'in Or2';show: t prettyPrint;cr.].						^t "clausification" ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Or class	instanceVariableNames: 'patternAnd patternAndSym patternTrue patternTrueSym patternFalse patternFalseSym'!!Or class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:13'!patternFalse	^patternFalse! !!Or class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:12'!patternTrueSym	^patternTrueSym! !!Or class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:12'!patternAndSym	^patternAndSym! !!Or class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:13'!patternFalseSym	^patternFalseSym! !!Or class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:12'!patternTrue	^patternTrue! !!Or class methodsFor: 'initialize' stamp: 'pm 10/4/2018 08:07'!initialize	symb:='\/'. 	patternAnd:=Or new: (And new: (Var new: 'a') rightProp: (Var new:('a')))  rightProp: (Var new: 'a').	patternAndSym:=Or new: (Var new: 'a') rightProp: (And new: (Var new: 'a') rightProp: (Var new:('a'))).	patternTrue:=Or new: (Var new: 'a') rightProp: (True_Const new).	patternTrueSym:=Or new: (True_Const new) rightProp:(Var new:'a').	patternFalse:=Or new: (Var new: 'a') rightProp: (False_Const new).	patternFalseSym:=Or new: (False_Const new) rightProp:(Var new:'a').! !!Or class methodsFor: 'initialize' stamp: 'pm 9/30/2018 16:11'!patternAnd	^patternAnd! !Atome subclass: #Predicate	instanceVariableNames: 'symb terms'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Predicate commentStamp: 'pm 10/9/2018 11:29' prior: 0!I represent a Predicate with a list of terms,Also in ClausaleForm we'll be representing a Positive predicate.Public API and Key MessagesCan be created two ways :-new: PredicateName Variable:aTerm-new: PredicateName Variables: aListOfTerm!!Predicate methodsFor: 'initialization' stamp: 'pm 10/8/2018 17:43'!initialize: symbl Variables: aLinkedListOfTerm	symb:=symbl.	terms:=aLinkedListOfTerm.! !!Predicate methodsFor: 'initialization' stamp: 'pm 10/9/2018 11:52'!initialize: symbl Variable: aTerm	(aTerm isKindOf: Term)	ifFalse:[Error new:'Predicates needs terms as arguments.'].	symb:=symbl.	terms:=LinkedList new.	terms add:aTerm.! !!Predicate methodsFor: 'initialization' stamp: 'pm 10/11/2018 14:59'!initialize: symbl	symb:=symbl.	terms:=LinkedList new.! !!Predicate methodsFor: 'testing' stamp: 'pm 10/5/2018 17:11'!isClause	^true.! !!Predicate methodsFor: 'testing' stamp: 'pm 10/5/2018 16:13'!isTheSame: predicate	^(self isSamePredicate:predicate) &	(self isSameVar:predicate).! !!Predicate methodsFor: 'testing' stamp: 'pm 10/7/2018 17:13'!isSameVar: predicate	"= defined on SequenceableCollection, LinkedList's superclass."	^(self terms)=(predicate terms).! !!Predicate methodsFor: 'testing' stamp: 'pm 10/5/2018 16:47'!isSamePredicate: predicate	^(self getSymb)=(predicate getSymb)! !!Predicate methodsFor: 'printing' stamp: 'pm 10/9/2018 17:26'!prettyPrint	|t|	t:=(self getSymb),'('."	Transcript show:terms ;cr."	terms do:[:each| t:=t,each prettyPrint. ] separatedBy:[t:=t,','].	t:=t,')'.	^t.! !!Predicate methodsFor: 'comparing' stamp: 'pm 10/15/2018 15:44'!=anotherPredicate	| res |	res:=anotherPredicate isKindOf: Predicate."check class, and polarity"	res:=res or:[.].	res:=res or: [(self getSymb)=(anotherPredicate getSymb).]."comparing the function symbol"	res:=res or:[(self arity)=(anotherPredicate arity).]."comparing aruty"	res:=res or:[(self terms) = (anotherPredicate terms).]."we let the superclass LinkedList check for the correct terms"	^res.! !!Predicate methodsFor: 'accessing' stamp: 'pm 10/7/2018 17:12'!terms	^terms.! !!Predicate methodsFor: 'accessing' stamp: 'pm 10/5/2018 15:50'!getSymb	^symb.! !!Predicate methodsFor: 'matching' stamp: 'pm 10/7/2018 17:13'!matchPatternWith: prop	"see Prop's comment for usage."	^true! !!Predicate methodsFor: 'Skoleminsation' stamp: 'pm 10/8/2018 20:33'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	^self updateTerms: setOfLinkedVar CorrespondingValue: aMap.! !!Predicate methodsFor: 'Skoleminsation' stamp: 'pm 10/8/2018 20:33'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	^self updateTerms: setOfLinkedVar CorrespondingValue: aMap.! !!Predicate methodsFor: 'Skoleminsation' stamp: 'pm 10/8/2018 20:33'!updateTerms: setOfLinkedVar CorrespondingValue: aMap	| res |	res := LinkedList new.	terms do:[ :term | res add: (term WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].	^Predicate new: (self getSymb) fromList:res.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Predicate class	instanceVariableNames: ''!!Predicate class methodsFor: 'instance creation' stamp: 'pm 10/8/2018 17:41'!new: symb fromList: aList	^self basicNew initialize: symb Variables: aList.! !!Predicate class methodsFor: 'instance creation' stamp: 'pm 10/5/2018 20:00'!new: symb variable: aVar	^self basicNew initialize: symb Variable:aVar.! !!Predicate class methodsFor: 'instance creation' stamp: 'pm 10/11/2018 14:59'!new: symb	^self basicNew initialize: symb.! !Predicate subclass: #NotPredicate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!NotPredicate commentStamp: 'pm 10/9/2018 11:24' prior: 0!I represent a negative Predicate, only in ClausalForm!!NotPredicate methodsFor: 'comparing' stamp: 'pm 10/15/2018 15:46'!=anotherPredicate	^(anotherPredicate isKindOf: NotPredicate) or:[super=anotherPredicate]."check class, and polarity"! !!NotPredicate methodsFor: 'printing' stamp: 'pm 10/9/2018 17:30'!prettyPrint 	^(Not symb),(super prettyPrint)! !AbstractTerm subclass: #Term	instanceVariableNames: 'symb'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Term commentStamp: 'pm 10/9/2018 10:36' prior: 0!I represent a Predicate's Term.My type will be specialized in ConstTerm, FuncTerm, LinkedVar when the propostion my predicate's in goes through skolemnisation.I look a lot like a proposition, but i'm conceptually different, hence the new object defined types.Public API and Key Messages-prettyPrint -> print the term as a string.-new: aChar -> new instance, with a char as a term. !!Term methodsFor: 'printing' stamp: 'pm 10/11/2018 11:55'!prettyPrint 	^self getSymb.! !!Term methodsFor: 'accessing' stamp: 'pm 10/11/2018 12:05'!initialize: aName	symb:=aName.! !!Term methodsFor: 'accessing' stamp: 'pm 10/11/2018 11:02'!getSymb	^symb! !!Term methodsFor: 'comparing' stamp: 'pm 10/15/2018 15:36'!=anotherTerm	"default comparing for terms."	^(self getSymb)=(anotherTerm getSymb).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Term class	instanceVariableNames: ''!!Term class methodsFor: 'instance creation' stamp: 'pm 10/11/2018 11:45'!new: aName	^(self basicNew) initialize:aName.! !Constant subclass: #True_Const	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!True_Const commentStamp: '<historical>' prior: 0!True Const!!True_Const methodsFor: 'matching' stamp: 'pm 9/30/2018 09:48'!matchPatternWith: prop	"see Prop comment for usage."	^prop isKindOf: True_Const! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!True_Const class	instanceVariableNames: ''!!True_Const class methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!initialize	symb:='T'.! !!True_Const class methodsFor: 'accessing' stamp: 'pm 9/28/2018 21:08'!symb	^symb! !Operator subclass: #Unary	instanceVariableNames: 'operand'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Unary commentStamp: 'pm 10/9/2018 10:56' prior: 0!I represent a Abstract binary operatorI factorise some of the attributes part of future operators.Public API and Key Messages- operand -> accessor.- new: -> create a binary operatorexample of initialization.UnaryOpClass new: (aPropClass newOperator) .!!Unary methodsFor: 'Matching' stamp: 'pm 9/30/2018 10:39'!matchPatternWith: prop	(self compareSymbol: prop)		ifTrue:[^operand matchPatternWith: (prop operand)]		ifFalse:[^false].! !!Unary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:28'!operand	^operand! !!Unary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:28'!operand: replacement	operand:=replacement.	^operand! !!Unary methodsFor: 'Initialize' stamp: 'pm 9/28/2018 22:38'!initialize: prop	operand:=prop.! !!Unary methodsFor: 'printing' stamp: 'pm 9/30/2018 19:21'!prettyPrint	^self getSymb,		((operand isKindOf: Atome) ifTrue:[' '] ifFalse:[' (']) ,		operand prettyPrint,		((operand isKindOf: Atome) ifTrue:[' '] ifFalse:[') ']).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Unary class	instanceVariableNames: ''!!Unary class methodsFor: 'Initialize' stamp: 'pm 9/28/2018 22:31'!new: prop	^self basicNew initialize: prop.! !Unary subclass: #Not	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Not commentStamp: '<historical>' prior: 0!I represent a Not  operator!!Not methodsFor: 'Skoleminsation' stamp: 'pm 10/7/2018 11:35'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	^(self class) new: (self operand Skolemnise: setOfLinkedVar CorrespondingValue: aMap).! !!Not methodsFor: 'Skoleminsation' stamp: 'pm 10/7/2018 11:35'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	^(self class) new: (self operand Herbrandise: setOfLinkedVar CorrespondingValue: aMap).! !!Not methodsFor: 'clausification' stamp: 'pm 9/30/2018 20:33'!isClause	" (!! a) is a clause, but !! (a \/ b) isn't"	^(operand isKindOf: Atome)! !!Not methodsFor: 'clausification' stamp: 'pm 10/1/2018 11:09'!clausification	"Only one clausification operation at time"	"/!!\ since we're in an unary operator, the pattern doesn't start at self, but at operand"	| t |	t:=nil.	((Not patternNot) matchPatternWith: operand)	ifTrue:[t:=operand operand.]	ifFalse:[			((Not patternTrue) matchPatternWith: operand)			ifTrue:[t:=False_Const new]			ifFalse:[				((Not patternFalse) matchPatternWith: operand)				ifTrue:[t:=True_Const new]				ifFalse:[					((Not patternOr) matchPatternWith: operand)					ifTrue:[t:=And new: (Not new:(operand left)) rightProp:(Not new:(operand right))]					ifFalse:[						((Not patternAnd) matchPatternWith: operand)						ifTrue:[t:=Or new: (Not new:(operand left)) rightProp:(Not new:(operand right))].						]					]				 ]			].		(t isNil) ifTrue:[(Prop debug) ifTrue:[Transcript show:'in Not';show: self prettyPrint;cr.].			 self operand:(operand clausification).								^self]					 ifFalse:[(Prop debug) ifTrue:[Transcript show:'in Not2';show: t prettyPrint;cr.].						^t "clausification" ].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Not class	instanceVariableNames: 'patternNot patternTrue patternFalse patternOr patternAnd'!!Not class methodsFor: 'accessing' stamp: 'pm 9/30/2018 14:14'!patternFalse	^patternFalse.! !!Not class methodsFor: 'accessing' stamp: 'pm 9/30/2018 14:15'!patternAnd	^patternAnd.! !!Not class methodsFor: 'accessing' stamp: 'pm 9/30/2018 14:15'!patternNot	^patternNot.! !!Not class methodsFor: 'accessing' stamp: 'pm 9/30/2018 14:15'!patternTrue	^patternTrue.! !!Not class methodsFor: 'accessing' stamp: 'pm 9/30/2018 14:14'!patternOr	^patternOr.! !!Not class methodsFor: 'Initialize' stamp: 'pm 9/30/2018 18:50'!initialize	symb:='!!'.	patternNot:=Not new:(Var new: 'a').	patternTrue:=True_Const new.	patternFalse:=False_Const new.	patternOr:=Or new:(Var new: 'a') rightProp: (Var new: 'a').	patternAnd:=And new:(Var new: 'a') rightProp: (Var new: 'a').! !Unary subclass: #Quantifier	instanceVariableNames: 'var'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Quantifier commentStamp: 'pm 10/9/2018 11:28' prior: 0!I represent a QuantifierI'm created this way:new: VariableIQuantifieAsChar!!Quantifier methodsFor: 'testing' stamp: 'pm 10/5/2018 17:21'!isClause	"very unsure here"	^false! !!Quantifier methodsFor: 'accessing' stamp: 'pm 10/4/2018 13:31'!var	^var.! !!Quantifier methodsFor: 'printing' stamp: 'pm 10/5/2018 15:34'!prettyPrint	^(self class symb),' ', (self var), '.(',	operand prettyPrint,	')'.! !!Quantifier methodsFor: 'initialization' stamp: 'pm 10/4/2018 23:48'!initialize: arg Property: prop	super initialize: prop.	var:=arg.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Quantifier class	instanceVariableNames: ''!!Quantifier class methodsFor: 'initialization' stamp: 'pm 10/4/2018 23:48'!new:arg Property:prop	^self basicNew initialize:arg Property:prop.! !Quantifier subclass: #Exists	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Exists commentStamp: 'pm 10/9/2018 11:26' prior: 0!I represent an Exists quantifier!!Exists methodsFor: 'Skoleminsation' stamp: 'pm 10/11/2018 08:30'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	setOfLinkedVar add: (Term new:(self var)).	^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.	"We don't keep the Quantifiers in the formula"! !!Exists methodsFor: 'Skoleminsation' stamp: 'pm 10/11/2018 16:02'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	| t |	t := setOfLinkedVar isEmpty		ifTrue: [ ConstTerm new ]"then it's a generated constant, same as an Exists"		ifFalse: [ FuncTerm newFuncWithVars:  setOfLinkedVar ].		"then it's a skolem function"	aMap add: (Association key: var value: t).	^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.		"We don't keep the Quantifiers in the formula"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Exists class	instanceVariableNames: ''!!Exists class methodsFor: 'initialization' stamp: 'pm 10/4/2018 13:36'!initialize	symb:='Exist'.! !Quantifier subclass: #ForAll	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!ForAll commentStamp: 'pm 10/9/2018 11:26' prior: 0!I represent a ForallQuantifier!!ForAll methodsFor: 'Skoleminsation' stamp: 'pm 10/11/2018 16:17'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	| t |	t := setOfLinkedVar isEmpty		ifTrue: [ ConstTerm new ]"then it's a generated constant, same as an Exists"		ifFalse: [ FuncTerm newFuncWithVars: setOfLinkedVar ].		"then it's a skolem function"	aMap add: (Association key: var value: t).	^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.	"(self class) new: ("	")"	"We don't keep the Quantifiers in the formula"! !!ForAll methodsFor: 'Skoleminsation' stamp: 'pm 10/11/2018 08:29'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	setOfLinkedVar add: (Term new:(self var)).	^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.	 	"We don't keep the Quantifiers in the formula"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ForAll class	instanceVariableNames: ''!!ForAll class methodsFor: 'initialization' stamp: 'pm 10/4/2018 23:52'!initialize	symb:='Forall'.! !AbstractTerm subclass: #UnaryTerm	instanceVariableNames: 'term'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!UnaryTerm methodsFor: 'initialize' stamp: 'pm 10/11/2018 09:24'!initialize:aTerm	(aTerm isKindOf: Term)	ifFalse:[^Error new: (self class),'Takes only Terms as parameters. This is a', (aTerm class). ]	ifTrue:[term:=aTerm].! !!UnaryTerm methodsFor: 'accessing' stamp: 'pm 10/11/2018 07:57'!term	^term.! !!UnaryTerm methodsFor: 'comparing' stamp: 'pm 10/15/2018 15:36'!=anotherTerm	^(anotherTerm isKindOf: (self class)) and:[(self term)=(anotherTerm term).].			! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!UnaryTerm class	instanceVariableNames: ''!!UnaryTerm class methodsFor: 'instance creation' stamp: 'pm 10/11/2018 09:23'!new: aTerm	^(self basicNew) initialize:aTerm.! !UnaryTerm subclass: #ConstTerm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!ConstTerm commentStamp: 'pm 10/9/2018 10:44' prior: 0!I represent a Const term, for a predicate.I should only be instanciated by the skolemnisation.I exists if my variable wasn't bound by anything OR if i'm bound by an exists which isn't bound by a previous forall.Public API and Key Messages-prettyPrint >> return the term as a String, with the character 'c' as a start. To differenciate it from the rest visually.!!ConstTerm methodsFor: 'initialization' stamp: 'pm 10/11/2018 08:12'!initialize	term:=Term new:(self class) getNum.! !!ConstTerm methodsFor: 'printing' stamp: 'pm 10/11/2018 12:50'!prettyPrint	^'c', (term prettyPrint).! !!ConstTerm methodsFor: 'testing' stamp: 'pm 10/15/2018 16:38'!isConst	^true.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ConstTerm class	instanceVariableNames: 'factoryNum'!!ConstTerm class methodsFor: 'initialization' stamp: 'pm 10/7/2018 11:09'!new:Const_Value	^self basicNew initialize:Const_Value.! !!ConstTerm class methodsFor: 'initialization' stamp: 'pm 10/7/2018 10:20'!factoryNum	^factoryNum.! !!ConstTerm class methodsFor: 'initialization' stamp: 'pm 10/11/2018 12:11'!getNum	factoryNum:=factoryNum+1.	^factoryNum asString! !!ConstTerm class methodsFor: 'initialization' stamp: 'pm 10/11/2018 08:06'!new "const Factory"	^self basicNew initialize.! !!ConstTerm class methodsFor: 'initialization' stamp: 'pm 10/7/2018 10:22'!initialize	factoryNum:=0.! !!ConstTerm class methodsFor: 'initialization' stamp: 'pm 10/7/2018 10:23'!nextConst	^'c',(self getNum).! !UnaryTerm subclass: #LinkedTerm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!LinkedTerm commentStamp: 'pm 10/9/2018 10:42' prior: 0!I represent a Linked Term, for a predicate.I should only be instanciated by the skolemnisation.I exists if my variable is bound by a forall earlier in the proposition.Public API and Key Messages-prettyPrint >> return the term as a String!!LinkedTerm methodsFor: 'printing' stamp: 'pm 10/11/2018 09:18'!prettyPrint 	^term prettyPrint.! !Object subclass: #Unifier	instanceVariableNames: 'setOfPairs'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Unifier methodsFor: 'printing' stamp: 'pm 10/15/2018 16:50'!printOn: aStream	super printOn:aStream.	self prettyPrint.! !!Unifier methodsFor: 'printing' stamp: 'pm 10/15/2018 16:50'!prettyPrint	| t |	t:='{'.	setOfPairs do: [:each| t:=t,each prettyPrint.] separatedBy: [ t:=t,','.]! !!Unifier methodsFor: 'initialization' stamp: 'pm 10/15/2018 16:29'!setOfPairs: anotherSet	setOfPairs:=anotherSet.	^self.! !!Unifier methodsFor: 'initialization' stamp: 'pm 10/15/2018 16:40'!add: aPair	setOfPairs add: aPair.	^self! !!Unifier methodsFor: 'initialization' stamp: 'pm 10/15/2018 16:26'!initialize: p1 Predicate2: p2	setOfPairs:=MinimalOrderedSet new.	setOfPairs add:(Pair left: p1 right: p2).! !!Unifier methodsFor: 'initialization' stamp: 'pm 10/15/2018 19:14'!add: value1 Value2: value2	setOfPairs add:(Pair left: value1 right: value2).! !!Unifier methodsFor: 'initialization' stamp: 'pm 10/15/2018 16:29'!setOfPairs	^setOfPairs! !!Unifier methodsFor: 'initialization' stamp: 'pm 10/15/2018 20:13'!UnifyMe	|modified previous res|			setOfPairs do:[:each|		modified:=true.		modified whileTrue:[			modified:=false.			previous:=setOfPairs at:1.			res:=previous unifyIt.			(res=previous)			ifFalse:[modified:=true].			]	]! !!Unifier methodsFor: 'initialization' stamp: 'pm 10/15/2018 16:40'!addUnifier: anotherUnifier	setOfPairs merge: (anotherUnifier setOfPairs ).	^self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Unifier class	instanceVariableNames: ''!!Unifier class methodsFor: 'instance creation' stamp: 'pm 10/15/2018 16:10'!new: p1 Predicate2: p2	^(self basicNew) initialize: p1 Predicate2:p2.! !Atome subclass: #Var	instanceVariableNames: 'symb'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Var commentStamp: 'pm 10/9/2018 11:23' prior: 0!I represent a variable in a Propositional logic.-new:VarName !!Var methodsFor: 'accessing' stamp: 'pm 9/28/2018 22:25'!getSymb	^symb! !!Var methodsFor: 'comparison' stamp: 'pm 9/29/2018 09:19'!isSameVar: other	^self getSymb = other getSymb.! !!Var methodsFor: 'matching' stamp: 'pm 9/30/2018 09:59'!matchPatternWith: prop	"see Prop comment for usage."	^true! !!Var methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!initialize: varName	symb:=varName.! !!Var methodsFor: 'printing' stamp: 'pm 10/3/2018 13:11'!prettyPrint	^(self getSymb).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Var class	instanceVariableNames: ''!!Var class methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!new: varName	^self basicNew initialize: varName.! !Var subclass: #NotVar	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!NotVar commentStamp: 'pm 10/9/2018 11:24' prior: 0!I represent a negative variable, only in ClausalForm!!NotVar methodsFor: 'printing' stamp: 'pm 10/3/2018 15:23'!prettyPrint	^(Not symb),(self getSymb).! !FuncTerm initialize!Prop initialize!False_Const initialize!And initialize!Equal initialize!Imply initialize!Or initialize!True_Const initialize!Not initialize!Exists initialize!ForAll initialize!ConstTerm initialize!