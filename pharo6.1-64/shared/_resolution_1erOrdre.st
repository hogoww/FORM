Object subclass: #ClausalForm	instanceVariableNames: 'clauses'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!ClausalForm methodsFor: 'initialization' stamp: 'pm 10/9/2018 13:35'!add: clause	(clause isKindOf: Clause)	ifTrue: [ self clauses add: clause ]	ifFalse:[Error new: 'Tried to add a non clause object to a clausaleForm'].! !!ClausalForm methodsFor: 'initialization' stamp: 'pm 10/2/2018 19:52'!initialize: ClausifiedFormula	clauses:=LinkedList new.	self addAll: ClausifiedFormula.! !!ClausalForm methodsFor: 'initialization' stamp: 'pm 10/9/2018 13:59'!addAll: clausifiedProp	((clausifiedProp  isKindOf: Or) | (clausifiedProp isKindOf: Atome))	 "If i'm in a or, there's only or(s) under him."	ifTrue:[self clauses add: (Clause new:clausifiedProp)]	ifFalse:[		(clausifiedProp isKindOf: Not)		ifTrue:[			((clausifiedProp operand) isKindOf:Atome)			ifTrue:[^self clauses add:(Clause new:clausifiedProp).]			ifFalse:[^Error new:'a not isn''t englobing an atome'.].			]		ifFalse:[			(clausifiedProp isKindOf: And)			ifTrue:[				self addAll: (clausifiedProp left).				self addAll: (clausifiedProp right).				]		ifFalse:[		Error new: 'Tried to add a non clause object to a clausaleForm'.].	].	].! !!ClausalForm methodsFor: 'initialization' stamp: 'pm 10/2/2018 19:49'!initialize	clauses:=LinkedList new.	! !!ClausalForm methodsFor: 'initialization' stamp: 'pm 10/9/2018 17:26'!prettyPrint	|t|	t:='{'.		clauses do: [  :each | t:=t,(each prettyPrint). ] separatedBy: [t:=t,','].	t:=t,'}'.	^t.! !!ClausalForm methodsFor: 'accessing' stamp: 'pm 10/1/2018 20:17'!clauses	^clauses.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClausalForm class	instanceVariableNames: ''!!ClausalForm class methodsFor: 'instance creation' stamp: 'pm 10/3/2018 12:49'!new: ClausaleProposition	^self basicNew initialize:ClausaleProposition.! !!ClausalForm class methodsFor: 'instance creation' stamp: 'pm 10/3/2018 12:50'!new	^self basicNew initialize.! !Object subclass: #Clause	instanceVariableNames: 'atomes'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Clause methodsFor: 'printing' stamp: 'pm 10/9/2018 17:25'!prettyPrint	|t|	t:='{'.		atomes do:[  :each | t:=t,(each prettyPrint). ] separatedBy:[t:=t,','].	t:=t,'}'.	^t.! !!Clause methodsFor: 'accessing' stamp: 'pm 10/9/2018 13:35'!add: var	(var isKindOf: Atome)		ifTrue:[			(self atomes) add:var.			^self."able chaining operation"			]		ifFalse:[				Error new: 'wrong type in clause'.			].! !!Clause methodsFor: 'accessing' stamp: 'pm 10/2/2018 17:33'!initialize: OrProp	atomes:=LinkedList new.	self addAll:OrProp.! !!Clause methodsFor: 'accessing' stamp: 'pm 10/1/2018 20:18'!atomes	^atomes.! !!Clause methodsFor: 'accessing' stamp: 'pm 10/9/2018 13:36'!addAll: orProp	(orProp isKindOf: Atome)	ifTrue:[self add:orProp.]	ifFalse:[		((orProp) isKindOf: Not)		ifTrue:["we're in a not"			(orProp operand isKindOf:Atome)				ifTrue:["we're in an atom"					((orProp operand) isKindOf: Predicate)					ifTrue:[self add:(NotPredicate new: (orProp operand) getSymb fromList: (orProp operand) terms).]					ifFalse:[						((orProp operand) isKindOf: Var)						ifTrue:[self add:(NotVar new:((orProp operand) getSymb)).]						ifFalse: [ Error new: 'shouldn''t be any True or false here' ]].						]				ifFalse:[					Error new:'Error, shouldn''t be any more not ( binaryOp )'				].			]		ifFalse:[			((orProp) isKindOf: Or)			ifTrue:[				self addAll: (orProp left).				self addAll: (orProp right).				]			ifFalse:["switch to Error new:"				Error new:'Error, shouldn''t be any other kind of prop here.'.				].			].		].! !!Clause methodsFor: 'accessing' stamp: 'pm 10/2/2018 17:03'!initialize	atomes:=LinkedList new.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Clause class	instanceVariableNames: ''!!Clause class methodsFor: 'instance creation' stamp: 'pm 10/2/2018 17:31'!new: OrProp	^self basicNew initialize:OrProp.! !!Clause class methodsFor: 'instance creation' stamp: 'pm 10/2/2018 17:06'!new	^self basicNew initialize.! !LinkedList subclass: #MinimalOrderedSet	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!MinimalOrderedSet commentStamp: 'pm 10/9/2018 10:08' prior: 0!I'm a ordered set, using a LinkedList. I'm a linked list which only override the method 'add' so i can be considered as a set.I also give access to a way to find an object via haveYouSeenThisObject.cf LinkedList.Public API and Key Messages- add: anObject (add an object IF it's not in the set)- haveYouSeenThisObject: anObject (search for an element in the set- To create instances , cf LinkedListp:=MinimalOrderSet new.p add: 1 >> "p contains { 1 }" p add : 1 >> "p contains { 1 }"p haveYouSeenThisObject: 1 >> "true"p haveYouSeenThisObject: 2 >> "false"!!MinimalOrderedSet methodsFor: 'adding' stamp: 'pm 10/7/2018 12:25'!add: anObject 	self do: [ :each | 		(each=anObject) 		ifTrue:[^self]"Object's already in, we're done"		].	 super add: anObject."we let LinkedList add the object"	^self.! !!MinimalOrderedSet methodsFor: 'search' stamp: 'pm 10/8/2018 17:19'!haveYouSeenThisObject: anObject 	"search for the object"	self do: [ :each | 		(each=anObject) 		ifTrue:[^true]		].	^false.! !Object subclass: #Prop	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Prop commentStamp: 'pm 10/9/2018 10:52' prior: 0!Abstract class which represent a Logical proposition,  First order proposition, and propositional logic.I allow a proposition to be clausified.I allow propositions of First order to be skolemnise, then clausifiedPublic API:- FullClausification -> return a Clausified version of  a Proposition- StartSkolemnise -> return a Skolemnised version of a first order proposition (self)- PrettyPrint -> returns a string representing my  internal state.!!Prop methodsFor: 'testing' stamp: 'pm 10/9/2018 13:33'!clausificationUnitTest	|t|	Transcript show: self prettyPrint; show: '  ' ;show: self isClause; cr.	t:=self fullClausification.	Transcript show: t prettyPrint; show: '  ' ;show: t isClause; cr;cr.	^t.! !!Prop methodsFor: 'testing' stamp: 'pm 10/9/2018 12:25'!propUnitTest	Transcript show: self prettyPrint; show: '  ' ;show: self isClause; cr; cr.	^self! !!Prop methodsFor: 'testing' stamp: 'pm 9/30/2018 12:34'!matchingUnitTest: prop	"self will be considered as a pattern"	Transcript cr;		show: 'prop : ' ; 		show: (prop prettyPrint);		cr;		show: 'pattern : ';		show: (self prettyPrint);		cr.		(self matchPatternWith: prop)			ifTrue:[ Transcript show: 'matched!!';cr.]			ifFalse:[ Transcript show: 'didn''t match!!';cr]	! !!Prop methodsFor: 'testing' stamp: 'pm 10/8/2018 22:12'!SkolemnisationTest	|t|	Transcript show: self prettyPrint; show: '  ' ; cr.	t:=self StartSkolemnisation.	Transcript show: t prettyPrint; show: '  ' ; cr;cr.	^t! !!Prop methodsFor: 'clausification' stamp: 'pm 9/29/2018 08:21'!isClause	^SubclassResponsibility ! !!Prop methodsFor: 'clausification' stamp: 'pm 9/30/2018 20:06'!clausification	"Only one iteration over the full formula."	"Basic empty comportement for atomes mostly. (only?)"! !!Prop methodsFor: 'clausification' stamp: 'pm 10/1/2018 10:58'!fullClausification	| t |	t:=self clausification.	[t isClause] whileFalse:[			(Prop debug) ifTrue:[Transcript show: t prettyPrint; show: t isClause;cr.].		t:=t clausification.].	^t! !!Prop methodsFor: 'matching' stamp: 'pm 9/30/2018 10:16'!compareSymbol: otherProp	^(self getSymb = otherProp getSymb) ! !!Prop methodsFor: 'matching' stamp: 'pm 9/30/2018 09:09'!matchPatternWith: prop	"Match self and prop. to end a branch of the pattern	use a random variable	var == whatever	anythingElse == anythingElse only :  !!n => T == !!(A /\ B)=> T for example	"	^SubclassResponsibility.! !!Prop methodsFor: 'printing' stamp: 'pm 10/9/2018 11:31'!prettyPrint	"return the internal representation of Proposition"	^SubclassResponsibility ! !!Prop methodsFor: 'accessing' stamp: 'pm 9/28/2018 22:42'!getSymb	^SubclassResponsibility. ! !!Prop methodsFor: 'Skoleminsation' stamp: 'pm 10/6/2018 18:09'!HerbranSkolemDocu	^Error new:'documentation of Skolemnisation'.	"return that prop skolemnised"! !!Prop methodsFor: 'Skoleminsation' stamp: 'pm 10/7/2018 19:40'!StartSkolemnisation	| set aMap |	set:=MinimalOrderedSet new.	aMap:=Dictionary new.	^self Skolemnise: set CorrespondingValue: aMap! !!Prop methodsFor: 'Skoleminsation' stamp: 'pm 10/7/2018 11:25'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	^SubclassResponsibility.! !!Prop methodsFor: 'Skoleminsation' stamp: 'pm 10/7/2018 11:31'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	^SubclassResponsibility.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Prop class	instanceVariableNames: 'debug'!!Prop class methodsFor: 'initialization' stamp: 'pm 10/1/2018 10:56'!initialize	debug:=false.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/5/2018 16:54'!testingMatch	|pattern prop|   "Transcript clear."	Transcript show: 'Testing matching related stuff'.		pattern:= Imply new: (True_Const new) rightProp: (Predicate new: 'P' variable: 'a').	prop:= Imply new: (True_Const new) rightProp: (Not new:(Predicate new: 'P' variable: 'a')).	pattern matchingUnitTest: prop.		pattern:= Imply new: (True_Const new) rightProp: (False_Const  new).	prop:= Imply new: (True_Const new) rightProp: (Not new:(Predicate new: 'P' variable: 'a')).	pattern matchingUnitTest: prop.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/8/2018 17:11'!initEverything	"classic logic"	Prop initialize.	Atome initialize.	Constant initialize.	False_Const initialize.	True_Const initialize.	Var initialize.	NotVar initialize.	Operator initialize.	Binary initialize.	And initialize.	Equal initialize.	Imply initialize.	Or initialize.	Unary initialize.	Not initialize.		"Predicate"	Quantifier initialize.	Exists initialize.	ForAll initialize.		"terms"	Term initialize.	ConstTerm initialize.	FuncTerm initialize.	LinkedTerm initialize.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/5/2018 00:09'!testingClausification 	"everything is tested in those few lines"	"Binary"	| p |	"	Transcript clear."	Transcript show: 'Testing clausification related stuff';cr.		p:=And new: (Var new: 'a') rightProp: (False_Const new).	p clausificationUnitTest.	p:=Or new: (Var new: 'a') rightProp: (False_Const new).	p clausificationUnitTest.	p:=Equal new: (Var new: 'a') rightProp: (True_Const new).	p clausificationUnitTest.		p:=Imply new: (Var new: 'a') rightProp: (True_Const new).	p clausificationUnitTest.	"unary"	p:=Not new: (Var new: 'a').	p clausificationUnitTest.		Transcript show: 'Bit more complicated stuff!!';cr.		p:=Imply new: (Equal new: (Not new: (Var new: 'a')) rightProp: (Var new: 'b')) rightProp: (False_Const new).	p clausificationUnitTest.			Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/10/2018 21:38'!testingSkolemn 	"everything is tested in those few lines"	"Binary"	| p terms terms2|		"Transcript clear."	Transcript show: 'Testing Skolemnisation related stuff';cr.		Transcript show: 'basic one';cr.	terms:=LinkedList new.	terms add:(Term new:'x');add:(Term new:'y');add:(Term new:'z').		p:=ForAll new: 'x' Property: (Exists new: 'y' Property: (ForAll new: 'z' Property: (Predicate new: 'P' fromList: terms ))).		p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).		Transcript cr;show:p prettyPrint ;cr;cr.	Transcript show: 'with imply and nested forall.';cr.	p:=Not new: 		(Imply new: 			(ForAll new: 'x' Property:				(Or new:  					(Predicate new: 'P' variable:(Term new:'x'))					 rightProp:					(Predicate new: 'Q' variable:(Term new:'x'))))			 rightProp:			(Or new: 				(Predicate new: 'P' variable:(Term new:'a'))				rightProp:(Predicate new: 'Q' variable:(Term new:'a')))).		p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).		Transcript cr; show:p prettyPrint ;cr;cr.			Transcript show: 'same as previous one, but with x representing a variable in one, and a const in the other.';cr.	p:=Not new:		(Imply new: 			(ForAll new: 'x' Property:				(Or new:  					(Predicate new: 'P' variable:(Term new:'x'))					 rightProp:					(Predicate new: 'Q' variable:(Term new:'x'))))			 rightProp:			(Or new: 				(Predicate new: 'P' variable:(Term new:'x'))				rightProp:(Predicate new: 'Q' variable:(Term new:'x')))).			p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).		Transcript cr; show:p prettyPrint;cr;cr.			Transcript show: 'same as previous one, check Unbound Exists is replaced by consts';cr.	p:=Not new:		(Imply new: 			(Exists new: 'x' Property:				(Or new:  					(Predicate new: 'P' variable:(Term new:'x'))					 rightProp:					(Predicate new: 'Q' variable:(Term new:'x'))))			 rightProp:			(Or new: 				(Predicate new: 'P' variable:(Term new:'x'))				rightProp:(Predicate new: 'Q' variable:(Term new:'x')))).		p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).		Transcript show:p prettyPrint;cr;cr.			Transcript show: 'Teacher''s stress test#1' ; cr.	p:=Not new:(        ForAll new: 'x' Property:         (Imply new: (ForAll new: 'y' Property: (Predicate new: 'P' variable: (Term new:'y')))         rightProp: (Predicate new:'Q' variable: (Term new:'x')))).                p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).        Transcript show:p prettyPrint;cr;cr.		Transcript show: 'Teacher''s stress test#2'	 ; cr.	terms:=LinkedList new.    terms add:(Term new: 'x') ; add:(Term new:'z').    terms2:=LinkedList new.    terms2 add:(Term new:'y') ; add: (Term new:'t').    p:=Not new:            (ForAll new: 'x' Property:                (ForAll new: 'y' Property:                    (Exists new: 'z' Property:                         (ForAll new: 't' Property:                             (Imply new:                                 (Predicate new: 'P' fromList: terms)                             rightProp:                                 (Predicate new: 'Q' fromList: terms2)))))).	  p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).     Transcript show:p prettyPrint;cr.				Transcript show: 'Test functionnal term in initial Predicate '	 ; cr.	terms:=LinkedList new.   terms add:(Term new: 'x') ; add:(FuncTerm new: 'f' Variable: (Term new:'z')).   p:=Not new:            (ForAll new: 'x' Property:                  (Predicate new: 'P' fromList: terms)).	p:=ClausalForm new:((p SkolemnisationTest) clausificationUnitTest).   Transcript show:p prettyPrint;cr.				Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/5/2018 16:33'!testingPropClassic 	"everything is tested in those few lines"	"Binary"	| p l r|		"Transcript clear."	Transcript show: 'Testing prop related stuff';cr.		Transcript show: 'testing every constructor in a simple way, and if they are clauses:';cr.		p:=And new: (Var new: 'a') rightProp: (False_Const new).	p propUnitTest.	p:=Or new: (Var new: 'a') rightProp: (False_Const new).	p propUnitTest.	p:=Equal new: (Var new: 'a') rightProp: (True_Const new).	p propUnitTest.		p:=Imply new: (Var new: 'a') rightProp: (True_Const new).	p propUnitTest.	"unary"	p:=Not new: (Var new: 'a').	p propUnitTest.		Transcript show: 'Bit more complicated stuff!!';cr.		p:=Imply new: (Equal new: (Not new: (Var new: 'a')) rightProp: (Var new: 'b')) rightProp: (False_Const new).	p propUnitTest.		Transcript show: 'Testing Comparisons on Vars:'; cr.		l:=Var new: 'a'.	r:=Var new: 'b'.	Transcript show: 'is var a = b ? ';			show: (l isSameVar: r); cr.	r:=Var new: 'a'.	Transcript show: 'is var a = a ? ';		show: (l isSameVar: r); cr.		Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/1/2018 10:58'!debug	^debug! !!Prop class methodsFor: 'testing' stamp: 'pm 10/8/2018 17:24'!testingProp 	"everything is tested in those few lines"	"Binary"	| p l r|		"Transcript clear."	Transcript show: 'Testing prop related stuff';cr.		Transcript show: 'testing every constructor in a simple way, and if they are clauses:';cr.		p:=Exists new: 'a' Property: (And new: (Predicate new: 'D' variable: (Term new: 'a')) rightProp: (False_Const new)).	p propUnitTest.	p:=Exists new: 'a' Property:(Or new: (Predicate new: 'C' variable:  (Term new: 'a')) rightProp: (False_Const new)).	p propUnitTest.	p:=ForAll new: 'x' Property: (Equal new: (Predicate new: 'A' variable:  (Term new: 'a')) rightProp: (True_Const new)).	p propUnitTest.		p:=ForAll new: 'x' Property: (Imply new: (Predicate new: 'B' variable:  (Term new: 'a')) rightProp: (True_Const new)).	p propUnitTest.	"unary"	p:=Not new: (Predicate new: 'Q' variable: (Term new: 'a')).	p propUnitTest.		Transcript show: 'Bit more complicated stuff!!';cr.		p:=Imply new: (Equal new: (Not new: (Predicate new: 'P' variable:  (Term new: 'a'))) rightProp: (Predicate new: 'P' variable:(Term new: 'b'))) rightProp: (False_Const new).	p propUnitTest.		Transcript show: 'Testing Comparisons on Vars:'; cr.		l:=Predicate new: 'P' variable:  'a'.	r:=Predicate new: 'P' variable:  'b'.	Transcript show: 'is P(a) = P(b) ? ';			show: (l isTheSame: r); cr.	r:=Predicate new: 'Q' variable:  'a'.	Transcript show: 'is var P(a) = Q(a) ? ';		show: (l isTheSame: r); cr.	r:=Predicate new: 'P' variable:  'a'.	Transcript show: 'is P(a) = P(a) ? ';		show: (l isTheSame: r); cr.		Transcript show: 'Done with the testing, did it work? :3' ; cr; cr.! !!Prop class methodsFor: 'testing' stamp: 'pm 10/8/2018 17:10'!testEverything	Transcript clear.	Prop initEverything.	Prop testingProp.	Prop testingMatch.	Prop testingClausification.	Prop testingSkolemn.! !Prop subclass: #Atome	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Atome commentStamp: 'pm 10/9/2018 11:03' prior: 0!I represent an Abstract atome in a Proposition.I factorise some proprieties.!!Atome methodsFor: 'printing' stamp: 'pm 9/28/2018 20:26'!prettyPrint	^self getSymb! !!Atome methodsFor: 'clausification' stamp: 'pm 9/29/2018 08:25'!isClause	^true! !!Atome methodsFor: 'testing' stamp: 'pm 10/5/2018 23:12'!isSkolem	^true.! !Atome subclass: #Constant	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Constant commentStamp: 'pm 10/9/2018 11:07' prior: 0!True and False constants, to represent them in Propositions!!Constant methodsFor: 'accessors' stamp: 'pm 9/28/2018 22:30'!getSymb	^(self class symb)! !!Constant methodsFor: 'Skoleminsation' stamp: 'pm 10/7/2018 19:50'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	^self.! !!Constant methodsFor: 'Skoleminsation' stamp: 'pm 10/7/2018 19:50'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	^self.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Constant class	instanceVariableNames: 'symb'!Constant subclass: #False_Const	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!False_Const commentStamp: '<historical>' prior: 0!False const!!False_Const methodsFor: 'matching' stamp: 'pm 9/30/2018 09:45'!matchPatternWith: prop	"see Prop comment for usage."	^prop isKindOf: False_Const! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!False_Const class	instanceVariableNames: ''!!False_Const class methodsFor: 'accessing' stamp: 'pm 9/28/2018 21:18'!symb	^symb! !!False_Const class methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!initialize	symb:='F'.! !Prop subclass: #Operator	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Operator commentStamp: 'pm 10/9/2018 10:48' prior: 0!I represent an operator whith an unknown number of argument.I only factorise a method for now, but I allow possible future evolutions.!!Operator methodsFor: 'print' stamp: 'pm 9/28/2018 20:26'!getSymb	^(self class symb)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Operator class	instanceVariableNames: 'symb'!!Operator class methodsFor: 'accessing' stamp: 'pm 10/4/2018 23:44'!symb	^symb.! !Operator subclass: #Binary	instanceVariableNames: 'left right'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Binary commentStamp: 'pm 10/9/2018 10:55' prior: 0!I represent a Abstract binary operatorI factorise some of the attributes part of future operators.Public API and Key Messages- left & right -> accessors.- new: rightProp: -> create a binary operatorexample of initialization.BinaryOpClass new: (aPropClass newOperator) 			    rightProp: (aPropClass newOperator).			!!Binary methodsFor: 'clausification' stamp: 'pm 9/29/2018 08:39'!isClause	"false unless it's a or/and"	^false! !!Binary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:27'!right: replacement	right:=replacement.	^right! !!Binary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:27'!left: replacement	left:=replacement.	^left! !!Binary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:27'!right	^right! !!Binary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:26'!left	^left! !!Binary methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!initialize: leftProp rightProp: rp	left:=leftProp.	right:=rp.	! !!Binary methodsFor: 'matching' stamp: 'pm 9/30/2018 12:00'!matchPatternWith: prop	(self compareSymbol: prop)		ifTrue:[			^(left matchPatternWith: (prop left))			& (right matchPatternWith: (prop right))			]		ifFalse:[^false].! !!Binary methodsFor: 'printing' stamp: 'pm 9/30/2018 12:15'!prettyPrint	^((left isKindOf: Atome) ifTrue:[' '] ifFalse:[' (']) ,		left prettyPrint,		((left isKindOf: Atome) ifTrue:[' '] ifFalse:[') ']) ,		self getSymb,		((right isKindOf: Atome) ifTrue:[' '] ifFalse:[' (']) ,		right prettyPrint,		((right isKindOf: Atome) ifTrue:[' '] ifFalse:[') ']).! !!Binary methodsFor: 'Skoleminsation' stamp: 'pm 10/9/2018 09:21'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) 			rightProp: (self right Herbrandise: setOfLinkedVar CorrespondingValue: aMap ).		"We pass veryDeepCopys to the leftProp, so each branch has it's own collections"! !!Binary methodsFor: 'Skoleminsation' stamp: 'pm 10/9/2018 09:21'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	^(self class) new: (self left Skolemnise: (setOfLinkedVar veryDeepCopy)  CorrespondingValue: (aMap veryDeepCopy)) 			rightProp: (self right Skolemnise: setOfLinkedVar CorrespondingValue: aMap).			"Works for at least Or & And. Maybe Equal?"				"We pass veryDeepCopys to the leftProp, so each branch has it's own collections"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Binary class	instanceVariableNames: ''!!Binary class methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!new: leftProp rightProp: rp	^self basicNew initialize: leftProp rightProp: rp.! !Binary subclass: #And	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!And commentStamp: 'pm 10/9/2018 11:29' prior: 0!I represent an And proposition!!And methodsFor: 'clausification' stamp: 'pm 9/29/2018 08:40'!isClause	^(left isClause & right isClause)! !!And methodsFor: 'clausification' stamp: 'pm 10/1/2018 11:09'!clausification	| t |	t:=nil. 	((And patternFalse) matchPatternWith: self)	ifTrue:[t:=right]	ifFalse:[		((And patternFalseSym) matchPatternWith: self)		ifTrue:[t:=left]		ifFalse:[			((And patternTrue) matchPatternWith: self)			ifTrue:[t:=left]			ifFalse:[				((And patternTrueSym) matchPatternWith: self)				ifTrue:[t:=right]				ifFalse:["					((And patternOr) matchPatternWith: self)					ifTrue:[t:=Or new: (And new: ((self left) left) rightProp: (self right)) 								  rightProp: (And new:((self left) right) rightProp: (self right))]					ifFalse:[						((And patternOrSym) matchPatternWith: self)						ifTrue:[t:=Or new:(And new: (self left) rightProp: ((self right) left)) 									  rightProp: (And new: (self left) rightProp: ((self right) right))].						]					"]				]			]		].		(t isNil) ifTrue:[ (Prop debug) ifTrue:[Transcript show:'in And';show: self prettyPrint;cr.].			self left:(left clausification).								self right:(right clausification).								^self]					 ifFalse:[(Prop debug) ifTrue:[Transcript show:'in And2';show: t prettyPrint;cr.].						^t "clausification"]. ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!And class	instanceVariableNames: 'patternOr patternOrSym patternTrue patternTrueSym patternFalse patternFalseSym'!!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternFalse	^patternFalse! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternTrueSym	^patternTrueSym! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternOrSym	^patternOrSym! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternTrue	^patternTrue! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternFalseSym	^patternFalseSym! !!And class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:15'!patternOr	^patternOr! !!And class methodsFor: 'initialize' stamp: 'pm 10/3/2018 20:06'!initialize	symb:='/\'.	patternOr:=And new: (Or new: (Var new: 'a') rightProp: (Var new:('a')))  rightProp: (Var new: 'a').	patternOrSym:=And new: (Var new: 'a') rightProp: (Or new: (Var new: 'a') rightProp: (Var new:('a'))).	patternTrue:=And new: (Var new: 'a') rightProp: (True_Const new).	patternTrueSym:=And new: (True_Const new) rightProp:(Var new:'a').	patternFalse:=And new: (Var new: 'a') rightProp: (False_Const new).	patternFalseSym:=And new: (False_Const new) rightProp:(Var new:'a').! !Binary subclass: #Equal	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Equal commentStamp: 'pm 10/9/2018 11:29' prior: 0!I represent an Equal proposition!!Equal methodsFor: 'clausification' stamp: 'pm 10/1/2018 11:09'!clausification	| t |	t:=Or new: (And new: (self left) rightProp: (self right))		 rightProp: (And new:(Not new: (self left)) rightProp:(Not new: (self right))).	(Prop debug) ifTrue:[Transcript show:'in equal';show: t prettyPrint;cr.].	^t "clausification".! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Equal class	instanceVariableNames: ''!!Equal class methodsFor: 'initialize' stamp: 'pm 9/30/2018 17:36'!initialize	symb:='<->'.! !Binary subclass: #Imply	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Imply commentStamp: 'pm 10/9/2018 11:29' prior: 0!I represent an Imply  proposition!!Imply methodsFor: 'Skoleminsation' stamp: 'pm 10/9/2018 09:21'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	^(self class) new: (self left Skolemnise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) 			rightProp: (self right Herbrandise: setOfLinkedVar CorrespondingValue: aMap).				"We pass veryDeepCopys to the leftProp, so each branch has it's own collections"! !!Imply methodsFor: 'Skoleminsation' stamp: 'pm 10/9/2018 09:21'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	^(self class) new: (self left Herbrandise: (setOfLinkedVar veryDeepCopy) CorrespondingValue: (aMap veryDeepCopy)) 			rightProp: (self right Skolemnise: setOfLinkedVar CorrespondingValue: aMap).	"We pass veryDeepCopys to the leftProp, so each branch has it's own collections"! !!Imply methodsFor: 'clausification' stamp: 'pm 10/1/2018 11:09'!clausification	|t|	t:=Or new: (Not new:left)  rightProp: right.	(Prop debug) ifTrue:[Transcript show:'in Imply';show: t prettyPrint;cr.].	^t "clausification".! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Imply class	instanceVariableNames: ''!!Imply class methodsFor: 'initialize' stamp: 'pm 9/30/2018 17:35'!initialize	symb:='->'.! !Binary subclass: #Or	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Or commentStamp: 'pm 10/9/2018 11:29' prior: 0!I represent an Or proposition!!Or methodsFor: 'clausification' stamp: 'pm 9/29/2018 08:41'!isClause	^(left isClause & right isClause)! !!Or methodsFor: 'clausification' stamp: 'pm 10/1/2018 11:09'!clausification	| t |	t:=nil. 	((Or patternFalse) matchPatternWith: self)	ifTrue:[t:=left]	ifFalse:[		((Or patternFalseSym) matchPatternWith: self)		ifTrue:[t:=right]		ifFalse:[			((Or patternTrue) matchPatternWith: self)			ifTrue:[t:=right]			ifFalse:[				((Or patternTrueSym) matchPatternWith: self)				ifTrue:[t:=left]				ifFalse:[					((Or patternAnd) matchPatternWith: self)					ifTrue:[t:=And new: (Or new: ((self left) left) rightProp: (self right)) 								  rightProp: (Or new:((self left) right) rightProp: (self right))]					ifFalse:[						((Or patternAndSym) matchPatternWith: self)						ifTrue:[t:=And new:(Or new: (self left) rightProp: ((self right) left)) 									  rightProp: (Or new: (self left) rightProp: ((self right) right))].						]					]				]			]		].		(t isNil) ifTrue:[(Prop debug) ifTrue:[Transcript show:'in Or';show: self prettyPrint;cr.].								self left:(left clausification).								self right:(right clausification).								^self]					 ifFalse:[(Prop debug) ifTrue:[Transcript show:'in Or2';show: t prettyPrint;cr.].						^t "clausification" ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Or class	instanceVariableNames: 'patternAnd patternAndSym patternTrue patternTrueSym patternFalse patternFalseSym'!!Or class methodsFor: 'initialize' stamp: 'pm 10/4/2018 08:07'!initialize	symb:='\/'. 	patternAnd:=Or new: (And new: (Var new: 'a') rightProp: (Var new:('a')))  rightProp: (Var new: 'a').	patternAndSym:=Or new: (Var new: 'a') rightProp: (And new: (Var new: 'a') rightProp: (Var new:('a'))).	patternTrue:=Or new: (Var new: 'a') rightProp: (True_Const new).	patternTrueSym:=Or new: (True_Const new) rightProp:(Var new:'a').	patternFalse:=Or new: (Var new: 'a') rightProp: (False_Const new).	patternFalseSym:=Or new: (False_Const new) rightProp:(Var new:'a').! !!Or class methodsFor: 'initialize' stamp: 'pm 9/30/2018 16:11'!patternAnd	^patternAnd! !!Or class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:13'!patternFalse	^patternFalse! !!Or class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:12'!patternTrueSym	^patternTrueSym! !!Or class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:12'!patternAndSym	^patternAndSym! !!Or class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:13'!patternFalseSym	^patternFalseSym! !!Or class methodsFor: 'accessing' stamp: 'pm 9/30/2018 16:12'!patternTrue	^patternTrue! !Atome subclass: #Predicate	instanceVariableNames: 'symb terms'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Predicate commentStamp: 'pm 10/9/2018 11:29' prior: 0!I represent a Predicate with a list of terms,Also in ClausaleForm we'll be representing a Positive predicate.Public API and Key MessagesCan be created two ways :-new: PredicateName Variable:aTerm-new: PredicateName Variables: aListOfTerm!!Predicate methodsFor: 'accessing' stamp: 'pm 10/7/2018 17:12'!terms	^terms.! !!Predicate methodsFor: 'accessing' stamp: 'pm 10/5/2018 15:50'!getSymb	^symb.! !!Predicate methodsFor: 'printing' stamp: 'pm 10/9/2018 17:26'!prettyPrint	|t|	t:=(self getSymb),'('."	Transcript show:terms ;cr."	terms do:[:each| t:=t,each prettyPrint. ] separatedBy:[t:=t,','].	t:=t,')'.	^t.! !!Predicate methodsFor: 'initialization' stamp: 'pm 10/8/2018 17:43'!initialize: symbl Variables: aLinkedListOfTerm	symb:=symbl.	terms:=aLinkedListOfTerm.! !!Predicate methodsFor: 'initialization' stamp: 'pm 10/9/2018 11:52'!initialize: symbl Variable: aTerm	(aTerm isKindOf: Term)	ifFalse:[Error new:'Predicates needs terms as arguments.'].	symb:=symbl.	terms:=LinkedList new.	terms add:aTerm.! !!Predicate methodsFor: 'matching' stamp: 'pm 10/7/2018 17:13'!matchPatternWith: prop	"see Prop's comment for usage."	^true! !!Predicate methodsFor: 'Skoleminsation' stamp: 'pm 10/8/2018 20:33'!updateTerms: setOfLinkedVar CorrespondingValue: aMap	| res |	res := LinkedList new.	terms do:[ :term | res add: (term WhatAmI:setOfLinkedVar CorrespondingValue:aMap). ].	^Predicate new: (self getSymb) fromList:res.! !!Predicate methodsFor: 'Skoleminsation' stamp: 'pm 10/8/2018 20:33'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	^self updateTerms: setOfLinkedVar CorrespondingValue: aMap.! !!Predicate methodsFor: 'Skoleminsation' stamp: 'pm 10/8/2018 20:33'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	^self updateTerms: setOfLinkedVar CorrespondingValue: aMap.! !!Predicate methodsFor: 'testing' stamp: 'pm 10/5/2018 17:11'!isClause	^true.! !!Predicate methodsFor: 'testing' stamp: 'pm 10/5/2018 16:13'!isTheSame: predicate	^(self isSamePredicate:predicate) &	(self isSameVar:predicate).! !!Predicate methodsFor: 'testing' stamp: 'pm 10/7/2018 17:13'!isSameVar: predicate	"= defined on SequenceableCollection, LinkedList's superclass."	^(self terms)=(predicate terms).! !!Predicate methodsFor: 'testing' stamp: 'pm 10/5/2018 16:47'!isSamePredicate: predicate	^(self getSymb)=(predicate getSymb)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Predicate class	instanceVariableNames: ''!!Predicate class methodsFor: 'instance creation' stamp: 'pm 10/8/2018 17:41'!new: symb fromList: aList	^self basicNew initialize: symb Variables: aList.! !!Predicate class methodsFor: 'instance creation' stamp: 'pm 10/5/2018 20:00'!new: symb variable: aVar	^self basicNew initialize: symb Variable:aVar.! !Predicate subclass: #NotPredicate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!NotPredicate commentStamp: 'pm 10/9/2018 11:24' prior: 0!I represent a negative Predicate, only in ClausalForm!!NotPredicate methodsFor: 'printing' stamp: 'pm 10/9/2018 17:30'!prettyPrint 	^(Not symb),(super prettyPrint)! !Object subclass: #Term	instanceVariableNames: 'symb'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Term commentStamp: 'pm 10/9/2018 10:36' prior: 0!I represent a Predicate's Term.My type will be specialized in ConstTerm, FuncTerm, LinkedVar when the propostion my predicate's in goes through skolemnisation.I look a lot like a proposition, but i'm conceptually different, hence the new object defined types.Public API and Key Messages-prettyPrint -> print the term as a string.-new: aChar -> new instance, with a char as a term. !!Term methodsFor: 'accessing' stamp: 'pm 10/6/2018 19:25'!PrettyPrint	^(self getSymb)! !!Term methodsFor: 'accessing' stamp: 'pm 10/6/2018 19:24'!getSymb	^symb! !!Term methodsFor: 'comparing' stamp: 'pm 10/8/2018 21:37'!=anotherTerm	(anotherTerm isKindOf: Term)	ifTrue:[		^(self getSymb)=(anotherTerm getSymb).		]	ifFalse:[^false].! !!Term methodsFor: 'Skoleminsation' stamp: 'pm 10/9/2018 09:34'!WhatAmI:setOfLinkedVar CorrespondingValue: aMap	| elem |	(setOfLinkedVar haveYouSeenThisObject:(self getSymb))	ifTrue:[^LinkedTerm new:(self getSymb).]	ifFalse:[		elem:=aMap at:(self getSymb)ifAbsent:[(ConstTerm new:(self getSymb))].		^elem.		]				"Weird formulation which means: 		ifFalse:[^elem]		ifTrue:[^(ConstTerm new:(self getSymb))].		]."! !!Term methodsFor: 'printing' stamp: 'pm 10/9/2018 08:57'!prettyPrint 	^self getSymb.! !!Term methodsFor: 'initialization' stamp: 'pm 10/7/2018 15:08'!initialize: symbo	symb:=symbo.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Term class	instanceVariableNames: ''!!Term class methodsFor: 'instance creation' stamp: 'pm 10/7/2018 15:08'!new: symbo	^self basicNew initialize:symbo.	! !Term subclass: #ConstTerm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!ConstTerm commentStamp: 'pm 10/9/2018 10:44' prior: 0!I represent a Const term, for a predicate.I should only be instanciated by the skolemnisation.I exists if my variable wasn't bound by anything OR if i'm bound by an exists which isn't bound by a previous forall.Public API and Key Messages-prettyPrint >> return the term as a String, with the character 'c' as a start. To differenciate it from the rest visually.!!ConstTerm methodsFor: 'initialization' stamp: 'pm 10/7/2018 10:24'!initialize	symb:=(self class) getNum.! !!ConstTerm methodsFor: 'initialization' stamp: 'pm 10/7/2018 11:09'!initialize:ConstValue	symb:=ConstValue.! !!ConstTerm methodsFor: 'printing' stamp: 'pm 10/9/2018 09:35'!prettyPrint	^'c',((self getSymb) asString).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ConstTerm class	instanceVariableNames: 'factoryNum'!!ConstTerm class methodsFor: 'initialization' stamp: 'pm 10/7/2018 11:09'!new:Const_Value	^self basicNew initialize:Const_Value.! !!ConstTerm class methodsFor: 'initialization' stamp: 'pm 10/7/2018 10:20'!factoryNum	^factoryNum.! !!ConstTerm class methodsFor: 'initialization' stamp: 'pm 10/8/2018 17:10'!getNum	factoryNum:=factoryNum+1.	^factoryNum ! !!ConstTerm class methodsFor: 'initialization' stamp: 'pm 10/7/2018 10:24'!new	^self basicNew initialize.! !!ConstTerm class methodsFor: 'initialization' stamp: 'pm 10/7/2018 10:22'!initialize	factoryNum:=0.! !!ConstTerm class methodsFor: 'initialization' stamp: 'pm 10/7/2018 10:23'!nextConst	^'c',(self getNum).! !Term subclass: #FuncTerm	instanceVariableNames: 'terms'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!FuncTerm commentStamp: 'pm 10/9/2018 10:43' prior: 0!I represent a Func term, for a predicate.I should only be instanciated by the skolemnisation.I exists if my variable was bound by an Exists, with a forall binding the said Exists beforehand.Public API and Key Messages-prettyPrint >> return the term as a String, with a standart name 'f' for the function, and a list of terms.!!FuncTerm methodsFor: 'initialization' stamp: 'pm 10/7/2018 15:12'!initialize: symbo Variables: setOfLinkedVar	super initialize:symbo.	terms:=LinkedList new.	setOfLinkedVar  do: [ :each | terms add:each.].! !!FuncTerm methodsFor: 'initialization' stamp: 'pm 10/10/2018 21:39'!initialize: symbo Variable: aTerm	super initialize:symbo.	terms:=LinkedList new.	terms add: aTerm.! !!FuncTerm methodsFor: 'printing' stamp: 'pm 10/10/2018 21:58'!prettyPrint	|t|	t:=(self getSymb),'('.	terms do: [:each| t:=t,each prettyPrint. ] separatedBy:[t:=t,','].	t:=t,')'.	^t.	! !!FuncTerm methodsFor: 'accessing' stamp: 'pm 10/6/2018 19:28'!terms	^terms! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!FuncTerm class	instanceVariableNames: ''!!FuncTerm class methodsFor: 'instance creation' stamp: 'pm 10/10/2018 21:39'!new: symbo Variable: aVar	^self basicNew initialize:symbo Variable: aVar.! !!FuncTerm class methodsFor: 'instance creation' stamp: 'pm 10/7/2018 15:10'!new: symbo Variables: setOfLinkedVar	^self basicNew initialize:symbo Variables: setOfLinkedVar.! !Term subclass: #LinkedTerm	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!LinkedTerm commentStamp: 'pm 10/9/2018 10:42' prior: 0!I represent a Linked Term, for a predicate.I should only be instanciated by the skolemnisation.I exists if my variable is bound by a forall earlier in the proposition.Public API and Key Messages-prettyPrint >> return the term as a String!Constant subclass: #True_Const	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!True_Const commentStamp: '<historical>' prior: 0!True Const!!True_Const methodsFor: 'matching' stamp: 'pm 9/30/2018 09:48'!matchPatternWith: prop	"see Prop comment for usage."	^prop isKindOf: True_Const! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!True_Const class	instanceVariableNames: ''!!True_Const class methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!initialize	symb:='T'.! !!True_Const class methodsFor: 'accessing' stamp: 'pm 9/28/2018 21:08'!symb	^symb! !Operator subclass: #Unary	instanceVariableNames: 'operand'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Unary commentStamp: 'pm 10/9/2018 10:56' prior: 0!I represent a Abstract binary operatorI factorise some of the attributes part of future operators.Public API and Key Messages- operand -> accessor.- new: -> create a binary operatorexample of initialization.UnaryOpClass new: (aPropClass newOperator) .!!Unary methodsFor: 'Matching' stamp: 'pm 9/30/2018 10:39'!matchPatternWith: prop	(self compareSymbol: prop)		ifTrue:[^operand matchPatternWith: (prop operand)]		ifFalse:[^false].! !!Unary methodsFor: 'printing' stamp: 'pm 9/30/2018 19:21'!prettyPrint	^self getSymb,		((operand isKindOf: Atome) ifTrue:[' '] ifFalse:[' (']) ,		operand prettyPrint,		((operand isKindOf: Atome) ifTrue:[' '] ifFalse:[') ']).! !!Unary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:28'!operand	^operand! !!Unary methodsFor: 'accessing' stamp: 'pm 9/30/2018 08:28'!operand: replacement	operand:=replacement.	^operand! !!Unary methodsFor: 'Initialize' stamp: 'pm 9/28/2018 22:38'!initialize: prop	operand:=prop.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Unary class	instanceVariableNames: ''!!Unary class methodsFor: 'Initialize' stamp: 'pm 9/28/2018 22:31'!new: prop	^self basicNew initialize: prop.! !Unary subclass: #Not	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Not commentStamp: '<historical>' prior: 0!I represent a Not  operator!!Not methodsFor: 'clausification' stamp: 'pm 9/30/2018 20:33'!isClause	" (!! a) is a clause, but !! (a \/ b) isn't"	^(operand isKindOf: Atome)! !!Not methodsFor: 'clausification' stamp: 'pm 10/1/2018 11:09'!clausification	"Only one clausification operation at time"	"/!!\ since we're in an unary operator, the pattern doesn't start at self, but at operand"	| t |	t:=nil.	((Not patternNot) matchPatternWith: operand)	ifTrue:[t:=operand operand.]	ifFalse:[			((Not patternTrue) matchPatternWith: operand)			ifTrue:[t:=False_Const new]			ifFalse:[				((Not patternFalse) matchPatternWith: operand)				ifTrue:[t:=True_Const new]				ifFalse:[					((Not patternOr) matchPatternWith: operand)					ifTrue:[t:=And new: (Not new:(operand left)) rightProp:(Not new:(operand right))]					ifFalse:[						((Not patternAnd) matchPatternWith: operand)						ifTrue:[t:=Or new: (Not new:(operand left)) rightProp:(Not new:(operand right))].						]					]				 ]			].		(t isNil) ifTrue:[(Prop debug) ifTrue:[Transcript show:'in Not';show: self prettyPrint;cr.].			 self operand:(operand clausification).								^self]					 ifFalse:[(Prop debug) ifTrue:[Transcript show:'in Not2';show: t prettyPrint;cr.].						^t "clausification" ].! !!Not methodsFor: 'Skoleminsation' stamp: 'pm 10/7/2018 11:35'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	^(self class) new: (self operand Skolemnise: setOfLinkedVar CorrespondingValue: aMap).! !!Not methodsFor: 'Skoleminsation' stamp: 'pm 10/7/2018 11:35'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	^(self class) new: (self operand Herbrandise: setOfLinkedVar CorrespondingValue: aMap).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Not class	instanceVariableNames: 'patternNot patternTrue patternFalse patternOr patternAnd'!!Not class methodsFor: 'Initialize' stamp: 'pm 9/30/2018 18:50'!initialize	symb:='!!'.	patternNot:=Not new:(Var new: 'a').	patternTrue:=True_Const new.	patternFalse:=False_Const new.	patternOr:=Or new:(Var new: 'a') rightProp: (Var new: 'a').	patternAnd:=And new:(Var new: 'a') rightProp: (Var new: 'a').! !!Not class methodsFor: 'accessing' stamp: 'pm 9/30/2018 14:14'!patternFalse	^patternFalse.! !!Not class methodsFor: 'accessing' stamp: 'pm 9/30/2018 14:15'!patternAnd	^patternAnd.! !!Not class methodsFor: 'accessing' stamp: 'pm 9/30/2018 14:15'!patternTrue	^patternTrue.! !!Not class methodsFor: 'accessing' stamp: 'pm 9/30/2018 14:15'!patternNot	^patternNot.! !!Not class methodsFor: 'accessing' stamp: 'pm 9/30/2018 14:14'!patternOr	^patternOr.! !Unary subclass: #Quantifier	instanceVariableNames: 'var'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Quantifier commentStamp: 'pm 10/9/2018 11:28' prior: 0!I represent a QuantifierI'm created this way:new: VariableIQuantifieAsChar!!Quantifier methodsFor: 'accessing' stamp: 'pm 10/4/2018 13:31'!var	^var.! !!Quantifier methodsFor: 'initialization' stamp: 'pm 10/4/2018 23:48'!initialize: arg Property: prop	super initialize: prop.	var:=arg.! !!Quantifier methodsFor: 'testing' stamp: 'pm 10/5/2018 17:21'!isClause	"very unsure here"	^false! !!Quantifier methodsFor: 'printing' stamp: 'pm 10/5/2018 15:34'!prettyPrint	^(self class symb),' ', (self var), '.(',	operand prettyPrint,	')'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Quantifier class	instanceVariableNames: ''!!Quantifier class methodsFor: 'initialization' stamp: 'pm 10/4/2018 23:48'!new:arg Property:prop	^self basicNew initialize:arg Property:prop.! !Quantifier subclass: #Exists	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Exists commentStamp: 'pm 10/9/2018 11:26' prior: 0!I represent an Exists quantifier!!Exists methodsFor: 'Skoleminsation' stamp: 'pm 10/8/2018 20:31'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	setOfLinkedVar add: (self var).	^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.	"We don't keep the Quantifiers in the formula"! !!Exists methodsFor: 'Skoleminsation' stamp: 'pm 10/8/2018 20:31'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	| t |	t := setOfLinkedVar isEmpty		ifTrue: [ ConstTerm new ]"then it's a generated constant, same as an Exists"		ifFalse: [ FuncTerm new: 'f' Variables: setOfLinkedVar ].		"then it's a skolem function"	aMap add: (Association key: var value: t).	^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.		"We don't keep the Quantifiers in the formula"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Exists class	instanceVariableNames: ''!!Exists class methodsFor: 'initialization' stamp: 'pm 10/4/2018 13:36'!initialize	symb:='Exist'.! !Quantifier subclass: #ForAll	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!ForAll commentStamp: 'pm 10/9/2018 11:26' prior: 0!I represent a ForallQuantifier!!ForAll methodsFor: 'Skoleminsation' stamp: 'pm 10/8/2018 20:30'!Herbrandise: setOfLinkedVar CorrespondingValue: aMap	| t |	t := setOfLinkedVar isEmpty		ifTrue: [ ConstTerm new ]"then it's a generated constant, same as an Exists"		ifFalse: [ FuncTerm new: 'f' Variables: setOfLinkedVar ].		"then it's a skolem function"	aMap add: (Association key: var value: t).	^(self operand) Herbrandise: setOfLinkedVar CorrespondingValue: aMap.	"(self class) new: ("	")"	"We don't keep the Quantifiers in the formula"! !!ForAll methodsFor: 'Skoleminsation' stamp: 'pm 10/8/2018 20:30'!Skolemnise: setOfLinkedVar CorrespondingValue: aMap	setOfLinkedVar add: (self var).	^(self operand) Skolemnise: setOfLinkedVar CorrespondingValue: aMap.	 	"We don't keep the Quantifiers in the formula"! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ForAll class	instanceVariableNames: ''!!ForAll class methodsFor: 'initialization' stamp: 'pm 10/4/2018 23:52'!initialize	symb:='Forall'.! !Atome subclass: #Var	instanceVariableNames: 'symb'	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!Var commentStamp: 'pm 10/9/2018 11:23' prior: 0!I represent a variable in a Propositional logic.-new:VarName !!Var methodsFor: 'matching' stamp: 'pm 9/30/2018 09:59'!matchPatternWith: prop	"see Prop comment for usage."	^true! !!Var methodsFor: 'comparison' stamp: 'pm 9/29/2018 09:19'!isSameVar: other	^self getSymb = other getSymb.! !!Var methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!initialize: varName	symb:=varName.! !!Var methodsFor: 'printing' stamp: 'pm 10/3/2018 13:11'!prettyPrint	^(self getSymb).! !!Var methodsFor: 'accessing' stamp: 'pm 9/28/2018 22:25'!getSymb	^symb! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Var class	instanceVariableNames: ''!!Var class methodsFor: 'initialize' stamp: 'pm 9/28/2018 20:26'!new: varName	^self basicNew initialize: varName.! !Var subclass: #NotVar	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '_resolution_1erOrdre'!!NotVar commentStamp: 'pm 10/9/2018 11:24' prior: 0!I represent a negative variable, only in ClausalForm!!NotVar methodsFor: 'printing' stamp: 'pm 10/3/2018 15:23'!prettyPrint	^(Not symb),(self getSymb).! !Prop initialize!False_Const initialize!And initialize!Equal initialize!Imply initialize!Or initialize!ConstTerm initialize!True_Const initialize!Not initialize!Exists initialize!ForAll initialize!